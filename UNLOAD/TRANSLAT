**** SOURCE FILE : M0004609.W03   ***
*
C
C              RENTRAN SUBROUTINE ALARM
C
C LINKAGE      SUBROUTINE ALARM(NUMBER,IPOS,ERLV,SUBNAM)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    BINBCD          SUBROUTINE    BOOLIF
C          SUBROUTINE    FOUTXX          SUBROUTINE    COMSTR
C          SUBROUTINE    MCXTRN          SUBROUTINE    GOLO
C          ASM ROUT.     CFORM           SUBROUTINE    GOPAT
C          ASM ROUT.     MOVE            SUBROUTINE    ICMPRS
C          ASM ROUT.     IVERGL          SUBROUTINE    INPAT
C                                        SUBROUTINE    INPUT
C                                        SUBROUTINE    ISSCOD
C                                        SUBROUTINE    LABCON
C                                        SUBROUTINE    LARGES
C                                        SUBROUTINE    LCANON
C                                        SUBROUTINE    LOOP
C                                        SUBROUTINE    MACLBL
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    MATCH
C                                        SUBROUTINE    MCXTRN
C                                        SUBROUTINE    MNPROC
C                                        SUBROUTINE    MOTION
C                                        INTEGER FCT.  NAME
C                                        SUBROUTINE    ONEARG
C                                        SUBROUTINE    OPCODE
C                                        SUBROUTINE    PRO020
C                                        SUBROUTINE    PRO021
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    READ
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    REFREF
C                                        SUBROUTINE    REPLAC
C                                        SUBROUTINE    RESERV
C                                        SUBROUTINE    RESRED
C                                        SUBROUTINE    SSDEF
C                                        SUBROUTINE    SUBCOD
C                                        SUBROUTINE    TSSMIL
C                                        SUBROUTINE    TWOARG
C
      SUBROUTINE ALARM(NUMBER,IPOS,ERLV,SUBNAM)
C
      IMPLICIT INTEGER (A-Z)
C
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C CNUMTB:      NUMBER TABLE
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),RTERM(2)
C RTERM:       (1)=CODE CLASS  4000,(2)=NAMTBL INDEX OF 'RTERM '
      EQUIVALENCE (RTERM(1),CODE(7))
C
C        7.    STRING STORAGE AREA
C              POINTER TO THE LAST PROCESSED CHARACTER OF A STATEMENT
      COMMON/INPTR/CNT
C
C       11.    SEQUENCE NUMBER STORAGE
C
      INCLUDE (SEQCOM)    
C SEQNO:       INTERNALLY GENERATED STATEMENT NUMBER
C SEQNUM:      ALPHANUMERIC REPRESENTATION OF CURRRENT STATEMENT NUMBER
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL PRTERR
      DIMENSION PRT(7)
C PRTERR:      TRUE IF PPOPTN/PRTER,ON. PRINTOUT OF STACK OR ARGSTK
      EQUIVALENCE (PRTERR,PRT(6))
C
C       21.    ERROR TEXT TABLE
C
      INCLUDE (ERRTXT)    
C ERND:        DIMENSION OF ERRAD1 AND ERRAD2 (PARTS OF ERRTXT)
C ERRDM:       DIMENSION OF ERRTXT
C ERRTXT:      STORAGE OF ERROR MESSAGES
C ERRAD1:      TRANSLATOR ERROR AND WARNING NUMBERS
C ERRAD2:      START POSITIONS OF ERROR MESSAGES IN ERRTXT
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL ILHLT,FINMAC
      DIMENSION MACXX1(71)
C ILHLT:       TRUE IF I.L. SHOULD NOT BE PLACED IN ILFILE
      EQUIVALENCE (ILHLT,MACXX1(14))
C FINMAC:      TRUE DURING FINAL MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C
C       33.    SYMBOLIC FILE DEFINITIONS
C
      INCLUDE (SYMFIL)    
C VLFILE:      VERIFICATION LISTING FILE
C
C       40.    PARAMETERS REQUIRED BY SUPERVISOR
C
      COMMON/SUPER/SUPER
      DIMENSION SUPER(36),XTRAS(7)
C ERRX:        ERROR LEVEL USED FOR SUPERVISOR
      EQUIVALENCE (ERRX,SUPER(5))
C XTRAS:       SPACE FOR ADDITIONAL PARAMETERS
      EQUIVALENCE (XTRAS(1),SUPER(10))
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ERRPNT,ESTACK,ERGSTK
      LOGICAL NOWARN
      DIMENSION ERRPOS(302),ERRPNT(100),ESTACK(100),ERGSTK(100)
C NOWARN:      FLAG TRUE IS SUPPRESSING OUTPUT OF WARNING NR. 50
      EQUIVALENCE (NOWARN,ERRPOS(1))
C ERRPNT:      CONTAINS POINTERS TO INPUT STATEMENT TEXT POSITION
      EQUIVALENCE (ERRPNT(1),ERRPOS(3))
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C ERGSTK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN ARGSTK
      EQUIVALENCE (ERGSTK(1),ERRPOS(203))
C*
C ARGUMENTS    NUMBER     INTEGER ERROR NUMBER
C              SUBNAM     NAME OF THE CALLING SUBROUTINE
C              IPOS       ERROR POSITION IN STACK OR ARGSTK
C
C... INITILIZE ARRAY INDICATING WHICH ERRORS ARE OF SEVERITY LEVEL FOUR.
C
      CHARACTER B*92,HERRNO*8,HEQU*16,HWARN*8,NOTEXT*52,FROM*16,SUBNAM*8
      CHARACTER*4 ASTRT,ESTRT,WSTRT,BLK,ISNCDE
      DATA B/' '/
      DATA ASTRT/'**  '/,ESTRT/'*$$*'/,WSTRT/'*$*$'/,BLK/'    '/
      DATA HERRNO/'ERR.NO. '/,HEQU/' EQUIVALENT TO  '/,HWARN/'WARNING '/
      DATA NOTEXT
     *     /'THERE IS NO DIAGNOSTIC MESSAGE FOR THIS ERROR NUMBER'/
      DATA ISNCDE/'ISN '/,ISEQ,INUM/2*0/
      DATA FROM /'FROM SUBROUTINE '/
C**
C...     CONVERT ERROR NO. TO BCD AND OUTPUT ERROR MESSAGE
C
C...     IF MACRO PROCESSING, ONLY OUTPUT ERROR DURING FINAL PASS
      IF((NUMBER.GE.20).AND.(NUMBER.LT.50))GO TO 5
      IF(ILHLT)GO TO 10
      IF(NUMBER.EQ.50.AND.NOWARN)GOTO 10
C
C...     POSITION OF ERROR IN THE INPUT STATEMENT
C
    5 IF(IPOS)510,550,520
  510 KK=ERGSTK(-IPOS)
      GOTO 530
  520 IF(IPOS.LT.2)IPOS=2
      KK=ESTACK(IPOS)
  530 IF(FINMAC)GOTO 600
      JJ=KK/100+1
      KK=MOD(KK,100)+12
      IF(JJ.EQ.1)GOTO 820
      CALL ICONV(JJ,B,KK+2,2)
      GOTO 820
  600 JJ=TOP
      IF(STACK(1,TOP).EQ.RTERM(2))JJ=JJ-1
      IF(IPOS.GT.0)JJ=MIN(IPOS+2,JJ)
      K=2
      KK=0
  605 B(1:88)=BLK
      J=12
C
      DO 650 I=K,JJ
      II=STACK(1,I)
      IF(II.LE.NAMMAX)GOTO 610
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
      II=II-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,II,IDUMMY)
      B(J:J+11)=CNUMTB(II)
      GOTO 620
  610 IF(II.LT.0)II=-NAMTBL(II)
      B(J:J+5)=CNAMTB(II)
  620 IF(I.EQ.IPOS)KK=J-1
      L=INDEX(B(J:J+11),' ')
      IF (L.EQ.0) THEN
        J=J+13
      ELSE
        J=J+L
      ENDIF
      IF(J.GT.68)GOTO 660
  650 CONTINUE
C
  660 IF(KK.GT.0)GOTO 790
      IF(I.GE.JJ)GOTO 670
      CALL FOUTXX(VLFILE,B,88)
      K=I+1
      GOTO 605
C
  670 IF(IPOS.GT.0)GOTO 550
      LL=-IPOS
      K=1
      GOTO 700
C
  680 B(1:88)=BLK
      J=12
C
  700 DO 750 I=K,ARGTOP
      B(J:J+1)=', '
      J=J+2
      L=ARGTOP+1-I
      II=ARGSTK(L)
      IF(II.LE.NAMMAX)GOTO 710
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
      II=II-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,II,IDUMMY)
      B(J:J+11)=CNUMTB(II)
      GOTO 720
  710 IF(II.LT.0)II=-NAMTBL(II)
      B(J:J+5)=CNAMTB(II)
  720 IF(L.NE.LL)GOTO 725
      KK=J-1
      GOTO 790
  725 L=INDEX(B(J:J+11),' ')
      IF (L.EQ.0) THEN
        J=J+13
      ELSE
        J=J+L
      ENDIF
      IF(J.GT.68)GOTO 760
  750 CONTINUE
C
  760 IF(KK.GT.0)GOTO 790
      IF(I.GE.ARGTOP)GOTO 550
      CALL FOUTXX(VLFILE,B,88)
      K=I+1
      GOTO 680
C
  790 CALL FOUTXX(VLFILE,B,88)
      B(1:88)=BLK
  820 CALL CFORM('A',B,KK,1)
      CALL FOUTXX(VLFILE,B,88)
      CALL CFORM('    ',B,KK,4)
C
C...     POSITION OF THE CURRENT ERROR NUMBER
C
  550 I=0
      NUMMIN=1
      NUMMAX=ERND
  200 NUMMER=(NUMMIN+NUMMAX)/2
      NUMB=ERRAD1(NUMMER)
      IF(I.GT.ERND)GOTO 230
      I=I+1
      IF(NUMBER-NUMB)220,230,210
  210 NUMMIN=NUMMER+1
      GOTO 200
  220 NUMMAX=NUMMER-1
      GOTO 200
  230 B(1:4)=ESTRT
      B(5:8)=ESTRT
      B(9:12)=ASTRT
      B(13:20)=HERRNO
      CALL BINBCD(NUMBER,B(21:),N)
      B(29:32)=BLK
      B(33:36)=ISNCDE
      B(37:44)=SEQNUM
      B(45:48)=BLK
      B(49:64)=FROM
      B(65:72)=SUBNAM
C
C... SET ERROR LEVEL INDICATOR FOR THE SUPERVISOR.
C
      I=2-ERLV/8
      XTRAS(I)=XTRAS(I)+1
      IF(ERLV.GT.ERRX)ERRX=ERLV
      IF(ERLV.EQ.8)GOTO 8
      B(1:4)=WSTRT
      B(5:8)=WSTRT
      B(13:20)=HWARN
    8 CALL FOUTXX(VLFILE,B,88)
C
      IF(ISEQ.EQ.SEQNO.AND.INUM.EQ.NUMBER)GOTO 150
      IF(I.LE.ERND)GOTO 235
      B(13:64)=NOTEXT
      GOTO 245
  235 KK=ERRAD2(NUMMER)
      IF (NUMMER.EQ.1) THEN
        II=NUMMER
      ELSE
        II=ERRAD2(NUMMER-1)+1
      ENDIF
  237 K=12
      DO 240 I=II,KK
      IF(K.GE.92)GOTO 245
      K=K+4
  240 B(K-3:K)=ERRTXT(I)
  245 IF (NUMBER.EQ.2058) THEN
        B(49:56)=CNAMTB(STACK(1,TOP+2))//'  '
        B(69:76)=CNAMTB(STACK(1,TOP+1))//'  '
        SEQNO=0
      ENDIF
      CALL FOUTXX(VLFILE,B,K)
      IF((KK-II).LT.20)GOTO 150
      II=I
      GOTO 237
C
  150 IF (.NOT. PRTERR) GO TO 250
      I=NUMBER/1000+1
      J = 1
      B(1:44)=BLK
C
C...     BRANCH ON ERROR TYPE (= NUMBER/1000) TO SET UP DUMP LIMITS
C
      GO TO(250,20,30,40),I
C
C...     1000 SERIES - DUMP STACK (FROM 1 TO TOP)
C
   20 K=TOP
      IF(NUMBER.EQ.1028) K=TOP-1
      GO TO 50
C
C...     2000 SERIES - DUMP ARGSTK (FROM 1 TO ARGTOP)
C
   30 K=ARGTOP
      GO TO 50
C
C...     3000 SERIES - DUMP NAME PORTION OF NAMTBL (FROM 1 TO NAMMAX)
C
   40 K=NAMMAX
      GOTO 50
C
C...     THIS LOOP DUMPS APPROPRIATE TABLE
C
   50 DO 120 L=J,K
C
C...     BRANCH ON ERROR TYPE TO DUMP APPROPRIATE TABLE
C
      GO TO(250,70,80,90),I
C
C...     1000 SERIES - EXTRACT NAMTBL POINTER FROM STACK
C
   70 M=STACK(1,L)
      GO TO 60
C
C...     2000 SERIES - EXTRACT NAMTBL POINTER FROM ARGSTK
C
   80 M=ARGTOP+1-L
      M=ARGSTK(M)
      GO TO 60
C
C...     3000 SERIES - USE NAMTBL POINTER
C
   90 M=L
C
C...     BRANCH IF ITEM IS NOT A NUMBER
C
   60 IF (M.LE.NAMMAX) GOTO 61
C
C...     STORE BCD OF NUMBER
C
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
      M=M-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,M,IDUMMY)
      B(5:16) = CNUMTB(M)
      B(17:20)=B(1:4)
      GOTO 62
C
C...     STORE BCD OF NAME
C
   61 B(5:10) =CNAMTB(M)
C
C...     IS IT A SYNONYM
C
      IF(NAMTBL(M).LT.0) GO TO 105
C
C...     NO. CONVERT CLASS/MODE TO BCD.
C
      CALL BINBCD(NAMTBL(M),B(13:),N)
C
C...     OUTPUT LINE
C
   62 IF(PRTERR) CALL FOUTXX(VLFILE,B,20)
      GOTO 110
C
C...     SYNONYM - FIND EQUIVALENT NAME, CONVERT TO BCD AND OUTPUT
C
  105 M = -NAMTBL(M)
      B(13:28)=HEQU
      B(29:34) = CNAMTB(M)
      CALL BINBCD(NAMTBL(M),B(37:),N)
      IF(PRTERR) CALL FOUTXX(VLFILE,B,44)
  110 CONTINUE
C
C.....   END OF LOOP
C
  120 CONTINUE
C
C...     ALL OF RELEVANT INFORMATION HAS BEEN PRINTED - RETURN
C
  250 B(1:88)=BLK
      CALL FOUTXX(VLFILE,B,88)
      ISEQ=SEQNO
      INUM=NUMBER
   10 RETURN
      END
**** SOURCE FILE : ANDF0000.ORG   ***
*
      INTEGER FUNCTION ANDF(A,B)
C
C.   THIS ROUTINE IS COMPILER DEPENDENT.
C
C    TWO POSSIBLE SOLUTIONS ARE OUTLINED HERE
C
C-VAX-VERSION
C
      INTEGER A,B
      ANDF=IAND(A,B)
C
C-PRIME=VERSION
C
C      INTEGER
C      ANDF=AND(A,B)
C
      RETURN
      END
**** SOURCE FILE : M0006616.V03   ***
*
C
C              FORTRAN SUBROUTINE ARGCVT
C
C LINKAGE      SUBROUTINE ARGCVT(INDEX)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    TWOARG          SUBROUTINE    ARGGEN
C                                        SUBROUTINE    ASNADZ
C                                        SUBROUTINE    BOOLIF
C                                        SUBROUTINE    GOLO
C                                        SUBROUTINE    GOPAT
C                                        SUBROUTINE    INPAT
C                                        SUBROUTINE    ISSCOD
C                                        SUBROUTINE    LARGES
C                                        SUBROUTINE    LCANON
C                                        SUBROUTINE    LOOP
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    MOTION
C                                        SUBROUTINE    PRO020
C                                        SUBROUTINE    PRO021
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    REFGEN
C                                        SUBROUTINE    REFREF
C                                        SUBROUTINE    REPLAC
C                                        SUBROUTINE    SSDEF
C                                        SUBROUTINE    SUBCOD
C                                        SUBROUTINE    TSSMIL
C
      SUBROUTINE ARGCVT(INDEX)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),TEMP(2),LABEL(2),IMPLAB(2),VBL(2)
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C IMPLAB:      (1)=CODE CLASS 23000,(2)=NAMTBL INDEX OF 'IMPLAB'
      EQUIVALENCE (IMPLAB(1),CODE(45))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C NOUGHT:      CONTAINS OPERAND TYPE 0
      EQUIVALENCE (NOUGHT,OPMOD(1))
C DLR:         CONTAINS OPERAND TYPE CODE 1
      EQUIVALENCE (DLR,OPMOD(2))
C DBLDLR:      CONTAINS OPERAND TYPE CODE 2
      EQUIVALENCE (DBLDLR,OPMOD(3))
C TRPDLR:      CONTAINS OPERAND TYPE CODE 3
      EQUIVALENCE (TRPDLR,OPMOD(4))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C*
C PURPOSE      TO DETERMINE THE LITERAL DESIGNATION OF AN
C              ARGUMENT AND OUTPUT THE APPROPRIATE ARGUMENT-
C              PAIR TO THE I.L. INTERNAL RECORD IMAGE
C              (ILFILE)
C
C ARGUMENTS    INDEX    NAME TABLE (NAMTBL) INDEX OF ARGUMENT.
C**
C...     IS INDEX A POINTER TO A NUMBER
C
      IF(INDEX.GT.NAMMAX) GOTO 20
C
C...     NO. CALCULATE CLASS OF THIS ITEM.
C
      L = MODULO*(NAMTBL(INDEX)/MODULO)
C
C...     IS MODE OF ITEM GREATER THAN MODHLF
C...     I.E. IS IT AN INDIRECT ADDRESS
C
      IF((NAMTBL(INDEX)-L).LT.MODHLF) GO TO 10
C
C...     YES. CALL TWOARG WITH MODIFIER OF 3 ($$$)
C
      CALL TWOARG(TRPDLR,INDEX)
      GO TO 100
C
C...     NOT AN INDIRECT ADDRESS.
C...     IS IT OF CLASS VBL, TEMP, LABEL, OR IMPLAB.
C
   10 IF ((L.NE.VBL(1)).AND.(L.NE.TEMP(1)).AND.(L.NE.LABEL(1))
     / .AND.(L.NE.IMPLAB(1))) GOTO 30
C
C...     YES. CALL TWOARG WITH MODIFIER OF 0
C
      CALL TWOARG(NOUGHT,INDEX)
      GO TO 100
C
C...     NUMBER. CALL TWOARG WITH MODIFIER OF 1 ($)
C
   20 CALL TWOARG(DLR,INDEX)
      GO TO 100
C
C...     BCD CHARACTER INDEX. CALL TWOARG WITH MODIFIER OF 2 ($$)
C
   30 CALL TWOARG(DBLDLR,INDEX)
  100 RETURN
       END
**** SOURCE FILE : M0006617.V01   ***
*
C
C              FORTRAN SUBROUTINE ARGGEN
C
C LINKAGE      SUBROUTINE ARGGEN
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ARGCVT          SUBROUTINE    PRO020
C                                        SUBROUTINE    PRO021
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    RECOG
C
      SUBROUTINE ARGGEN
C
      IMPLICIT INTEGER (A-Z)
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),ARGSTK(99)
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C*
C PURPOSE      OUTPUTS ENTIRE CONTENTS OF THE ARGUMENT
C              STACK (ARGSTK) TO THE I.L. INTERNAL RECORD
C              IMAGE (ILFILE).
C NOTES        THE ARGUMENTS ARE PLACED IN ILFILE IN THE
C              REVERSE ORDER IN WHICH THEY ARE STORED IN
C              ARGSTK.
C**
C...     FETCH ITEMS FROM ARGSTK IN REVERSE ORDER TO THAT IN WHICH
C...     THEY WERE INSERTED, AND OUTPUT TO ILFILE USING ARGCVT.
C
      DO 1 II = 1,ARGTOP
      I = ARGTOP-II+1
      K = ARGSTK(I)
    1 CALL ARGCVT(K)
C
C...     SET ARGTOP TO ZERO (I.E. CLEAR ARGSTK) AND RETURN
C
      ARGTOP = 0
      RETURN
       END
**** SOURCE FILE : M0006618.V01   ***
*
C
C              FORTRAN SUBROUTINE ASNADZ
C
C LINKAGE      SUBROUTINE ASNADZ(IADD,ITAKE)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ARGCVT          SUBROUTINE    COMSTR
C          SUBROUTINE    ONEARG          SUBROUTINE    MACREC
C          SUBROUTINE    OPCODE
C          SUBROUTINE    RLSLIN
C
      SUBROUTINE ASNADZ(IADD,ITAKE)
C
      IMPLICIT INTEGER (A-Z)
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C ASNADD:      CONTAINS COMMAND CODE (15) FOR ASNADD COMMAND
      EQUIVALENCE (ASNADD,IL(15))
C*
C PURPOSE      TO GENERATE AND OUTPUT TO THE I.L. INTERNAL
C              RECORD IMAGE (ILFILE) THE ASNADD I.L. COMMAND
C              THAT STORES THE ADDRESS OF AN ASSIGNED VALUE
C              AS THE VALUE OF A MACRO VARIABLE.
C
C ARGUMENTS    IADD     NAME TABLE (NAMTBL) INDEX OF MACRO VARIABLE
C              ITAKE    NAME TABLE INDEX OF ASSIGNED VALUE.
C
C NOTES        INDIRECT ADDRESSING EMPLOYED TO RETRIEVE
C              ASSIGNED VALUE.
C**
      CALL OPCODE(ASNADD)
      CALL ONEARG(IADD)
      CALL ARGCVT(ITAKE)
      CALL RLSLIN
       RETURN
       END
**** SOURCE FILE : M0006619.V01   ***
*
C
C              FORTRAN SUBROUTINE ASNJPZ
C
C LINKAGE      SUBROUTINE ASNJPZ(ILBL,ITAKE)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    OPCODE          SUBROUTINE    COMSTR
C          SUBROUTINE    RLSLIN
C          SUBROUTINE    TWOARG
C
      SUBROUTINE ASNJPZ(ILBL,ITAKE)
C
      IMPLICIT INTEGER (A-Z)
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C ASNJMP:      CONTAINS COMMAND CODE (16) FOR ASNJMP COMMAND
      EQUIVALENCE (ASNJMP,IL(16))
C*
C PURPOSE      TO GENERATE AND OUTPUT TO THE I.L. INTERNAL
C              RECORD IMAGE (ILFILE) THE ASNJPZ I.L.
C              COMMAND THAT STORES THE ADDRESS OF A LABEL
C              AS THE VALUE OF A MACRO VARIABLE.
C
C ARGUMENTS    ILBL    NAME TABLE (NAMTBL) INDEX OF MACRO VARIABLE.
C              ITAKE   NAME TABLE (NAMTBL) INDEX OF LABEL.
C**
      CALL OPCODE(ASNJMP)
      CALL TWOARG(ILBL,ITAKE)
      CALL RLSLIN
       RETURN
       END
**** SOURCE FILE : M0000500.V03   ***
*
C
C.....IMPLEMENTATION DEPENDENT SUBROUTINE ...BCDBIN   8/68          HG
C.... IMPLEMENTATION DEPENDENT   ....BCDBIN....   HLG  12/67      ..CD.
C PURPOSE      TO CONVERT AN INTEGER FROM BCD TO BINARY.
C
C LINKAGE      CALL BCDBIN (WORD, I, COUNT)
C
C ARGUMENTS    WORD     CONTAINS THE BCD REPRESENTATION OF
C                       THE NUMBER, LEFT JUSTIFIED.
C              I        WILL CONTAIN THE BINARY INTEGER
C              COUNT    WILL CONTAIN A COUNT OF THE NUMBER
C                       OF DIGITS IN THE NUMBER.
C
C
C SUBSIDIARIES TYPE                ENTRY
C              SUBROUTINE          HELP
C
C
      SUBROUTINE BCDBIN(WORD,I,COUNT)
C
      INTEGER I,COUNT,NUM
      CHARACTER WORD*8,W*8,CHAR,ZERO,PERIOD,BLANK
C
      DATA PERIOD/'.'/,BLANK/' '/,ZERO/'0'/
C
      W=WORD
      I=0
      DO 300 J=1,8
      COUNT=J
      CHAR=W(J:J)
      IF( CHAR   .EQ.PERIOD.OR. CHAR   .EQ.BLANK) GOTO 100
      NUM=ICHAR(CHAR)-ICHAR(ZERO)
      IF(NUM.GT.9.OR.NUM.LT.0) GOTO 400
      I=I*10+NUM
  300 CONTINUE
  200 RETURN
  100 COUNT=COUNT-1
      GOTO 200
  400 COUNT = -1
      GOTO 200
      END
**** SOURCE FILE : M0006641.V06   ***
*
C
C...  FORTRAN BLOCK DATA ROUTINE       IPL       8/81      FE353
C
      BLOCK DATA BDIPL
C
      IMPLICIT INTEGER (A-Z)
C
C...        34.    COMMON BLOCK FOR INTERPRETIVE C.I.L. OUTPUT
C
      INCLUDE (OUTBUF)    
C
C...        20.    IO - ARRAY
C
      INCLUDE (DARRAY)    
C
C...        34.    COMMON BLOCK FOR INTERPRETIVE C.I.L. OUTPUT
C
      DATA PPPAGE,MCPAGE,PAGPAK,ISC,ISCARR,ICFORM,MACWDS,IBUF,ILBUF,
     1PPWRDS,LPAGE,MACFLG,LABFLG,RSVFLG/0,0,65536,8*0,3*.FALSE./,
     2 IFLOAT,ICOM/2*0/
C
C...        20.    IO - ARRAY
C
      DATA DARRAY/' '/
      END
**** SOURCE FILE : BDSDP000.ORG   ***
*
      BLOCK DATA BDSDP
C
C  PURPOSE TO INITIALIZE SYSTEM DEPENDENT PARAMETERS
C
      INCLUDE (SDP)    
C
C     NBCHAR:  NO. OF BITS PER BYTE
      DATA NBCHAR/8/
C     NBWRD:   NO OF BITS PER WORD
      DATA NBWRD/32/
C     IWRD:    NO OF BYTES PER WORD
      DATA IWRD/4/
C     IFAC:    BYTE LEFT SHIFT MULTIPLICATION FACTOR
      DATA IFAC/256/
C
      END
**** SOURCE FILE : M0000502.W01   ***
*
C
C *  BINBCD  *  FORTRAN 77 SUBROUTINE   E.MCLELLAN  06.85
C
      SUBROUTINE BINBCD(JNTGER,SYMBOL,COUNT)
      INTEGER COUNT,INTGER
      CHARACTER SYMBOL*(*),BCD*8,ZERO,BLANK
      DATA BLANK/' '/,ZERO/'0'/
C
      INTGER=JNTGER
      COUNT=0
      BCD=BLANK
      IF(INTGER.LT.0) THEN
        SYMBOL=BCD
      ELSE
        WRITE(BCD,'(I8)') INTGER
        DO 10 I=1,8
          IF (BCD(I:I).NE.BLANK) THEN
            J=I
            GOTO 20
          ENDIF
   10   CONTINUE
C
   20   COUNT=9-J
        SYMBOL=BCD(J:8)//BLANK
      ENDIF
      RETURN
      END
**** SOURCE FILE : M0006621.W02   ***
*
C
C              FORTRAN SUBROUTINE BINCHK
C
C LINKAGE      SUBROUTINE BINCHK(I)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    BCDBIN          SUBROUTINE    ICMPRS
C
      SUBROUTINE BINCHK(I)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C IFIXST:      NAMTBL INDEX OF BEGINNING OF FIXED POINT NUMBER SECTION
C
C       19.    INTERMEDIATE LANGUAGE TEXT
C
      COMMON/ILTEXT/ILTEXT
      DIMENSION ILTEXT(94),TEXTIN(90)
C OPTEXT:      CONTAINS COMMAND CODE FOR CURRENT I.L. COMMAND
      EQUIVALENCE (OPTEXT,ILTEXT(4))
C TEXTIN:      STORAGE FOR CURRENTLY GENERATED I.L. COMMAND ARGUM.LIST
      EQUIVALENCE (TEXTIN(1),ILTEXT(5))
C
      INCLUDE (NUMBLK)    
C
C**
C...     IS ARGUMENT MODIFIER 1 OR 6
C
      IF (TEXTIN(I).EQ.6) GOTO 5
      IF (TEXTIN(I).NE.1) RETURN
C
C...     YES. IS INDEX A POINTER TO AN INTEGER
C
      IF (TEXTIN(I+1).GT.(IFIXST+9)) RETURN
C
C...     YES. STORE MODIFIER OF 5 AND BINARY INTEGER
C
      TEXTIN(I) = 5
    5 J = TEXTIN(I+1)-NAMMAX
      CALL BCDBIN(CNUMTB(J),KK,K)
      IF (KK.GT.32767) THEN
        TEXTIN(I)=7
        NMBRS=NMBRS+1
      ELSE
        TEXTIN(I+1)=KK
      ENDIF
      RETURN
       END
**** SOURCE FILE : M0006623.V01   ***
*
C
C              FORTRAN SUBROUTINE BITMCH
C
C LINKAGE      LOGICAL FUNCTION BITMCH(WORD,N)
C
C          SUBSIDIARIES                  CALLED BY
C          NONE                          TYPE          ENTRY
C                                        SUBROUTINE    COMSTR
C
      LOGICAL FUNCTION BITMCH(WORD,N)
C
      IMPLICIT INTEGER (A-Z)
C
C       32.    COMMON BLOCK FOR SETBIT AND BITMCH
C              CONTAINS ONE WORD FOR EACH BIT WITH ONLY THAT BIT SET
      COMMON/BITCOM/BIT
      DIMENSION BIT(32)
C*
C PURPOSE      TO DETERMINE WHETHER THE BIT POSITION DESIGNATED
C              BY THE SECOND ARGUMENT N IS SET IN THE FIRST
C              ARGUMENT WORD.
C
C ARGUMENTS    WORD    ELEMENT WHOSE BIT POSITION IS BEING EXAMINED
C              N       BIT POSITION
C**
      BITMCH=.FALSE.
      IF (MOD(WORD/BIT(N+1),2) .EQ. 1) BITMCH= .TRUE.
   2  RETURN
       END
**** SOURCE FILE : M0006624.W03   ***
*
C
C              FORTRAN SUBROUTINE BOOLIF
C
C LINKAGE      SUBROUTINE  BOOLIF(PROD)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ARGCVT          SUBROUTINE    RECOG
C          SUBROUTINE    MACLBL          SUBROUTINE    INPUT
C          LOGICAL FCT.  IFTMP
C          INTEGER FCT.  MODE
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          INTEGER FCT.  GETTMP
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    RLSLIN
C          SUBROUTINE    LABELZ
C          SUBROUTINE    ALARM
C          SUBROUTINE    TWOARG
C
      SUBROUTINE  BOOLIF(PROD)
C
      IMPLICIT INTEGER (A-Z)
C
C              FUNCTION DECLARATION
      LOGICAL IFTMP
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),NUMBER(2),LABEL(2),IMPLAB(2),RELAT(2),AND(2)
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C IMPLAB:      (1)=CODE CLASS 23000,(2)=NAMTBL INDEX OF 'IMPLAB'
      EQUIVALENCE (IMPLAB(1),CODE(45))
C RELAT:       (1)=CODE CLASS 27000,(2)=NAMTBL INDEX OF 'RELAT '
      EQUIVALENCE (RELAT(1),CODE(53))
C AND:         (1)=CODE CLASS 29000,(2)=NAMTBL INDEX OF 'AND   '
      EQUIVALENCE (AND(1),CODE(57))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(501),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C CONJMP:      CONTAINS COMMAND CODE (11) FOR CONJMP COMMAND
      EQUIVALENCE (CONJMP,IL(11))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C REAL:        MODE CODE (21) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C BOOL:        MODE CODE (23) FOR BOOLEAN
      EQUIVALENCE (BOOL,MODX(23))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL FINMAC
      DIMENSION MACXX1(71)
C FINMAC:      TRUE IF SECOND FINAL PASS OF MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C WHCHMN:      EQUAL TO NUMBER OF CURRENT MACRO BEING PROCESSED
      EQUIVALENCE (WHCHMN,MACXX1(63))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C QUIDLR:      CONTAINS OPERAND TYPE CODE 5
      EQUIVALENCE (QUIDLR,OPMOD(6))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136)
C LOGIF:       NAMTBL POINTER TO EXECUTION SUBROUTINE RELAT
      EQUIVALENCE (LOGIF,SUBLST(104))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       43.    DO LOOP CONTROL VALUES
C
      COMMON/DOLOOP/DOLOOP
      LOGICAL IFFLAG
      DIMENSION DOLOOP(9)
C JUMPTO:      MARKER SET AFTER JUMPTO OR IF FOR LABEL CONTROL
      EQUIVALENCE (JUMPTO,DOLOOP(1))
C IFFLAG:      FLAG ON WHEN LOGICAL IF OCCURS
      EQUIVALENCE (IFFLAG,DOLOOP(9))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ESTACK,ERGSTK
      DIMENSION ERRPOS(302),ESTACK(100),ERGSTK(100)
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C ERGSTK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN ARGSTK
      EQUIVALENCE (ERGSTK(1),ERRPOS(203))
C*
      DIMENSION LGSTK(50)
      LOGICAL BOLFLG
      DATA KK/20000/,LASTMN/-1/
C**
      IF(PROD.GT.0)GOTO 5
      IF(LASTMN.NE.WHCHMN) GOTO 300
      IFFLAG=.FALSE.
      LASTMN=-1
      CALL LABELZ(LBL)
      JUMPTO=0
      GOTO 300
C
    5 IF(ARGTOP.EQ.0)BOLFLG=.FALSE.
      GOTO(10,20,50,70,70),PROD
C
C     PRODUKTION 34:  ALL $ VBL $ NOT
C
   10 K=STACK(1,TOP-1)
      IF(IFTMP(K))GOTO 310
      IF(MOD(NAMTBL(K),MODHLF).NE.BOOL)
     *CALL ALARM(1008,TOP-1,8,'BOOLIF  ')
      RSLT=GETTMP(BOOL)
      CALL CALLZZ(LOGIF)
      CALL ARGCVT(RSLT)
      CALL TWOARG(QUIDLR,7)
      CALL ARGCVT(K)
      CALL ARGCVT(K)
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=RSLT
      BOLFLG=.TRUE.
      STACK(1,TOP-2)=RSLT
      STACK(2,TOP-2)=META(NAMTBL(RSLT)/MODULO)
      STACK(1,TOP-1)=STACK(1,TOP)
      STACK(2,TOP-1)=STACK(2,TOP)
      ERGSTK(ARGTOP)=ESTACK(TOP-1)
      TOP=TOP-1
      GOTO 40
C
C     PRODUKTION 35: ALL $ VBL,TEMP,NUMBER $ RELAT $ VBL,TEMP,NUMBER
C
   20 DO 30 I=1,3,2
      J=MODE(STACK(1,TOP-I))
   30 IF(J.NE.REAL)CALL ALARM(1008,TOP-I,8,'BOOLIF  ')
      ART=NAMTBL(STACK(1,TOP-2))-RELAT(1)
      RSLT=GETTMP(BOOL)
      CALL CALLZZ(LOGIF)
      CALL ARGCVT(RSLT)
      CALL TWOARG(QUIDLR,ART)
      CALL ARGCVT(STACK(1,TOP-3))
      CALL ARGCVT(STACK(1,TOP-1))
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=RSLT
      BOLFLG=.TRUE.
      STACK(1,TOP-3)=RSLT
      STACK(2,TOP-3)=META(NAMTBL(RSLT)/MODULO)
      STACK(1,TOP-2)=STACK(1,TOP)
      STACK(2,TOP-2)=STACK(2,TOP)
      ERGSTK(ARGTOP)=ESTACK(TOP-2)
      TOP=TOP-2
   40 CALL RLSLIN
      GOTO 300
C
C     PRODUKTION 36:  ALL $ VBL,TEMP $ AND,OR $ VBL,TEMP
C
   50 IF(BOLFLG)GOTO 60
      K=STACK(1,TOP-1)
      IF(MOD(NAMTBL(K),MODHLF).NE.BOOL)
     *CALL ALARM(1008,TOP-1,8,'BOOLIF  ')
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=STACK(1,TOP-1)
      ERGSTK(ARGTOP)=ESTACK(TOP-1)
   60 BOLFLG=.FALSE.
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=STACK(1,TOP-2)
      ERGSTK(ARGTOP)=ESTACK(TOP-2)
      STACK(1,TOP-2)=STACK(1,TOP)
      STACK(2,TOP-2)=STACK(2,TOP)
      TOP=TOP-2
      GOTO 300
C
C     PRODUKTION 32:    ( $ VBL,TEMP,NUMBER $ ) $ IF $ LTERM
C     PRODUKTION 23,24: RTERM $ VBL,TEMP,NUMBER  $ = .......
C
   70 IF(BOLFLG)GOTO 80
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=STACK(1,TOP-1)
      ERGSTK(ARGTOP)=ESTACK(TOP-1)
      BOLFLG=.TRUE.
   80 RSLT=STACK(1,TOP-1)
      IF(ARGTOP.LE.1)GOTO 200
      ART=AND(1)/MODULO
      TP=0
      I=0
  100 RSLT=0
  110 I=I+2
      IF(I.GE.ARGTOP)GOTO 170
      K=ARGSTK(I)
      L=ARGSTK(I-1)
      IF(NAMTBL(K)/MODULO.EQ.ART)GOTO 130
      IF(.NOT.BOLFLG)GOTO 120
      TP=TP+1
      LGSTK(TP)=L
  120 BOLFLG=.TRUE.
      GOTO 100
C
C     HANDLING OF OTHER TEMPORARY RESULTS IN STACK
C
  130 J=ARGSTK(I+1)
      IF(RSLT.GT.0)GOTO 150
      IF(IFTMP(L))RSLT=L
      IF(RSLT.GT.0)GOTO 140
      IF(IFTMP(J))RSLT=J
      IF(RSLT.GT.0)GOTO 140
      RSLT=GETTMP(BOOL)
  140 TP=TP+1
      LGSTK(TP)=RSLT
      CALL CALLZZ(LOGIF)
      CALL ARGCVT(RSLT)
      CALL TWOARG(QUIDLR,9)
      CALL ARGCVT(J)
      CALL ARGCVT(L)
      GOTO 160
  150 CALL CALLZZ(LOGIF)
      CALL ARGCVT(RSLT)
      CALL TWOARG(QUIDLR,9)
      CALL ARGCVT(RSLT)
      CALL ARGCVT(J)
  160 CALL RLSLIN
      BOLFLG=.FALSE.
      GOTO 100
C
  170 IF(.NOT.BOLFLG)GOTO 180
      TP=TP+1
      LGSTK(TP)=ARGSTK(ARGTOP)
C
C    PROCESSING OF OR
C
  180 RSLT=LGSTK(1)
      IF(TP.EQ.2)GOTO 200
      K=RSLT
      IF(IFTMP(RSLT))GOTO 185
      RSLT=GETTMP(BOOL)
  185 DO 190 I=2,TP
      CALL CALLZZ(LOGIF)
      CALL ARGCVT(RSLT)
      CALL TWOARG(QUIDLR,8)
      CALL ARGCVT(K)
      CALL ARGCVT(LGSTK(I))
      CALL RLSLIN
  190 K=RSLT
C
C     WORKING UP OF IF(BOOL) LAB1,LAB1,LAB2
C
  200 IF (PROD.NE.5)GOTO 210
      STACK(1,TOP-1)=RSLT
      STACK(2,TOP-1)=META(NAMTBL(RSLT)/MODULO)
      GOTO 300
  210 CALL OPCODE(CONJMP)
      CALL ARGCVT(RSLT)
      L=WHCHMN
      IF(L.EQ.0)L=MSEQDM+3
      KK=KK+50000
      CALL MACLBL(KK,-L,JJ)
      NAMTBL(JJ)=JJ
      KK=KK+50000
      CALL MACLBL(KK,-L,K)
      IF((.NOT.FINMAC).AND.(WHCHMN.NE.0))GOTO 220
      NAMTBL(JJ)=LABEL(1)+WHCHMN
      NAMTBL(K)=LABEL(1)+WHCHMN
      GOTO 230
C
C     WORKING UP OF IF-LABELS
C
  220 NAMTBL(JJ)=IMPLAB(1)+WHCHMN
      NAMTBL(K)=IMPLAB(1)+WHCHMN
  230 CALL ONEARG(JJ)
      CALL ONEARG(JJ)
      CALL ONEARG(K)
      CALL RLSLIN
      CALL LABELZ(K)
      IF (IFFLAG)GOTO 290
      LBL=JJ
      LASTMN=WHCHMN
      IFFLAG=.TRUE.
  290 BOLFLG=.FALSE.
      TOP=0
  300 RETURN
C
  310 CALL ALARM(1007,TOP-1,8,'BOOLIF  ')
      TOP=-1
      GOTO 300
C
      END
**** SOURCE FILE : M0006622.V01   ***
*
C
C              FORTRAN SUBROUTINE CALLZZ
C
C LINKAGE      SUBROUTINE CALLZZ(INDEX)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ONEARG          SUBROUTINE    BOOLIF
C          SUBROUTINE    OPCODE          SUBROUTINE    COMSTR
C                                        SUBROUTINE    GOLO
C                                        SUBROUTINE    GOPAT
C                                        SUBROUTINE    INPAT
C                                        SUBROUTINE    LARGES
C                                        SUBROUTINE    LCANON
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    MOTION
C                                        SUBROUTINE    PRO020
C                                        SUBROUTINE    PRO021
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    REFGEN
C                                        SUBROUTINE    REFREF
C                                        SUBROUTINE    SSDEF
C                                        SUBROUTINE    TSSMIL
C
      SUBROUTINE CALLZZ(INDEX)
C
      IMPLICIT INTEGER (A-Z)
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C CALL:        CONTAINS COMMAND CODE (18) FOR CALL COMMAND
      EQUIVALENCE (CALL,IL(18))
C*
C PURPOSE      TO GENERATE THE I.L. FOR A CALL OPCODE AND
C              THE PROCEDURE INDEX.
C
C ARGUMENTS    INDEX  NAME TABLE (NAMTBL) INDEX OF THE PROCEDURE NAME.
C**
C...     GENERATE CALL OPCODE, AND FIRST ARGUMENT (PROCEDURE INDEX)
C
      CALL OPCODE(CALL)
      CALL ONEARG(INDEX)
      RETURN
       END
**** SOURCE FILE : M0006625.V01   ***
*
C
C              FORTRAN SUBROUTINE CALMCX
C
C LINKAGE      SUBROUTINE CALMCX(NPNTR,LEV,INDX)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ONEARG          SUBROUTINE    INPUT
C          SUBROUTINE    OPCODE          SUBROUTINE    MACREC
C          SUBROUTINE    RLSLIN          SUBROUTINE    PATH
C          SUBROUTINE    TWOARG
C
      SUBROUTINE CALMCX(NPNTR,LEV,INDX)
C
      IMPLICIT INTEGER (A-Z)
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C CALMC:       CONTAINS COMMAND CODE (14) FOR CALMC COMMAND
      EQUIVALENCE (CALMC,IL(14))
C*
C PURPOSE      TO GENERATE AND OUTPUT TO THE I.L. INTERNAL
C              RECORD IMAGE (ILFILE) THE CALMC I.L. COMMAND
C              THAT ESTABLISHES LINKAGE WITH REMOTE APT
C              MACRO I.L..
C
C ARGUMENTS    NPNTR  NAME TABLE (NAMTBL) INDEX OF LABEL.
C              LEV    LEVEL OF CALL TO MACRO.
C**            INDX   INDEX REGISTER NUMBER.
C
C...     GENERATE I.L. CALMC COMMAND
C
      CALL OPCODE(CALMC)
      CALL ONEARG(NPNTR)
      CALL TWOARG(LEV,INDX)
      CALL RLSLIN
      RETURN
       END
**** SOURCE FILE : M0006627.V03   ***
*
C
C              FORTRAN SUBROUTINE CLMODE
C
C LINKAGE      INTEGER FUNCTION CLMODE (WHERE)
C
C          SUBSIDIARIES                  CALLED BY
C          NONE                          TYPE          ENTRY
C                                        SUBROUTINE    GOLO
C                                        SUBROUTINE    PRO026
C
      INTEGER FUNCTION CLMODE (WHERE)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),NUMBER(2),TEMP(2),PERMID(2),VBL(2)
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C*
C PURPOSE      TO FIND THE CLMODE OF AN ARGUMENT FOR USE BY
C              THE CLTAPE EDITOR IN PROCESSING POST-PRO-
C              CESSOR AND CLTAPE EDITOR COMMANDS.
C
C ARGUMENTS    WHERE    NAMTBL INDEX OF ARGUMENT
C**
      IF(WHERE.GT.NAMMAX)GO TO 50
C
C...     SET WHAT TO CLASS OF WHERE
C
      WHAT=MODULO*(NAMTBL(WHERE)/MODULO)
C
C...     TEST FOR NUMBER
C
      IF(WHAT.NE.NUMBER(1))GO TO 100
C
C...     NUMBER - SET CLMODE TO 1
C
   50 CLMODE=1
      RETURN
C
C...     TEST FOR CLASS PERMANENT IDENTIFIER
C
  100 IF(WHAT.NE.PERMID(1))GO TO 200
C
C...     PERMID - SET CLMODE TO 2
C
      CLMODE = 2
      RETURN
C
C...     TEST FOR CLASS VARIABLE OR TEMPORARY
C
  200 IF ((WHAT.NE.VBL(1)).AND.(WHAT.NE.TEMP(1))) GOTO 9999
C
C...     VBL OR TEMP - SET CLMODE TO (TRANSLATOR MODE + 2)
C
      CLMODE = MOD(NAMTBL(WHERE),MODHLF) + 2
      IF(CLMODE.EQ.23) CLMODE=1
      RETURN
C
C...     ILLEGAL META-LINGUISTIC CLASS - SET CLMODE TO ZERO.
C
 9999 CLMODE = 0
      RETURN
       END
**** SOURCE FILE : M0006628.V04   ***
*
C              FORTRAN SUBROUTINE COMSTR
C
C LINKAGE      SUBROUTINE COMSTR
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ASNADZ          SUBROUTINE    MACREC
C          SUBROUTINE    ASNJPZ
C          LOGICAL FCT.  BITMCH
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    JUMPZZ
C          SUBROUTINE    ALARM
C          SUBROUTINE    LABELZ
C          SUBROUTINE    MACLBL
C          INTEGER FCT.  NAME
C          SUBROUTINE    RETMCX
C          SUBROUTINE    RLSLIN
C
      SUBROUTINE COMSTR
C
      IMPLICIT INTEGER (A-Z)
C
C              FUNCTION DECLARATION
C
      LOGICAL BITMCH
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE
C CNAMTB:      NAME TABLE OR DICTIONARY
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),LABEL(2)
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      DIMENSION MACXX1(71)
C MCSAVP:      PRESENT NEST LEVEL DURING MACRO PROCESSING
      EQUIVALENCE (MCSAVP,MACXX1(5))
C MAXSPS:      NUMBER OF MACRO VARIABLES+1 FOR CURRENT MACRO
      EQUIVALENCE (MAXSPS,MACXX1(21))
C NUMCAL:      CONTAINS NUMBER OF CALLS FOR CURRENT MACRO
      EQUIVALENCE (NUMCAL,MACXX1(28))
C BITWDS:      NUMBER OF WORDS NEEDED FOR ALL CALL QUALITIES OF MACRO
      EQUIVALENCE (BITWDS,MACXX1(29))
C MACTOP:      POINTER TO EXPRESSION NUMBER IN MACSPD TABLE
      EQUIVALENCE (MACTOP,MACXX1(42))
C NUMBIT:      CONTAINS NUMBER OF BITS IN A FIXED POINT WORD
      EQUIVALENCE (NUMBIT,MACXX1(56))
C MCSPDP:      POINTER TO LAST ENTRY IN MACSPD TABLE
      EQUIVALENCE (MCSPDP,MACXX1(57))
C MCSRCH:      AT FINAL MACRO PRECESSING MACDF1 POINTER
      EQUIVALENCE (MCSRCH,MACXX1(59))
C NUMARG:      NUMBER OF MACRO VARIABLES+1 FOR CURRENT MACRO
      EQUIVALENCE (NUMARG,MACXX1(61))
C
C       24.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX3/MACXX3
      DIMENSION MACXX3(1430),MACDF1(400)
C MACDF1:      STORES MACRO NAME AND ALL MACRO VBL NAMTBL POINTERS
      EQUIVALENCE (MACDF1(1),MACXX3(1))
C
C      25A.    TEMPORARY STORAGE DURING FINAL MACRO PROCESSING
C
      COMMON/MACXX5/ITMPSV
      DIMENSION ITMPSV(135)
C
C       26.    NAMTBL POINTERS OF THE ASSIGNED VALUES FOR MACRO CALL
C
      COMMON/MACXX6/MACSPD
      DIMENSION MACSPD(1300)
C*
C PURPOSE      FOR EACH CALL AND NORMAL VALUE INITIALIZATION
C              TO GENERATE AND OUTPUT I.L. COMMANDS THAT
C              MOVE ASSIGNED VALUE AND BRANCHING LABEL
C              ADDRESSES INTO THE APPROPRIATE MACRO
C              VARIABLE AND LINKAGE LOCATIONS.
C
C NOTES        1.  COMSTR IS ACCESSED AFTER ALL BRANCHING
C                  AND COMMON I.L. TEXT HAS BEEN GENERATED
C                  FOR A MACRO.
C              2.  FOR EACH ACTUAL BRANCHING SITUATION THE
C                  MACSPD TABLE CONTAINS THE FOLLOWING
C                  INFORMATION STREAM.
C                   M = NUMBER OF WORDS NEEDED FOR CALL
C                       QUALITIES.
C                   N = NUMBER OF DIFFERENT BRANCHES.
C                  1)         NEGATIVE OF BRANCHING EXPRESSION
C                             NUMBER.
C                  2          CALL QUALITY WORDS.  QUALITIES
C                  THRU       SET FOR CALLS ASSOCIATED WITH
C                  M+1)       THE FOLLOWING BRANCH LABEL.
C                  M+2)       1ST BRANCH LABEL.  NEGATIVE
C                             IF ONLY NORMAL VALUES USED.
C                  (N-1) (M+2)+2 CALL QUALITY WORDS.
C                  THRU N(M+1))
C                  N(M+1)+1)    NTH BRANCH LABEL.  NEGATIVE IF
C                               ONLY NORMAL VALUES USED.
C
      CHARACTER*6 I297
      DATA I297,J297/'APT297',19206/
C**
      I=NAME(I297)
      NAMTBL(I)=J297
      CALL CALLZZ(I)
      CALL RLSLIN
C
C...     GENERATE RETURN TERMINATOR FOR MACRO COMMON TEXT.
C
      CALL RETMCX(1)
      IF (NUMARG.EQ.0) RETURN
C
C...     INITIALIZE NORMAL VALUE STORAGE.
C
      DO 80 I=1,MAXSPS
   80 ITMPSV(I)=0
C
C...     ARGCNT=NUMBER OF MACRO VARIABLES FOR CORRENT MACRO.
C
      ARGCNT=NUMARG-1
C
C...     ONE ITERATION PER CALL.
C
      DO 200 I=1,NUMCAL
C
C...     COMPUTE WORD POSITION (WDCAL) AND QUALITY (BITCAL) ASSOCIATED
C...     WITH THIS CALL.
C
      WDCAL=(I-1)/NUMBIT
      BITCAL=I-WDCAL*NUMBIT
C
C...     CALCULATE LABEL  FOR CALL INITIALIZATION. LABEL NAME BASED ON
C...     MACRO NAMTBL POINTER AND CALL NUMBER.
C
      CALL MACLBL(MACDF1(MCSRCH),-I,J)
      NAMTBL(J) = LABEL(1)
C
C...     GENERATE LABEL COMMAND.
C
   20 CALL LABELZ(J)
C
C...     ONE ITERATION PER MACRO VARIABLE.
C
   30 DO 1 J=1,ARGCNT
      NUMARG=NUMARG+1
C
C...     IF NEGATIVE, ASSIGNED VALUE=NORMAL VALUE.
C
      IF(MACSPD(NUMARG))40,1,41
C
C...     SAVE IN VBLSAV(J) USED NORMAL VALUE ASSIGNED TO JTH MACRO VAR..
C
   40 ITMPSV(J)=-MACSPD(NUMARG)
      GO TO 1
C
C...     I.L. TO PLACE ADDRESS OF ASSIGNED VALUE IN MACRO VARIABLE WORD.
C
   41 CALL ASNADZ(MACSPD(J),MACSPD(NUMARG))
    1 CONTINUE
C
C...     BEGIN SEARCH IN THE APPROPRIATE SECTION OF THE MACSPD TABLE
C...     (MACCNT) FOR BRANCHING LABELS ASSOCIATED WITH THIS CALL.
C
      MACCNT=MCSPDP
C
C...     ARGSCR KEEPS TRACK OF CURRENT BRANCHING SITUATION.
C
      ARGSCR=ARGCNT+2
    2 MACCNT=MACCNT+1
C
C...     BRANCH IF ALL LABELS HAVE BEEN ASSIGNED FOR THIS CALL.
C
      IF(ARGSCR.GT.MAXSPS)GO TO 11
   50 K=MACCNT+WDCAL
      MACCNT = MACCNT+BITWDS+1
C
C...     FOR CURRENT BRANCHING SITUATION IF BRANCHING LABEL FOR CURRENT
C...     CALL IS FOUND BITMCH=.TRUE.. IF LOOP IS EXHAUSTED WITHOUT
C...     LOCATING LABEL ISSUE DIAGNOSTIC.
C
      IF(BITMCH(MACSPD(K+1),BITCAL))GO TO 10
      IF((MACCNT.LT.MACTOP).AND.(MACSPD(MACCNT+1).GE.0))GO TO 50
C
C...     1021 - ERROR IN FINAL MACRO PROCESSING
C
      CALL ALARM(1021,0,8,'COMSTR  ')
      GO TO 11
C
C...     IF CALL BRANCHING LABEL DOES NOT INVOLVE ONLY NORMAL VALUES
C...     THEN BRANCH.
C
   10 IF(MACSPD(MACCNT).GT.0)GO TO 6
C
C...     SAVE BRANCHING LABEL FOR BRANCH INVOLVING ONLY NORMAL VALUES IN
C...     POSITION OF VBLSAV ARRAY CORRESPONDING TO CURRENT BRANCHING
C...     SITUATION.
C
      ITMPSV(ARGSCR)=-MACSPD(MACCNT)
      GO TO 7
C
C...     CALCULATE LABEL NAME BASED ON MACRO NEST LEVEL AND NUMBER OF
C...     CURRENT BRANCHING SITUATION.
C
    6 CALL MACLBL(-MCSAVP,-ARGSCR,J)
      NAMTBL(J)=LABEL(1)
      CALL ASNJPZ(J,MACSPD(MACCNT))
C
C...     I.L. TO PLACE CALL BRANCHING LABEL IN APPROPRIATE LINKAGE CELL
C...     SO THAT CORRECT BRANCH FOR THIS BRANCHING SITUATION IS
C...     SELECTED WHEN EXECUTING MACRO FOR THIS CALL.
C
    7 ARGSCR=ARGSCR+1
    8 IF(MACCNT.GE.MACTOP)GO TO 11
      IF(MACSPD(MACCNT+1).LT.0)GO TO 2
C
C...     LOCATE NEXT BRANCHING SITUATION INFORMATION.
C
      MACCNT=MACCNT+BITWDS+1
      GO TO 8
C
C...     CALCULATE LABEL NAME OF MACRO COMMON TEXT AND GENERATE A
C...     TRANSFER TO IT AS A CALL INITIALIZATION TERMINATOR.
C
   11 CALL MACLBL(-1,MACDF1(MCSRCH),J)
      NAMTBL(J)=LABEL(1)
      CALL JUMPZZ(J)
  200 NUMARG=NUMARG+1
C
C...     GENERATE LABEL FOR NORMAL VALUE INITIALIZATION.
C
      CALL LABELZ(MACDF1(MCSRCH))
C
C...     FOR EACH MACRO VARIABLE AND EACH BRANCHING SITUATION USING
C...     NORMAL VALUES (VBLSAV(J).GT.0) ASSIGN NORMAL VALUE AND LABEL
C...     ADDRESSES TO THE CORRESPONDING MACRO VARIABLE AND LINKAGE CELLS
C
      DO 100 I=1,MAXSPS
      IF(ITMPSV(I).EQ.0)GO TO 100
      IF(I-ARGCNT)110,110,120
  110 CALL ASNADZ(MACSPD(I),ITMPSV(I))
      GO TO 100
  120 CALL MACLBL(-MCSAVP,-I,J)
      NAMTBL(J)=1
      CALL ASNJPZ(J,ITMPSV(I))
  100 CONTINUE
C
C...     GENERATE RETURN TERMINATOR FOR NORMAL VALUE INITIALIZATION.
C
      CALL RETMCX(2)
      RETURN
       END
**** SOURCE FILE : CONCAT00.ORG   ***
*
      SUBROUTINE CONCAT(CHR,BCD)
C
C.....INSERT A SINGLE CHARACTER, BCD, INTO NEXT AVAILABLE POSITION
C.....IN STRING OF CHARACTERS, CHR
C
C.....THE NUMBER OF CHARACTERS IN THE STRING IS HELD IN THE FIRST 3 CHAR
C.....LOCATIONS OF CHR
C
      CHARACTER*(*) CHR,BCD
      INTEGER NCHR,K
C
      READ(CHR,'(I3)') NCHR
      NCHR = NCHR+1
      WRITE(CHR(1:3),'(I3)') NCHR
      K = NCHR+3
      CHR(K:K) = BCD(1:1)
C
      RETURN
      END
                                                                        00002000
**** SOURCE FILE : M0006632.V02   ***
*
C
C              FORTRAN SUBROUTINE FOUTXX
C
C LINKAGE      SUBROUTINE FOUTXX (IFILE,ARRAY,COUNT)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    CPRINT          SUBROUTINE    ALARM
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    PRTIL
C                                        SUBROUTINE    PUTTMP
C                                        SUBROUTINE    RLSLIN
C                                        SUBROUTINE    START
C
      SUBROUTINE FOUTXX (IFILE,ARRAY,COUNT)
C
      IMPLICIT INTEGER (A-Z)
C
C       20.    IO - ARRAY
C
      INCLUDE (DARRAY)    
      CHARACTER*(*) ARRAY
C**
      DARRAY(1:COUNT)=ARRAY(1:COUNT)
      CALL CPRINT (DARRAY)
      RETURN
      END
**** SOURCE FILE : M0006633.V05   ***
*
C
C              FORTRAN SUBROUTINE GETTMP
C
C LINKAGE      INTEGER FUNCTION GETTMP(MODE)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          INTEGER FCT.  NAME            SUBROUTINE    BOOLIF
C          SUBROUTINE    RESRVZ          SUBROUTINE    INPAT
C          SUBROUTINE    SHIFT           SUBROUTINE    ISSCOD
C          SUBROUTINE    BINBCD          SUBROUTINE    LARGES
C                                        SUBROUTINE    LCANON
C                                        SUBROUTINE    LOOP
C                                        SUBROUTINE    PRO020
C                                        SUBROUTINE    PRO021
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    SSDEF
C                                        SUBROUTINE    SUBCOD
C
      INTEGER FUNCTION GETTMP(MODE)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),TEMP(2)
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C*
C PURPOSE      THIS ROUTINE RETURNS THE NAME TABLE (NAMTBL)
C              INDEX FOR THE CURRENT TEMPORARY NAME OF THIS
C              MODE.
C
C ARGUMENTS    MODE    THE MODE OF THE SURFACE REQUIRING
C                      TEMPORARY STORAGE.
C
C ARGUMENTS    MODE    THE MODE OF THE SURFACE REQUIRING
C                      TEMPORARY STORAGE.
C
      CHARACTER SYMBOL*6,SYMI*8,BLK*1
      DATA BLK/' '/
C**
C...     INCREMENT COUNTER FOR THIS MODE
C
      TXXXX(2,MODE)=TXXXX(2,MODE)+1
C
C...     GENERATE NAME OF TEMPORARY LOCATION
C
      SYMBOL = BLK
C
C...           START SYMBOL WITH A $
C
      CALL SHIFT(SYMBOL,'$')
C
C...     IS MODE .GT. 9
C
      IF (MODE/10 .EQ. 0) GO TO 10
C
C...     YES. CONVERT TENS DIGIT OF MODE TO BCD AND SHIFT INTO SYMBOL
C
      CALL BINBCD(MODE/10,SYMI,COUNT)
      CALL SHIFT(SYMBOL,SYMI)
C
C...     CONVERT UNITS DIGIT TO BCD AND SHIFT INTO SYMBOL
C
   10 CALL BINBCD(MOD(MODE,10),SYMI,COUNT)
      CALL SHIFT(SYMBOL,SYMI)
C
C...           SHIFT T$ INTO SYMBOL
C
      CALL SHIFT(SYMBOL,'T')
      CALL SHIFT(SYMBOL,'$')
C
C...     IS COUNTER FOR THIS MODE .GT. 9
C
      IF (TXXXX(2,MODE)/10 .EQ. 0)  GO  TO  20
C
C...     YES. CONVERT TENS DIGIT TO BCD AND SHIFT INTO SYMBOL
C
      CALL BINBCD(TXXXX(2,MODE)/10,SYMI,COUNT)
      CALL SHIFT(SYMBOL,SYMI)
C
C...     CONVERT UNITS DIGIT OF POINTER TO BCD AND SHIFT INTO SYMBOL
C
   20 CALL BINBCD(MOD(TXXXX(2,MODE),10),SYMI,COUNT)
      CALL SHIFT(SYMBOL,SYMI)
C
C...     FIND NAMTBL INDEX OF NAME JUST CREATED AND STORE AS GETTMP
C
      GETTMP=NAME(SYMBOL)
C
C...     IS FIRST COLUMN OF NAMTBL ZERO.
C...     IF SO, THEN THIS IS THE FIRST APPEARENCE OF THIS NAME.
C...     IF NOT, IT HAS BEEN USED BEFORE, SO RETURN.
C
      IF (NAMTBL(GETTMP).NE.0) RETURN
C
C...     FIRST APPEARENCE - GENERATE RESRV CODE AND SET CORRECT CLASS
C...     AND MODE IN COLUMN 1 OF NAMTBL. THEN RETURN.
C
      CALL RESRVZ(GETTMP,MODE,TXXXX(1,MODE),1)
      NAMTBL(GETTMP) = TEMP(1)+MODE
      RETURN
       END
**** SOURCE FILE : M0006635.W01   ***
*
C
C              FORTRAN SUBROUTINE GOPAT
C
C LINKAGE      SUBROUTINE GOPAT
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    CALLZZ          SUBROUTINE    PRO026
C          SUBROUTINE    ALARM
C          INTEGER FCT.  NAME
C          SUBROUTINE    OPCODE
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  SEARCH
C          SUBROUTINE    TWOARG
C
      SUBROUTINE GOPAT
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),ARGSTK(99)
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),NUMBER(2),TEMP(2),PERMID(2),VBL(2),IDENT(2)
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12),ZERO(1)
C ZERO:        NAMTBL POINTER TO '0     '
      EQUIVALENCE (ZERO(1),NUMPTR(1))
C ZEROPT:      NAMTBL POINTER TO '0.    '
      EQUIVALENCE (ZEROPT,NUMPTR(2))
C ONE:         NAMTBL POINTER TO '1     '
      EQUIVALENCE (ONE,NUMPTR(3))
C
C       10.    TABLE STORAGE FOR GEOMETRIC FUNCTION PROCESSOR
C
      INCLUDE (GMTY)    
C GEOLOC:      GEOMETRIC PRODUCTION STARTING INDEX IN GEOMTB
C PMIDTB:      INTERNAL BIT REPRESENTATIONS FOR EACH ELEMENT OF GEOMTB
C GEOMTB:      GEOMETRIC FORMAT PRODUCTIONS ARRANGED BY SURFACE TYPE
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C MOVE:        CONTAINS COMMAND CODE (19) FOR MOVE COMMAND
      EQUIVALENCE (MOVE,IL(19))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C REAL:        MODE CODE (24) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C PATERN:      MODE CODE (26) FOR PATTERN
      EQUIVALENCE (PATERN,MODX(26))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C QUIDLR:      CONTAINS OPERAND TYPE CODE 5
      EQUIVALENCE (QUIDLR,OPMOD(6))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136),APTXXX(120)
C APTXXX:      NAMTBL POINTERS FOR XECUTION SUBROUTINE NAMES
      EQUIVALENCE (APTXXX(1),SUBLST(1))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C*
C PURPOSE      TO VALIDATE GO/PATERN STATEMENTS AND GENERATE
C              APPROPRIATE INTERMEDIATE LANGUAGE.
C
      DIMENSION BIGSTK(10),NUMREC(5),OMTLST(18),AVDLST(18)
      LOGICAL LOMIT,LRETAI
      CHARACTER*6 HDOLSC,HDOLPC
      DATA NUMREC/1,5,4,3,2/
      DATA KOMIT /64/, KRETAI /65/, KINVER /35/, KZIGZA /61/
      DATA HDOLSC,HDOLPC /'$SCRTH','$PCRTH'/
C**
C......             INITIALIZE
C
      IARG1=ZERO(1)
      IARG2=ZERO(1)
      IO=0
      IA=0
      KMOVO=-1
      KMOVA=-1
      KSCRTH=NAME(HDOLSC)
      KPCRTH=NAME(HDOLPC)
      ASSIGN 15 TO IEND
C                             POINTER FOR ARGSTK, 1 BELOW PATERN
      IARG=ARGTOP-1
C                             POINTER FOR BIGSTK
      IBIG=5
C                             FLAGS FOR OMIT AND RETAIN
      LOMIT=.FALSE.
      LRETAI=.FALSE.
C                             NUMBER OF ARGS TO DELETE FROM BIGSTK
      IGET=5
      IF(IARG.EQ.0)GO TO 40
C
C......             SETUP BIGSTK CORRESPONDING TO TOP 5 ARGUMENTS OF
C......             ARGSTK, IN FORMAT TO BE RECOGNIZED BY PATERN
C......             GEOMETRIC PRODUCTIONS
C
      ASSIGN 10 TO ISETUP
      GO TO 1000
C
C......             LOOK FOR PATERN
C
   10 J=GEOLOC(PATERN)
      ERRPT=IBIG
      KSERCH=SEARCH(BIGSTK,10,GEOMTB(J),ERRPT)
C......             ERROR IF NO MATCH ON CORRECT TYPE
C
      IF(KSERCH.LE.12 .OR. KSERCH.GE.18)GO TO 1258
C
C......             DETERMINE NUMBER OF ELEMENTS RECOGNIZED
C
      I=KSERCH-12
      IGET=NUMREC(I)
C
      NAMX=BIGSTK(9)
      IF(NAMX.GT.NAMMAX)GO TO 12
      KMODE=MOD(NAMTBL(NAMX),MODULO)
C
C                   BRANCH TO PROCESS RECOGNIZED ELEMENTS
C
   12 GO TO(100,210,300,200,300),I
C
C                   INVERS OR ZIGZAG
C
  100 IF(KMODE.EQ.KINVER)IARG1=ONE
      IF(KMODE.EQ.KZIGZA)IARG2=ONE
      GO TO 15
C
C                   AVOID
C
  200 AVDSAV=BIGSTK(7)
  210 AVDLST(IA+1)=BIGSTK(7)
      AVDLST(IA+2)=BIGSTK(5)
      IF(KSERCH.NE.14)GO TO 215
      AVDLST(IA+3)=BIGSTK(1)
      GO TO 220
  215 AVDLST(IA+3)=ZEROPT
  220 IA=IA+3
      IF(IA.LT.18)GO TO 15
C                   IF NOT ALREADY DONE,DECLARE ARRAY OF SCRATCH
C                   STORAGE IN PART PROGRAM.  MOVE AVOID INFORMATION
C                   INTO LOCATIONS 1 THRU 102 OF THIS ARRAY.
  250 IF(NAMTBL(KSCRTH).NE.0)GO TO 255
      NAMTBL(KSCRTH)=VBL(1)
      CALL RESRVZ(KSCRTH,0,102,1)
  255 IF((KMOVA-IA).LT.(-102))GO TO 2010
      CALL OPCODE(MOVE)
      CALL TWOARG(KMOVA,KSCRTH)
      DO 260 I=1,IA
  260 CALL ARGCVT(AVDLST(I))
      CALL RLSLIN
      KMOVA=KMOVA-IA
      IA=0
      GO TO IEND,(15,35,40)
C
C                   OMIT OR RETAIN
C
  300 LOMIT=KMODE.EQ.KOMIT. OR. LOMIT
      LRETAI=KMODE.EQ.KRETAI. OR. LRETAI
      IF(LOMIT.AND.LRETAI)GO TO 2000
      OMTLST(IO+1)=BIGSTK(7)
      IF(KSERCH.NE.15)GO TO 315
      OMTLST(IO+2)=BIGSTK(3)
      GO TO 320
  315 OMTLST(IO+2)=OMTLST(IO+1)
  320 IO=IO+2
      IF(IO.LT.18)GO TO 15
C                   IF NOT ALREADY DONE, DECLARE ARRAY OF SCRATCH
C                   STORAGE IN PART PROGRAM.  MOVE OMIT OR RETAIN
C                   INFORMATION INTO LOCATIONS 1 THRU 98 OF THIS ARRAY.
  350 IF(NAMTBL(KPCRTH).NE.0)GO TO 355
      NAMTBL(KPCRTH)=VBL(1)
      CALL RESRVZ(KPCRTH,0,98,1)
  355 IF((KMOVO-IO).LT.(-98))GO TO 2010
      CALL OPCODE(MOVE)
      CALL TWOARG(KMOVO,KPCRTH)
      DO 360 I=1,IO
  360 CALL ARGCVT(OMTLST(I))
      CALL RLSLIN
      KMOVO=KMOVO-IO
      IO=0
      GO TO IEND,(15,35,40)
C
C                   BRANCH IF ARGSTK ALL EXAMINED
C
   15 IF(IARG+IBIG-IGET.EQ.0)GO TO 30
C
C                   RESET BIGSTK
C
      ASSIGN 20 TO ISETUP
      GO TO 1000
C
C                   LOOP IF REAL LIST CANNOT FOLLOW
C
   20 IF(KSERCH.LE.15)GO TO 10
C
C                   PROCESS ELEMENT OF REAL LIST IF PRESENT
C
      NAMX=BIGSTK(9)
      IGET=1
      IF(NAMX.GT.NAMMAX)GO TO 17
      KCLASS=NAMTBL(NAMX)/MODULO
      IF(KCLASS.EQ.NUMBER(1))GO TO 17
      KMODE=MOD(NAMTBL(NAMX),MODHLF)
      IF(KMODE.NE.REAL)GO TO 10
   17 IF(KSERCH.EQ.17)GO TO 18
C                   ELEMENT OF AVOID LIST
      AVDLST(IA+1)=AVDSAV
      AVDLST(IA+2)=BIGSTK(9)
      GO TO 215
C                   ELEMENT OF OMIT OR RETAIN LIST
   18 OMTLST(IO+1)=BIGSTK(9)
      GO TO 315
C
C                   MOVE ANY ELEMENTS REMAINING IN OMTLST OR
C                   AVDLST TO $SCRTH
C
   30 IF(IO.EQ.0)GO TO 35
      ASSIGN 35 TO IEND
      GO TO 350
   35 IF(IA.EQ.0)GO TO 40
      ASSIGN 40 TO IEND
      GO TO 250
C                   DETERMINE NUMBER OF TWO-ELEMENT ENTRIES IN
C                   OMIT/RETAIN TABLE, OMTLST.
C                   IF RETAIN, SET NUMBER NEGATIVE.
   40 IARG3=-(KMOVO+1)/2
      IF(LRETAI)IARG3=IARG3+1000
C                   DETERMINE NUMBER OF THREE-ELEMENT ENTRIES
C                   IN AVOID TABLE, AVDLST.
      IARG4=-(KMOVA+1)/3
C                   GENERATE CALL TO XECUTION SUBROUTINE GOTOPN
   50 CALL CALLZZ(APTXXX(99))
      CALL ARGCVT(ARGSTK(ARGTOP))
      CALL ARGCVT(IARG1)
      CALL ARGCVT(IARG2)
      CALL TWOARG(QUIDLR,IARG3)
      CALL TWOARG(QUIDLR,IARG4)
      IF(NAMTBL(KPCRTH).EQ.0)GO TO 52
      CALL TWOARG(0,KPCRTH)
      GO TO 53
   52 CALL ARGCVT(ZEROPT)
   53 IF(NAMTBL(KSCRTH).EQ.0)GO TO 54
      CALL TWOARG(0,KSCRTH)
      GO TO 60
   54 CALL ARGCVT(ZEROPT)
   60 CALL RLSLIN
C
      RETURN
C-----------------------------------------------------------------------
C
C     PURPOSE       TO MOVE INTERNAL BIT CONFIGURATIONS CORRESPONDING TO
C                   ELEMENTS OF ARGSTK INTO BIGSTK, FOR RECOGNITION BY
C                   PATERN GEOMETRIC PRODUCTIONS
C
C     ARGUMENTS     IARG      INDEX OF NEXT ELEMENT OF ARGSTK.
C                   IGET      NUMBER OF RECOGNIZED ELEMENTS TO BE POPPED
C                             FROM BIGSTK.
C                   ISETUP    RETURN INDEX.
C
C                             POP RECOGNIZED ELEMENTS
 1000 IIN=10
      IIOUT=10-2*IGET
      IBIG=IBIG-IGET
 1005 IF (IIOUT.EQ.0) GO TO 1010
      BIGSTK(IIN)=BIGSTK(IIOUT)
      BIGSTK(IIN-1)=BIGSTK(IIOUT-1)
      IIN=IIN-2
      IIOUT=IIOUT-2
      GO TO 1005
C                             CONVERT STACK ELEMENTS
 1010 DO 1250 I=1,IGET
      IF(IARG.NE.0)GO TO 1200
      J=10-2*IBIG
      BIGSTK(J)=-1
      GO TO 1255
 1200 NAMX=ARGSTK(IARG)
      ERRPT=IARG
      IF(NAMX.GT.NAMMAX)GO TO 1205
      KCLASS=MODULO*(NAMTBL(NAMX)/MODULO)
      KMODE =NAMTBL(NAMX)-KCLASS
      IF(KMODE.GE.MODHLF) KMODE=KMODE-MODHLF
      IF(KMODE.EQ.0)GOTO 1260
      IF (KCLASS.EQ.VBL(1) .OR. KCLASS.EQ.TEMP(1)) GO TO 1220
     0IF (KCLASS.EQ.IDENT(1)) NAMTBL(NAMX)=NAMTBL(NAMX)-IDENT(1)
     1                                      +PERMID(1)
      IF (KCLASS.EQ.IDENT(1).OR.KCLASS.EQ.PERMID(1)) GO TO 1210
      IF (KCLASS.NE.NUMBER(1)) GO TO 1260
 1205 KMODE=REAL
      GO TO 1220
 1210 KMODE=KMODE+50
 1220 J=10-2*IBIG
      BIGSTK(J)=PMIDTB(KMODE)
      BIGSTK(J-1)=NAMX
      IARG=IARG-1
      IBIG=IBIG+1
 1250 CONTINUE
C                             RETURN
 1255 GO TO ISETUP,(10,20)
C                             IMPROPER ARGUMENT IN GOTO/PATERN STATEMENT
 1258 ERRPT=MAX(IARG+1,IARG+ERRPT)
 1260 IERROR=2036
      GO TO 3000
C                             BOTH OMIT AND RETAIN SPECIFIED IN GOTO/
C                             PATERN STATEMENT
 2000 IERROR=2037
      ERRPT=IARG+IBIG
      GO TO 3000
C                   TOO MANY OMIT, RETAIN OR AVOID POINTS IN GOTO/
C                             PATERN STATEMENT
 2010 IERROR=2038
      ERRPT=IARG+1
 3000 CALL ALARM(IERROR,-ERRPT,8,'GOPAT   ')
      RETURN
C
C
      END
**** SOURCE FILE : M0000449.ORG   ***
*
C.....COMPUTER DEPENDENT ROUTINE      HELP.......HL GRAY    12/67  *CD*
C
C PURPOSE      TO PROVIDE A TRACE-BACK IN THE CASE OF A
C              CASTASTROPHIC FAILURE.
C
C LINKAGE      CALL HELP
C
C ARGUMENTS    NONE
C
C NOTES        THE METHOD USED TO OBTAIN THE TRACE-BACK
C              MIGHT NEED TO BE CHANGED ON SOME COMPUTERS.
C
C SUBSIDIARIES NONE
C
      SUBROUTINE HELP
C
C...     CATASTROPHIC FAILURE
C...     PRODUCE EXECUTION FAILURE SO AS TO OBTAIN AUTOMATIC TRACE-BACK
C
      DIMENSION Y(1)
      DO 10 I=100000,1000000,10
      X=Y(I)
   10 Y(I)=X
    1 RETURN
       END
**** SOURCE FILE : M0006638.V03   ***
*
C
C              FORTRAN SUBROUTINE IFTMP
C
C LINKAGE      LOGICAL FUNCTION IFTMP(A)
C
C          SUBSIDIARIES                  CALLED BY
C          NONE                          TYPE          ENTRY
C                                        SUBROUTINE    BOOLIF
C                                        SUBROUTINE    INPAT
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    PRO020
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    REPLAC
C                                        SUBROUTINE    SSDEF
C                                        SUBROUTINE    SUBCOD
C
      LOGICAL FUNCTION IFTMP(A)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),TEMP(2)
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C**
C
C...     IS A THE NAMTBL INDEX OF A TEMPORARY LOCATION
C
      IF(A.GT.NAMMAX)GO TO 5
      IF((NAMTBL(A)/MODULO.EQ.TEMP(1)/MODULO).AND.
     /  ((NAMTBL(A)-MODULO*(NAMTBL(A)/MODULO)).LT.MODHLF))GO TO 10
C
C...     NO. RETURN IFTMP AS .FALSE.
C
    5 IFTMP=.FALSE.
      RETURN
C
C...     YES. RETURN IFTMP AS .TRUE.
C
   10 IFTMP=.TRUE.
      RETURN
       END
**** SOURCE FILE : M0006639.W01   ***
*
C
C              FORTRAN SUBROUTINE INPAT
C
C LINKAGE      SUBROUTINE INPAT(IACT,BIGCNT)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    RECOG
C          SUBROUTINE    CALLZZ
C          INTEGER FCT.  GETTMP
C          SUBROUTINE    BCDBIN
C          LOGICAL FCT.  IFTMP
C          SUBROUTINE    MCXTRN
C          SUBROUTINE    ARGCVT
C          INTEGER FCT.  NAME
C          INTEGER FCT.  NUMB
C          SUBROUTINE    OPCODE
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  SEARCH
C          SUBROUTINE    TWOARG
C          SUBROUTINE    BINBCD
C
      SUBROUTINE INPAT(IACT,BIGCNT)
C
      IMPLICIT INTEGER (A-Z)
C
C              FUNCTION DECLARATION
C
      LOGICAL IFTMP
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),COMMA(2),NUMBER(2),TEMP(2),PERMID(2),VBL(2),ID
     *          ENT(2)
C COMMA:       (1)=CODE CLASS  1000,(2)=NAMTBL INDEX OF ',     '
      EQUIVALENCE (COMMA(1),CODE(1))
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(502),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        8.    NAME TABLE POINTERS TO BCD LITERALS
C
      COMMON/BCDPTR/BCDPTR
      DIMENSION BCDPTR(7)
C DOTTAB:      NAMTBL POINTER TO ALPHAMERIC LITERAL '$$TAB'
      EQUIVALENCE (DOTTAB,BCDPTR(7))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12),ZERO(1)
C ZERO:        NAMTBL POINTER TO '0     '
      EQUIVALENCE (ZERO(1),NUMPTR(1))
C ZEROPT:      NAMTBL POINTER TO '0.    '
      EQUIVALENCE (ZEROPT,NUMPTR(2))
C ONE:         NAMTBL POINTER TO '1     '
      EQUIVALENCE (ONE,NUMPTR(3))
C TWO:         NAMTBL POINTER TO '2     '
      EQUIVALENCE (TWO,NUMPTR(5))
C FOUR:        NAMTBL POINTER TO '4     '
      EQUIVALENCE (FOUR,NUMPTR(7))
C
C       10.    TABLE STORAGE FOR GEOMETRIC FUNCTION PROCESSOR
C
      INCLUDE (GMTY)    
C GEOLOC:      GEOMETRIC PRODUCTION STARTING INDEX IN GEOMTB
C PMIDTB:      INTERNAL BIT REPRESENTATIONS FOR EACH ELEMENT OF GEOMTB
C GEOMTB:      GEOMETRIC FORMAT PRODUCTIONS ARRANGED BY SURFACE TYPE
C
C       12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE
      DIMENSION CFSIZE(205),MAXSIZ(2),CANSIZ(2,100)
C CANTOP:      POINTER TO THE LAST CANSIZ ENTRY
      EQUIVALENCE (CANTOP,CFSIZE(1))
C MAXSIZ:      SIZE OF THE LAST LARGEST LARGE DATA ARRAY
      EQUIVALENCE (MAXSIZ(1),CFSIZE(4))
C CANSIZ:      NUMBER OF ITEMS A. NAMTBL INDEX OF EACH LARGE DATA ARRAY
      EQUIVALENCE (CANSIZ(1,1),CFSIZE(6))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C MOVE:        CONTAINS COMMAND CODE (19) FOR MOVE COMMAND
      EQUIVALENCE (MOVE,IL(19))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C POINT:       MODE CODE (19) FOR POINT
      EQUIVALENCE (POINT,MODX(19))
C REAL:        MODE CODE (24) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C PATERN:      MODE CODE (26) FOR PATTERN
      EQUIVALENCE (PATERN,MODX(26))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      DIMENSION MACXX1(71)
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C DLR:         CONTAINS OPERAND TYPE CODE 1
      EQUIVALENCE (DLR,OPMOD(2))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136),APTXXX(120)
C APTXXX:      NAMTBL POINTERS FOR XECUTION SUBROUTINE NAMES
      EQUIVALENCE (APTXXX(1),SUBLST(1))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C*
C     PURPOSE       TO VALIDATE THE FORMAT OF PATTERN DEFINITION
C                   STATEMENTS AND GENERATE APPROPRIATE INTER-
C                   MEDIATE LANGUAGE
C
C     RESTRICTIONS  CURRENTLY CANNOT HANDLE NESTED DEFINITIONS
C                   OR SUBSTITUTION OF MACRO VARIABLES FOR
C                   MINOR WORDS.
C
      DIMENSION BIGSTK(20)
      LOGICAL FOULUP,INCLST
      CHARACTER*6 HDOLSC
      CHARACTER*4 HPERI,XLANK
      DIMENSION ARGS(5)
      CHARACTER BUFF*12,DECPT*1
      DIMENSION KTYPES(12)
C                   LINEAR    LINEAR    LINEAR    ARC       ARC
C                   POINT     POINT     POINT     CIRCLE    CIRCLE
C                   POINT     VECTOR    VECTOR    REAL      REAL
C                   REAL      REAL      INCR      REAL      CLW,CCLW
C                                                 CLW,CCLW  INCR
C                                                 REAL
     0DATA KTYPES  /      101,      102,      103,      201,      202,
C
C                   GRID      GRID      GRID      RANDOM    PERIM
C                   PATERN    PATERN    PATERN    POINT,    PATERN
C                   PATERN    VECTOR    VECTOR      PATERN  PATERN
C                             REAL      INCR
     1                    301,      302,      303,      401,      501,
C
C                   PERIM     PERIM
C                   PATERN    PATERN
C                   VECTOR    VECTOR
C                   REAL      INCR
     2                    502,      503/
C
      DATA HPERI/'PERI'/, HDOLSC/'$SCRTH'/,XLANK/'    '/
      DATA DECPT/'.'/
C**
C
C.......                      IF FIRST TIME THROUGH FOR THIS DEFINITION,
C.......                      DO INITIALIZATIONS
C
      IF (BIGCNT.NE.1) GO TO 100
C                             INITIALIZE INDEX FOR NEXT BIGSTK ENTRY
      BIGNXT=20
C                             SET LOCAL FLAG - NO FORMAT ERRORS YET
      FOULUP=.FALSE.
C                             INITIALIZE WORD COUNT FOR EXTERNAL FORM
      NWDS=4
C                             SET LOCAL FLAG - NOT PROCESSING INCR LIST
C                             YET
      INCLST=.FALSE.
C                             MOVE FIRST ARGUMENT INTO BIGSTK
      ASSIGN 100 TO IPUSH
      ERRPT=TOP-3
      ELMENT=STACK(1,ERRPT)
      GO TO 1000
C
C.......            BRANCH IF END OF DEFINITION
C
  100 IF(IACT.GE.103) GO TO 200
C                             IF ERROR HAS ALREADY OCCURRED, SKIP
C                             PROCESSING
      IF (FOULUP) GOTO 2020
C
C.......            PROCESS ELEMENT OF ARGUMENT LIST
C
C                             MOVE LATEST ARGUMENT INTO BIGSTK
      ASSIGN 110 TO IPUSH
      ERRPT=TOP-1
      ELMENT=STACK(1,ERRPT)
      GO TO 1000
C                             SEARCH FOR MATCHING PATERN GEOMETRIC
C                             PRODUCTION IN BIGSTK.
  110 J=GEOLOC(PATERN)
      EPT=10
      KSERCH=SEARCH(BIGSTK,20,GEOMTB(J),EPT)
C                             IF ACTION NUMBER=200, NO MATCHING PRODUC-
C                             TION WAS FOUND.  RETURN FOR MORE OF ARG
C                             LIST, UNLES 6 ELEMENTS ARE ACCUMULATED.
      IF (KSERCH.LE.11 ) GO TO 120
      IF (BIGNXT.LT.(2*EPT)) GOTO 1990
      IF (BIGNXT.GT.8) GOTO 2020
      GO TO 1990
C                             BRANCH IF PROCESSING INCREMENT LIST
  120 IF (INCLST) GO TO 170
C                             DETERMINE TYPE CODE FROM ACTION NUMBER
C                             AND FIRST WORD FOLLOWING SLASH
      IFIRST=BIGSTK(19)
      K=KSERCH
      IF(CNAMTB(IFIRST)(1:4).EQ.HPERI)GO TO 1980
      KTYPE=KTYPES(K)
C                             SAVE ARGUMENTS FOR CALL TO DEFINITION
C                             REDUCTION ROUTINE
      DO 130 I=1,5
      J=19-2*I
      ARGS(I)=BIGSTK(J)
      IF (J.LE.BIGNXT) ARGS(I)=ZEROPT
  130 CONTINUE
C
C.......            TAKE APPROPRIATE BRANCH-
C.......                 FOR RANDOM TYPE, GO PROCESS ARG.
C.......                 FOR INCR TYPE, GO SET UP INCR.
C.......                 FOR OTHERS, GO DETERMINE SIZE OF EXTERNAL
C.......                 CANONICAL FORM.
C       KTYPE 101  102  103  201  202  301  302  303  401  501  502  503
     0GO TO (3010,3010,3020,3030,3025,3040,3050,3060, 140,3040,3050,3060
     1      ),K
C                             LINEAR PATERN-INITIAL BLOCK
C                                            POINT AND VECTOR
 3010 NWDS=NWDS+6
C                             INCREMENTS
 3012 INAMTB=BIGSTK(BIGNXT+1)
      ASSIGN 3015 TO IRET
      GO TO 4000
C                             RETURN, EXPECT END OF DEFINITION
 3015 BIGNXT=18
      GOTO 2020
C                             LINEAR PATERNS- ADD STORAGE FOR INITIAL
C                                    BLOCK AND BRANCH TO PROCESS INCR
C                                    LIST
 3020 NWDS=NWDS+6
      GO TO 150
C                             ARC PATERNS- ADD STORAGE FOR INITIAL BLOCK
C                                    AND BRANCH TO PROCESS INCR LIST
 3025 NWDS=NWDS+6
      GO TO 150
C                             ARC PATERNS-INITIAL BLOCK
 3030 NWDS=NWDS+6
C                             BRANCH TO ADD INCREMENTS
      GO TO 3012
C                             GRID/PERIM PATERNS-ADD STORAGE FOR TWO
C                                                COMPONENT PATERNS
 3040 INAMTB=BIGSTK(15)
      ASSIGN 3042 TO IRET
      GO TO 5000
 3042 NWDS=NWDS+CANSIZ(1,ICANX)
 3043 INAMTB=BIGSTK(17)
      ASSIGN 3044 TO IRET
      GO TO 5000
 3044 NWDS=NWDS+CANSIZ(1,ICANX)+1
      GO TO 3015
C                             GRID/PERIM PATERNS- ADD STORAGE FOR ONE
C                                    COMPONENT PATERN AND ONE INCREMENT
 3050 INAMTB=BIGSTK(13)
      ASSIGN 3052 TO IRET
      GO TO 4000
 3052 GO TO 3043
C                             GRID/PERIM PATERNS- ADD STORAGE FOR ONE
C                                    COMPONENT PATERN AND BRANCH TO
C                                    PROCESS INCREMENT LIST
 3060 INAMTB=BIGSTK(17)
      ASSIGN 3062 TO IRET
      GO TO 5000
 3062 NWDS=NWDS+12+CANSIZ(1,ICANX)
      GO TO 150
C
C...                PROCESS RANDOM TYPE ARGUMENT
C
C                             IF FIRST TIME THROUGH FOR THIS DEFINITION,
C                             GENERATE INITIALIZATION CALL TO APT100
  140 IF(BIGCNT.NE.1) GO TO 145
      CALL CALLZZ(APTXXX(73))
      CALL TWOARG(1,ZERO)
      CALL TWOARG(1,ZERO)
      CALL RLSLIN
C                             INITIALIZE ARGUMENT COUNTER
      IRANDG=0
C                             GENERATE CALL TO PRE-PATERN DEFINTION
C                             ROUTINE APT 100
  145 CALL CALLZZ(APTXXX(73))
C                             SET FLAG FOR POINT OR PATERN
      IF(BIGSTK(BIGNXT+2).EQ.PMIDTB(POINT)) K=ONE
      IF(BIGSTK(BIGNXT+2).EQ.PMIDTB(PATERN)) K=TWO
      CALL TWOARG(1,K)
      CALL ARGCVT(ELMENT)
      CALL RLSLIN
      IF(IFTMP(ELMENT))CALL PUTTMP(MOD(NAMTBL(ELMENT),MODULO))
C                             UPDATE EXTERNAL CANONICAL FORM WORD COUNT
      IF (K.EQ.ONE) GO TO 148
      INAMTB=BIGSTK(17)
      ASSIGN 147 TO IRET
      GO TO 5000
  147 NWDS=NWDS+CANSIZ(1,ICANX)
      GO TO 149
C
  148 NWDS=NWDS+4
  149 CONTINUE
C                             INCREMENT ARGUMENT COUNTER
      IRANDG=IRANDG+1
C                             COMPRESS LAST ARG OUT OF BIGSTK
      BIGNXT=BIGNXT+2
      BIGSTK(BIGNXT)=-1
C                             RETURN
      GOTO 2020
C
C...                SET UP FOR INCR LIST PROCESSING
C
C                             SET FLAG
  150 INCLST=.TRUE.
C                             IF NOT ALREADY DONE, DECLARE ARRAY OF
C                             SCRATCH STORAGE IN PART PROGRM, OF LENGTH
C                             102 AND NAME $SCRTH
      KSCRTH=NAME(HDOLSC)
      IF (NAMTBL(KSCRTH).NE.0) GO TO 160
      NAMTBL(KSCRTH)=VBL(1)
      CALL RESRVZ(KSCRTH,0,102,1)
C                             SET PROPER ARG TO SCRATCH STORAGE ARRAY
  160 IARG=(20-BIGNXT)/2
      ARGS(IARG)=KSCRTH
C                             INITIALIZE COUNTER FOR INCR LIST
      INCCNT=0
C                             PUT INCR AT TOP OF BIGSTK
      BIGSTK(20)=BIGSTK(BIGNXT+2)
      BIGSTK(18)=-1
      BIGNXT=18
C                             RETURN
      GOTO 2020
C
C......             PROCESS TERM OF INCR LIST
C
C                             BRANCH IF REAL-AT-REAL TYPE
  170 IF (KSERCH.EQ.11) GO TO 180
C                             BRANCH IF EXCESS INCR ARGS
      IF(INCCNT+1.GE.102)GO TO 195
C                             GENERATE CODE TO MOVE FIRST REAL ARG
C                               MOVE   HDOLSC(INCCNT+1),ARG
      CALL OPCODE(MOVE)
      CALL TWOARG(-(INCCNT+2),KSCRTH)
      CALL ARGCVT(BIGSTK(17))
      CALL RLSLIN
C                             COMPRESS BIGSTK
      BIGSTK(18)=BIGSTK(16)
      BIGSTK(17)=BIGSTK(15)
      BIGNXT=16
C                             UPDATE INCR TERM COUNTER
      INCCNT=INCCNT+1
C                             UPDATE EXTERNAL CANONICAL FORM WORD COUNT
      NWDS=NWDS+1
C                             RETURN
      GOTO 2020
C                             BRANCH IF EXCESS INCR ARGS
  180 IF(INCCNT+3.GE.102)GO TO 195
C                             GENERATE CODE TO MOVE ARGS
      CALL OPCODE(MOVE)
      CALL TWOARG(-(INCCNT+2),KSCRTH)
      DO 190 I=1,3
      J=19-2*I
      CALL ARGCVT(BIGSTK(J))
  190 CONTINUE
      CALL RLSLIN
C                             UPDATE EXTERNAL CANONICAL FORM WORD COUNT
      INAMTB=BIGSTK(17)
      ASSIGN 197 TO IRET
      GO TO 4000
  197 CONTINUE
C                             COMPRESS BIGSTK
      BIGNXT=18
      BIGSTK(18)=-1
C                             UPDATE INCR TERM COUNTER
      INCCNT=INCCNT+3
C                             RETURN
      GOTO 2020
C                             ERROR - EXCESS INCR ARGS
  195 IERROR= 2041
      GO TO 2000
C
C......             PROCESS END OF DEFINITION
C
C                             FIND NAME TABLE INDEX OF RESULT.
C                             IF AN UNNAMED NESTED DEF, SET UP TEMPORARY
  200 IF (IACT.NE.105) GO TO 210
      RESULT=GETTMP(PATERN)
      GO TO 222
C                             IF CLASS NOT PERMANENTLY SET, DEFINE NOW
  210 RESULT=STACK(1,TOP-5)
      ICLASS=MODULO*(NAMTBL(RESULT)/MODULO)
      IF (ICLASS.EQ.VBL(1) .OR. ICLASS.EQ.TEMP(1)) GOTO 220
      NAMTBL(RESULT)=VBL(1)+PATERN
      CALL RESRVZ(RESULT,PATERN,2,1)
C...                          IF THIS VARIABLE HAS BEEN PREVIOUSLY
C...                          DEFINED WITH ANOTHER MODE, ISSUE
C...                          ERROR AND TERMINATE PROCESSING
  220 IF(MODE(RESULT).EQ.PATERN) GO TO 221
      IERROR=1001
      ERRPT=TOP-6
      GOTO 2045
C...                          IF THIS VARIABLE HAS BEEN PREVIOUSLY
C...                          DEFINED WITH THE SAME MODE, ISSUE
C...                          WARNING AND CONTINUE PROCESSING
  221 IF(ICLASS.EQ.VBL(1).AND.INTMED.EQ.0)CALL ALARM(50,TOP-5,4,
     * 'INPAT   ')
C                             IF WE WERE PROCESSING AN INCR LIST, CHECK
C                             FORMAT OF RESIDUE IN BIGSTK, AND MOVE
C                             FINAL ARG IF NECESSARY.
  222 IF(.NOT.INCLST)GO TO 230
      IF (BIGNXT.EQ.18) GO TO 225
      IF (BIGNXT.NE.16 .OR. BIGSTK(18).NE.PMIDTB(REAL)) GO TO 2030
      CALL OPCODE(MOVE)
      CALL TWOARG(-(INCCNT+2),KSCRTH)
      CALL ARGCVT(BIGSTK(17))
      CALL RLSLIN
      INCCNT=INCCNT+1
C                             UPDATE EXTERNAL CANONICAL FORM WORD COUNT
      NWDS=NWDS+1
      BIGNXT=18
C                             GENERATE CODE TO STORE INCR LIST COUNT
  225 BUFF=XLANK
      CALL BINBCD(INCCNT,BUFF,ICNT)
      BUFF (ICNT+1:ICNT+1)=DECPT
      INUMB=NUMB(BUFF)+NAMMAX
      CALL OPCODE(MOVE)
      CALL TWOARG(-1,KSCRTH)
      CALL ARGCVT(INUMB)
      CALL RLSLIN
C                             IF RANDOM TYPE, SET ARG1 TO THE NUMBER
C                             OF ARGUMENTS
  230 IF (KTYPE.NE.401) GO TO 250
      BUFF=XLANK
      CALL BINBCD (IRANDG,BUFF,ICNT)
      BUFF(ICNT+1:ICNT+1)=DECPT
      INUMB=NUMB(BUFF)+NAMMAX
      ARGS(1)=INUMB
      DO 235 I=2,5
      ARGS(I)=ZEROPT
  235 CONTINUE
C                             VERIFY BIGSTK CLEANED UP AT THIS POINT
  250 IF (BIGNXT.NE.18) GO TO 2030
C                             IF NO ERRORS ENCOUNTERED PREVIOUSLY,
C                             GENERATE CALL TO PATERN DEFINITION ROUTINE
      IF (FOULUP) GO TO 2050
      CALL CALLZZ(APTXXX(100))
      CALL TWOARG(5,1)
      CALL ARGCVT(RESULT)
      CALL TWOARG(5,KTYPE)
      DO 310 I=1,5
      CALL ARGCVT(ARGS(I))
      K=ARGS(I)
      IF(IFTMP(K))CALL PUTTMP(MOD(NAMTBL(K),MODULO))
  310 CONTINUE
      CALL RLSLIN
C                             STORE THE NUMBER OF WORDS IN THE EXTERNAL
C                             CANONICAL FORM IN CANSIZ.
      IF (NWDS.LE.0) NWDS=200
      INAMTB=RESULT
      ASSIGN 311 TO IRET
      GO TO 5000
  311 CANSIZ(1,ICANX)=NWDS
      CANSIZ(2,ICANX)=RESULT
C                             UPDATE SIZES OF TWO LARGEST EXTERNAL FORMS
      IF(NWDS.LE.(IABS(MAXSIZ(2))))GO TO 315
      IF(NWDS.LE.(IABS(MAXSIZ(1))))GO TO 312
      MAXSIZ(2)=MAXSIZ(1)
      MAXSIZ(1)=NWDS
      GO TO 315
  312 MAXSIZ(2)=NWDS
C
C                             ADJUST THE STACK AND RETURN
  315 IF (IACT-104) 335,320,340
  320 TOP=TOP-6
  330 STACK(1,TOP) = RESULT
      K=NAMTBL(RESULT)/MODULO
      STACK(2,TOP) = META(K)
  335 RETURN
  340 TOP=TOP-4
      GO TO 330
C
C
C
C-----------------------------------------------------------------------
C
C              PURPOSE   TO ADD ELEMENT TO BIGSTK
C                                       FIND CORRECT INDEX TO USE WHEN
C                                       ACCESSING TABLE OF INTERNAL BIT
C                                       REPRESENTATIONS FOR GEOMETRIC
C                                       PRODUCTIONS.
C                                       IF NOT IN NAME PORTION, INDEX IS
C                                       MODE REAL
C
 1000 IF(ELMENT.GT.NAMMAX) GO TO 1030
      IERROR=1008
C                                       CLASS
      ICLASS=MODULO*(NAMTBL(ELMENT)/MODULO)
C                                       MODE
      IMODE = NAMTBL(ELMENT)-ICLASS
C                                       STRIP OFF INDIRECT ADDRESS
C                                       INCREMENT IF PRESENT
      IF(IMODE.GE.500) IMODE=IMODE-500
      IF(IMODE.EQ.0) GOTO 2010
      IF (ICLASS.NE.IDENT(1)) GO TO 1025
      ICLASS=PERMID(1)
      NAMTBL(ELMENT)=NAMTBL(ELMENT)-IDENT(1)+PERMID(1)
C                                       ADD PERMANENT IDENTIFIER INCRE-
C                                       MENT IF APPROPRIATE
 1025 IF (ICLASS.EQ.PERMID(1)) IMODE=IMODE+50
     0 IF (ICLASS.EQ.VBL(1)    .OR.
     1    ICLASS.EQ.PERMID(1).OR.
     2    ICLASS.EQ.TEMP(1)  ) GO TO 1050
      IF (ICLASS.NE.NUMBER(1)) GO TO 2010
 1030 IMODE=REAL
C
C...                          STORE INTERNAL REPRESENTATION IN BIGSTK
C
 1050 BIGSTK(BIGNXT)=PMIDTB(IMODE)
C                             STORE NAMTABL INDEX
      BIGSTK(BIGNXT-1)=ELMENT
C                                       RESET STACK POINTER
      BIGNXT=BIGNXT-2
C                                       STORE DUMMY VALUE TO TERMINATE
C                                       SCANS
      BIGSTK(BIGNXT)=-1
C                                       RETURN
      GO TO IPUSH,(100,110)
C
C...                          INVALID FORMAT- ISSUE DIAGNOSTIC AND SET
C...                          LOCAL FLAG
C
 1980 ERRPT=TOP-3
 1990 IERROR=1041
C
C......             ERROR- ISSUE DIAGNOSTIC, SET LOCAL FLAG, AND RETURN
C
 2000 IF(FOULUP)GOTO 2020
      FOULUP=.TRUE.
 2010 CALL ALARM(IERROR,ERRPT,8,'INPAT   ')
C                             COMPRESS LAST ARGUMENT AND PRECEEDING
C                             DELIMITER FROM STACK.
 2020 STACK(1,TOP-2)=STACK(1,TOP)
      STACK(2,TOP-2)=STACK(2,TOP)
      TOP=TOP-2
      RETURN
C
C...                FINAL ERROR PROCESSING, GENERATE CALL TO APT094
C...                TO UNDEFINE THE SUFACE
C
 2030 ERRPT=TOP+1
      STACK(1,TOP)=COMMA(2)
 2040 IF(FOULUP)GOTO 2050
      IERROR=1041
 2045 TOP=TOP+1
      CALL ALARM(IERROR,ERRPT,8,'INPAT   ')
      TOP=TOP-1
 2050 CALL CALLZZ(APTXXX(68))
      CALL TWOARG(DLR,FOUR)
      CALL ARGCVT(RESULT)
      CALL TWOARG(0,DOTTAB)
      CALL RLSLIN
      GO TO 315
C-----------------------------------------------------------------------
C
C     PURPOSE  TO COMPUTE NUMBER OF INCREMENTS STORED WITH CANONICAL
C              FORM OF A PATERN, ARC OR LINEAR, AND ADD TO NWDS
C
C     ARGUMENTS     INAMTB    NAMTBL INDEX OF FINAL ARGUMENT OF PATERN
C                             DEFINITION
C
C                             IF LAST ARG NOT A NUMERIC, FLAG BY SETTING
C                                NWDS-10000. LATER A STANDARD MAX INSERT
 4000 IF(INAMTB.LE.NAMMAX) GO TO 4010
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
      INAMTB=INAMTB-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,INAMTB,IDUMMY)
      CALL BCDBIN(CNUMTB(INAMTB),I,IDUM)
      GO TO 4020
C
 4010 I=-10000-NWDS
 4020 NWDS=NWDS+I
      GO TO IRET,(3015,3052,197)
C-----------------------------------------------------------------------
C
C     PURPOSE  TO LOOK UP A PATERN IN THE CANSIZ TABLE, RETURN THE INDEX
C              OF THE LOCATION WHERE IT IS FOUND (OR WILL BE PLACED).
C
C     ARGUMENTS     INAMTB    NAMTBL INDEX OF THE PATERN
C
 5000 ICANX=1+MOD(INAMTB,CANTOP)
      DO 5010 I=1,CANTOP
      IF (CANSIZ(1,ICANX).EQ.0 .OR. CANSIZ(2,ICANX).EQ.INAMTB) GOTO 5020
      ICANX=1+MOD(ICANX,CANTOP)
 5010 CONTINUE
C                             TABLE FULL, ISSUE DIAGNOSTIC
      IERROR=53
      ERRPT=TOP-5
      GO TO 2010
 5020 GO TO IRET,(3042,3044,3060,147,311,3062)
      END
**** SOURCE FILE : M0006640.W01   ***
*
C
C              FORTRAN SUBROUTINE INPUT
C
C LINKAGE      SUBROUTINE INPUT
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    RECOG
C          SUBROUTINE    BOOLIF
C          SUBROUTINE    CALMCX
C          SUBROUTINE    HELP
C          SUBROUTINE    MACLBL
C          SUBROUTINE    MACTAB
C          SUBROUTINE    MATCH
C          SUBROUTINE    MCXTRN
C          INTEGER FCT.  NAME
C          SUBROUTINE    PATH
C          SUBROUTINE    READ
C
      SUBROUTINE INPUT
C
      IMPLICIT INTEGER (A-Z)
C
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),RTERM(2),SLASH(2),NUMBER(2),LABEL(2),IMPLAB(
     *          2),MACNAM(2),MCLTRM(2)
C RTERM:       (1)=CODE CLASS  4000,(2)=NAMTBL INDEX OF 'RTERM '
      EQUIVALENCE (RTERM(1),CODE(7))
C SLASH:       (1)=CODE CLASS  5000,(2)=NAMTBL INDEX OF '/     '
      EQUIVALENCE (SLASH(1),CODE(9))
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C IMPLAB:      (1)=CODE CLASS 23000,(2)=NAMTBL INDEX OF 'IMPLAB'
      EQUIVALENCE (IMPLAB(1),CODE(45))
C MACNAM:      (1)=CODE CLASS 34000,(2)=NAMTBL INDEX OF 'MACNAM'
      EQUIVALENCE (MACNAM(1),CODE(67))
C MCLTRM:      (1)=CODE CLASS 38000,(2)=NAMTBL INDEX OF 'MCLTRM'
      EQUIVALENCE (MCLTRM(1),CODE(75))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(502),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        5.    PROGRAM CONTROL FLAGS
C
      COMMON/FLAGS/FLAGS
      LOGICAL ENDFLG,NEWSTM
      DIMENSION FLAGS(4)
C ENDFLG:      TRUE WHEN  SOURCE STATEMENT TOTALLY IN STACK
      EQUIVALENCE (ENDFLG,FLAGS(1))
C NEWSTM:      TRUE WHEN NEXT SOURCE STATEMENT REQUESTED FOR PROCESS
      EQUIVALENCE (NEWSTM,FLAGS(2))
C
C        7.    STRING STORAGE AREA
C              POINTER TO THE LAST PROCESSED CHARACTER OF A STATEMENT
      COMMON/INPTR/CNT
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL CALLON,CALLMV,MACRED,FINMAC,ENTRY,SHOULD
      DIMENSION MACXX1(71)
C MCHSTP:      POINTER TO LAST MACHST ENTRY
      EQUIVALENCE (MCHSTP,MACXX1(3))
C MCSAVP:      PRESENT NEST LEVEL DURING MACRO PROCESSING
      EQUIVALENCE (MCSAVP,MACXX1(5))
C CALLON:      TRUE AT A NESTED CALL DURING INTERMED. MACRO PROCESSING
      EQUIVALENCE (CALLON,MACXX1(10))
C CALLMV:      TRUE IF A CALL/MACRO VARIABLE STATEMENT IS ENCOUNTERED
      EQUIVALENCE (CALLMV,MACXX1(11))
C MVSEG:       CONTAINS POSITION NUMBER OF MACRO VBL IF CALLMV IS TRUE
      EQUIVALENCE (MVSEG,MACXX1(12))
C CALLPT:      MACTXT INDEX OF CURRENT CALL STATEMENT
      EQUIVALENCE (CALLPT,MACXX1(13))
C TEXTST:      POINTER TO MCBUFF OF MACRO TEXT WORD BEING PROCESSED
      EQUIVALENCE (TEXTST,MACXX1(15))
C MVPNT:       CONTAINS POINTER-1 OF FIRST MACRO VARIABLE VBLSAV
      EQUIVALENCE (MVPNT,MACXX1(16))
C MACRED:      SET TRUE TO INDICATE INPUT FROM MCBUFF TABLE
      EQUIVALENCE (MACRED,MACXX1(18))
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C FINMAC:      TRUE IF SECOND FINAL PASS OF MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C WAY:         INDICATES TYPE OF MACRO PROCESSING
      EQUIVALENCE (WAY,MACXX1(26))
C MHSTDM:      CONTAINS DIMENSION OF ARRAY MACHST
      EQUIVALENCE (MHSTDM,MACXX1(33))
C ENTRY:       FALSE ON FIRST ENTRY TO MATCH FOR A MACRO EXPRESSION
      EQUIVALENCE (ENTRY,MACXX1(40))
C MCSTRT:      INDEX IN MACSPD OF CURRENT CALL BEING EXAMINED
      EQUIVALENCE (MCSTRT,MACXX1(43))
C MCSRCH:      AT FINAL MACRO PRECESSING MACDF1 POINTER
      EQUIVALENCE (MCSRCH,MACXX1(59))
C NUMARG:      NUMBER OF MACRO VARIABLES+1 FOR CURRENT MACRO
      EQUIVALENCE (NUMARG,MACXX1(61))
C SHOULD:      MACRO INDICATOR. NORMALLY FALSE
      EQUIVALENCE (SHOULD,MACXX1(70))
C
C       24.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX3/MACXX3
      DIMENSION MACXX3(2630),MACDF1(400),MACDF2(400),MACHST(1800),MACSV1
     *          (10)
C MACDF1:      STORES MACRO NAME AND ALL MACRO VBL NAMTBL POINTERS
      EQUIVALENCE (MACDF1(1),MACXX3(1))
C MACDF2:      STORES NORMAL VALUES FOR ALL MACRO VARIABLES
      EQUIVALENCE (MACDF2(1),MACXX3(401))
C MACHST:      MACRO CALL HISTORY TABLE
      EQUIVALENCE (MACHST(1),MACXX3(801))
C MACSV1:      CONTAINS MACRO NEST LEVEL INFORMATIONS
      EQUIVALENCE (MACSV1(1),MACXX3(2601))
C
C       25.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX6/MACXX6
      DIMENSION MACXX6(1300),MACTBL(400),MACSPD(1300),VBLSAV(900)
C MACTBL:      NAMTBL POINTERS OF THE ASSIGNED VALUES FOR MACRO CALL
      EQUIVALENCE (MACTBL(1),MACXX6(1))
C MACSPD:      NAMTBL POINTERS OF THE ASSIGNED VALUES FOR MACRO CALL
      EQUIVALENCE (MACSPD(1),MACXX6(1))
C VBLSAV:      SAVES MACRO VBL ASSIGNED VALUES DURING INTERMED. PROCESS
      EQUIVALENCE (VBLSAV(1),MACXX6(401))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C
C       36.    SYSTEM MACRO AND SEGMENT READ VARIABLES
C
      COMMON/MACSEG/MACSEG
      LOGICAL LMRSTR
      DIMENSION MACSEG(6)
C LMRSTR:      FLAG ON STARTS READING IN A SYSTEM MACRO
      EQUIVALENCE (LMRSTR,MACSEG(4))
C
C       43.    DO LOOP CONTROL VALUES
C
      COMMON/DOLOOP/DOLOOP
      LOGICAL DLRFLG
      DIMENSION DOLOOP(8)
C DLRFLG:      FLAG IS ON WHEN CONTINUATION CARD EXPECTED
      EQUIVALENCE (DLRFLG,DOLOOP(8))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ERRPNT,ESTACK,ERGSTK
      DIMENSION ERRPOS(302),ERRPNT(100),ESTACK(100),ERGSTK(100)
C ERRPNT:      CONTAINS POINTERS TO INPUT STATEMENT TEXT POSITIONS
      EQUIVALENCE (ERRPNT(1),ERRPOS(3))
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C ERGSTK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN ARGSTK
      EQUIVALENCE (ERGSTK(1),ERRPOS(203))
C*
C PURPOSE      TO PLACE THE NEXT CHARACTER OR WORD FROM
C              THE INPUT STREAM INTO THE WORKING STACK
C              (STACK) AND TO HANDLE THE PROCESSING OF
C              CALL STATEMENTS IMBEDDED IN MACROS.
C
C NOTES        1.  MACRED=.FALSE. IF SINGLE CHARACTERS
C                  ARE SELECTED FROM THE SOURCE INPUT
C                  FILE.
C                  MACRED=.TRUE. IF SINGLE WORDS ARE
C                  SELECTED FROM THE MACTXT TABLE, AN
C                  INTERNAL FILE CONTAINING MACRO TEXT.
C              2.  IT IS ASSUMED THAT THE CHARACTER POR-
C                  TION OF THE NAME TABLE (NAMTBL) IS
C                  ARRANGED SO THAT THE VALUE OF EACH
C                  CHARACTER IS EQUAL TO ONE LESS THAN ITS
C                  INDEX IN THE NAME TABLE (NAMTBL).
C
      DIMENSION INCHAR(80)
      CHARACTER NCALL*6
      LOGICAL ERRFLG
      DATA NCALL/'CALL  '/,ERRFLG/.FALSE./
C**
C
C...     BRANCH IF MACRO TEXT REQUIRED.
C
    5 IF(MACRED)GO TO 400
C
      IF((.NOT.ENDFLG).AND.(.NOT.LMRSTR))GO TO 100
   10 CALL READ (INCHAR)
C
C...               FETCH CHARACTER CODE
C
  100 CNT = CNT+1
      II=INCHAR(CNT)
      ESTACK(TOP+1)=ERRPNT(CNT)
  150 ENDFLG = .FALSE.
      IF(II.GT.NAMMAX)GO TO 160
      IF(II.NE.0)GO TO 170
C
C...               IGNORE INVALID CHARACTER
C
      CALL ALARM(1,TOP+1,8,'INPUT   ')
      GO  TO  100
C
  160 ICROD=NUMBER(1)
      GO TO 300
  170 IF(II.LT.0)GO TO 300
      ICROD=NAMTBL(II)
      IF(ICROD.NE.RTERM(1))GOTO 300
      ENDFLG=.TRUE.
      ESTACK(TOP+1)=ESTACK(TOP)
C
C...               PLACE CHARACTER IN STACK
C
  300 TOP = TOP +1
      IF (TOP-100) 320,310,315
  310 IF (.NOT.ERRFLG)CALL ALARM(1028,99,8,'INPUT   ')
      ERRFLG=.TRUE.
  315 TOP=99
      IF( ENDFLG) GOTO 318
      IF (DLRFLG) GOTO 10
      IF (.NOT.MACRED) GOTO 317
  316 TEXTST=TEXTST+1
      CALL MCXTRN(2,TEXTST,II)
      IF (II.NE.RTERM(2)) GOTO 316
  317 ICROD = RTERM(1)
      II = RTERM(2)
      ENDFLG=.TRUE.
  318 TOP=2
  320 STACK(1,TOP) = II
      IF(II.LT.0)GOTO 355
      ICROD = ICROD/MODULO
      STACK(2,TOP) = META(ICROD)
  350 RETURN
  355 STACK(2,TOP)=0
      GOTO 350
  400 TEXTST = TEXTST+1
      CALL MCXTRN(2,TEXTST,MCTXWD)
      IF(MCTXWD)410,460,440
C
C...     MACRO VARIABLE ENCOUNTERED. BRANCH IF NESTED CALL IS BEING
C...     EXAMINED DURING INTERMEDIATE MACRO PROCESSING.
C
  410 IF(CALLON) GO TO 450
      IF(INTMED) 420,420,430
C
C...     SUBSTITUTE ASSIGNED VALUE FOR MACRO VARIABLE DURING
C...     INTERMEDIATE MACRO PROCESSING.
C
  420 II=MVPNT-MCTXWD
      II = VBLSAV(II)
      GO TO  150
C
C...     SUBSTITUTE SPECIAL MACRO VARIABLE NAME (BASED ON MACRO NAME AND
C...     POSITION OF MACRO VARIABLE) FOR MACRO VARIABLE DURING FINAL
C...     MACRO PROCESSING.
C
  430 II=-MCTXWD
      II = MACSPD(II)
      GO TO 150
C
C...     PICK UP NEXT WORD FROM MACTXT TABLE.
C
  440 II=MCTXWD
      GO TO 150
C
C...     PICK UP MACRO VARIABLE NAME FROM MACDF1 TABLE. NESTED CALL IS
C...     BEING EXAMINED DURING INTERMEDIATE MACRO PROCESSING.
C
  450 II=MACSV1(MCSAVP)-MCTXWD
      II = IABS(MACDF1(II+2))
      GO TO 150
C
C...     CALL ENCOUNTERED IN MACRO TEXT.
C
  460 IF(INTMED) 470,470,570
  470 II = MACSV1(MCSAVP)
      IF(MACTBL(II)) 480, 480, 540
C
C...     CURRENT MACRO HAS NOT PREVIOUSLY UNDERGONE INTERMEDIATE MACRO
C...     PROCESSING.PREPARE TO PERFORM SUCH PROCESSING ON NESTED CALL.
C
  480 CALLON = .TRUE.
      CALLPT = TEXTST
      STACK(1,TOP+1)=NAME(NCALL)
      STACK(1,TOP+2) = SLASH(2)
      CALL MCXTRN(2,TEXTST+2,MCTXWD)
      IF(MCTXWD)490,490,500
C
C...     NAME FOLLOWING CALL/ IS A MACRO VARIABLE.
C
  490 MVSEG=-MCTXWD
      CALLMV = .TRUE.
      II = MVPNT+MVSEG
C
C...     SUBSTITUTE ASSIGNED MACRO NAME FOR MACRO VARIABLE IN NESTED
C...     CALL.
C
      STACK(1,TOP+3) = VBLSAV(II)
      GO TO 510
C
C...     PLACE MACRO NAME IN STACK FOR NESTED CALL.
C
  500 STACK(1,TOP+3)=MCTXWD
C
C...     PREPARE STACK TO BEGIN INTERMEDIATE MACRO PROCESSING OF NESTED
C...     CALL.
C
  510 DO  520 I = 1,3
      TOP = TOP+1
      II = STACK(1,TOP)
      II = NAMTBL(II)/MODULO
  520 STACK(2,TOP) = META(II)
      II=STACK(1,TOP)
      IF((NAMTBL(II)/MODULO).EQ.(MACNAM(1)/MODULO))GO TO 530
      CALLON=.FALSE.
      CALLMV=.FALSE.
      CALL MCXTRN(1,TEXTST,STACK(1,TOP-2))
  530 TEXTST=TEXTST+2
      GO TO 350
C
C...     CURRENT MACRO IS UNDERGOING INTERMEDIATE MACRO REPROCESSING.
C...     DETERMINE WHETHER OR NOT MACRO NAMED IN NESTED CALL REQUIRES
C...     INTERMEDIATE MACRO REPROCESSING.
C
  540 CALL MCXTRN(2,TEXTST+1,MCTXWD)
      IF(MCTXWD)550,560,550
C
C  NO INTERMEDIATE MACRO PROCESSING OF CALLED MACRO REQUIRED.
  550 CALL MCXTRN(2,TEXTST+3,TEXTST)
  551 STACK(1,TOP)=RTERM(2)
      NEWSTM = .TRUE.
      ARGTOP=0
C  MODIFY STACK TO INDICATE INTERMEDIATE MACRO. REPROCESSING OF CALLED
C  MACRO REQUIRED.
      GO TO 350
  560 II = MCLTRM(1)/MODULO
      TOP = 2
      STACK(1,1) = MCLTRM(2)
      STACK(1,2) = MCLTRM(2)
      STACK(2,1) = META(II)
      STACK(2,2) = META(II)
C  CALL ENCOUNTERED DURING FINAL MACRO PROCESSING.
      GO TO 350
C  CALLED MACRO A MACRO VARIABLE AND/OR MACRO VARIABLE =MACRO VARIABLE
C  IN ARGUMENT LIST.
  570 CALL MCXTRN(2,TEXTST+1,MCTXWD)
      IF(MCTXWD)580,580,750
  580 CALL MCXTRN(2,TEXTST+2,MCTXWD)
      ICROD=-MCTXWD
      WAY=5
      II=TEXTST+3
C  FIRST PASS OF FINAL MACRO PROCESSING IN EFFECT. ALL ELEMENTS OF CALL
C  STATEMENT WHICH ARE CALL MACRO VARIABLES ARE PLACED IN ARGSTK FOR
C  ANALYSIS TO DETERMINE IF BRANCHING I.L. REQUIRED.
      IF(FINMAC)GO TO 740
      IF(ICROD.LT.0)GO TO 600
      ARGSTK(1)=MACSPD(ICROD)
      ARGTOP=1
  600 CALL MCXTRN(2,II,MCTXWD)
      IF(MCTXWD/100000)610,630,620
  610 J=-MCTXWD+100000*(MCTXWD/100000)
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=IABS(MACSPD(J))
  620 II=II+1
      GO TO 600
  630 ERGSTK(100)=-ARGTOP
      CALL MATCH
C  BRANCH IF ALL REQUIRED BRANCHING CODE FOR CALL STATEMENT HAS BEEN
C  GENERATED.
      M=MCSTRT
      IF(.NOT.ENTRY)GO TO 735
  635 IF(ICROD.LT.0)GO TO 640
      K=M+ICROD
      K=IABS(MACSPD(K))
      J=1
      CALL MACTAB(K,J)
      GO TO 650
C  COMPRESSED CALL INFORMATION FOR THE CALLED MACRO INVOLVED IN THE
C  CURRENT BRANCH IS PLACED IN THE MACHST TABLE.
  640 J=-ICROD
  650 MCHSTP=MCHSTP+3
      IF(MCHSTP.LE.MHSTDM)GO TO 655
  652 CALL ALARM(22,0,8,'INPUT   ')
      CALL HELP
  655 MACHST(MCHSTP-2)=MCSRCH
      MACHST(MCHSTP-1)=J
      MACDF2(J+2)=MACDF2(J+2)+1
      MACHST(MCHSTP)=MACDF2(J+2)
      II=TEXTST+3
  660 CALL MCXTRN(2,II,MCTXWD)
      ICRAD=100000*(MCTXWD/100000)
      IF(ICRAD)670,710,680
  670 I=-MCTXWD+ICRAD+M
      I=IABS(MACSPD(I))
      GO TO 690
  680 I=MCTXWD-ICRAD
  690 K=J+IABS(ICRAD/100000)
      IF(I.EQ.MACDF2(K+2))GO TO 700
      MCHSTP=MCHSTP+1
      IF(MCHSTP.GT.MHSTDM)GO TO 652
      MACHST(MCHSTP)=IABS(ICRAD)+I
  700 II=II+1
      GO TO 660
C  BRANCH IF CALLED MACRO HAS NO MACRO VARIABLES.
  710 K=MACDF2(J+2)
  720 IF(MACDF1(J+2).EQ.0)GO TO 800
      CALL CALMCX(MACDF1(J),0,2)
C  GENERATE I.L. CODE WHICH PROVIDES LINKAGE WITH CALLED MACRO.
      CALL MACLBL(MACDF1(J),-K,I)
      NAMTBL(I) = IMPLAB(1)
      CALL CALMCX( I,MCSAVP,1)
  810 CALL MCXTRN(2,TEXTST+1,MCTXWD)
      IF(MCTXWD)730,730,736
  730 IF(.NOT.FINMAC)GO TO 630
  735 CALL MCXTRN(2,II,TEXTST)
C  SECOND PASS OF FINAL MACRO PROCESSING.
      GO TO 551
  740 CALL PATH
C  BRANCH TO GENERATE CALL I.L. IF NO SUCH CODE WAS GENERATED DURING
C  FIRST PASS OF FINAL MACRO PROCESSING.
      M=NUMARG
      IF(SHOULD)GO TO 635
  736 CALL MCXTRN(2,II,MCTXWD)
      IF((MCTXWD/100000).EQ.0)GO TO 735
      II=II+1
      GO TO 736
  750 II=TEXTST+3
      IF(.NOT.FINMAC)GO TO 736
      K=MCTXWD
      CALL MCXTRN(2,TEXTST+2,J)
C  GENERATE CALL I.L. FOR MACRO EMPLOYING NO MACRO VARIABLES.
      GO TO 720
  800 CALL MACLBL(-1,MACDF1(J),I)
      NAMTBL(I)=LABEL(1)
      CALL CALMCX(I,MCSAVP,1)
      GO TO 810
       END
**** SOURCE FILE : M0006643.V06   ***
*
C
C              FORTRAN SUBROUTINE ISSCOD
C
C LINKAGE      SUBROUTINE ISSCOD
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    INPUT
C          SUBROUTINE    CONCAT
C          SUBROUTINE    BINBCD
C          INTEGER FCT.  GETTMP
C          INTEGER FCT.  NUMB
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          SUBROUTINE    RLSLIN
C          SUBROUTINE    ARGCVT
C
      SUBROUTINE ISSCOD
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),COMMA(2),TEMP(2)
C COMMA:       (1)=CODE CLASS  1000,(2)=NAMTBL INDEX OF ',     '
      EQUIVALENCE (COMMA(1),CODE(1))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(502),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C        7.    STRING STORAGE AREA
C              POINTER TO THE LAST PROCESSED CHARACTER OF A STATEMENT
      COMMON/INPTR/CNT
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C CVTSUB:      CONTAINS COMMAND CODE (13) FOR CVTSUB COMMAND
      EQUIVALENCE (CVTSUB,IL(13))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C SUBSCR:      MODE CODE (24) FOR SUBSCRIPT
      EQUIVALENCE (SUBSCR,MODX(24))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       37.    INCLUSIVE SUBSCRIPT VARIABLES
C
      COMMON/ISSCOM/ISSCOM
      LOGICAL ISSFL,ISSEND
      DIMENSION ISSCOM(9),ISSTRM(2)
C ISSA:        LOWEST SUBSCRIPT OF AN INCLUSIVE SUBSCRIPT STRING
      EQUIVALENCE (ISSA,ISSCOM(1))
C ISSB:        HIGHEST SUBSCRIPT OF AN INCLUSIVE SUBSCRIPT STRING
      EQUIVALENCE (ISSB,ISSCOM(2))
C ISSC:        INCREMENT OR DECREMENT FOR INCLUSIVE SUBSCRIPT STRING
      EQUIVALENCE (ISSC,ISSCOM(3))
C ISSVBL:      NAMTBL POINTER TO THE INCLUSIVE SUBSCRIPTED VARIABLE
      EQUIVALENCE (ISSVBL,ISSCOM(4))
C ISSMOD:      MODE OF THE INCLUSIVE SUBSCRIPTED VARIABLE
      EQUIVALENCE (ISSMOD,ISSCOM(5))
C ISSFL:       TRUE DURING INCLUSIVE SUBSCRIPT PROCESSING
      EQUIVALENCE (ISSFL,ISSCOM(6))
C ISSEND:      END OF INCLUSIVE SUBSCRIPT PROCESSING
      EQUIVALENCE (ISSEND,ISSCOM(7))
C ISSTRM:      SAVES THE STACK TOP ITEMS DURING SUBSCRIPT PROCESSING
      EQUIVALENCE (ISSTRM(1),ISSCOM(8))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ERRPNT,ESTACK
      DIMENSION ERRPOS(302),ERRPNT(100),ESTACK(100)
C ERRPNT:      CONTAINS POINTERS TO INPUT STATEMENT TEXT POSITIONS
      EQUIVALENCE (ERRPNT(1),ERRPOS(3))
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C**
      CHARACTER IBUFF*15,IHBLK*4
      DATA IHBLK/'    '/
C
C...     CHECK FOR SPACE IN STACK
C
      IERROR=0
      IF(TOP+2.LE.97)GO TO 10
      IERROR=1028
C
C...     ENTER NEW SUBSCRIPT IN NAMTBL
C
   10 IBUFF(12:15)=IHBLK
      CALL BINBCD(ISSA,IBUFF(4:),I)
      WRITE(IBUFF(1:3),'(I3)') I
      CALL CONCAT(IBUFF,'.')
      INUMB=NUMB(IBUFF(4:15))+NAMMAX
C
C...     GENERATE SUBSCRIPT I.L. AND PLACE TEMPORARY IN STACK
C
      IRSLT=GETTMP(SUBSCR)
      NAMTBL(IRSLT)=TEMP(1)+SUBSCR
      CALL OPCODE(CVTSUB)
      CALL ARGCVT(IRSLT)
      CALL ARGCVT(ISSVBL)
      CALL ARGCVT(INUMB)
      CALL ONEARG(TXXXX(1,ISSMOD))
      CALL RLSLIN
      NAMTBL(IRSLT)=TEMP(1)+ISSMOD+MODHLF
      STACK(1,TOP+1)=IRSLT
      I=TEMP(1)/MODULO
      STACK(2,TOP+1)=META(I)
      TOP=TOP+2
      ESTACK(TOP)=ERRPNT(CNT-2)
C
C...     UPDATE ISSA AND CHECK FOR END OF SUBSCRIPT STRING
C
      ISSA=ISSA+ISSC
      IF((ISSC.LT.0 .AND. ISSA.LT.ISSB) .OR.
     /   (ISSC.GT.0 .AND. ISSA.GT.ISSB)) GO TO 500
      IF(IERROR.NE.0)GO TO 400
C
C...     PLACE COMMA IN TOP OF STACK AND CONTINUE
C
      STACK(1,TOP)=COMMA(2)
      I=COMMA(1)/MODULO
      STACK(2,TOP)=META(I)
      GO TO 600
C
C...     END OF INCLUSIVE SUBSCRIPT STRING - RESTORE TOP ITEM
C          OF STACK AND SET FLAGS
C
  400 CALL ALARM(IERROR,TOP,8,'ISSCOD  ')
  500 DO 550 I=1,2
      STACK(I,TOP)=ISSTRM(I)
  550 CONTINUE
      ISSEND=.TRUE.
      ISSFL=.FALSE.
C
  600 RETURN
      END
**** SOURCE FILE : M0006644.V01   ***
*
C
C              FORTRAN SUBROUTINE JUMPZZ
C
C LINKAGE      SUBROUTINE JUMPZZ(INDEX)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ONEARG          SUBROUTINE    COMSTR
C          SUBROUTINE    OPCODE          SUBROUTINE    PRO026
C          SUBROUTINE    RLSLIN
C
      SUBROUTINE JUMPZZ(INDEX)
C
      IMPLICIT INTEGER (A-Z)
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C JUMP:        CONTAINS COMMAND CODE ( 8) FOR JUMP COMMAND
      EQUIVALENCE (JUMP,IL(8))
C*
C PURPOSE      TO GENERATE  AND OUTPUT TO THE I.L. INTERNAL
C              RECORD IMAGE (ILFILE) THE JUMP I.L. COMMAND.
C
C ARGUMENTS    INDEX    NAME TABLE (NAMTBL) INDEX OF A LABEL.
C**
C...     GENERATE I.L. FOR JUMP COMMAND.
C
      CALL OPCODE(JUMP)
      CALL ONEARG(INDEX)
      CALL RLSLIN
      RETURN
       END
**** SOURCE FILE : M0006629.V01   ***
*
C
C              FORTRAN SUBROUTINE KONAST
C
C LINKAGE      SUBROUTINE  KONAST(TENPT)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    SETCHR          SUBROUTINE    RECOG
C
      SUBROUTINE  KONAST(TENPT)
C
      IMPLICIT INTEGER (A-Z)
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),ASTER(2),NUMBER(2),DBLAST(2)
C ASTER:       (1)=CODE CLASS  9000,(2)=NAMTBL INDEX OF '*     '
      EQUIVALENCE (ASTER(1),CODE(17))
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C DBLAST:      (1)=CODE CLASS 32000,(2)=NAMTBL INDEX OF 'DBLAST'
      EQUIVALENCE (DBLAST(1),CODE(63))
C**
      TOP=TOP+2
      STACK(1,TOP)=STACK(1,TOP-2)
      STACK(2,TOP)=STACK(2,TOP-2)
      STACK(1,TOP-1)=STACK(1,TOP-3)
      STACK(2,TOP-1)=STACK(2,TOP-3)
      CALL SETCHR(TOP-2,DBLAST)
      CALL SETCHR(TOP-3,NUMBER)
      STACK(1,TOP-3)=TENPT
      CALL SETCHR(TOP-4,ASTER)
C
      RETURN
      END
**** SOURCE FILE : M0006645.W01   ***
*
C
C              FORTRAN SUBROUTINE LABCON
C
C LINKAGE      SUBROUTINE LABCON(K)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    BINBCD          SUBROUTINE    PRO026
C          SUBROUTINE    ALARM           SUBROUTINE    RECOG
C
      SUBROUTINE LABCON(K)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),LABEL(2)
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C
C       11.    SEQUENCE NUMBER STORAGE
C
      COMMON/SEQCOM/SEQCOM
      DIMENSION SEQCOM(3),SEQNUM(2)
C SEQNO:       INTERNALLY GENERATED STATEMENT NUMBER
      EQUIVALENCE (SEQNO,SEQCOM(1))
C SEQNUM:      ALPHANUMERIC REPRESENTATION OF CURRRENT STATEMENT NUMBER
      EQUIVALENCE (SEQNUM(1),SEQCOM(2))
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL PRTERR
      DIMENSION PRT(7)
C PRTERR:      TRUE IF PPOPTN/PRTER,ON. PRINTOUT OF STACK OR ARGSTK
      EQUIVALENCE (PRTERR,PRT(6))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL ILHLT
C ILHLT:       TRUE IF I.L. SHOULD NOT BE PLACED IN ILFILE
      EQUIVALENCE (ILHLT,MACXX1(14))
      DIMENSION MACXX1(71)
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C
C       43.    DO LOOP CONTROL VALUES
C
      COMMON/DOLOOP/DOLOOP
      DIMENSION DOLOOP(8)
C JUMPTO:      MARKER SET AFTER JUMPTO OR IF FOR LABEL CONTROL
      EQUIVALENCE (JUMPTO,DOLOOP(1))
C*
      DIMENSION     LABARY(2,150)
      LOGICAL    PRTER
      DATA ISEQ,LABCNT,LABARY/302*0/,LABDM/151/
C**
      IF(ILHLT)GOTO 150
      L=IABS(K)
      IF (L.GT.0) THEN
      M=MODULO*(NAMTBL(L)/MODULO)
      ENDIF
      IF(K)50,100,10
C
C     JUMPTO STATEMENT,SEARCH FOR FORMER LABEL
C
   10 IF(M.EQ.LABEL(1))GOTO 40
C
C     NO FORMER LABEL, SEARCH FOR FORMER JUMPTO
C
      DO 20 I=1,LABCNT
      IF(LABARY(1,I).NE.K)GOTO 20
      IF(LABARY(2,I).EQ.0)GOTO 40
   20 CONTINUE
      LABCNT=LABCNT+1
      IF(LABCNT-LABDM)30,160,40
   30 LABARY(1,LABCNT)=K
      LABARY(2,LABCNT)=SEQNO
   40 IF(ISEQ.EQ.SEQNO)GOTO 150
      ISEQ=SEQNO
      GOTO 130
C
C     LABEL STATEMENT, SEARCH FOR FORMER JUMPTO
C
   50 DO 60 I=1,LABCNT
      IF(LABARY(1,I).EQ.L)LABARY(2,I)=0
   60 CONTINUE
      GOTO 140
C
C     FINI OR TERMAC HAS COME
C
  100 IF(LABCNT.EQ.0)GOTO 130
      IF(LABCNT.GE.LABDM)LABCNT=LABDM-1
      L=SEQNUM(1)
      M=SEQNUM(2)
      PRTER=PRTERR
      PRTERR=.FALSE.
      DO 110 I=1,LABCNT
      IF(LABARY(2,I).EQ.0)GOTO 110
      CALL BINBCD(LABARY(2,I),SEQNUM,N)
      LABARY(2,I)=0
      CALL ALARM(1002,0,4,'LABCON  ')
  110 CONTINUE
      LABCNT=0
      SEQNUM(1)=L
      SEQNUM(2)=M
      PRTERR=PRTER
  130 IF(JUMPTO.NE.0)CALL ALARM(1009,0,4,'LABCON  ')
  140 JUMPTO=0
      IF(K.GT.0)JUMPTO=SEQNO+2
C
  150 RETURN
  160 CALL ALARM(40,0,4,'LABCON  ')
      GOTO 130
      END
**** SOURCE FILE : M0006646.V01   ***
*
C
C              FORTRAN SUBROUTINE LABELZ
C
C LINKAGE      SUBROUTINE LABELZ(INDEX)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ONEARG          SUBROUTINE    BOOLIF
C          SUBROUTINE    OPCODE          SUBROUTINE    COMSTR
C          SUBROUTINE    RLSLIN          SUBROUTINE    LOOP
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    MATCH
C                                        SUBROUTINE    RECOG
C
      SUBROUTINE LABELZ(INDEX)
C
      IMPLICIT INTEGER (A-Z)
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C LABELX:      CONTAINS COMMAND CODE ( 6) FOR LABEL COMMAND
      EQUIVALENCE (LABELX,IL(6))
C*
C PURPOSE      TO GENERATE AND OUTPUT TO THE I.L. RECORD IMAGE
C              (ILFILE) THE LABEL I.L. COMMAND.
C
C ARGUMENTS    INDEX    NAME TABLE (NAMTBL) INDEX OF LABEL.
C**
      CALL OPCODE(LABELX)
      CALL ONEARG(INDEX)
      CALL RLSLIN
      RETURN
       END
**** SOURCE FILE : M0006647.W01   ***
*
C
C              FORTRAN SUBROUTINE LARGES
C
C LINKAGE      SUBROUTINE  LARGES (ACTNO,BIGCNT)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          INTEGER FCT.  GETTMP          SUBROUTINE    RECOG
C          SUBROUTINE    HELP
C          SUBROUTINE    ARGCVT
C          INTEGER FCT.  MODE
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  SEARCH
C          SUBROUTINE    SETMOD
C          SUBROUTINE    ALARM
C          SUBROUTINE    TWOARG
C
      SUBROUTINE  LARGES (ACTNO,BIGCNT)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),COMMA(2),BLANK(2),NUMBER(2),TEMP(2),PERMID(2),
     *          VBL(2),IDENT(2)
C COMMA:       (1)=CODE CLASS  1000,(2)=NAMTBL INDEX OF ',     '
      EQUIVALENCE (COMMA(1),CODE(1))
C BLANK:       (1)=CODE CLASS 13000,(2)=NAMTBL INDEX OF '      '
      EQUIVALENCE (BLANK(1),CODE(25))
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(502),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C        8.    NAME TABLE POINTERS TO BCD LITERALS
C
      COMMON/BCDPTR/BCDPTR
      DIMENSION BCDPTR(7)
C DOTTAB:      NAMTBL POINTER TO ALPHAMERIC LITERAL '$$TAB'
      EQUIVALENCE (DOTTAB,BCDPTR(7))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12),ZERO(12)
C ZERO:        NAMTBL POINTER TO '0     '
      EQUIVALENCE (ZERO(1),NUMPTR(1))
C ONE:         NAMTBL POINTER TO '1     '
      EQUIVALENCE (ONE,NUMPTR(3))
C TWO:         NAMTBL POINTER TO '2     '
      EQUIVALENCE (TWO,NUMPTR(5))
C FOUR:        NAMTBL POINTER TO '4     '
      EQUIVALENCE (FOUR,NUMPTR(7))
C
C       10.    TABLE STORAGE FOR GEOMETRIC FUNCTION PROCESSOR
C
      INCLUDE (GMTY)    
C GEOLOC:      GEOMETRIC PRODUCTION STARTING INDEX IN GEOMTB
C PMIDTB:      INTERNAL BIT REPRESENTATIONS FOR EACH ELEMENT OF GEOMTB
C GEOMTB:      GEOMETRIC FORMAT PRODUCTIONS ARRANGED BY SURFACE TYPE
C
C       12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE
      LOGICAL TABCYS
      DIMENSION CFSIZE(205),MAXSIZ(2),CANSIZ(2,100)
C CANTOP:      POINTER TO THE LAST CANSIZ ENTRY
      EQUIVALENCE (CANTOP,CFSIZE(1))
C TABCYS:      TRUE WHEM PART PROGRAM CONTAINS TABCYLS
      EQUIVALENCE (TABCYS,CFSIZE(3))
C MAXSIZ:      SIZE OF THE LAST LARGEST LARGE DATA ARRAY
      EQUIVALENCE (MAXSIZ(1),CFSIZE(4))
C CANSIZ:      NUMBER OF ITEMS A. NAMTBL INDEX OF EACH LARGE DATA ARRAY
      EQUIVALENCE (CANSIZ(1,1),CFSIZE(6))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C REPL:        CONTAINS COMMAND CODE (17) FOR REPL COMMAND
      EQUIVALENCE (REPL,IL(17))
C MOVE:        CONTAINS COMMAND CODE (19) FOR MOVE COMMAND
      EQUIVALENCE (MOVE,IL(19))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C TABCYL:      MODE CODE (11) FOR TABULATED CYLINDER
      EQUIVALENCE (TABCYL,MODX(11))
C POINT:       MODE CODE (19) FOR POINT
      EQUIVALENCE (POINT,MODX(19))
C REAL:        MODE CODE (24) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C SUBSCR:      MODE CODE (24) FOR SUBSCRIPT
      EQUIVALENCE (SUBSCR,MODX(24))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      DIMENSION MACXX1(71)
      LOGICAL NESTG
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C NESTG:       TRUE WHEN A NESTED GEOMETRIC EXPRESSION ENCOUNTERED
      EQUIVALENCE (NESTG,MACXX1(45))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C NOUGHT:      CONTAINS OPERAND TYPE 0
      EQUIVALENCE (NOUGHT,OPMOD(1))
C DLR:         CONTAINS OPERAND TYPE CODE 1
      EQUIVALENCE (DLR,OPMOD(2))
C TRPDLR:      CONTAINS OPERAND TYPE CODE 3
      EQUIVALENCE (TRPDLR,OPMOD(4))
C QUIDLR:      CONTAINS OPERAND TYPE CODE 5
      EQUIVALENCE (QUIDLR,OPMOD(6))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136),APTXXX(120)
C APTXXX:      NAMTBL POINTERS FOR XECUTION SUBROUTINE NAMES
      EQUIVALENCE (APTXXX(1),SUBLST(1))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C*
C PURPOSE      TO VALIDATE THE FORMAT OF LARGE DATA ARRAY DEFINITION
C              STATEMENTS AND TO GENERATE THE APPROPRIATE INTERMEDIATE
C              LANGUAGE.
C
C ARGUMENTS    ACTNO          MATCHING BASIC PRODUCTION ACTION NUMBER.
C              BIGCNT         DEFINITION ARGUMENT NUMBER + 1
C
C NOTES        DESCRIPTION OF THE CANSIZ ARRAY IN CDE PACKAGE NO. 12
C                  CANSIZ(1,I) = NUMBER OF WORDS IN THE EXTERNAL
C                                CANONICAL FORM OF A LARGE DATA ARRAY.
C                  CANSIZ(2,I) = THE NAME TABLE POINTER OF THE RESULT.
C              ALSO SEE NOTES FOR PRO020.
C
C
      LOGICAL  FOULUP,NOMORE
      DIMENSION BIGSTK(12)
      CHARACTER*6 NORMAL
      DATA  NORMAL /'NORMAL'/
C
C***********************************************************************
C
C... IF THIS IS THE FIRST TIME THRU FOR A GEOMETRIC DEFINITION,
C... INITIALIZE BIGSTK AND DO OTHER HOUSEKEEPING.
C
      IF (BIGCNT .NE. 1)  GO TO 100
      FOULUP = .FALSE.
      PNTCNT = 0
      SLOPCT = 0
      EP = 0
      MATRX = BLANK(2)
      VECTR = BLANK(2)
      NOMORE = .FALSE.
      INDEX = -18
      FIRST = ZERO(1)
      SECOND = ZERO(1)
      TRFORM = ZERO(1)
C
      BIGSTK(2) = -1
      ERRPT=TOP-3
      L = STACK(1,ERRPT)
      XYZ=MOD(NAMTBL(L),MODHLF)
      IF(L.GT.NAMMAX)GO TO 5
      IF(NAMTBL(L)/MODULO.EQ.IDENT(1)/MODULO)CALL SETMOD(TOP-3,PERMID)
    5 M=6
      ASSIGN 10 TO N
      GO TO 1000
   10 BIGTOP = 6
C
C... CHECK IF THIS IS FINAL PROCESSING FOR THIS DEFINITION.
C
  100 IF (ACTNO .NE. 102)   GO TO 500
C
C **********************************************************************
C... PRODUCTION 102  ***************************************************
C
C... IF AN ERROR WAS PREVIOUSLY ENCOUNTERED,SUPPRESS I.L. GENERATION
C
      IF(.NOT.FOULUP)GO TO 102
      LK=STACK(1,TOP-1)
      KL=2
      GO TO 3000
C
C...  IF NOMORE = .TRUE.,SLOPE OR NORMAL IN WRONG PLACE--TAKE ERROR PATH
C
  102 IF(NOMORE)GO TO 1030
C
C... IF STACK(1,TOP-1) IS CLASS IDENT, CHANGE IT TO CLASS PERMID.
C
      ERRPT=TOP-1
      L = STACK(1,ERRPT)
  103 IF(L.GT.NAMMAX)GO TO 105
      IF(NAMTBL(L)/MODULO.EQ.IDENT(1)/MODULO)CALL SETMOD(TOP-1,PERMID)
C
C... PLACE STACK(1,TOP-1) IN BIGSTK
C
  105 M=4
      ASSIGN 110 TO N
      GO TO 1000
C
C... SEARCH GEOMETRIC PRODUCTIONS
C
  110 J = GEOLOC(TABCYL)
      EP=ACTNO
      K = SEARCH (BIGSTK,BIGTOP, GEOMTB(J),EP)
C
C... IF ACTION NUMBER = 200, NO MATCHING PRODUCTION WAS FOUND.
C
      IF (K.GE.200)GOTO 1030
C
C... EXAMINE, WHETHER SPLINE AND VECTOR APPEAR IN VALID POSITION
C
      IF (BIGCNT.GT.4)GOTO 200
      GOTO(150,160,200,170),BIGCNT
  150 IF(K.NE.1)GOTO 1030
      GOTO 210
  160 IF(XYZ.NE.28)GOTO 200
      IF(K.NE.3.AND.K.NE.4)GOTO 1030
      GOTO 200
  170 IF(XYZ.NE.28)GOTO 200
      IF(VECTR.NE.BLANK(2))GOTO 200
      IF(K.NE.4)GOTO 1030
C
C... BRANCH ON GEOMETRIC ACTION NUMBER.
C
  200 GO TO (210,220,230,240,250,260,270,280,290,300,310,320,330,310),K
C... GEO ACTION NUMBER 1   *********************************************
C
  210 IF (BIGCNT .NE. 1)  GO TO 1030
      GO TO 400
C
C... GEO ACTION NUMBER 2   *********************************************
C... SAVE MATRIX AND COMPRESS BIGSTK
C
  220 MATRX = STACK(1,TOP-1)
      TRFORM = ONE
      CALL OPCODE(REPL)
      CALL ONEARG(12)
      CALL TWOARG(-6,DOTTAB)
      CALL ARGCVT(MATRX)
      CALL RLSLIN
      LK=MATRX
      KL=1
      GO TO 3000
C
C... GEO ACTION NUMBER 3   *********************************************
C... EXPAND BIGSTK TO ACCOMODATE TRFORM-MATRIX IF TRFORM IS ARGUMENT 3
C... OF THE DEFINITION.
C
  230 IF (BIGCNT .NE. 2)  GO TO 1030
      GO TO 390
C
C... GEO ACTION NUMBER 4   *********************************************
C... CHECK TO SEE THAT THE FORMAT IS CORRECT AND SAVE THE VECTOR
C
  240 IF ((BIGCNT .NE. 2) .AND. ((BIGCNT .NE. 4) .OR. (MATRX .EQ.
     /BLANK(2))))  GO TO 1030
      VECTR = STACK(1,TOP-1)
      CALL OPCODE(REPL)
      CALL ONEARG(3)
      CALL TWOARG(-3,DOTTAB)
      CALL ARGCVT(VECTR)
      CALL RLSLIN
      LK=VECTR
      KL=2
      GO TO 3000
C
C... GEO ACTION NUMBER 5   *********************************************
C
  250 I = STACK(1,TOP-1)
      SLOPCT = SLOPCT + 1
      IF(PNTCNT.EQ.0)GOTO 1030
C
C... DETERMINE IF SLOPE OR NORMAL IS FOR FIRST OR LAST POINT AND
C... COMPRESS BIGSTK.
C
      CALL OPCODE(MOVE)
      KL=-1
      IF(PNTCNT .GT. 1) KL=-2
      CALL TWOARG(KL,DOTTAB)
      CALL ARGCVT(I)
      CALL RLSLIN
      LK=I
      KL=3
C
C... SET NOMORE =.TRUE. INDICATING THIS MUST BE THE LAST ARGUMENT.
C
      IF(PNTCNT.GT.1) NOMORE = .TRUE.
      GO TO 3000
C
C... GEO ACTION NUMBER 6   *********************************************
C
  260 I = STACK(1,TOP-1)
C
C... DETERMINE IF SLOPE OR NORMAL IS FOR THE FIRST OR LAST POINT.
C
      IF (PNTCNT .GT. 1)   GO TO 265
C
C... DETERMINE IF ARGUMENT = SLOPE OR NORMAL AND SET FIRST = ONE OR TWO.
C... EXPAND BIGSTK.
C
      IF(CNAMTB(I).EQ.NORMAL)
     /    GO TO 261
      FIRST = ONE
      GO TO 390
  261 FIRST = TWO
      GO TO 390
C
C... DETERMINE IF ARGUMENT = SLOPE OR NORMAL AND SET SECOND = ONE OR TWO
C... EXPAND BIGSTK
C
  265 IF(CNAMTB(I).EQ.NORMAL)
     /    GO TO 266
      SECOND = ONE
      GO TO 390
  266 SECOND = TWO
      GO TO 390
C
C... GEO ACTION NUMBER 7   *********************************************
C... ADD 1 TO POINT COUNT, ADVANCE ..TAB INDEX BY 2, COMPRESS BIGSTK,
C... ADD SECOND COORDINATE TO MOVE I.L. ARGUMENT LIST AND RELEASE THE IL
C
  270 PNTCNT = PNTCNT + 1
      IF(PNTCNT.EQ.139)GOTO 1030
      CALL OPCODE(MOVE)
      CALL TWOARG(INDEX,DOTTAB)
      CALL ARGCVT(SAVE1)
      INDEX  = INDEX - 2
      CALL ARGCVT (STACK(1,TOP-1))
      CALL RLSLIN
      LK=SAVE1
      KL=4
      GO TO 3000
  271 LK=STACK(1,TOP-1)
      KL=5
      GO TO 3000
C
C... GEO ACTION NUMBER 8   *********************************************
C... ADD 1 TO POINT COUNT, ADVANCE ..TAB INDEX BY 3, COMPRESS BIGSTK,
C... ADD THIRD COORDINATE TO MOVE I.L. ARGUMENT LIST AND RELEASE THE IL
C
  280 PNTCNT = PNTCNT + 1
      IF(PNTCNT.EQ.139)GOTO 1030
      CALL OPCODE(MOVE)
      CALL TWOARG(INDEX,DOTTAB)
      CALL ARGCVT(SAVE1)
      CALL ARGCVT(SAVE2)
      INDEX = INDEX - 3
      CALL ARGCVT (STACK(1,TOP-1))
      CALL RLSLIN
      LK=SAVE1
      KL=6
      GO TO 3000
  281 LK=SAVE2
      KL=7
      GO TO 3000
  282 LK=STACK(1,TOP-1)
      KL=8
      GO TO 3000
C
C... GEO ACTION NUMBER 9   *********************************************
C... ADD SECOND COORDINATE TO MOVE I.L. ARGUMENT LIST, EXPAND BIGSTK
C
  290 SAVE2=STACK(1,TOP-1)
      GO TO 380
C
C... GEO ACTION NUMBER 10  *********************************************
C... GENERATE MOVE I.L. COMMAND, PUT FIRST COORDINATE IN MOVE ARGUMENT
C... LIST, AND EXPAND BIGSTK.
C
  300 SAVE1=STACK(1,TOP-1)
C
C
      GO TO 390
C
C... GEO ACTION NUMBERS 11,12,13, AND 14  ******************************
C... ADD 1 TO POINT COUNT, ADVANCE ..TAB INDEX, GENERATE MOVE I.L.
C... COMMAND AND RELEASE THE I.L.
C
  310 I1 = -1
      I2 = -2
      GO TO 335
C
  320 I1 = -2
      I2 = -3
      GO TO 335
C
  330 I1 = -3
      I2 = -1
      GO TO 335
C
  335 PNTCNT = PNTCNT + 1
      IF(PNTCNT.EQ.139)GOTO 1030
      LK=STACK(1,TOP-1)
      IF(MOD(NAMTBL(LK),MODULO).LT.MODHLF)GO TO 336
      J=GETTMP(POINT)
      CALL OPCODE(REPL)
      CALL ONEARG(3)
      CALL TWOARG(NOUGHT,J)
      CALL TWOARG(TRPDLR,LK)
      CALL RLSLIN
      STACK(1,TOP-1)=J
      CALL PUTTMP(POINT)
  336 KL=9
      GO TO 3000
  338 CALL OPCODE(MOVE)
      CALL TWOARG(INDEX, DOTTAB)
      CALL TWOARG(I1,STACK(1,TOP-1))
      CALL TWOARG(I2,STACK(1,TOP-1))
      IF (K .NE. 14)  GO TO 340
      CALL TWOARG(-3,STACK(1,TOP-1))
      INDEX = INDEX - 1
  340 CALL RLSLIN
      INDEX = INDEX - 2
      GO TO 400
C
C... COMPRESS BIGSTK
C
  350 BIGSTK(8) = BIGSTK(10)
  360 BIGSTK(6) = BIGSTK(8)
      BIGTOP = 6
      GO TO 400
C
C... SLIDE BIGSTK ARGUMENTS UP
C
  380 BIGTOP = 10
      BIGSTK(10) = BIGSTK(8)
      GO TO 395
  390 BIGTOP = 8
  395 BIGSTK(8)  = BIGSTK(6)
      BIGSTK(6)  = BIGSTK(4)
C
C... COMPRESS STACK AND EXIT
C
  400 STACK(1,TOP-2) = STACK(1,TOP)
      STACK(2,TOP-2) = STACK(2,TOP)
      TOP = TOP-2
       RETURN
C
C **********************************************************************
C... FINAL PROCESSING  *************************************************
C
C... RESERVE SPACE FOR RESULT OF TABCYL DEFINITION IF NECESSARY.
C
  500 IF (ACTNO .EQ. 105)  GO TO 530
      RESULT = STACK(1,TOP-5)
      J = MODULO * (NAMTBL(RESULT) / MODULO)
      IF ((J .EQ. VBL(1)) .OR. (J .EQ. TEMP(1)))    GO TO 540
      NAMTBL(RESULT) = VBL(1) + TABCYL
      CALL RESRVZ (RESULT, TABCYL, TXXXX(1,TABCYL), 1)
      GO TO 545
  530 RESULT = GETTMP(TABCYL)
      NESTG = .TRUE.
      GO TO 550
C
C... IF THIS VARIABLE HAS BEEN PREVIOUSLY DEFINED WITH ANOTHER MODE,
C... ISSUE ERROR AND TERMINATE PROCESSING.
  540 K = MODE (RESULT)
      IERROR=1001
      ERRPT=TOP-6
      IF (K .NE. TABCYL)  GO TO 1040
C
C... IF THIS VARIABLE HAS BEEN PREVIOUSLY DEFINED WITH THE SAME MODE,
C... ISSUE WARNING AND CONTINUE PROCESSING
      IF(J.EQ.VBL(1).AND.INTMED.EQ.0)CALL ALARM(50,TOP-5,4,'LARGES  ')
C
C... IF ERROR OCCURED PREVIOUSLY,GENERATE A CALL TO APT094.
C
      IF (FOULUP)  GO TO 1050
C
C... CHECK FOR INCOMPLETE ARGUMENT LIST AND CHECK THAT THE NUMBER OF
C... POINTS IS WITHIN BOUNDS.
C
  545 IERROR=1025
      ERRPT=0
      IF ((PNTCNT+SLOPCT).LT.4.OR.BIGTOP.NE.6)GOTO 1035
C
C... TRANSLATE FIRST MODIFIER TO AN I.L. NUMBER
C
  550 L = STACK(1,TOP-1)
      J = NAMTBL(L) - (NAMTBL(L)/MODULO)*MODULO - 19
      IF (J-5)  552,554,554
  552 II = ONE
      GO TO 556
  554 II = ZERO(J)
C
C... CHECK TO SEE IF WE HAVE AN XYZ FORMAT WITH NO DIRECTRIX SPECIFIED.
C
C... CHECK IF THIS TABCYL IS ONE OF THE TWO LARGEST LARGE DATA ARRAY
C... CANONICAL FORMS ENCOUNTERED AND IF SO SAVE ITS SIZE IN MAXSIZ.
C
  556 NOWRDS=21+7*PNTCNT
      IF(NOWRDS.LE.(IABS(MAXSIZ(2))))GO TO 570
      IF(NOWRDS.LE.(IABS(MAXSIZ(1))))GO TO 560
      MAXSIZ(2)=MAXSIZ(1)
      MAXSIZ(1)=NOWRDS
      GO TO 570
  560 MAXSIZ(2)=NOWRDS
C
C... INSERT TABCYL SIZE IN CANSIZ ARRAY FOR FUTURE REFERENCE.
C
  570 J = RESULT - (CANTOP*(RESULT/CANTOP))
      DO 580  I = 1,CANTOP
      J = J + 1 - (CANTOP*(J/CANTOP))
      IF((CANSIZ(1,J).NE.0).AND.(CANSIZ(2,J).NE.RESULT))GO TO 580
      CANSIZ(1,J) = NOWRDS
      CANSIZ(2,J) = RESULT
      GO TO 600
  580 CONTINUE
C
C... CANSIZ HAS OVERFLOWED--- TOO MANY LARGE DATA ARRAYS IN PART PROGRAM
C
      IERROR=53
      ERRPT=TOP-6
      GO TO 1040
C
C...  GENERATE CALL I.L. FOR APT088 (TABCYL DEFINITION REDUCTION RTN.)
C
  600 TABCYS = .TRUE.
      CALL  CALLZZ (APTXXX(67))
      CALL  ARGCVT (RESULT)
      CALL  ARGCVT (II)
      CALL  TWOARG (QUIDLR, PNTCNT)
      CALL  ARGCVT (FIRST)
      CALL  ARGCVT (SECOND)
      CALL  ARGCVT (TRFORM)
      CALL TWOARG(NOUGHT,DOTTAB)
      CALL  RLSLIN
C
C... ADJUST THE STACK AND RETURN
C
  610 IF (ACTNO - 104)  635,620,640
  620 TOP = TOP - 6
  630 STACK(1,TOP) = RESULT
      K = NAMTBL(RESULT) / MODULO
      STACK(2,TOP) = META(K)
  635 RETURN
  640 TOP = TOP - 4
      NESTG = .FALSE.
      GO TO 630
C
C ********************************************************************
C... CONVERT AN ELEMENT OF THE STACK TO MACHINE DEPENDENT REPRESENTATION
C... AND INSERT IT IN BIGSTK SO IT CAN BE MATCHED WITH THE GEOMETRIC
C... PRODUCTIONS.
C
C... LINKAGE --- SET L = STACK ELEMENT (NAMTBL POINTER)
C...             SET M = BIGSTK INDEX
C...             ASSIGN N TO RETURN STATEMENT NUMBER
C
 1000 IF(L.GT.NAMMAX)GO TO 1005
      KK = MODULO * (NAMTBL(L) /MODULO)
      IARG = NAMTBL(L) - KK
      IF (IARG .GE. 500)   IARG = IARG - 500
      IF ((KK .EQ. VBL(1)) .OR. (KK .EQ. TEMP(1)))   GO TO 1020
      IF (KK .EQ. PERMID(1))  GO TO 1010
      IF (KK .NE. NUMBER(1))  GO TO 1030
 1005 IARG =REAL
      GO TO 1020
C---     CHECK FOR UNDEFINED SLOPE VALUE
 1010 IF(IARG.EQ.0) GO TO 1030
      IARG=IARG+50
 1020 BIGSTK(M) = PMIDTB(IARG)
      GO TO N, (10,110)
C
C ********************************************************************
C... INVALID TABCYL DEFINITION
C
 1030 CALL ALARM(1025,ERRPT,8,'LARGES  ')
      FOULUP = .TRUE.
      GO TO 400
C
C... FINAL PROCESSING CANNOT BE COMPLETED
C
 1035 IF(FOULUP)GOTO 1050
      IF(EP.EQ.0)GOTO 1040
      STACK(1,TOP)=COMMA(2)
      ERRPT=TOP+1
 1040 TOP=TOP+1
      CALL ALARM(IERROR,ERRPT,8,'LARGES  ')
      TOP=TOP-1
 1050 CALL CALLZZ(APTXXX(68))
      CALL TWOARG(DLR,FOUR)
      CALL ARGCVT(RESULT)
      CALL TWOARG (NOUGHT,DOTTAB)
      CALL RLSLIN
      GO TO 610
C
C...  IF INDIRECT ADRESS TEMPORARY,RELEASE IT.
C.
 3000 IF(LK.GT.NAMMAX)GO TO 4000
      I=NAMTBL(LK)
      IF(I/MODULO.NE.TEMP(1)/MODULO)GO TO 4000
      J=I-TEMP(1)
      IF(J.GE.MODHLF)J=SUBSCR
      CALL PUTTMP(J)
 4000 GO TO(360,400,360,271,360,281,282,350,338),KL
      CALL HELP
      RETURN
       END
**** SOURCE FILE : M0006649.V07   ***
*
C
C              FORTRAN SUBROUTINE LCANON
C
C LINKAGE      SUBROUTINE LCANON(ACTNO,BIGCNT)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    CONCAT          SUBROUTINE    RECOG
C          INTEGER FCT.  GETTMP
C          SUBROUTINE    BINBCD
C          SUBROUTINE    ARGCVT
C          INTEGER FCT.  NUMB
C          SUBROUTINE    OPCODE
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    TWOARG
C          SUBROUTINE    ALARM
C
      SUBROUTINE LCANON(ACTNO,BIGCNT)
C
      IMPLICIT INTEGER (A-Z)
C
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),COMMA(2),TEMP(2),VBL(2),BIGGEO(2)
C COMMA:       (1)=CODE CLASS  1000,(2)=NAMTBL INDEX OF ',     '
      EQUIVALENCE (COMMA(1),CODE(1))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C BIGGEO:      (1)=CODE CLASS 44000,(2)=NAMTBL INDEX OF 'BIGGEO'
      EQUIVALENCE (BIGGEO(1),CODE(87))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(502),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C        8.    NAME TABLE POINTERS TO BCD LITERALS
C
      COMMON/BCDPTR/BCDPTR
      DIMENSION BCDPTR(7)
C DOTTAB:      NAMTBL POINTER TO ALPHAMERIC LITERAL '$$TAB'
      EQUIVALENCE (DOTTAB,BCDPTR(7))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12)
C ONE:         NAMTBL POINTER TO '1     '
      EQUIVALENCE (ONE,NUMPTR(3))
C FOUR:        NAMTBL POINTER TO '4     '
      EQUIVALENCE (FOUR,NUMPTR(7))
C
C       12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE
      DIMENSION CFSIZE(205),MAXSIZ(2),CANSIZ(2,100)
C CANTOP:      POINTER TO THE LAST CANSIZ ENTRY
      EQUIVALENCE (CANTOP,CFSIZE(1))
C MAXSIZ:      SIZE OF THE LAST LARGEST LARGE DATA ARRAY
      EQUIVALENCE (MAXSIZ(1),CFSIZE(4))
C CANSIZ:      NUMBER OF ITEMS A. NAMTBL INDEX OF EACH LARGE DATA ARRAY
      EQUIVALENCE (CANSIZ(1,1),CFSIZE(6))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C MOVE:        CONTAINS COMMAND CODE (19) FOR MOVE COMMAND
      EQUIVALENCE (MOVE,IL(19))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C REAL:        MODE CODE (24) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C SUBSCR:      MODE CODE (24) FOR SUBSCRIPT
      EQUIVALENCE (SUBSCR,MODX(24))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL FINMAC
      DIMENSION MACXX1(71)
C FINMAC:      TRUE DURING FINAL MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C DLR:         CONTAINS OPERAND TYPE CODE 1
      EQUIVALENCE (DLR,OPMOD(2))
C QUIDLR:      CONTAINS OPERAND TYPE CODE 5
      EQUIVALENCE (QUIDLR,OPMOD(6))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136),APTXXX(120)
C APTXXX:      NAMTBL POINTERS FOR XECUTION SUBROUTINE NAMES
      EQUIVALENCE (APTXXX(1),SUBLST(1))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       42.    COMMON BLOCK FOR CANON AND OBTAIN ARGUMENT STORAGE
C
      COMMON/CANSTR/CANSTR
      DIMENSION CANSTR(18),CANSTK(16)
C CANPTR:      POINTER TO LAST CANSTK ENTRY
      EQUIVALENCE (CANPTR,CANSTR(1))
C CANSTK:      ARGUMENT STACK FOR CANON AND OBTAIN STATEMENTS
      EQUIVALENCE (CANSTK(1),CANSTR(3))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ESTACK,ERGSTK
      DIMENSION ERRPOS(302),ESTACK(100),ERGSTK(100)
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C ERGSTK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN ARGSTK
      EQUIVALENCE (ERGSTK(1),ERRPOS(203))
C*
C PURPOSE      TO GENERATE I.L. FOR LARGE DATA ARRAY CANON DEFINITIONS
C
C ARGUMENTS    ACTNO   BASIC PRODUCTION ACTION NUMBER
C              BIGCNT  NUMBER OF CALLS TO LCANON FOR THIS DEFINITION
C
      CHARACTER IBUFF*15,IHBLK*4
      DATA IHBLK/'    '/
C**
C...       IF FIRST CALL, INITIALIZE
C
      IF(BIGCNT.NE.1)GO TO 100
      ICODE=1
      IBR=1
C
  100 IF(ACTNO.GE.103)GO TO 500
C
C...       PICK UP ARG.  GENERATE I.L. FOR THREE ARGUMENTS AT A TIME.
C
      CANPTR=CANPTR+1
      CANSTK(CANPTR)=STACK(1,TOP-1)
      ERGSTK(101-CANPTR)=ESTACK(TOP-1)
      STACK(1,TOP-2)=STACK(1,TOP)
      STACK(2,TOP-2)=STACK(2,TOP)
      TOP=TOP-2
      IF(CANPTR.NE.3)GO TO 900
C
  200 DO 230 I=1,CANPTR
      N=CANSTK(I)
      IF(N.GT.NAMMAX)GO TO 210
      IF(NAMTBL(N)/MODULO.NE.TEMP(1)/MODULO)GO TO 210
      M=NAMTBL(N)-TEMP(1)
      IF(M.GE.MODHLF)M=SUBSCR
      CALL PUTTMP(M)
  210 IF(ICODE.EQ.4)GO TO 230
      IF(MODE(N).NE.REAL)GO TO 1010
  220 CONTINUE
  230 CONTINUE
C
      IF(ICODE.EQ.4)GO TO 250
      CALL OPCODE(MOVE)
      CALL TWOARG(-BIGCNT+1,DOTTAB)
      DO 240 I=1,CANPTR
      N=CANSTK(I)
  240 CALL ARGCVT(N)
      CALL RLSLIN
  250 IF(IBR.EQ.2)GO TO 510
      CANPTR=0
      GO TO 900
C
C...       PROCESS END OF DEFINITION.
C          FIRST CHECK FOR ARGUMENTS LEFT IN CANSTK.
C
  500 IF(CANPTR.EQ.0 .OR. ICODE.EQ.4)GO TO 520
      IBR=2
      BIGCNT=BIGCNT-CANPTR+2
      GO TO 200
  510 BIGCNT=BIGCNT+CANPTR-2
      CANPTR=0
C
  520 N=STACK(1,TOP-3)
      M=NAMTBL(N)-BIGGEO(1)
      IF(M.GT.MODHLF)M=M-MODHLF
      IF(ACTNO.NE.105)GO TO 530
C
      N5=GETTMP(M)
      K5=TEMP(1)
      GO TO 550
C
  530 N5=STACK(1,TOP-5)
      K5=(NAMTBL(N5)/MODULO)*MODULO
      IF(K5.NE.VBL(1) .AND. K5.NE.TEMP(1))GO TO 540
      M5=NAMTBL(N5)-K5
      IF(M5.GE.MODHLF)M5=M5-MODHLF
      IF(M5.EQ.M)GO TO 550
      IBR=3
      GO TO 1020
  540 NAMTBL(N5)=VBL(1)+M
      CALL RESRVZ(N5,M,TXXXX(1,M),1)
C
C...       UPDATE MAXSIZ IF NECESSARY.  ADD SIZE AND NAME TO CANSIZ.
C
  550 IF(BIGCNT.LE.(IABS(MAXSIZ(2))))GO TO 560
      IF(BIGCNT.LE.(IABS(MAXSIZ(1))))GO TO 555
      MAXSIZ(2)=MAXSIZ(1)
      MAXSIZ(1)=BIGCNT
      GO TO 560
  555 MAXSIZ(2)=BIGCNT
  560 J=MOD(N5,CANTOP)
      DO 570 I=1,CANTOP
      J=MOD(J,CANTOP)+1
      IF(CANSIZ(1,J).NE.0 .AND. CANSIZ(2,J).NE.N5)GO TO 570
      CANSIZ(1,J)=BIGCNT
      CANSIZ(2,J)=N5
      GO TO 600
  570 CONTINUE
      IBR=4
      GO TO 1030
C
C...       GENERATE I.L. TO STORE SIZE IN INTERNAL CANONICAL FORM.
C
  600 IBUFF(12:15)=IHBLK
      CALL BINBCD(BIGCNT,IBUFF(4:),I)
      WRITE(IBUFF(1:3),'(I3)') I
      CALL CONCAT(IBUFF,'.')
      INUMB=NUMB(IBUFF(4:15)) + NAMMAX
      CALL OPCODE(MOVE)
      CALL TWOARG(-2,N5)
      CALL ARGCVT(INUMB)
      CALL RLSLIN
C
C...       GENERATE CALL TO APT094
C
  610 CALL CALLZZ(APTXXX(68))
      IF (ICODE.EQ.1) THEN
        CALL TWOARG(DLR,ONE)
      ELSE
        CALL TWOARG(DLR,FOUR)
      ENDIF
      CALL ARGCVT(N5)
      CALL TWOARG(0,DOTTAB)
      CALL RLSLIN
      IF(ACTNO-104)900,640,620
C
  620 TOP=TOP-4
      GO TO 660
  640 TOP=TOP-6
  660 STACK(1,TOP)=N5
      J=NAMTBL(N5)/MODULO
      STACK(2,TOP)=META(J)
      K=NAMTBL(N5)/MODULO
      STACK(2,TOP)=META(K)
C
  900 RETURN
C
C...       DIAGNOSTIC PROCESSING
C
 1010 IERROR=1032
      ERRPT=I-101
      IF(.NOT.FINMAC)GOTO 1090
      N=TOP
      J=STACK(1,TOP)
      STACK(1,TOP)=COMMA(2)
      DO 1015 K=1,I
      STACK(1,TOP+1)=CANSTK(K)
      STACK(1,TOP+2)=COMMA(2)
 1015 TOP=TOP+2
      CALL ALARM(IERROR,TOP-1,8,'LCANON  ')
      TOP=N
      STACK(1,TOP)=J
      GOTO 1100
 1020 IERROR=1001
      GO TO 1080
 1030 IERROR=53
 1080 ERRPT=TOP-5
 1090 CALL ALARM(IERROR,ERRPT,8,'LCANON  ')
 1100 ICODE=4
      GO TO(220,220,550,610),IBR
      END
**** SOURCE FILE : M0006648.V03   ***
*
C
C              FORTRAN SUBROUTINE LOOP
C
C LINKAGE      SUBROUTINE  LOOP
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    INPUT
C          SUBROUTINE    ARGCVT          SUBROUTINE    RECOG
C          SUBROUTINE    MACLBL          SUBROUTINE    PRO026
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          INTEGER FCT.  GETTMP
C          INTEGER FCT.  MODE
C          SUBROUTINE    REPLAC
C          SUBROUTINE    RLSLIN
C          SUBROUTINE    LABELZ
C          SUBROUTINE    SETCHR
C
      SUBROUTINE  LOOP
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C NAMTBL:      NAME TABLE OR DICTIONARY
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),COMMA(2),NUMBER(2),TEMP(2),LABEL(2),IMPLAB(2)
     *         ,VBL(2),IDENT(2)
C COMMA:       (1)=CODE CLASS  1000,(2)=NAMTBL INDEX OF ',     '
      EQUIVALENCE (COMMA(1),CODE(1))
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C IMPLAB:      (1)=CODE CLASS 23000,(2)=NAMTBL INDEX OF 'IMPLAB'
      EQUIVALENCE (IMPLAB(1),CODE(45))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(501),META(50)
C META:        END OF CHARACTER CONCATENATION AND STRING PRODUCTION
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12)
C ONEPT:       NAMTBL POINTER TO '1.    '
      EQUIVALENCE (ONEPT,NUMPTR(4))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C FADD:        CONTAINS COMMAND CODE ( 1) FOR FADD COMMAND
      EQUIVALENCE (FADD,IL(1))
C FSUB:        CONTAINS COMMAND CODE ( 2) FOR FSUB COMMAND
      EQUIVALENCE (FSUB,IL(2))
C FMPY:        CONTAINS COMMAND CODE ( 3) FOR FMPY COMMAND
      EQUIVALENCE (FMPY,IL(3))
C CONJMP:      CONTAINS COMMAND CODE (11) FOR CONJMP COMMAND
      EQUIVALENCE (CONJMP,IL(11))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C REAL:        MODE CODE (21) FOR REAL
      EQUIVALENCE (REAL,MODX(21))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      DIMENSION MACXX1(71)
      LOGICAL FINMAC
C FINMAC:      TRUE DURING FINAL MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C WHCHMN:      EQUAL TO NUMBER OF CURRENT MACRO BEING PROCESSED
      EQUIVALENCE (WHCHMN,MACXX1(63))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C
C       40.    PARAMETERS REQUIRED BY SUPERVISOR
C
      COMMON/SUPER/SUPER
      LOGICAL FINI
      DIMENSION SUPER(36)
C FINI:        FLAG ON INDICATES A FINI CARD HAS BEEN READ
      EQUIVALENCE (FINI,SUPER(7))
C
C       43.    DO LOOP CONTROL VALUES
C
      COMMON/DOLOOP/DOLOOP
      LOGICAL DOFLAG
      DIMENSION DOLOOP(8)
C ABSDO:       LOOP NUMBER FOR LABEL CREATION
      EQUIVALENCE (ABSDO,DOLOOP(2))
C RELDO:       CURRENTLY NESTED DO LOOPS
      EQUIVALENCE (RELDO,DOLOOP(3))
C DONEST:      CURRENTLY NESTED DO LOOPS
      EQUIVALENCE (DONEST,DOLOOP(4))
C DOMAX:       MAXIMAL NESTING OF LOOPS
      EQUIVALENCE (DOMAX,DOLOOP(5))
C DOJUMP:      VBL FOR COMPUTED GOTO AT LOOP PROCESSING
      EQUIVALENCE (DOJUMP,DOLOOP(6))
C DOFLAG:      FLAG IS ON DURING OPENED LOOP
      EQUIVALENCE (DOFLAG,DOLOOP(7))
C*
C PURPOSE      DISSECTS AND PROCESSES FORTRAN-LIKE PROGRAMMED DO-LOOPS
C              FOR I.L.-OUTPUT BY SETTING THE START-VALUE, ADDING WITH
C              RETURN-POINTER AND IF-SCANNING ON LOOP-END-VALUE WITH
C              RETURN OR BRANCHING OUT OF THE LOOP RESPECTIVELY.
C
C
C INPUT                                DO / LABEL, I1 = I2, I3, I4
C                              LABEL ) CONTIN
C                        OR    LABEL ) APT - STATEMENT
C
C              DOJUMP         1        DO STATEMENT PROGRAMMED
C                             2     LABEL STATEMENT PROGRAMMED
C                             3     PRODUCTION OF THE LOOP-END
C                             4     TERMAC STATEMENT
C                             5     FINI   STATEMENT
C              LABSAV(J,K)          NAMTBL ADDRESS
C                     J       1     I1
C                             2     I2
C                             3     I3
C                             4     I4
C                             5     PROGRAMMED LABEL
C                             6     PRODUCED LABEL
C                             7     VALUE FOR PRODUCING LABEL
C
C
      DIMENSION LABSAV(7,10),ISTCK(5)
      DATA ISTCK/7,5,3,1,9/
C**
      GOTO(5,170,100,250,300),DOJUMP
      GOTO 999
C
C     START OF DO-LOOP; INPUT STATEMENT DO / LAB , I1 = I2 , I3 (, I4)
C
C     ERROR-CONTROL
C
    5 IF(ARGTOP.GT.0)GOTO 835
      IF(TOP.EQ.DOMAX)GOTO 10
      TOP=DOMAX
      STACK(1,TOP)=STACK(1,TOP-2)
      STACK(2,TOP)=STACK(2,TOP-2)
      CALL SETCHR(TOP-2,COMMA)
      STACK(1,TOP-1)=ONEPT
      L=NUMBER(1)/MODULO
      STACK(2,TOP-1)=META(L)
C
C     PROVIDING AN ADDRESS ON TEMPORARY INPUT
C
   10 LL=TOP
      ABSDO=ABSDO+1
      DO 29 J=2,4
      M=LL-ISTCK(J)
      IF (STACK(1,M).GT.NAMMAX) GOTO 29
      KK=MODULO*(NAMTBL(STACK(1,M))/MODULO)
      IF(KK.NE.TEMP(1))GOTO 29
      K=STACK(1,M)
      KK=20000+998*ABSDO-J
      L=WHCHMN
      IF(L.EQ.0)L=51
      CALL MACLBL(KK,-L,K)
      NAMTBL(K)=IDENT(1)
      KK=STACK(1,M-2)
      MM=STACK(2,M-2)
      TOP=M+1
      STACK(1,M-2)=K
      CALL REPLAC
      STACK(1,M)=STACK(1,M-2)
      STACK(2,M)=META(NAMTBL(STACK(1,M))/MODULO)
      STACK(1,M-2)=KK
      STACK(2,M-2)=MM
   29 CONTINUE
      TOP=LL
C
C     STORING THE DO-VALUES IN LABSAV; CONTROL ON MULTIPLY DEFINED
C     VARIABLES IN INTERLEAVINGS.
C
      RELDO=RELDO+1
      IF(RELDO.GT.DONEST)GOTO 820
      DO 20 K=1,5
   20 LABSAV(K,RELDO)=STACK(1,(TOP-ISTCK(K)))
C
      IF(RELDO.LE.1)GOTO 23
      KK=RELDO-1
      DO 22 K=1,KK
      IF(LABSAV(1,K).EQ.LABSAV(1,RELDO))GOTO 830
   22 CONTINUE
C
C     WORKING UP OF I1=I2-I4
C
   23 DO 25 K=2,4
   25 IF(MODE(LABSAV(K,RELDO)).NE.REAL) CALL ALARM(1008,TOP-9+2*K,8,
     /'LOOP    ')
      RSLT=GETTMP(REAL)
      CALL OPCODE(FSUB)
      CALL ARGCVT(RSLT)
      CALL ARGCVT(LABSAV(2,RELDO))
      CALL ARGCVT(LABSAV(4,RELDO))
      CALL RLSLIN
      STACK(1,TOP-3)=LABSAV(1,RELDO)
      STACK(1,TOP-1)=RSLT
      CALL REPLAC
C
C     WORKING UP OF LABEL)
C
      KK=20000+998*ABSDO
      LABSAV(7,RELDO)=KK+1
      L=WHCHMN
      IF(L.EQ.0)L=51
      CALL MACLBL(KK,-L,K)
      LABSAV(6,RELDO)=K
      IF((.NOT.FINMAC).AND.(WHCHMN.NE.0))GOTO 40
      NAMTBL(K)=LABEL(1)+WHCHMN
   30 CALL LABELZ(K)
      GOTO 50
   40 NAMTBL(K)=IMPLAB(1)+WHCHMN
      GOTO 30
C
C     WORKING UP OF I1 = I1 + I4
C
   50 CALL OPCODE(FADD)
      CALL ARGCVT(LABSAV(1,RELDO))
      CALL ARGCVT(LABSAV(1,RELDO))
      CALL ARGCVT(LABSAV(4,RELDO))
      CALL RLSLIN
      GOTO 999
C
C     END OF A DO-LOOPS;  INPUT: LABEL)CONTIN  RESP. STATEMENT
C
  100 IF(.NOT.DOFLAG)GOTO 999
      DOFLAG=.FALSE.
C
C     WORKING UP OF TEMP = I3+I1
C
      RSLT=GETTMP(REAL)
      DO 160 J=1,III
      CALL OPCODE(FSUB)
      CALL ARGCVT(RSLT)
      CALL ARGCVT(LABSAV(3,RELDO))
      CALL ARGCVT(LABSAV(1,RELDO))
      CALL RLSLIN
C
C     WORKING UP OF TEMP = TEMP -I4
C
      CALL OPCODE(FSUB)
      CALL ARGCVT(RSLT)
      CALL ARGCVT(RSLT)
      CALL ARGCVT(LABSAV(4,RELDO))
      CALL RLSLIN
C
C     WORKING UP OF TEMP = I4 * TEMP
C
      CALL OPCODE(FMPY)
      CALL ARGCVT(RSLT)
      CALL ARGCVT(LABSAV(4,RELDO))
      CALL ARGCVT(RSLT)
      CALL RLSLIN
C
C     WORKING UP OF IF(TEMP) LAB1,LAB2,LAB2
C
      CALL OPCODE(CONJMP)
      CALL ARGCVT(RSLT)
      KK=LABSAV(7,RELDO)
      L=WHCHMN
      IF(L.EQ.0)L=51
      CALL MACLBL(KK,-L,K)
      IF((.NOT.FINMAC).AND.(WHCHMN.NE.0))GOTO 140
      NAMTBL(K)=LABEL(1)+WHCHMN
      GOTO 150
C
C     WORKING UP OF IF-LABELS
C
  140 NAMTBL(K)=IMPLAB(1)+WHCHMN
  150 CALL ONEARG(K)
      CALL ONEARG(LABSAV(6,RELDO))
      CALL ONEARG(LABSAV(6,RELDO))
      CALL RLSLIN
      CALL LABELZ(K)
  160 RELDO=RELDO-1
      GOTO 999
C
C     CHECK IF LABEL BELONGS TO A DO-LOOP
C
  170 IF(RELDO.LE.0) GOTO 999
  171 III=0
      DO 172 L=1,RELDO
      K=RELDO+1-L
      IF(LABSAV(5,K).EQ.STACK(1,TOP-1))III=III+1
  172 CONTINUE
      IF(III.EQ.0)GOTO 999
      DO 175 L=1,III
      K=RELDO+1-L
      IF(LABSAV(5,K).NE.STACK(1,TOP-1))GOTO 805
  175 CONTINUE
  177 DOFLAG=.TRUE.
      GOTO 999
C
C     MACRO HAS BEEN COMPLETED
C
  250 IF(.NOT.FINI)GOTO 999
      ABSDO=0
      GOTO 310
C
C     FINI HAS BEEN READ IN
  300 ABSDO=0
  310 IF(RELDO.GT.0)GOTO 810
C
  999 RETURN
C
C     ERROR-MESSAGES
C
C     ERROR 1037   ON FINI OR TERMAC OPEN LOOP
  810 CALL ALARM(1037,0,8,'LOOP    ')
      RELDO=0
      GOTO 999
C     ERROR 1038   TOO MANY DO'S NESTED (MORE THAN 10)
  820 CALL ALARM(1038,2,8,'LOOP    ')
  825 RELDO=RELDO-1
      GOTO 999
C     ERROR 1039   WRONGLY NESTED DO
  805 CALL ALARM(1039,TOP-1,8,'LOOP    ')
      GOTO 177
C     ERROR 1040   DO-VARIABLE IDENTICAL
  830 CALL ALARM(1040,TOP-7,8,'LOOP    ')
      GOTO 825
C     ERROR 1036   DO-ARGUMENT WITHOUT VALUE-ASSIGNEMENT
  835 IF(TOP.EQ.DOMAX)GOTO 840
      CALL ALARM(1036,-ARGTOP,8,'LOOP    ')
      GOTO 999
C     ERROR 2052   TOO MANY DO-ARGUMENTS
  840 CALL ALARM(2052,-ARGTOP,8,'LOOP    ')
      GOTO 10
C
      END
**** SOURCE FILE : M0006650.V04   ***
*
C
C              FORTRAN SUBROUTINE  MACLBL
C
C LINKAGE      SUBROUTINE  MACLBL(LABEL1,LABEL2,LABEL3)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    SHIFT           SUBROUTINE    BOOLIF
C          INTEGER FCT.  NAME            SUBROUTINE    COMSTR
C          SUBROUTINE    HELP            SUBROUTINE    INPUT
C          SUBROUTINE    ALARM           SUBROUTINE    LOOP
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    MATCH
C                                        SUBROUTINE    MNPROC
C                                        SUBROUTINE    MOTION
C                                        SUBROUTINE    PATH
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C
      SUBROUTINE MACLBL(LABEL1, LABEL2, LABEL3)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C*
C PURPOSE      TO CONSTRUCT A UNIQUE LABEL NAME CORRESPONDING
C              TO AN ORDERED PAIR OF NUMBERS.
C ARGUMENTS    LABEL1    IS THE FIRST NUMBER OF THE PAIR
C              LABEL2    IS THE SECOND NUMBER OF THE PAIR
C              LABEL3    WILL CONTAIN THE NAME TABLE (NAMTBL)
C                        INDEX OF THE GENERATED LABEL.
C...  COUNT IS THE TOTAL NUMBER OF GENERATED LABELS.
C...  TABL IS AN ARRAY CONTAINING EACH UNIQUE PAIR OF ARGUMENTS
C...    RECEIVED AND THE CORRESPONDING NAMTBL INDEX FOR THE
C...    GENERATED LABEL.
C**
      DIMENSION TABL(3,600)
C...
      CHARACTER BLK,CHARAC(12),FIND*8
      DATA BLK/' '/
      DATA CHARAC/ '0','1','2','3','4','5','6','7','8','9','Z','$'/
      DATA COUNT /0/
      DATA TABL/1800*0/
C...      INITIALIZE FIND WITH BLANKS
      FIND=BLK
C...      IF ARGUMENT PAIR ISIIN TABLE THEN BRANCH - RETURN NAMTBL INDEX
      DO 100 I=1,COUNT
      IF (TABL(1,I).NE.LABEL1) GO TO 100
      IF (TABL(2,I).EQ.LABEL2) GO TO 200
  100 CONTINUE
C...      OTHERWISE PUT ARGUMENTS IN TABLE- GENERATE LABEL
      COUNT=COUNT+1
      IF(COUNT.LE.600) GOTO 105
C TABL LENGTH EXCEEDED.  TERMINATE PROGRAM
      CALL ALARM(15,0,8,'MACLBL  ')
      CALL  HELP
  105 TABL(1,COUNT)=LABEL1
      TABL(2,COUNT)=LABEL2
C...      SHIFT Z$ INTO 1ST TWO POSITIONS OF LABEL BEING GENERATED
      DO 110 I=1,2
      CALL SHIFT(FIND,CHARAC(I+10))
  110 CONTINUE
C...      SHIFT CHARACTER EQUIVALENT OF TABLE INDEX INTO LABEL
      INTGER=COUNT
      DECR=1000
      DO 120 I=1,4
      SYMBOL=INTGER/DECR
      CALL SHIFT(FIND,CHARAC(SYMBOL+1))
      INTGER=INTGER-DECR*SYMBOL
      DECR=DECR/10
  120 CONTINUE
C...      PUT NAMTBL INDEX CORRESPONDING TO GENERATED LABEL IN TABLE
      TABL(3,COUNT)=NAME(FIND)
      I=COUNT
C...      ASSIGN NAMTBL INDEX OF GENERATED LABEL TO RETURN PARAMETER
  200 LABEL3=TABL(3,I)
      RETURN
      END
**** SOURCE FILE : M0006651.W03   ***
*
C
C              FORTRAN SUBROUTINE MACREC
C
C LINKAGE      SUBROUTINE MACREC(IPROD)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    HELP            SUBROUTINE    RECOG
C          SUBROUTINE    ALARM
C          INTEGER FCT.  BCDF
C          SUBROUTINE    BINBCD
C          LOGICAL FCT.  IFTMP
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    LABELZ
C          SUBROUTINE    MACLBL
C          SUBROUTINE    CALMCX
C          SUBROUTINE    MACTAB
C          SUBROUTINE    COMSTR
C          SUBROUTINE    MCXTRN
C          SUBROUTINE    MNPROC
C          INTEGER FCT.  NAME
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    ASNADZ
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          SUBROUTINE    EPILOG
C
      SUBROUTINE MACREC(IPROD)
C
      IMPLICIT INTEGER (A-Z)
C
C              FUNCTION DECLARATION
C
      LOGICAL IFTMP
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C NUMBST:      NAMTBL INDEX OF BEGINNING OF NUMBER SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),RTERM(2),GEOM(2),TEMP(2),FCN(2),PROCED(2),
     *          PERMID(2),LABEL(2),IMPLAB(2),VBL(2),MACNAM(2),IDENT(2),
     *          MACVBL(2),CONGEO(2),CONPRO(2),DIGIT(2)
C RTERM:       (1)=CODE CLASS  4000,(2)=NAMTBL INDEX OF 'RTERM '
      EQUIVALENCE (RTERM(1),CODE(7))
C DIGIT:       (1)=CODE CLASS 10000,(2)=NAMTBL INDEX OF 'DIGIT '
      EQUIVALENCE (DIGIT(1),CODE(19))
C GEOM:        (1)=CODE CLASS 16000,(2)=NAMTBL INDEX OF 'GEOM  '
      EQUIVALENCE (GEOM(1),CODE(31))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C FCN:         (1)=CODE CLASS 18000,(2)=NAMTBL INDEX OF 'FCN   '
      EQUIVALENCE (FCN(1),CODE(35))
C PROCED:      (1)=CODE CLASS 19000,(2)=NAMTBL INDEX OF 'PROCED'
      EQUIVALENCE (PROCED(1),CODE(37))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C IMPLAB:      (1)=CODE CLASS 23000,(2)=NAMTBL INDEX OF 'IMPLAB'
      EQUIVALENCE (IMPLAB(1),CODE(45))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C MACNAM:      (1)=CODE CLASS 34000,(2)=NAMTBL INDEX OF 'MACNAM'
      EQUIVALENCE (MACNAM(1),CODE(67))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C MACVBL:      (1)=CODE CLASS 36000,(2)=NAMTBL INDEX OF 'MACVBL'
      EQUIVALENCE (MACVBL(1),CODE(71))
C CONGEO:      (1)=CODE CLASS 39000,(2)=NAMTBL INDEX OF 'CONGEO'
      EQUIVALENCE (CONGEO(1),CODE(77))
C CONPRO:      (1)=CODE CLASS 40000,(2)=NAMTBL INDEX OF 'CONPRO'
      EQUIVALENCE (CONPRO(1),CODE(79))
C
C        5.    PROGRAM CONTROL FLAGS
C
      COMMON/FLAGS/FLAGS
      LOGICAL NEWSTM
      DIMENSION FLAGS(4)
C NEWSTM:      TRUE WHEN NEXT SOURCE STATEMENT REQUESTED FOR PROCESS
      EQUIVALENCE (NEWSTM,FLAGS(2))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C       11.    SEQUENCE NUMBER STORAGE
C
      COMMON/SEQCOM/SEQCOM
      DIMENSION SEQCOM(3),SEQNUM(2)
C SEQNO:       INTERNALLY GENERATED STATEMENT NUMBER
      EQUIVALENCE (SEQNO,SEQCOM(1))
C SEQNUM:      ALPHANUMERIC REPRESENTATION OF CURRENT STATEMENT NUMBER
      EQUIVALENCE (SEQNUM(1),SEQCOM(2))
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL MCHDNG
      DIMENSION PRT(7)
C MCHDNG:      TRUE IF START OF NEW MACRO PROCESSING
      EQUIVALENCE (MCHDNG,PRT(7))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C REPL:        CONTAINS COMMAND CODE (17) FOR REPL COMMAND
      EQUIVALENCE (REPL,IL(17))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C SUBSCR:      MODE CODE (24) FOR SUBSCRIPT
      EQUIVALENCE (SUBSCR,MODX(24))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL MACLDD,CALLON,CALLMV,ILHLT,MVMAC,MACRED,MVTRUE,FINMAC,
     *          MACEND
      DIMENSION MACXX1(71)
C MACDFP:      POINTER TO LAST ENTRY IN MACDF1 AND MACDF2 ARRAYS
      EQUIVALENCE (MACDFP,MACXX1(1))
C MCNMB:       NUMBER OF DEFINED MACROS
      EQUIVALENCE (MCNMB,MACXX1(2))
C MCHSTP:      POINTER TO LAST MACHST ENTRY
      EQUIVALENCE (MCHSTP,MACXX1(3))
C MCTXTP:      POINTER TO LAST MACTXT TABLE ENTRY
      EQUIVALENCE (MCTXTP,MACXX1(4))
C MCSAVP:      PRESENT NEST LEVEL DURING MACRO PROCESSING
      EQUIVALENCE (MCSAVP,MACXX1(5))
C MNMVBP:      POINTER TO LAST MNMVB AND MNMVC TABLE ENTRY
      EQUIVALENCE (MNMVBP,MACXX1(6))
C MACLDD:      TRUE WHEN MACRO TEXT IS TO BE LOAD INTO MCBUFF TABLE
      EQUIVALENCE (MACLDD,MACXX1(7))
C TEMP1:       MACRO TEMPORARY STORAGE
      EQUIVALENCE (TEMP1,MACXX1(8))
C CALLON:      TRUE AT A NESTED CALL DURING INTERMED. MACRO PROCESSING
      EQUIVALENCE (CALLON,MACXX1(10))
C CALLMV:      TRUE IF A CALL/MACRO VARIABLE STATEMENT IS ENCOUNTERED
      EQUIVALENCE (CALLMV,MACXX1(11))
C MVSEG:       CONTAINS POSITION NUMBER OF MACRO VBL IF CALLMV IS TRUE
      EQUIVALENCE (MVSEG,MACXX1(12))
C CALLPT:      MACTXT INDEX OF CURRENT CALL STATEMENT
      EQUIVALENCE (CALLPT,MACXX1(13))
C ILHLT:       TRUE IF I.L. SHOULD NOT BE PLACED IN ILFILE
      EQUIVALENCE (ILHLT,MACXX1(14))
C TEXTST:      POINTER TO MCBUFF OF MACRO TEXT WORD BEING PROCESSED
      EQUIVALENCE (TEXTST,MACXX1(15))
C MVPNT:       CONTAINS POINTER-1 OF FIRST MACRO VARIABLE VBLSAV
      EQUIVALENCE (MVPNT,MACXX1(16))
C MVMAC:       TRUE IF IN NESTED CALL LIST MACROVBL = MACRO VBL
      EQUIVALENCE (MVMAC,MACXX1(17))
C MACRED:      SET TRUE TO INDICATE INPUT FROM MCBUFF TABLE
      EQUIVALENCE (MACRED,MACXX1(18))
C MVTRUE:      TRUE IF SOME ASSIGNED VALUE IS A MACRO NAME
      EQUIVALENCE (MVTRUE,MACXX1(19))
C BRANCH:      SET 2 IF MACRO IS TO UNDERGO INTERMEDIATE PROCESSING.
      EQUIVALENCE (BRANCH,MACXX1(20))
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C FINMAC:      TRUE IF SECOND FINAL PASS OF MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C MCDFDM:      DIMENSION OF ARRAYS MACDF1,MACDF2 AND MACTBL
      EQUIVALENCE (MCDFDM,MACXX1(32))
C MHSTDM:      CONTAINS DIMENSION OF ARRAY MACHST
      EQUIVALENCE (MHSTDM,MACXX1(33))
C MCSVDM:      DIMENSION OF ARRAYS MACSV1,MACSV2 AND MACSV3
      EQUIVALENCE (MCSVDM,MACXX1(34))
C MNMVDM:      CONTAINS DIMENSION OF MNMVB AND MNMVC
      EQUIVALENCE (MNMVDM,MACXX1(35))
C MSEQDM:      CONTAINS DIMENSION OF THE ARRAY MACSEQ
      EQUIVALENCE (MSEQDM,MACXX1(36))
C MCSRCH:      AT FINAL MACRO PRECESSING MACDF1 POINTER
      EQUIVALENCE (MCSRCH,MACXX1(59))
C NUMARG:      NUMBER OF MACRO VARIABLES+1 FOR CURRENT MACRO
      EQUIVALENCE (NUMARG,MACXX1(61))
C MACEND:      TRUE WHEN ALL MACRO PROCESSING IS FINISHED
      EQUIVALENCE (MACEND,MACXX1(62))
C WHCHMN:      EQUAL TO NUMBER OF CURRENT MACRO BEING PROCESSED
      EQUIVALENCE (WHCHMN,MACXX1(63))
C VBLSVP:      POINTER TO LAST VBLSAV ENTRY
      EQUIVALENCE (VBLSVP,MACXX1(66))
C IVSVDM:      DIMENSION OF ARRAY VBLSAV
      EQUIVALENCE (IVSVDM,MACXX1(67))
C PATHLN:      CURRENT ACTUAL BRANCHING EXPRESSION. INITIALLY=NUMARG
      EQUIVALENCE (PATHLN,MACXX1(68))
C NXTLN:       POINTER TO NEXT LINUSD POSITION TO BE EXAMINED
      EQUIVALENCE (NXTLN,MACXX1(69))
C PATHCH:      CURRENT ACTUAL BRANCHING EXPRESSION. INITIALLY=NUMARG
      EQUIVALENCE (PATHCH,MACXX1(71))
C
C       24.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX3/MACXX3
      DIMENSION MACXX3(2630),MACDF1(400),MACDF2(400),MACHST(1800),MACSV1
     *         (10),MACSV3(10),MACSV2(10)
C MACDF1:      STORES MACRO NAME AND ALL MACRO VBL NAMTBL POINTERS
      EQUIVALENCE (MACDF1(1),MACXX3(1))
C MACDF2:      STORES NORMAL VALUES FOR ALL MACRO VARIABLES
      EQUIVALENCE (MACDF2(1),MACXX3(401))
C MACHST:      MACRO CALL HISTORY TABLE
      EQUIVALENCE (MACHST(1),MACXX3(801))
C MACSV1:      CONTAINS MACRO NEST LEVEL INFORMATIONS
      EQUIVALENCE (MACSV1(1),MACXX3(2601))
C MACSV2:      CONTAINS MACRO NEST LEVEL INFORMATIONS
      EQUIVALENCE (MACSV2(1),MACXX3(2611))
C MACSV3:      CONTAINS MACRO NEST LEVEL INFORMATIONS
      EQUIVALENCE (MACSV3(1),MACXX3(2621))
C
C       25.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX4/MACXX4
      DIMENSION MACXX4(100),MNMVB(25),MNMVC(25),MACSEQ(50)
C MNMVB:       INDICATES MACROS IN WHICH ARE ASSIGNED VALUES
      EQUIVALENCE (MNMVB(1),MACXX4(1))
C MNMVC:       CALLED MACRO FOR WHICH CORRESPONDING MNMVB ENTRY IS MADE
      EQUIVALENCE (MNMVC(1),MACXX4(26))
C MACSEQ:      PRESERVES INITIAL SEQUENCE NUMBERS OF THE MACROS
      EQUIVALENCE (MACSEQ(1),MACXX4(51))
C
C       26.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX6/MACXX6
      DIMENSION MACXX6(1300),MACTBL(400),VBLSAV(900)
C MACTBL:      NAMTBL POINTERS OF THE ASSIGNED VALUES FOR MACRO CALL
      EQUIVALENCE (MACTBL(1),MACXX6(1))
C VBLSAV:      SAVES MACRO VBL ASSIGNED VALUES DURING INTERMED. PROCESS
      EQUIVALENCE (VBLSAV(1),MACXX6(401))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       36.    SYSTEM MACRO AND SEGMENT READ VARIABLES
C
      COMMON/MACSEG/MACSEG
      DIMENSION MACSEG(6)
C ITMPCT:      NUMBER OF INTERNAL SYMBOLS GENERATED IN TRANSLATION
      EQUIVALENCE (ITMPCT,MACSEG(5))
C
C       38.    COMMON BLOCK MACRO CALL STATEMENT
C              INDICATES A MACRO CALL BEING PROCESSED
      COMMON/CALFLG/ICALLF
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ESTACK
      DIMENSION ERRPOS(302),ESTACK(100)
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C
C       45.    NUMBER TABLE INDICES
C
      INCLUDE (NUMBLK)    
C MNMBND:      LAST NAME TABLE ENTRY TO MACRO ASSIGNED NUMBER SECTION
C NUMIDX:      NAMTBL INDEX OF A NUMBER GIVEN IN THE CURRENT STATEMENT
C MASGND:      NAMTBL INDEX OF SECTION END FOR NUMBERS ASSIGNED TO MACRO
C*
C PURPOSE    EXECUTIVE ROUTINE FOR ALL PRODUCTIONS RELATED TO
C            APT MACRO PROCESSING
C
C ARGUMENT   IPROD  NUMBER ASSOCIATED WITH CURRENTLY MATCHED PRODUCTION
C NOTES      IPROD IS 50 LESS THAN ORIGINAL PRODUCTION NUMBER
C
C   MACRO-SPEZIAL-STACK FUER 50 MACROVARIABLE
      DIMENSION MRGSTK(150),ISEQ(3)
      CHARACTER*6 HCALL,I296
      LOGICAL JLHLT
      INTEGER ICNUM,BCDF
      DATA HCALL/'CALL  '/,MRGTOP/0/,IMRGDM/150/
      DATA I296,J296/'APT296',19205/
C**
      K = TOP
      GO TO(4100,4200,4300,4400,4500,4600,4700,4800,
     X      4900,5000,4300,4420), IPROD
 4100 I = STACK(1,TOP-1)
      IF(I.GT.NAMMAX)GO TO 4102
      J = NAMTBL(I)
      IF(J/MODULO.NE.TEMP(1)/MODULO)GO TO 4101
      M=J-TEMP(1)
      ITMPCT=ITMPCT+1
      CALL MACLBL(I,-ITMPCT,II)
      IF(M.GT.MODHLF)M=SUBSCR
      NAMTBL(II)=VBL(1)+M
      CALL RESRVZ(II,M,TXXXX(1,M),1)
      STACK(1,TOP-1) = II
      IF(M.EQ.SUBSCR)GO TO 4120
      CALL OPCODE(REPL)
      CALL ONEARG(TXXXX(1,M))
      CALL ARGCVT(II)
      CALL ARGCVT(I)
      CALL RLSLIN
      GO TO 4125
 4120 M=J-TEMP(1)
      CALL ASNADZ(II,I)
 4125 IF(IFTMP(I))CALL PUTTMP(MODE(I))
      NAMTBL(II)=VBL(1)+M
 4101 IF(MRGTOP+3.LE.IMRGDM)GO TO 4103
 4104 CALL ALARM(32,TOP-1,8,'MACREC  ')
      IPROD=4
      GO TO 4420
 4102 MNMBND=MNMBND+1
      IF(MNMBND.LT.MASGND)GOTO 4106
      IF(MNMBND.EQ.MASGND)CALL ALARM(3002,TOP-1,8,'MACREC  ')
      MNMBND=MASGND+1
 4106 STACK(1,TOP-1)=MNMBND + NAMMAX
      CNUMTB(MNMBND)=CNUMTB(I-NAMMAX)
      GOTO 4101
 4103 MRGSTK(MRGTOP+3)=STACK(1,TOP-1)
      TOP = TOP-2
 4110 I = STACK(1,TOP-1)
      MRGSTK(MRGTOP+1) = I
      MRGSTK(MRGTOP+2) = NAMTBL(I)
      MRGTOP=MRGTOP+3
      ICALLF=1
      NAMTBL(I) = MACVBL(1)+MRGTOP/3
      TOP = TOP - 2
      STACK(1,TOP) = STACK(1,K)
      STACK(2,TOP) = STACK(2,K)
      GO TO 1
 4200 IF(MRGTOP+3.GT.IMRGDM)GO TO 4104
      MRGSTK(MRGTOP+3)=0
      GO TO 4110
 4300 IF(MCSAVP)4310,4320,4310
 4310 CALL ALARM(1016,TOP-3,8,'MACREC  ')
      GO TO 4360
 4320 IF((MACDFP+3+MRGTOP/3).LE.MCDFDM)GO TO 4325
      CALL ALARM(21,0,8,'MACREC  ')
      CALL HELP
 4325 IF(MRGTOP)4350,4350,4330
 4330 DO 4340 I=3,MRGTOP,3
      J=MACDFP+I/3
      MACDF1(J+3)=MRGSTK(I-2)
 4340 MACDF2(J+3)=MRGSTK(I)
      MACDF1(MACDFP+3) = J+3
 4350 L = STACK(1,TOP-3)
      IF (IPROD.EQ.11) L=STACK(1,TOP-4)
      MACDF1(MACDFP+1)=L
      MCNMB=MCNMB+1
      MACDF2(MACDFP+2) = MCNMB
C
C...     PRESERVE INITIAL SEQUENCE NO. FOR THIS MACRO
C
      IF(MCNMB.LE.MSEQDM)GO TO 4355
      CALL ALARM(27,0,8,'MACREC  ')
      CALL HELP
 4355 MACSEQ(MCNMB)=SEQNO
      NAMTBL(L) = MACNAM(1)+MCNMB
      MACDF1(MACDFP+2) = MCTXTP
 4360 MACLDD=.TRUE.
  600 NEWSTM = .TRUE.
    1 RETURN
 4400 MACLDD=.FALSE.
 4410 MACDFP=MACDFP+3
      IF(MRGTOP.NE.0)MACDFP=MACDF1(MACDFP)
      CALL MCXTRN(1,MCTXTP+1,STACK(1,TOP-1))
      CALL MCXTRN(1,MCTXTP+2,RTERM(2))
      MCTXTP=MCTXTP+2
 4415 IF(MRGTOP)600,600,4420
 4420 DO 4430 I=3,MRGTOP,3
      J= MRGSTK(I-2)
 4430 NAMTBL(J) = MRGSTK(I-1)
      MRGTOP = 0
      ICALLF=0
      GO TO 600
 4500 I=STACK(1,TOP-1)
      MCTXTP = MCTXTP+1
      IF(I.GT.NAMMAX)GO TO 1410
      IF(CNAMTB(I).EQ.HCALL)I=0
      IF(NAMTBL(I)/MODULO.EQ.MACVBL(1)/MODULO
     /) I=MACVBL(1) - NAMTBL(I)
      CALL MCXTRN(1,MCTXTP,I)
      GOTO 1420
 1410 J=NUMBST+NAMMAX
      CALL MCXTRN(1,MCTXTP,J)
      DO 1415 J=1,9,4
        MCTXTP=MCTXTP+1
        ICNUM=BCDF(CNUMTB(I-NAMMAX)(J:J+3))
        CALL MCXTRN(1,MCTXTP,ICNUM)
 1415 CONTINUE
 1420 I=STACK(1,TOP)
      IF(I.GT.NAMMAX)GOTO 1450
      CALL MCXTRN(1,MCTXTP+1,I)
      IF (I.EQ.RTERM(2)) GOTO 4501
 1430 TOP=TOP-2
      NUMIDX=MNMBND
      GO TO 5010
 1440 TOP=TOP+1
 1450 J=NUMBST+NAMMAX
       CALL MCXTRN(1,MCTXTP+1,J)
      DO 1425 J=1,9,4
        MCTXTP=MCTXTP+1
        ICNUM=BCDF(CNUMTB(I-NAMMAX)(J:J+3))
        CALL MCXTRN(1,MCTXTP+1,ICNUM)
 1425 CONTINUE
      GOTO 1430
 4501 IPROD = 6
      GOTO 4601
 4600 CALL MCXTRN(1,MCTXTP+1,RTERM(2))
 4601 MCTXTP = MCTXTP+1
      GO TO 600
 4700 I=STACK(1,TOP-3)
      ICALLF=0
      IF(CNAMTB(I).EQ.HCALL)GOTO 4701
      CALL ALARM(1017,TOP-3,8,'MACREC  ')
      GO TO 4415
 4701 BRANCH=1
      J=STACK(1,TOP-1)
 4702 MVMAC=.FALSE.
      MVTRUE=.FALSE.
      CALLON=.FALSE.
      IF(MCHSTP+4.LE.MHSTDM)GO TO 4780
 4782 CALL ALARM(22,0,8,'MACREC  ')
      CALL HELP
 4780 TEMP1=MCHSTP
      I=1
      CALL MACTAB(J,I)
 4704 J2=MACDF1(I+2)
      MACSV2(MCSAVP+1)=VBLSVP+1
      MACSV1(MCSAVP+1)=I
      IF(J2)4728,4728,4705
 4705 J1=I+3
      M1=0
      KK=0
      DO 4731 J=J1,J2
      K=IABS(MACDF1(J))
      M1=M1+100000
      KK=KK+1
      GO TO (4790,4802),BRANCH
 4790 IF(K.GT.NAMMAX)GO TO 15
C   MACRO-CALL OHNE ARGUMENTE
      IF(MRGTOP.EQ.0)GO TO 15
      IF(NAMTBL(K)/MODULO.NE.MACVBL(1)/MODULO)GO TO 15
 4706 DO 4707 L=3,MRGTOP,3
      IF(K.EQ.MRGSTK(L-2))GO TO 4708
 4707 CONTINUE
 4708 IF(MCSAVP)4715,4715,4709
 4709 M=MACSV1(MCSAVP)
      N2=MACDF1(M+2)
      IF(N2)4715,4715,4710
 4710 N1=M+3
      DO 4711 N=N1,N2
      IF(MRGSTK(L).EQ.IABS(MACDF1(N)))GO TO 4712
 4711 CONTINUE
      GO TO 4715
 4712 N3=N-N1+MACSV2(MCSAVP)
      VBLSAV(VBLSVP+1)=VBLSAV(N3)
      MACHST(MCHSTP+4)=-(M1+N-N1+1)
      MVMAC=.TRUE.
 4713 MCHSTP=MCHSTP+1
      IF(MCHSTP+4.GT.MHSTDM)GO TO 4782
 4714 MRGSTK(L)=-1
      NAMTBL(K) = MRGSTK(L-1)
      GO TO 4717
 4715 IF(MACDF2(J).EQ.MRGSTK(L))GO TO 4716
      VBLSAV(VBLSVP+1)=MRGSTK(L)
      MACHST(MCHSTP+4) = M1 + MRGSTK(L)
      GO TO 4713
 4716 VBLSAV(VBLSVP+1)=MACDF2(J)
      GO TO 4714
   15 VBLSAV(VBLSVP+1) = MACDF2(J)
 4717 N=VBLSAV(VBLSVP+1)
      IF(N.GT.NAMMAX)GO TO 4718
      IF ((NAMTBL(N)/MODULO).EQ.(MACNAM(1)/MODULO)) GOTO 4720
 4718 IF(MACDF1(J))4719,4727,4727
 4719 CALL ALARM(1018,0,8,'MACREC  ')
      GO TO 4720
 4720 IF(MACDF1(J)*MACDF2(I))4723,4722,4721
 4721 CALL ALARM(1019,0,8,'MACREC  ')
      GO TO 4723
 4722 MACDF1(J)=-MACDF1(J)
 4723 L=1
      CALL MACTAB(N,L)
      IF(MACDF2(L).EQ.0)MVTRUE=.TRUE.
      IF(MNMVBP)4726,4726,4724
 4724 DO 4725 K=1,MNMVBP
      IF((MNMVB(K).EQ.N).AND.(MNMVC(K).EQ.I))GO TO 4727
 4725 CONTINUE
 4726 MNMVBP=MNMVBP+1
      IF(MNMVBP.LE.MNMVDM)GO TO 4786
      CALL ALARM(28,0,8,'MACREC  ')
      CALL HELP
 4786 MNMVB(MNMVBP)=N
      MNMVC(MNMVBP)=I
      IF((MACDF2(L).NE.0).AND.(MACDF2(L).LE.(MCSAVP+1)))MACDF2(L)=MCSAVP
     1+2
 4727 IF(MACDF2(J).NE.0.OR.MACHST(MCHSTP+3)/100000.EQ.KK) THEN
        CONTINUE
      ELSE
      JLHLT=ILHLT
      ILHLT=.FALSE.
      DO 4744 N3=1,3
        ISEQ(N3)=SEQCOM(N3)
 4744 CONTINUE
      N3=MACDF2(J1-2)
      SEQNO=MACSEQ(N3)
      CALL BINBCD(SEQNO,SEQNUM,N3)
      STACK(1,TOP+1)=MACDF1(J1-3)
      STACK(1,TOP+2)=MACDF1(J)
      CALL ALARM(2055,0,8,'MACREC  ')
      ILHLT=JLHLT
      DO 4745 N3=1,3
        SEQCOM(N3)=ISEQ(N3)
 4745 CONTINUE
      ENDIF
      VBLSVP=VBLSVP+1
 4731 CONTINUE
      IF(VBLSVP.LT.IVSVDM)GO TO 4728
 4788 CALL ALARM(29,0,8,'MACREC  ')
      CALL HELP
 4728 GO TO(4752,4739),BRANCH
 4752 IF(MRGTOP)4729,4732,4729
 4729 DO 4730 L=3,MRGTOP,3
      IF(MRGSTK(L).NE.(-1))CALL ALARM(1020,0,8,'MACREC  ')
 4730 CONTINUE
 4732 IF(CALLMV) GO TO 4735
      IF(MVMAC)  GO TO 4736
      MACDF2(I+2)=MACDF2(I+2)+1
      MACHST(TEMP1+3)=MACDF2(I+2)
      MCHSTP=MCHSTP+3
      IF(MCHSTP+4.GT.MHSTDM)GO TO 4782
      IF(MCSAVP)4733,4733,4734
 4733 IF(J2.NE.0)GO TO 1010
      CALL MACLBL(-1,MACDF1(I),J)
      NAMTBL(J)=LABEL(1)
      CALL CALMCX(J,0,1)
      GO TO 1020
 1010 CALL CALMCX(MACDF1(I),0,2)
      CALL MACLBL(MACDF1(I),-MACDF2(I+2),L)
      NAMTBL(L) = IMPLAB(1)
      CALL CALMCX(L,0,1)
 1020 MACHST(TEMP1+1)=0
      GO TO 4742
 4734 CALL MCXTRN(1,CALLPT+1,MACDF2(I+2))
      CALL MCXTRN(1,CALLPT+2,I)
      GO TO 4703
 4735 CALL MCXTRN(1,CALLPT+2,-MVSEG)
      CALLMV=.FALSE.
      GO TO 4737
 4736 CALL MCXTRN(1,CALLPT+2,I)
 4737 CALL MCXTRN(1,CALLPT+1,0)
      IF(TEMP1.EQ.MCHSTP)GO TO 4739
      M=MCHSTP-1
      DO 4738 L=TEMP1,M
      CALL MCXTRN(1,CALLPT+3,MACHST(L+4))
 4738 CALLPT=CALLPT+1
 4739 MCHSTP=TEMP1+3
      MACHST(MCHSTP)=0
 4703 MACHST(TEMP1+1)=MACSV1(MCSAVP)
      GO TO(4740,4742),BRANCH
 4740 CALL MCXTRN(1,CALLPT+3,TEXTST)
 4741 MACSV3(MCSAVP)=TEXTST
 4742 MACHST(TEMP1+2)=I
      IF(MACDF2(I))4743,4760,4743
 4743 IF(MACDF2(I).GT.MCSAVP) GO TO 4749
      MACDF2(I)=MCSAVP+1
 4749 IF(MVTRUE)GO TO  4757
      IF(MACDF1(I+2))4754,4754,4767
 4767 SWITCH=2
      GO TO 4762
 4754 IF(MCSAVP)4759,4415,4759
 4760 IF(MACDF1(I+2))4757,4757,4761
 4761 SWITCH=1
 4762 J=MACSV2(MCSAVP+1)
      J1=I+3
      J2=MACDF1(I+2)
      DO 4766 K=J1,J2
      GO TO(4765,4763),SWITCH
 4763 L=VBLSAV(J)
      M = MACTBL(K)
      IF (L.GT.NAMMAX) GOTO 4766
      N = MODULO*(NAMTBL(L)/MODULO)
      IF (M.GT.NAMMAX) GOTO 4777
      M = MODULO*(NAMTBL(M)/MODULO)
      IF(N.NE.CONGEO(1))GO TO 4791
      IF(M.EQ.GEOM(1))GO TO 4798
      GO TO 4793
 4791 IF(N.NE.CONPRO(1))GO TO 4792
      IF(M.EQ.PROCED(1))GO TO 4798
      GO TO 4793
 4777 M = VBL(1)
 4792 IF(N.NE.IDENT(1) .AND. N.NE.PERMID(1))GO TO 4793
      IF (M .EQ. PERMID(1)) GO TO 4798
      IF (M. NE. FCN(1)) GO TO 4793
 4798 NAMTBL(L) = M + NAMTBL(L) - N
      GO TO 4766
 4793 IF(M.NE.VBL(1))GO TO 4766
      SWITCH=1
      GO TO 4766
 4765 MACTBL(K)=VBLSAV(J)
 4766 J=J+1
      GO TO(4757,4754),SWITCH
 4757 INTMED=-1
      MACRED=.TRUE.
      ILHLT=.TRUE.
      MVPNT=MACSV2(MCSAVP+1)-1
      MCSAVP=MCSAVP+1
      IF(MCSAVP.LT.MCSVDM)GO TO 4784
      CALL ALARM(24,0,8,'MACREC  ')
      CALL HELP
 4784 MACDF2(I)=MCSAVP
      WHCHMN=MACDF2(I+1)
      GO TO(4758,4808),BRANCH
 4758 TEXTST = MACDF1(I+1)
 4759 GO TO(4415,4812),BRANCH
 4800 CALL MCXTRN(2,TEXTST+2,J)
      JJ = TEXTST + 3
 4820 CALL MCXTRN(2,JJ,MCTXWD)
      IF((MCTXWD/100000).EQ.0)GO TO 4821
      JJ = JJ + 1
      GO TO 4820
 4821 BRANCH = 2
      IF(J)4801,4801,4702
 4801 J=MVPNT-J
      J=VBLSAV(J)
      GO TO 4702
 4802 SAVE=TEXTST+3
 4803 CALL MCXTRN(2,SAVE,MCTXWD)
      SAVE1=MCTXWD/100000
      IF(SAVE1)4804,4851,4804
 4851 VBLSAV(VBLSVP+1)=MACDF2(J)
      GO TO 4717
 4804 IF(100000*IABS(SAVE1).EQ.M1)GO TO 4805
      SAVE=SAVE+1
      GO TO 4803
 4805 IF(SAVE1)4806,4807,4807
 4806 SAVE1=MACSV2(MCSAVP)-(M1+MCTXWD)-1
      VBLSAV(VBLSVP+1)=VBLSAV(SAVE1)
      GO TO 4717
 4807 VBLSAV(VBLSVP+1)=MCTXWD-M1
      GO TO 4717
 4808 CALL MCXTRN(2,JJ,MACSV3(MCSAVP-1))
      TEXTST=MACDF1(I+1)
 4811 STACK(1,TOP) = RTERM(2)
      GO TO 4415
 4812 CALL MCXTRN(2,JJ,TEXTST)
      GO TO 4811
 4900 IF(INTMED)4901,4904,4905
 4901 MCSAVP=MCSAVP-1
      L=MACSV1(MCSAVP+1)
      MACTBL(L)=1
      VBLSVP=MACSV2(MCSAVP+1)-1
      IF(VBLSVP.GE.IVSVDM)GO TO 4788
      IF(MCSAVP)4904,4902,4903
 4904 CALL ALARM(37,0,8,'MACREC  ')
      CALL HELP
 4902 ILHLT=.FALSE.
      MACRED=.FALSE.
      INTMED=0
      WHCHMN=0
      GO TO 600
 4903 TEXTST=MACSV3(MCSAVP)
      MVPNT=MACSV2(MCSAVP)-1
      L=MACSV1(MCSAVP)
      WHCHMN=MACDF2(L+1)
      GO TO 600
 4905 IF(FINMAC)GO TO 4906
      FINMAC=.TRUE.
C
C...  BEGIN FINAL MACRO PROCESSING FOR THIS MACRO
C
      J = MACDF2(MCSRCH+1)
      SEQNO=MACSEQ(J)
      ILHLT=.FALSE.
      TEXTST=MACDF1(MCSRCH+1)
      PATHLN=NUMARG
      NXTLN=1
      PATHCH=NUMARG
      CALL MACLBL(-1,MACDF1(MCSRCH),J)
      NAMTBL(J) = LABEL(1)
      MCHDNG=.TRUE.
      CALL LABELZ(J)
      J=NAME(I296)
      NAMTBL(J)=J296
      CALL CALLZZ(J)
      CALL RLSLIN
      GO TO 600
 4906 CALL COMSTR
      CALL MNPROC
      IF(.NOT.MACEND)GO TO 600
      CALL EPILOG
      MACRED = .FALSE.
      GOTO 600
 5000 I=STACK(1,TOP)
      IF(I.GT.NAMMAX)GOTO 1440
      IF(NAMTBL(I)/MODULO.EQ.MACVBL(1)/MODULO)I=MACVBL(1)-NAMTBL(I)
      CALL MCXTRN(1,MCTXTP+1,I)
      TOP=TOP-1
 5010 MCTXTP=MCTXTP+1
      GO TO 1
       END
**** SOURCE FILE : M0006652.V01   ***
*
C
C              FORTRAN SUBROUTINE MACTAB
C
C LINKAGE      SUBROUTINE MACTAB(PONTER,STAAT)
C
C          SUBSIDIARIES                  CALLED BY
C          NONE                          TYPE          ENTRY
C                                        SUBROUTINE    INPUT
C                                        SUBROUTINE    MACREC
C
      SUBROUTINE MACTAB(PONTER,STAAT)
C
      IMPLICIT INTEGER (A-Z)
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      DIMENSION MACXX1(71)
C MACDFP:      POINTER TO LAST ENTRY IN MACDF1 AND MACDF2 ARRAYS
      EQUIVALENCE (MACDFP,MACXX1(1))
C
C       24.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX3/MACXX3
      DIMENSION MACXX3(1430),MACDF1(400)
C MACDF1:      STORES MACRO NAME AND ALL MACRO VBL NAMTBL POINTERS
      EQUIVALENCE (MACDF1(1),MACXX3(1))
C*
C PURPOSE      TO DETERMINE THE POSITION OF A PARTICULAR MACRO
C              NAME IN THE MACDF1 TABLE.
C
C ARGUMENTS    PONTER   NAME TABLE (NAMTBL) INDEX OF MACRO NAME
C              STAAT    FOUND MACDF1 INDEX OF MACRO NAME
C**
      J=PONTER
      I=STAAT
    1 IF(I.GE.MACDFP)GO TO 4
      IF(MACDF1(I).EQ.J)GO TO 6
      IF(MACDF1(I+2))2,2,3
    2 I=I+3
      GO TO 1
    3 I=MACDF1(I+2)+1
      GO TO 1
    4 STAAT=0
    5 RETURN
    6 STAAT=I
      GO TO 5
       END
**** SOURCE FILE : M0006653.V04   ***
*
C
C              FORTRAN SUBROUTINE MATCH
C
C LINKAGE      SUBROUTINE MATCH
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    LABELZ          SUBROUTINE    INPUT
C          INTEGER FCT.  MODE            SUBROUTINE    PRO020
C          SUBROUTINE    MACLBL          SUBROUTINE    PRO026
C          SUBROUTINE    ALARM           SUBROUTINE    RECOG
C          SUBROUTINE    RETMCX          SUBROUTINE    REPLAC
C          SUBROUTINE    SETBIT
C          SUBROUTINE    HELP
C
      SUBROUTINE MATCH
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),ARGSTK(99)
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),NUMBER(2),PERMID(2),LABEL(2),IMPLAB(2)
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C IMPLAB:      (1)=CODE CLASS 23000,(2)=NAMTBL INDEX OF 'IMPLAB'
      EQUIVALENCE (IMPLAB(1),CODE(45))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL ILHLT,ENTRY,NESTG
      DIMENSION MACXX1(71)
C ILHLT:       TRUE IF I.L. SHOULD NOT BE PLACED IN ILFILE
      EQUIVALENCE (ILHLT,MACXX1(14))
C MAXSPS:      NUMBER OF MACRO VARIABLES+1 FOR CURRENT MACRO
      EQUIVALENCE (MAXSPS,MACXX1(21))
C MAJWRD:      CONTAINS ACTUAL MAJOR WORD
      EQUIVALENCE (MAJWRD,MACXX1(23))
C NMLINE:      EQUALS NUMBER OF EXPRESSIONS THAT REQUIRE BRANCHING I.L.
      EQUIVALENCE (NMLINE,MACXX1(25))
C WAY:         INDICATES TYPE OF MACRO PROCESSING
      EQUIVALENCE (WAY,MACXX1(26))
C BITWDS:      NUMBER OF WORDS NEEDED FOR ALL CALL QUALITIES OF MACRO
      EQUIVALENCE (BITWDS,MACXX1(29))
C MACLNT:      TEMPORARY STORAGE FOR MCSLNT
      EQUIVALENCE (MACLNT,MACXX1(37))
C MCSLNT:      NUMBER OF MACRO VBLS IN ARGSTK FOR CURRENT EXPRESSION
      EQUIVALENCE (MCSLNT,MACXX1(38))
C MSP:         POINTER TO THE LAST ENTRY IN MAS ARRAY
      EQUIVALENCE (MSP,MACXX1(39))
C ENTRY:       FALSE ON FIRST ENTRY TO MATCH FOR A MACRO EXPRESSION
      EQUIVALENCE (ENTRY,MACXX1(40))
C MVEXST:      POSITION NUMBER OF MACRO VARIABLE, 0=NO MACRO VARIABLE
      EQUIVALENCE (MVEXST,MACXX1(41))
C MACTOP:      POINTER TO EXPRESSION NUMBER IN MACSPD TABLE
      EQUIVALENCE (MACTOP,MACXX1(42))
C MCSTRT:      INDEX IN MACSPD OF CURRENT CALL BEING EXAMINED
      EQUIVALENCE (MCSTRT,MACXX1(43))
C MAJOR:       CURRENT CALL ASSIGNED VALUE IF MAYWRD IS MACRO VARIABLE
      EQUIVALENCE (MAJOR,MACXX1(44))
C NESTG:       TRUE WHEN A NESTED GEOMETRIC EXPRESSION ENCOUNTERED
      EQUIVALENCE (NESTG,MACXX1(45))
C ROUTE:       CLASS CODE OF A MAJOR WORD DURING MACRO PROCESSING
      EQUIVALENCE (ROUTE,MACXX1(46))
C ROAD:        CLASS CODE OF A MAJOR WORD DURING MACRO PROCESSING
      EQUIVALENCE (ROAD,MACXX1(47))
C SAVMSP:      USED TO SAVE A POINTER TO THE MAS ARRAY
      EQUIVALENCE (SAVMSP,MACXX1(48))
C TYP:         1 WHEN AN INVALID PATTERN FOR CURRENT EXPRESSION APPEARS
      EQUIVALENCE (TYP,MACXX1(49))
C LNUSDP:      INDEX OF LAST LINUSD ENTRY
      EQUIVALENCE (LNUSDP,MACXX1(51))
C MCTOPP:      TEMPORARY STORAGE IN MATCH FOR MACTOP VALUE
      EQUIVALENCE (MCTOPP,MACXX1(52))
C LNSDDM:      DIMENSION OF LINUSD
      EQUIVALENCE (LNSDDM,MACXX1(53))
C MVARDM:      CONTAINS DIMENSION OF THE ARRAY MACVAR
      EQUIVALENCE (MVARDM,MACXX1(54))
C MASDM:       CONTAINS DIMENSION OF ARRAY MAS
      EQUIVALENCE (MASDM,MACXX1(55))
C NUMBIT:      CONTAINS NUMBER OF BITS IN A FIXED POINT WORD
      EQUIVALENCE (NUMBIT,MACXX1(56))
C MCSPDP:      POINTER TO LAST ENTRY IN MACSPD TABLE
      EQUIVALENCE (MCSPDP,MACXX1(57))
C NUMARG:      NUMBER OF MACRO VARIABLES+1 FOR CURRENT MACRO
      EQUIVALENCE (NUMARG,MACXX1(61))
C WHCHMN:      EQUAL TO NUMBER OF CURRENT MACRO BEING PROCESSED
      EQUIVALENCE (WHCHMN,MACXX1(63))
C MSPDDM:      CONTAINS DIMENSION OF THE ARRAY MACSPD
      EQUIVALENCE (MSPDDM,MACXX1(65))
C
C      25A.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX5/MACXX5
      DIMENSION MACXX5(135),ITMPSV(135)
C ITMPSV:      TEMPORARY STORAGE DURING FINAL MACRO PROCESSING
      EQUIVALENCE (ITMPSV(1),MACXX5(1))
C
C       26.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX6/MACXX6
      DIMENSION MACXX6(1300),MACSPD(1300)
C MACSPD:      NAMTBL POINTERS OF THE ASSIGNED VALUES FOR MACRO CALL
      EQUIVALENCE (MACSPD(1),MACXX6(1))
C
C      26A.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX7/MACXX7
      DIMENSION MACXX7(182),MACVAR(32),MAS(100),LINUSD(50)
C LINUSD:      NUMBERS OF EXPRESSIONS REQUIRING BRANCHING FOR MACROS
      EQUIVALENCE (LINUSD(1),MACXX7(1))
C MAS:         NAMTBL POINTERS OR ASSIGNED VALUES OF MACRO VBL MAJOR W.
      EQUIVALENCE (MAS(1),MACXX7(51))
C MACVAR:      POSITION NUMBER OF EACH UNIQUE MACRO VARIABLE
      EQUIVALENCE (MACVAR(1),MACXX7(151))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ERGSTK
      DIMENSION ERRPOS(302),ERGSTK(100)
C ERGSTK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN ARGSTK
      EQUIVALENCE (ERGSTK(1),ERRPOS(203))
C*
C PURPOSE      TO DETERMINE WHICH EXPRESSIONS IN AN APT MACRO
C              REQUIRE BRANCHING
C
C NOTES        1.  MATCH IS ACCESSED DURING THE FIRST PASS OF
C                  FINAL MACRO PROCESSING
C              2.  FOR EACH CALL A 'STATE' BASED UPON THE KIND
C                  OF EXPRESSION ENCONTERED IS CALCULATED FOR
C                  EACH INVOLVED MACRO VARIABLE.  EVERY TIME
C                  THE CURRENT CALL STRING OF 'STATES' DIFFERS
C                  IN AT LEAST ONE POSITION FROM ALL OTHER
C                  PREVIOUS STRINGS, A NEW BRANCH IS INITIATED
C                  AND THE STRING OF 'STATES' IS STORED IN THE
C**
      LOGICAL EXTERN
      DATA LBRCH/0/
      DATA EXTERN/.FALSE./
      IF (NUMARG .EQ. 0) GO TO 7
C
C...     ENTRY=.TRUE. IF MATCH IS BEING ENTERED AGAIN FOR SAME
C...     PRODUCTION INDICATING A BRANCHING SITUATION EXISTS.
C
      IF(ENTRY)GO TO 99
C
C...     NMLINE=NUMBER OF CURRENT (POTENTIAL) BRANCHING EXPRESSION.
C
      NMLINE=NMLINE+1
      K1 = NUMARG
      M1 = 0
      ARGARG=ARGTOP
      DO 1 I=2,NUMARG
    1 ITMPSV(I+99)=0
C
C...     MCSLNT=NUMBER OF UNIQUE MACRO VARIABLES IN ARGSTK.
C
      MCSLNT=0
C
C...     MVEXST=POSITION NUMBER IF APT MAJOR WORD A MACRO VARIABLE.
C...     NORMALLY=0.
C
      MVEXST=0
C
C...     IF FUNCTION,NO BRANCHING REQUIRED FOR MACRO VARIABLE ARGUMENTS.
C
      IF((ARGTOP.EQ.0).OR.(WAY.EQ.3))GO TO 3
      DO 2 I=1,ARGTOP
C
C...     SAVE CONTENTS OF ARGSTK IN ITMPSV(1) THRU ITMPSV(99)
C
      ITMPSV(I)=ARGSTK(I)
C
C...     SCAN ARGSTK AND PLACE THE POSITION NUMBER OF EACH UNIQUE MACRO
C...     VARIABLE FOUND IN THE FIRST FREE POSITION OF MACVAR ARRAY.
C
      DO 2 J=2,NUMARG
      IF(MACSPD(J-1).NE.ARGSTK(I))GO TO 2
      IF(ITMPSV(J+99).NE.0)GO TO 2
      MCSLNT=MCSLNT+1
      IF(MCSLNT.LE.MVARDM)GO TO 17
   18 CALL ALARM(32,-I,8,'MATCH   ')
      CALL HELP
   17 MACVAR(MCSLNT)=J-1
      ITMPSV(J+99)=1
    2 CONTINUE
    3 MACLNT=MCSLNT
C
C...     CALL EXPRESSIONS REQUIRE NO MAJOR WORD ANALYSIS.
C
      IF(WAY.EQ.5)GO TO 6
C
C...     ROUTE=CLASS CODE OF MAJOR WORD.
C...     ROAD=MODE CODE OF MAJOR WORD.
C
      ROUTE = MODULO*(NAMTBL(MAJWRD)/MODULO)
      ROAD = NAMTBL(MAJWRD)-ROUTE
      DO 4 I=2,NUMARG
      IF(MACSPD(I-1).EQ.MAJWRD)GO TO 5
    4 CONTINUE
      GO TO 6
C
C...     STORE POSITION NUMBER OF MACRO VARIABLE MAJOR WORD IN BOTH
C...     MVEXST AND FIRST FREE CELL OF MACVAR ARRAY.
C
    5 MVEXST=I-1
C
C...     IF GEOMETRIC EXPRESSION HAS MACRO VARIABLE MAJOR WORD, THEN
C...     ISSUE DIAGNOSTIC.
C
      IF(NESTG)GO TO 62
      I=100
      IF(MCSLNT.GE.MVARDM)GO TO 18
      MACVAR(MCSLNT+1)=MVEXST
      MACLNT=MCSLNT+1
C
C...     RETURN IF NO MACRO VARIABLES INVOLVED IN EXPRESSION.
C
    6 IF(MACLNT.NE.0)GO TO 8
    7 RETURN
C
C...     EACH CALL IS EXAMINED AND COMPARED TO THE ONES PRECEDING IT TO
C...     DETERMINE WHEN AND IF CODE FOR A NEW BRANCH IS REQUIRED.
C...     MCSTRT POINTS TO CURRENT CALL ASSIGNED VALUES IN MACSPD TABLE.
C...     MSP POINTS TO LAST ENTRY IN MAS TABLE.
C
    8 MCSTRT=0
      MSP=0
    9 MCSTRT=MCSTRT+NUMARG
C
C...     IF CALLS REMAIN TO BE PROCESSED, THEN BRANCH.
C
      IF(MCSTRT.LT.MCSPDP)GO TO 10
C
C...     RESET CONTROL PARAMETERS FOR FINAL EXIT FOR THIS EXPRESSION.
C
      L=NUMARG
      ILHLT=.TRUE.
      ENTRY = .FALSE.
      M1=1
      GO TO 60
   10 TYP=0
      NRMVAL=-1
      SAVMSP=MSP+1
      ARGTOP=ARGARG
C
C...     MAJOR=CURRENT CALL ASSIGNED VALUE (MACSPD(I)) IF MAJOR WORD IS
C...     A MACRO VARIABLE. OTHERWISE MAJOR=MAJOR WORD (MAJWRD).
C
      MAJOR = MAJWRD
      IF(MVEXST.EQ.0)GO TO 13
   11 I = MVEXST + MCSTRT
      MAJOR=IABS(MACSPD(I))
C
C...     FOR EACH CALL A MACRO VARIABLE MAJOR WORD HAS EITHER ITS
C...     ASSIGNED VALUE MODE OR NAMTBL POINTER STORED IN MAS ARRAY
C...     DEPENDING UPON EXPRESSION TYPE.
C
      GO TO (101,202,202,102),WAY
  101 MAS(MSP+1) = MAJOR
      GO TO 12
  202 MAS(MSP+1)=NAMTBL(MAJOR)-ROUTE
      IF(ENTRY)GO TO 20
      EXTERN=.TRUE.
      M1=1
      GO TO 20
  102 MAS(MSP+1) = NAMTBL(MAJOR)-ROUTE
      IF (WAY.EQ.4) GOTO 12
C
C...     IF A POSTPROCESSOR OR GOLFT,GORGT,GOUP,GODOWN,GOFWD,GOBACK
C...     PROCEDURE IS ENCOUNTERED, BRANCHING ON MAJOR WORD UNNECESSARY.
C
   20 IF((MAS(MSP+1).EQ.0).OR.(MAS(MSP+1).EQ.34))MAJOR=MAJWRD
   12 ROAD=MAS(MSP+1)
      MSP=MSP+1
      IF(MSP.LT.MASDM)GO TO 13
   16 CALL ALARM(26,0,8,'MATCH   ')
      CALL HELP
C
C...     IF NO ELEMENTS OF ARGSTK ARE MACRO VARIABLES, THEN BRANCH.
C
   13 IF((ARGTOP.EQ.0).OR.(WAY.EQ.3))GO TO 51
C
C...     RESTORE CONTENTS OF ARGSTK WHICH MIGHT HAVE BEEN ALTERED IN
C...     GENERATING BRANCHING CODE FOR PRIOR CALLS.
C
      DO 14 I=1,ARGTOP
   14 ARGSTK(I)=ITMPSV(I)
      IF(MCSLNT.EQ.0)GO TO 51
C
C...     ESTABLISH 'STATE' OF EACH INVOLVED MACRO VARIABLE FOR THIS CALL
C
      DO 50 I=1,MCSLNT
      J=MACVAR(I)+MCSTRT
C
C...     PICK UP ASSIGNED VALUE POINTER.
C
      K=IABS(MACSPD(J))
C
C...     NRMVAL=1 IF AT LEAST ONE NON-NORMAL VALUE USED.
C
      IF(MACSPD(J).GE.0)NRMVAL=1
C
C...     ASSIGN INITIAL 'STATE' OF MACRO VARIABLE.
C
      MAS(MSP+1)=MODE(K)
C
C...     M=CLASS OF ASSIGNED VALUE.
C
      IF (K.LE.NAMMAX) GOTO 1100
      M = NUMBER(1)
      GOTO 1110
 1100 M = MODULO*(NAMTBL(K)/MODULO)
      L = NAMTBL(K)-M
C
C...     WAY=1 FOR GEOM, WAY=2 FOR PROC, WAY=3 FOR FUNC, WAY=4 FOR REPL,
C...     WAY=5 FOR CALL.
C
 1110 GOTO (41,15,50,71,43),WAY
   71 IF (MAS(MSP+1) .EQ. 0) GO TO 22
      IF (MAS(MSP+1) .EQ. ROAD) GO TO 50
      GO TO 22
   15 IF (ROAD.EQ.0) GOTO 50
      IF (ROAD.LT.22) GOTO 22
      IF (ROAD - 41) 26,25,22
   26 IF (ROAD-24) 24,21,44
   21 IF((M.NE.LABEL(1)).AND.(M.NE.IMPLAB(1)))GO TO 22
   23 IF (L.NE.WHCHMN) GOTO 22
      MAS(MSP+1)=200
      GO TO 50
   25 IF((MAS(MSP+1).EQ.0).OR.(MAS(MSP+1).GT.17))GO TO 22
   38 MAS(MSP+1) = 50
      GO TO 50
   24 IF (ROAD .EQ. 23) GO TO 47
      IF (MAS(MSP+1) .NE. 21) GO TO 22
      GO TO 50
   47 IF (MAS(MSP+1) .NE. 2) GO TO 22
      GO TO 50
   44 IF(MAS(MSP+1).EQ.21)GO TO 50
      IF(ROAD-34)27,29,30
   27 IF (ROAD .EQ. 25) GO TO 36
C
C...     INVALID 'STATE'. A SINGLE BRANCH FOR ALL SUCH CALLS.
C
   22 TYP=1
      GO TO 50
   36 IF(M.NE.PERMID(1))GO TO 25
      GO TO 42
   29 IF(MAS(MSP+1).NE.0)GO TO 25
      IF (M .NE. PERMID(1)) GO TO 21
      IF (L.EQ.5) L=3
      GO TO 42
   30 IF(ROAD-37)31,33,32
   31 IF(MAS(MSP+1).EQ.19)GO TO 50
      GO TO 22
   32 IF (ROAD-39) 33,46,39
   33 IF(MAS(MSP+1).EQ.20)GO TO 50
      GO TO 46
   39 IF(MAS(MSP+1).EQ.19)GO TO 50
      GO TO 46
   41 IF(MAS(MSP+1).NE.0)GO TO 50
   46 IF (M .NE. PERMID(1)) GO TO 22
   42 IF (L.EQ.0) GOTO 22
      MAS(MSP+1) = L+100
      GO TO 50
   43 MAS(MSP+1)=K
   50 MSP=MSP+1
      IF(MSP.GE.MASDM)GO TO 16
C
C...     BRANCH IF NO INVALID 'STATES' ENCOUNTERED.
C
      IF(TYP.EQ.0)GO TO 51
C
C...     SET ALL 'STATES' = 0 FOR THIS CALL.
C
   61 DO 45 I=SAVMSP,MSP
   45 MAS(I)=0
   51 J=MACVAR(MACLNT)+MCSTRT
      IF(MACSPD(J).GE.0) NRMVAL=1
      IF(MSP.NE.MACLNT)GO TO 98
C
C...     THIS PATH FOLLOWED FOR 1ST CALL SINCE NO COMPARISON CAN YET BE
C...     MADE TO DETERMINE IF BRANCHING IS NECESSARY.
C
      NRMSAV=NRMVAL
      MAJSAV=MAJOR
      IF (.NOT.EXTERN) GO TO 9
      EXTERN=.FALSE.
      GO TO 105
   98 K1=K1+NUMARG
      L=MSP-MACLNT
      K=L+1
C
C...     COMPARE 'STATES' FOR THIS CALL WITH 'STATES' FOR EACH CALL THAT
C...     INITIATED A NEW BRANCH. UPON COMPLETION OF A CALL COMPARISON
C...     M1=0 IF SAME AS SOME PREVIOUS CALL. OTHERWISE BRANCH (M1=1).
C
      DO 53 I=1,L,MACLNT
      M1 = 0
      DO 52 J=K,MSP
      N=I+J-K
   52 IF (MAS(J) .NE. MAS(N)) M1 = 1
      IF (M1 .EQ. 0) GO TO 59
   53 CONTINUE
C
C...     ENTRY=.FALSE. IF 1ST BRANCH ENCOUNTERED FOR THIS EXPRESSION.
C
      IF(ENTRY)GO TO 56
C
C...     MAXSPS KEEPS TRACK OF NUMBER OF ACTUAL BRANCHING EXPRESSIONS IN
C...     MACRO.
C
  105 MAXSPS=MAXSPS+1
C
C...     EVERY POTENTIAL BRANCHING SITUATION HAS A NUMBER ASSOCIATED
C...     WITH IT (NMLINE INCREMENTED EACH TIME). THOSE ACTUAL BRANCHING
C...     EXPRESSIONS HAVE CURRENT VALUE OF NMLINE STORED IN LINUSD ARRAY
C
      LNUSDP=LNUSDP+1
      IF(LNUSDP.LE.LNSDDM)GO TO 54
      CALL ALARM(20,0,8,'MATCH   ')
      CALL HELP
   54 LINUSD(LNUSDP)=NMLINE
C
C...     NEGATIVE OF BRANCHING EXPRESSION NUMBER STORED IN MACSPD TABLE.
C
      MACSPD(MACTOP+1)=-NMLINE
      ILHLT=.FALSE.
      NRMVAL=NRMSAV
      MAJOR=MAJSAV
      K1=2*NUMARG
      MCSTRT=NUMARG
      MSP=MACLNT
      IF(MSP.GE.MASDM)GO TO 16
      ENTRY=.TRUE.
      MACTOP=MACTOP+1
C
C...     MCTOPP IS POINTER TO EXPRESSION NUMBER IN MACSPD TABLE.
C
      MCTOPP=MACTOP
      IF(MACTOP.LT.MSPDDM)GO TO 56
   55 CALL ALARM(31,0,8,'MATCH   ')
      CALL HELP
   56 LBRCH=LBRCH+1
      CALL MACLBL(+2,-LBRCH,N)
      NAMTBL(N)=LABEL(1)
C
C...     GENERATE BRANCH LABEL COMMAND.
C
      CALL LABELZ(N)
      M=MACTOP
      MACTOP=MACTOP+BITWDS+1
      IF(MACTOP.GE.MSPDDM)GO TO 55
C
C...     STORE THE LATEST BRANCH LABEL IN THE BRANCHING HISTORY PORTION
C...     OF THE MACSPD TABLE. IF THIS BRANCH ONLY EMPLOYS NORMAL VALUES
C        (NRMVAL=-1), THEN STORE THE NEGATIVE OF THE LABEL POINTER.
C
      MACSPD(MACTOP)=NRMVAL*N
   57 J=(MACSPD(K1)-1)/NUMBIT
      N=MACSPD(K1)-NUMBIT*J
      K=M+J+1
C
C...     SET THE NTH CALL QUALITY FOR THE APPROPRIATE BRANCH.
C
      CALL SETBIT(MACSPD(K),N)
      L=MCSTRT
C
C...     UPDATE THE CLASS AND MODE FOR EACH MACRO VARIABLE TO CORRESPOND
C...     TO THE ASSIGNED VALUES FOR THE CURRENT CALL.
C
   60 DO 58 I=2,NUMARG
      J=MACSPD(I-1)
      K=IABS(MACSPD(L+1))
      NAMTBL(J) = NUMBER(1)+MODHLF
      IF(K.GT.NAMMAX)GO TO 58
      KK=NAMTBL(K)
      IF(KK-MODULO*(KK/MODULO).LT.MODHLF)KK=KK+MODHLF
      NAMTBL(J)=KK
   58 L=L+1
      IF (M1 .EQ. 0) GO TO 9
      GO TO 7
   59 MSP=MSP-MACLNT
      IF(.NOT.ENTRY)GO TO 9
C
C...     COMPUTE POSITION IN MACSPD TABLE FOR BRANCH ASSOCIATED WITH
C...     THIS CALL.
C
      M = MCTOPP+((I-1)/MACLNT)*(BITWDS+1)
      GO TO 57
C
C...     GENERATE RETURN TERMINATOR FOR BRANCH CODE.
C
   99 CALL RETMCX(2)
      GO TO 9
C
C...     1015 - SURFACE TYPE CHANGED IN NESTED GEOMETRIC DEFINITION
C
   62 CALL ALARM(1015,ERGSTK(100),8,'MATCH   ')
      GO TO 7
       END
**** SOURCE FILE : M0006654.V06   ***
*
C
C              FORTRAN SUBROUTINE MCXTRN
C
C LINKAGE      SUBROUTINE MCXTRN(IBR,INDEX,INFO)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    HELP            SUBROUTINE    ALARM
C          SUBROUTINE    ALARM           SUBROUTINE    IEPLOG
C          SUBROUTINE    AREAD           SUBROUTINE    INPAT
C          SUBROUTINE    AWRITE          SUBROUTINE    INPUT
C          SUBROUTINE    TAPOP           SUBROUTINE    MACREC
C          SUBROUTINE    CHREAD          SUBROUTINE    MOTION
C          SUBROUTINE    CHWRIT          INTEGER FCT.  NUMB
C                                        SUBROUTINE    OPPAIR
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RESERV
C                                        SUBROUTINE    RESRED
C
      SUBROUTINE MCXTRN(IBR,INDEX,INFO)
C
      IMPLICIT INTEGER (A-Z)
C
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NUMBST:      NAMTBL INDEX OF BEGINNING OF NUMBER SECTION
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL ASSEMB
      DIMENSION PRT(7)
C ASSEMB:      SET TRUE INDICATES ASSEMBLY APPROACH (CONTRL/ASMBLE)
      EQUIVALENCE (ASSEMB,PRT(4))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      DIMENSION MACXX1(71)
C MBPTR:       POINTER TO LAST MBREC ENTRY
      EQUIVALENCE (MBPTR,MACXX1(30))
C
C       23.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX2/MACXX2
      DIMENSION MACXX2(902),MBUFF(350,2),MACRTB(200),MBREC(2)
C MBREC:       IDENTIFIES THE RECORDS(350 WORD BLK) CURRENTLY IN MBUFF
      EQUIVALENCE (MBREC(1),MACXX2(1))
C BUFF:        BUFFER ARRAY IN ORDER TO READ OR WRITE ON EXTERNAL FILE
      EQUIVALENCE(MBUFF(1,1),MACXX2( 3))
C MACRTB:      BUFFER ARRAY OF THE EXTERNAL FILE
      EQUIVALENCE (MACRTB(1),MACXX2(703))
C
C       33.    SYMBOLIC FILE DEFINITIONS
C
      INCLUDE (SYMFIL)    
C MACTXT:          EXTERNAL FILE  OF MACRO TEXT
C XNUM  :          OVERFLOW NUMBER TABLE
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NMOD:        NUMBER OF ENTRIES PERMITTED IN INTERNAL NUMBER TABLE
      EQUIVALENCE (NMOD,NTBL(1))
C NCRNT:       ACTUAL NUMBER TABLE BLOCK - INITIALLY 1
      EQUIVALENCE (NCRNT,NTBL(2))
C NNDX:        CONVERSION BETWEEN ABS. AND VIRTUAL NUMBER TABLE POINTER
      EQUIVALENCE (NNDX,NTBL(3))
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C*
C ARGUMENTS    IBR     SET TO 1 FOR STORE, 2 FOR RETRIEVE
C              INDEX   POINTER TO REFERENCED MACRO TEXT WORD
C              INFO    DATA TO BE STORED OR RETRIEVED
C**
      IF(IBR.GT.2)GO TO 500
C
C...     DETERMINE RECORD NUMBER AND WORD NUMBER
C
      ITMP = (INDEX-1)/350
      IREC = ITMP + 1
      IF (IREC.LT.200) GO TO 10
      CALL ALARM(35,0,8,'MCXTRN  ')
      CALL HELP
   10 IWRD = INDEX-350*ITMP
C...  IS THIS RECORD IN THE BUFFERS
      IF (IREC.EQ.MBREC(MBPTR)) GO TO 100
      MBPTR = 3-MBPTR
      IF(IREC.EQ.MBREC(MBPTR)) GO TO 100
C...  WRITE OLD BUFFER TO EXTERNAL FILE
      I = MBREC(MBPTR)
      IF(MACRTB(I).NE.0) GO TO 20
      NREC = 0
      CALL AWRITE(MACTXT,NREC,MBUFF(1,MBPTR),350,IRET)
      MACRTB(I)=NREC
C...  RECORD INDICATOR INDICATES NEW RECORD NUMBER
   20 MBREC(MBPTR) = IREC
      IF(MACRTB(IREC).GT.0) GO TO 30
      IF(IBR.EQ.2) CALL ALARM(35,0,8,'MCXTRN  ')
      GO TO 100
C...  READ IN RECORD
   30 CALL AREAD (MACTXT,MACRTB(IREC),MBUFF(1,MBPTR),350,IRET)
  100 IF(IBR.EQ.2) GO TO 200
C...  STORE INFO
      MBUFF(IWRD,MBPTR)=INFO
      IF(MACRTB(IREC).NE.0) MACRTB(IREC) = 0
      GO TO 400
C...  READ INFO
  200 INFO=MBUFF(IWRD,MBPTR)
      GO TO 400
C
C
C...     NUMBER TABLE OVERFLOW PROCESSING
C
  500 IBRTMP = IBR-2
      GO TO (530,540,550,560),IBRTMP
C
C...  WRITE FIRST PART OF TABLE
C
  530 L=(NMOD*12)/2
      J=0
C... 4TH ARGUMENT OF CHWRIT IS NUMBER OF BYTES
      CALL CHWRIT(XNUM,J,CNUMTB(NUMBST),L,IRET)
      NLAST = NLAST+1
      NNDX = NNDX +(NMOD/2)
      L = NUMBST + (NMOD/2) - 1
      DO 544 I=NUMBST,L
      CNUMTB(I) = ' '
  544 CONTINUE
      GO TO 400
C
C.... WRITE SECOND PART OF TABLE
C
  540 IF(ASSEMB) GO TO 805
      J=0
      I=NUMBST + (NMOD/2)
      L = (NMOD*12)/2
C... 4TH ARGUMENT OF CHWRIT IS NUMBER OF BYTES
      CALL CHWRIT(XNUM,J,CNUMTB(I),L,IRET)
      NLAST = NLAST+1
      NNDX = NNDX + (NMOD/2)
      NCRNT = 2
      GO TO 400
C
C.... READ IN BLOCK CONTAINING INDEX
C
  550 L = NMOD/2
      IF (INDEX.LT.NUMBST) GO TO 400
      ITMP=(INDEX-NUMBST)/L
      INDEX = INDEX - ITMP*L
      IF(ITMP.EQ.NLAST) GO TO 400
      INDEX = INDEX + L
      IF(ITMP+1.EQ.NCRNT) GO TO 400
      NREC = ITMP + 1
      I = NUMBST + L
      L = L*12
C... 4TH ARGUMENT OF CHREAD IS NUMBER OF BYTES
      CALL AREAD (XNUM,NREC,CNUMTB(I),L,IRET)
      NCRNT = NREC
      GO TO 400
C
C
C.... WRITE OUT FINAL RECORD
C
  560 CALL TAPOP (XNUM,-2)
  400 RETURN
  805 CALL ALARM(36,0,8,'MCXTRN  ')
      CALL HELP
      RETURN
      END
**** SOURCE FILE : M0006655.V04   ***
*
C
C              FORTRAN SUBROUTINE MNPROC
C
C LINKAGE      SUBROUTINE MNPROC
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    HELP            SUBROUTINE    MACREC
C          SUBROUTINE    ALARM           SUBROUTINE    PRO026
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          SUBROUTINE    MACLBL
C          SUBROUTINE    RLSLIN
C
      SUBROUTINE MNPROC
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),NUMBER(2),LABEL(2),MACVBL(2)
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C MACVBL:      (1)=CODE CLASS 36000,(2)=NAMTBL INDEX OF 'MACVBL'
      EQUIVALENCE (MACVBL(1),CODE(71))
C
C       11.    SEQUENCE NUMBER STORAGE
C
      COMMON/SEQCOM/SEQCOM
      DIMENSION SEQCOM(3)
C SEQNO:       INTERNALLY GENERATED STATEMENT NUMBER
      EQUIVALENCE (SEQNO,SEQCOM(1))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C ENTRYX:      CONTAINS COMMAND CODE ( 7) FOR ENTRY COMMAND
      EQUIVALENCE (ENTRYX,IL(7))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL ILHLT,FINMAC,ENTRY,MACEND
      DIMENSION MACXX1(71)
C MACDFP:      POINTER TO LAST ENTRY IN MACDF1 AND MACDF2 ARRAYS
      EQUIVALENCE (MACDFP,MACXX1(1))
C MCHSTP:      POINTER TO LAST MACHST ENTRY
      EQUIVALENCE (MCHSTP,MACXX1(3))
C MCSAVP:      PRESENT NEST LEVEL DURING MACRO PROCESSING
      EQUIVALENCE (MCSAVP,MACXX1(5))
C MNMVBP:      POINTER TO LAST MNMVB AND MNMVC TABLE ENTRY
      EQUIVALENCE (MNMVBP,MACXX1(6))
C ILHLT:       TRUE IF I.L. SHOULD NOT BE PLACED IN ILFILE
      EQUIVALENCE (ILHLT,MACXX1(14))
C TEXTST:      POINTER TO MCBUFF OF MACRO TEXT WORD BEING PROCESSED
      EQUIVALENCE (TEXTST,MACXX1(15))
C MAXSPS:      NUMBER OF MACRO VARIABLES+1 FOR CURRENT MACRO
      EQUIVALENCE (MAXSPS,MACXX1(21))
C FINMAC:      TRUE IF SECOND FINAL PASS OF MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C NMLINE:      EQUALS NUMBER OF EXPRESSIONS THAT REQUIRE BRANCHING I.L.
      EQUIVALENCE (NMLINE,MACXX1(25))
C NUMCAL:      CONTAINS NUMBER OF CALLS FOR CURRENT MACRO
      EQUIVALENCE (NUMCAL,MACXX1(28))
C BITWDS:      NUMBER OF WORDS NEEDED FOR ALL CALL QUALITIES OF MACRO
      EQUIVALENCE (BITWDS,MACXX1(29))
C NUMBIT:      CONTAINS NUMBER OF BITS IN A FIXED POINT WORD
      EQUIVALENCE (NUMBIT,MACXX1(56))
C ENTRY:       FALSE ON FIRST ENTRY TO MATCH FOR A MACRO EXPRESSION
      EQUIVALENCE (ENTRY,MACXX1(40))
C MACTOP:      POINTER TO EXPRESSION NUMBER IN MACSPD TABLE
      EQUIVALENCE (MACTOP,MACXX1(42))
C LNUSDP:      INDEX OF LAST LINUSD ENTRY
      EQUIVALENCE (LNUSDP,MACXX1(51))
C MCSPDP:      POINTER TO LAST ENTRY IN MACSPD TABLE
      EQUIVALENCE (MCSPDP,MACXX1(57))
C MCSRCH:      AT FINAL MACRO PRECESSING MACDF1 POINTER
      EQUIVALENCE (MCSRCH,MACXX1(59))
C MACFND:      1 IF NO MACRO OF CURRENT LEVEL ENCOUNTERED. OTHERWISE 0
      EQUIVALENCE (MACFND,MACXX1(60))
C NUMARG:      NUMBER OF MACRO VARIABLES+1 FOR CURRENT MACRO
      EQUIVALENCE (NUMARG,MACXX1(61))
C MACEND:      TRUE WHEN ALL MACRO PROCESSING IS FINISHED
      EQUIVALENCE (MACEND,MACXX1(62))
C WHCHMN:      EQUAL TO NUMBER OF CURRENT MACRO BEING PROCESSED
      EQUIVALENCE (WHCHMN,MACXX1(63))
C LARGMV:      KEEPS TRACK OF LARGEST NUMBER OF MACRO VARIABLES
      EQUIVALENCE (LARGMV,MACXX1(64))
C MSPDDM:      CONTAINS DIMENSION OF THE ARRAY MACSPD
      EQUIVALENCE (MSPDDM,MACXX1(65))
C PATHLN:      CURRENT ACTUAL BRANCHING EXPRESSION. INITIALLY=NUMARG
      EQUIVALENCE (PATHLN,MACXX1(68))
C NXTLN:       POINTER TO NEXT LINUSD POSITION TO BE EXAMINED
      EQUIVALENCE (NXTLN,MACXX1(69))
C PATHCH:      CURRENT ACTUAL BRANCHING EXPRESSION. INITIALLY=NUMARG
      EQUIVALENCE (PATHCH,MACXX1(71))
C
C       24.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX3/MACXX3
      DIMENSION MACXX3(1430),MACDF1(400),MACDF2(400),MACHST(600)
C MACDF1:      STORES MACRO NAME AND ALL MACRO VBL NAMTBL POINTERS
      EQUIVALENCE (MACDF1(1),MACXX3(1))
C MACDF2:      STORES NORMAL VALUES FOR ALL MACRO VARIABLES
      EQUIVALENCE (MACDF2(1),MACXX3(401))
C MACHST:      MACRO CALL HISTORY TABLE
      EQUIVALENCE (MACHST(1),MACXX3(801))
C
C       25.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX4/MACXX4
      DIMENSION MACXX4(100),MNMVB(25),MNMVC(25),MACSEQ(50)
C MNMVB:       INDICATES MACROS IN WHICH ARE ASSIGNED VALUES
      EQUIVALENCE (MNMVB(1),MACXX4(1))
C MNMVC:       CALLED MACRO FOR WHICH CORRESPONDING MNMVB ENTRY IS MADE
      EQUIVALENCE (MNMVC(1),MACXX4(26))
C MACSEQ:      PRESERVES INITIAL SEQUENCE NUMBERS OF THE MACROS
      EQUIVALENCE (MACSEQ(1),MACXX4(51))
C
C      26A.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX6/MACXX6
      DIMENSION MACXX6(1300),MACSPD(1300)
C MACSPD:      NAMTBL POINTERS OF THE ASSIGNED VALUES FOR MACRO CALL
      EQUIVALENCE (MACSPD(1),MACXX6(1))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C
C..... LOCAL ARRAY TO KEEP TRACK OF ASSIGNED VARIABLES TO AVOID
C      CORRUPTING NAME AND NUMBER TABLES
       DIMENSION IASV(6000)
C**
C...     LARGMV KEEPS COUNT OF NUMBER OF MACRO VARIABLES AND LINKAGE
C...     CELLS NEEDED FOR ALL MACROS OF CURRENT LEVEL.
C
      IF(MAXSPS.GT.LARGMV)LARGMV=MAXSPS
C
C...     BRANCH IF NOT FIRST MACRO TO UNDERGO FINAL PROCESSING.
C
      IF(MCSRCH.NE.0)GO TO 35
      MCSAVP = 1
   71 MCSRCH=1
C
C...     BRANCH IF ALL MACROS OF CURRENT LEVEL HAVE BEEN PROCESSED.
C
    1 IF(MCSRCH.GT.MACDFP)GO TO 65
      MCSPDP=0
C
C...       SKIP IF MACRO WAS NOT CALLED
C
      IF(MACDF2(MCSRCH+2).EQ.0)GO TO 35
C
C...     CHECK IF MACRO BEING EXAMINED IS OF CURRENT LEVEL.
C...     = NEGATIVE - MACRO ALREADY PROCESSED.
C...     = ZERO     - PROCESS IT.
C...     = PLUS     - NOT READY TO PROCESS THIS MACRO.
C
    2 IF(MACDF2(MCSRCH)-MCSAVP)35,7,6
C
C...     DETERMINE LOCATION OF NEXT MACRO IN MACDF1 TABLE.
C
   35 IF(MACDF1(MCSRCH+2))3,3,4
    3 MCSRCH=MCSRCH+3
      GO TO 1
    4 MCSRCH=MACDF1(MCSRCH+2)+1
      GO TO 1
C
C...     MACFND SET TO 1 IF NO MACRO OF CURRENT LEVEL ENCOUNTERED.
C...     OTHERWISE SET TO 0.
C
    6 MACFND=IABS(MACFND)
      GO TO 35
    7 MACFND=0
C
C...     COMPUTE BEGINNING (NUMBEG) AND END (NUMARG) OF MACRO VARIABLES
C...     IN THE MACDF1 TABLE.
C
      NUMARG=MACDF1(MCSRCH+2)
    8 NUMBEG=MCSRCH+3
C
C...     INITIALLY ZERO THE MACSPD TABLE PRIOR TO STORING CALL HISTORY.
C
      DO 51 I=1,1300
   51 MACSPD(I)=0
      MCSPDP=1
      IF(NUMARG.NE.0)MCSPDP=NUMARG-MCSRCH-1
C
C...     BEGIN SCANNING THE MACHST TABLE TO RETRIEVE, EXPAND, AND PLACE
C...     IN THE MACSPD TABLE CALL INFORMATION FOR CURRENT MACRO.
C
      L=2
C
C...     DO NOT BRANCH IF CALL INFORMATION FOR CURRENT MACRO FOUND.
C
    9 IF(MACHST(L).NE.MCSRCH)GO TO 5
      K=1
      M=L
      IF(MACHST(L+1).EQ.0)GO TO 91
      IF(NUMARG.EQ.0)GO TO 93
      IF(MCSPDP+NUMARG-NUMBEG+2.LE.MSPDDM)GO TO 94
   95 CALL ALARM(31,0,8,'MNPROC  ')
      CALL HELP
C
C...     PLACE ASSIGNED VALUES FOR THIS CALL IN MACSPD TABLE.
C
   94 DO 12 I=NUMBEG,NUMARG
      IF(K.NE.(MACHST(L+2)/100000))GO TO 10
      MACSPD(MCSPDP+1)=MACHST(L+2)-100000*K
      L=L+1
      GO TO 11
   10 MACSPD(MCSPDP+1)=MACDF2(I)
      IF(NLAST.GT.0)MACSPD(MCSPDP+1)=-MACSPD(MCSPDP+1)
   11 MCSPDP=MCSPDP+1
   12 K=K+1
C
C...     PLACE CALL NUMBER IN MACSPD TABLE.
C
   93 MCSPDP=MCSPDP+1
      IF(MCSPDP.GT.MSPDDM)GO TO 95
      MACSPD(MCSPDP)=MACHST(M+1)
   91 L=L+2
   92 IF(MCHSTP-L)13,14,14
C
C...     NO MORE CALL INFORMATION REMAINS TO BE SCANNED.
C
   13 MCHSTP=M-2
C
C...     BRANCH IF THERE ARE NO MACRO VARIABLES.
C
   18 IF(NUMARG.EQ.0)GO TO 19
      NUMARG=NUMARG-NUMBEG+2
C
C...     GENERATE MACRO VARIABLE NAMES, STORE THEM IN NAMTBL, AND PLACE
C...     THEIR NAMTBL INDICES IN THE MACSPD TABLE.
C
      DO 32 I=2,NUMARG
      CALL MACLBL(-MCSAVP,-I,L)
C      PROTECT NAMTBL ENTRY ON SUBSEQUENT CALLS
      NAMTBL(L) = MACVBL(1)
   32 MACSPD(I-1)=L
C
C...     BRANCH IF NO MACRO VARIABLES HAVE BEEN ASSIGNED MACRO NAMES.
C
   19 IF(MNMVBP.EQ.0)GO TO 20
      I=1
   61 IF(MNMVC(I).NE.MCSRCH)GO TO 62
C
C...     REMOVE REFERENCES TO CURRENT MACRO FROM MNMVC TABLE.
C
      MNMVBP=MNMVBP-1
      MNMVB(I)=MNMVB(MNMVBP+1)
      MNMVC(I)=MNMVC(MNMVBP+1)
   63 IF(MNMVBP.LT.I)GO TO 20
      GO TO 61
   62 I=I+1
      GO TO 63
C
C...     INITIALIZE COUNTERS,POINTERS, AND FLAGS USED IN FINAL MACRO
C...     PROCESSING.
C
   20 TEXTST=MACDF1(MCSRCH+1)
      WHCHMN=MACDF2(MCSRCH+1)
      SEQNO=MACSEQ(WHCHMN)
      ILHLT=.TRUE.
      FINMAC=.FALSE.
      MACTOP=MCSPDP
      ENTRY=.FALSE.
      NMLINE=NUMARG
      NUMCAL=MACDF2(MCSRCH+2)
      IF(NUMARG.EQ.0)GO TO 53
C
C...     FOR EACH MACRO VARIABLE SELECT AS ITS NORMAL VALUE THE MOST
C...     COMMONLY USED ASSIGNED VALUE. ALSO ESTABLISH AS THE CLASS AND
C...     MODE OF EACH MACRO VARIABLE THAT OF ITS FIRST ASSIGNED VALUE.
C
      I=1
   52 I=I+1
      J=MACSPD(I-1)
      L=NUMARG+I
      K=MACSPD(L-1)
      IF((NLAST.GT.0).AND.(K.LT.0))K=-K
      NAMTBL(J)=NUMBER(1)+MODHLF
      IF(K.GT.NAMMAX)GO TO 55
      KK=NAMTBL(K)
      IF(KK-MODULO*(KK/MODULO).LT.MODHLF)KK=KK+MODHLF
      NAMTBL(J)=KK
   55 IF(NLAST.GT.0)GO TO 140
      L=0
C
C...IASV IS USED TO KEEP TRACK OF THE FREQUENCY OF THE ASSIGNED VALUES.
C
      M=I
      DO 109 J=1,NUMCAL
      M=M+NUMARG
      N=MACSPD(M-1)
  109 IASV(N)=0
C
C...     K POINTS TO MOST COMMONLY USED ASSIGNED VALUE.
C...     L KEEPS TRACK OF ITS FREQUENCY.
C
      DO 110 J=1,NUMCAL
      M=J*NUMARG+I
      N=MACSPD(M-1)
      IASV(N)=IASV(N)+1
      IF(N.EQ.K)GO TO 102
      IF(IASV(N).LE.L)GO TO 110
      L=IASV(N)
      K=N
      GO TO 110
  102 L=L+1
  110 CONTINUE
      GO TO 130
C
C...     INITIALIZE PARAMETERS AND COUNTERS USED IN MACRO PROCESSING.
C
   53 BITWDS=(NUMCAL-1)/NUMBIT+1
      MAXSPS=NUMARG
      NXTLN=1
      LNUSDP=0
      PATHLN=NUMARG
      PATHCH=NUMARG
      RETURN
C
C...     COMPRESS MACHST TABLE TO ERASE CURRENT CALL INFORMATION STRING.
C
   14 DO 15 I=L,MCHSTP
      J=I-(L-M+1)
   15 MACHST(J)=MACHST(I)
      MACHST(J+1)=0
      MCHSTP=J
      L=M
      GO TO 9
C
C...     LOCATE NEXT CALL INFORMATION STRING IN MACHST.
C
    5 IF(MACHST(L+2)/100000)16,17,16
   16 L=L+1
      GO TO 5
   17 L=L+3
      IF(L-MCHSTP)9,9,18
   65 IF(LARGMV)27,27,25
C
C...     GENERATE I.L. TRANSFER COMMANDS FOR MACRO VARIABLES AND LINKAGE
C...     CELLS FOR CURRENT MACRO DEPTH LEVEL.
C
   25 DO 26 I=2,LARGMV
      CALL MACLBL(-MCSAVP,-I,L)
      NAMTBL(L) = LABEL(1)
      CALL OPCODE(ENTRYX)
      CALL ONEARG(L)
   26 CALL RLSLIN
   27 IF(MACFND)28,29,30
C
C...     PREPARE TO PROCESS MACROS OF NEXT DEPTH LEVEL.
C
   29 MCSAVP=MCSAVP+1
      LARGMV=0
      MACFND=-1
      IF(MNMVBP.EQ.0)GO TO 73
C
C...     ADJUST DEPTH LEVEL IN MACDF2 TABLE OF THOSE UNPROCESSED MACROS
C...     WHICH ARE MACRO VARIABLE ASSIGNED VALUES.
C
      DO 72 I=1,MNMVBP
      K=MNMVC(I)
   72 IF(MACDF2(K).LE.MCSAVP)MACDF2(K)=MCSAVP+1
C
C...     ADJUST DEPTH LEVEL OF THOSE MACROS WHICH ARE DIRECTLY CALLED BY
C...     UNPROCESSED MACROS WHICH ARE MACRO VARIABLE ASSIGNED VALUES.
C
   73 I=1
   74 IF(I.GT.MCHSTP)GO TO 71
      K=MACHST(I)
      IF(MACDF2(K).LT.MCSAVP)GO TO 75
      J=MACHST(I+1)
      IF(MACDF2(J).LE.MACDF2(K))MACDF2(J)=MACDF2(K)+1
   75 I=I+2
   76 I=I+1
      IF((MACHST(I)/100000).EQ.0)GO TO 74
      GO TO 76
C
C...     NO MORE MACROS REMAIN TO BE PROCESSED.
C
   28 MACEND=.TRUE.
      RETURN
C
C...     1022 - RECURSIVE USE OF MACROS
C
   30 CALL ALARM(1022,0,8,'MNPROC  ')
      GO TO 28
C
C     MARK MOST COMMON ASSIGNMENT
  130 DO 120 L=1,NUMCAL
      J=NUMCAL-L+1
      M = J*NUMARG+I
      N=MACSPD(M-1)
      IF(N.EQ.K)MACSPD(M-1)=-MACSPD(M-1)
  120 CONTINUE
      IF(I.LT.NUMARG) GOTO 52
      GO TO 53
  140 KK=NUMARG+I-1
      K=MACSPD(KK)
      IF(K.LT.0)GO TO 180
      DO 150 L=1,NUMCAL
      J=NUMCAL-L+1
      M=J*NUMARG+I
      N=MACSPD(M-1)
      IF(N.LT.0)GO TO 180
  150 CONTINUE
      DO 160 L=1,NUMCAL
      J=NUMCAL-L+1
      M=J*NUMARG+I
      N=MACSPD(M-1)
      IF(N.EQ.K)MACSPD(M-1)=-MACSPD(M-1)
  160 CONTINUE
  180 IF(I.LT.NUMARG)GO TO 52
      GO TO 53
      END
**** SOURCE FILE : M0006656.V03   ***
*
C
C              FORTRAN SUBROUTINE MODE
C
C LINKAGE      INTEGER FUNCTION MODE(INDEX)
C
C          SUBSIDIARIES                  CALLED BY
C          NONE                          TYPE          ENTRY
C                                        SUBROUTINE    BOOLIF
C                                        SUBROUTINE    GOLO
C                                        SUBROUTINE    INPAT
C                                        SUBROUTINE    LARGES
C                                        SUBROUTINE    LCANON
C                                        SUBROUTINE    LOOP
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    MATCH
C                                        SUBROUTINE    MOTION
C                                        SUBROUTINE    PRO020
C                                        SUBROUTINE    PRO021
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    SSDEF
C                                        SUBROUTINE    SUBCOD
C                                        SUBROUTINE    TSSMIL
C
      INTEGER FUNCTION MODE(INDEX)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),NUMBER(2),TEMP(2),VBL(2)
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C REAL:        MODE CODE (21) FOR REAL
      EQUIVALENCE (REAL,MODX(21))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C*
C ARGUMENTS    INDEX     NAME TABLE (NAMTBL) INDEX OF THE VARIABLE.
C**
C...     IS INDEX THAT OF A NUMBER
C
      IF (INDEX.LE.NAMMAX) GOTO 100
C
C...     YES - MODE = REAL.
C
   10 MODE = REAL
      RETURN
C
C...     SET K TO CLASS OF ITEM.
C
  100 K = MODULO*(NAMTBL(INDEX)/MODULO)
C
C...     IS IT OF CLASS NUMBER
C
      IF (K.EQ.NUMBER(1)) GOTO 10
C
C...     NO. IS IT OF CLASS VBL OR TEMP. IF SO RETURN CORRECT MODE.
C
      IF ((K.NE.VBL(1)).AND.(K.NE.TEMP(1))) GOTO 25
      MODE = NAMTBL(INDEX)-K
C
C...     IS IT A SUBSCRIPT. IF SO RETURN DERIVATIVE MODE.
C
      IF (MODE.GE.MODHLF) MODE = MODE-MODHLF
      RETURN
C
C...     NOT NUMBER, VBL, OR TEMP - SO RETURN ZERO MODE.
C
   25 MODE = 0
      RETURN
       END
**** SOURCE FILE : M0006657.V06   ***
*
C
C              FORTRAN SUBROUTINE MOTION
C
C LINKAGE       SUBROUTINE MOTION
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    CALLZZ          SUBROUTINE    PRO026
C          SUBROUTINE    BCDBIN
C          SUBROUTINE    MACLBL
C          SUBROUTINE    MCXTRN
C          INTEGER FCT.  MODE
C          INTEGER FCT.  NAME
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    RLSLIN
C          SUBROUTINE    TWOARG
C          SUBROUTINE    ALARM
C
       SUBROUTINE MOTION
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),ARGSTK(99)
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),TEMP(2),PERMID(2),LABEL(2),IMPLAB(2),VBL(2)
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C IMPLAB:      (1)=CODE CLASS 23000,(2)=NAMTBL INDEX OF 'IMPLAB'
      EQUIVALENCE (IMPLAB(1),CODE(45))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C
C        8.    NAME TABLE POINTERS TO BCD LITERALS
C
      COMMON/BCDPTR/BCDPTR
      DIMENSION BCDPTR(7)
C DOTAC:       NAMTBL POINTER TO ALPHAMERIC LITERAL '.AC.'
      EQUIVALENCE (DOTAC,BCDPTR(1))
C FEDRAT:      NAMTBL POINTER TO ALPHAMERIC LITERAL 'FEDRAT'
      EQUIVALENCE (FEDRAT,BCDPTR(2))
C TO:          NAMTBL POINTER TO ALPHAMERIC LITERAL 'TO'
      EQUIVALENCE (TO,BCDPTR(3))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12)
C ONEPT:       NAMTBL POINTER TO '1.    '
      EQUIVALENCE (ONEPT,NUMPTR(4))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C VBLJMP:      CONTAINS COMMAND CODE (20) FOR VBLJMP COMMAND
      EQUIVALENCE (VBLJMP,IL(20))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C REAL:        MODE CODE (24) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      DIMENSION MACXX1(71)
C WHCHMN:      EQUAL TO NUMBER OF CURRENT MACRO BEING PROCESSED
      EQUIVALENCE (WHCHMN,MACXX1(63))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C DBLDLR:      CONTAINS OPERAND TYPE CODE 2
      EQUIVALENCE (DBLDLR,OPMOD(3))
C QUIDLR:      CONTAINS OPERAND TYPE CODE 5
      EQUIVALENCE (QUIDLR,OPMOD(6))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136)
C APT200:      NAMTBL POINTER FOR APT200
      EQUIVALENCE (APT200,SUBLST(127))
C APT201:      NAMTBL POINTER FOR APT201
      EQUIVALENCE (APT201,SUBLST(128))
C APT299:      NAMTBL POINTER FOR APT299
      EQUIVALENCE (APT299,SUBLST(131))
C ERROR:       NAMTBL POINTER TO EXECUTION SUBROUTINE ERROR
      EQUIVALENCE (ERROR,SUBLST(132))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       31.    COMMON BLOCK FOR PRO026 AND MOTION
C
      COMMON/COMP26/COMP26
      LOGICAL FEDSAV,FMTERR,MCSJMP,JMPING
      DIMENSION COMP26(16),TAGTBL(3)
C INTOF:       DESIRED DS AND CS INTERSECTION IN MULTIPLE INTERS. CASE
      EQUIVALENCE (INTOF,COMP26(1))
C ARGCNT:      POINTER FOR CURRENT ARGSTK ELEMENT
      EQUIVALENCE (ARGCNT,COMP26(2))
C CSPNTR:      CONTAINS NAMTBL POINTER TO CS
      EQUIVALENCE (CSPNTR,COMP26(3))
C JMPCS:       TAGTBL POINTER
      EQUIVALENCE (JMPCS,COMP26(4))
C NUMBCS:      NUMBER OF CHECK SURFACES
      EQUIVALENCE (NUMBCS,COMP26(5))
C TEST:        NAMTBL INDEX OF CURRENT ARGUMENT
      EQUIVALENCE (TEST,COMP26(6))
C TEST1:       CLASS OF CURRENT ARGUMENT
      EQUIVALENCE (TEST1,COMP26(7))
C FEDSAV:      INDICATES FINAL ARGUMENT MAY BE A FEEDRATE SPECIFICATION
      EQUIVALENCE (FEDSAV,COMP26(8))
C FMTERR:      ERROR FLAG FOR CERTAIN MOTION STATEMENTS
      EQUIVALENCE (FMTERR,COMP26(9))
C MCSJMP:      MULTIBLE CHECK SUBTRACT INDICATOR
      EQUIVALENCE (MCSJMP,COMP26(10))
C JMPING:      INDICATES LABEL POINTER ADDED TO TAGTBL
      EQUIVALENCE (JMPING,COMP26(11))
C K:           NAMTBL POINTER TO MAJOR WORD
      EQUIVALENCE (K,COMP26(12))
C LERR:        ERROR TYPE INDICATOR
      EQUIVALENCE (LERR,COMP26(13))
C TAGTBL:      NAMTBL POINTERS TO LABELS USED AT MULTIBLE CHECK SURFACE
      EQUIVALENCE (TAGTBL(1),COMP26(14))
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C
      CHARACTER*6 ITANTO
      DATA ITANTO/'TANTO '/
C**
C...     GOFWD, GOBACK, GOUP, GODOWN, GOLFT, OR GORGT / ......
C...     INITIALISE CHECK SURFACE COUNT.
C
 1901 NUMBCS=0
C
C...     INITIALIZE MULTIPLE CHECK SURFACE EXISTENCE FLAG.
C
      MCSJMP = .FALSE.
      FMTERR = .FALSE.
      INTOF=0
      LERR=0
      IF (MODE (ARGSTK (1) ) .NE. REAL)  GO TO 13
      TEST = ARGSTK (1)
      IF (TEST .LE. NAMMAX)  GO TO 11
C...  MAY BE A FEDRAT SPECIFICATION
      TEST = ARGSTK (2)
      IF(TEST.GT.NAMMAX)GO TO 11
      I=NAMTBL(TEST)/MODULO
      IF(((I.NE.(VBL(1)/MODULO)).AND.
     / (I.NE.(TEMP(1)/MODULO))))GO TO 11
C...  RESERVE JUDGEMENT
      FEDSAV = .TRUE.
      ARGCNT = 2
      JMPCS=1
      GO TO 16
C...  NO FEDRAT SPECIFICATION IN THIS STATEMENT
   13 ARGCNT = 1
      GO TO 15
C...  FEDRAT SPECIFICATION
   11 ARGCNT = 2
   14 CALL CALLZZ (APT299)
      CALL TWOARG (QUIDLR,1)
      CALL TWOARG (DBLDLR,FEDRAT)
      CALL TWOARG (QUIDLR,1)
      CALL ARGCVT(ARGSTK(1))
      CALL RLSLIN
   15 FEDSAV=.FALSE.
      JMPCS=1
   16 IF(ARGTOP-ARGCNT)17,18,68
   17 CALL ALARM(2020,-ARGTOP,8,'MOTION  ')
      LERR = -1
      GO TO 900
   18 IF(.NOT.FEDSAV) GO TO 19
      IF(NUMBCS.LE.1) GO TO 14
C...  TWO OR MORE CHECK SURFACES HAVE BEEN COUNTED
      TAGTBL(1)=ARGSTK(1)
      JMPCS=1
C...  CHECK MODE OF DRIVE SURFACE FOR ACCEPTABILITY
   19 TEST=MODE(ARGSTK(ARGCNT))
      ERRPT=-ARGCNT
      IF((TEST.LT.1 .OR. TEST.GT.17) .AND.
     1   (TEST.LT.29 .OR. TEST.GT.30)) GO TO 17
C...  RELEASE DRIVE SURFACE CALL TO ARELEM STACK
   20 CALL CALLZZ(APT201)
      CALL ARGCVT (ARGSTK(ARGTOP))
      CALL ARGCVT(K)
      IF(MCSJMP) GO TO 21
  900 RETURN
C...  THE JUMP TABLE (TAGTBL) MUST BE DUMPED FOR PROPER RETURN
   21 CALL RLSLIN
   23 CALL OPCODE(VBLJMP)
      CALL ARGCVT(DOTAC)
      DO 24    I=1,NUMBCS
      TEST=TAGTBL(JMPCS)
 6003 IF(TEST.GT.NAMMAX)GO TO 6005
      IF(WHCHMN.NE.0)GO TO 6002
      GO TO 6006
C     DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
 6005 TEST=TEST-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,TEST,IDUMMY)
      CALL BCDBIN(CNUMTB(TEST),KK,ICOUNT)
      TEST=KK+10000
 6002 CALL MACLBL(TEST,-WHCHMN,TEST)
      IF(NAMTBL(TEST).EQ.0)NAMTBL(TEST)=IMPLAB(1)+WHCHMN
 6006 CALL ONEARG(TEST)
      JMPCS=JMPCS+1
   24 CONTINUE
      GO TO 900
C...  EVALUATE CHECK SURFACE EXPRESSSION
C     IS THE LAST ITEM A SURFACE NAME
   68 TEST = MODE(ARGSTK(ARGCNT))
      IF((TEST.LT.1 .OR. TEST.GT.17) .AND.
     1   (TEST.LT.29 .OR. TEST.GT.30)) GO TO 78
C...  THE LAST ITEM IS THE NAME OF A SURFACE
      CSPNTR=ARGSTK(ARGCNT)
C...  ADVANCE ARGUMENT STACK POINTER
   50 ARGCNT=ARGCNT+1
C...  COMPUTE NAMTBL INDEX OF NEXT ITEM
   69 TEST=ARGSTK(ARGCNT)
C...  WHAT ARE THE MODIFIERS FOR THIS CHACK SURFACE
C     IS THE NEXT ITEM A PERMANENT IDENTIFIER
      IF(TEST.GT.NAMMAX)GO TO 71
      IF(NAMTBL(TEST)/MODULO.NE.PERMID(1)/MODULO)GO TO 71
C...  YES, IS IT DEFINED FOR THIS FORMAT
      L = NAMTBL(TEST) - PERMID(1)
      IF(L.GE.MODHLF)L=L-MODHLF
      IF(L.EQ.6)GO TO 73
      IF(L.EQ.3.OR.L.EQ.4.OR.L.EQ.147) GO TO 6004
C...  NO MATCH FOR THIS ITEM IN DEFINED LIST
C     SET CHECK SURFACE MODIFIER FOR TO STOPPING POSSITION
   71 TEST=0
      GO TO 74
C...  TEST FOR MULTIPLE CHECK SURFACE TAG, SINCE LAST ITM IS NOT SFC
   78 TEST=ARGSTK(ARGCNT)
C...  IS IT A NUMBER
C...  IF IT IS DO NOT CHANGE MODE
      IF (TEST.GT.NAMMAX) GOTO 81
      TEST1 = MODULO*(NAMTBL(TEST)/MODULO)
C...  IS THE LAST ITEM A LABEL OR IMPLIED LABEL
      IF((TEST1.EQ.LABEL(1)).OR.(TEST1.EQ.IMPLAB(1))) GO TO 81
C...  IS IT A PERMANENT IDENTIFIER
      IF(TEST1.EQ.PERMID(1)) GO TO 80
C)..  FORMAT IS NOT-SFC,ID OR SFC.
      CALL ALARM(2022,-ARGCNT,8,'MOTION  ')
      FMTERR =.TRUE.
C...  IGNORE THE UNACCEPTABLE ITEM
      GO TO 50
C...  CHANGE THE MODE ASSIGNMENT
   80 IF(JMPING)GO TO 88
      NAMTBL(TEST)=IMPLAB(1)
C...  ITEM QUALIFIES AS A LABEL OF SOME KIND
C     COMPUTE JMPTBL INDEX,ALLOWING FOR FEDSAV ACTION
   81 I=NUMBCS+JMPCS
      IF(I.GT.3)CALL ALARM(14,-ARGCNT,4,'MOTION  ')
C...  VERIFY WE CAN WRITE INTO TAG TABLE FOR THIS CHECK SURFACE
      IF(JMPING) GO TO 88
      TAGTBL(I)=TEST
      MCSJMP=.TRUE.
C...  INDICATE TAG ADDED TO TAGTBL
      JMPING=.TRUE.
      ARGCNT=ARGCNT+1
C...  GO BACK TO FIND THE ASSOCIATED CHECK SURFACE
      GO TO 68
C...  PERMID DEFINED FOR THIS FORMAT, IS IT INTOF
C...  NO, PICK UP MODIFIER AS HMOD
 6004 ARGCNT=ARGCNT+1
C...  HAVE WE PASSED THROUGH WITHOUT ERROR
   74 IF(FMTERR) GO TO 75
C...  YES, FORMAT SEEMS OK
      NUMBCS=NUMBCS+1
C...  SET UP INTERMEDIATE LANGUAGE CALL FOR THIS CHECK SURFACE
      CALL CALLZZ(APT200)
      IF(TEST)6007,6007,6008
 6007 I=TO
      GO TO 6016
 6008 IF(L.NE.147) GO TO 6015
      I=NAME(ITANTO)
 6016 CALL TWOARG(DBLDLR,I)
      GO TO 6009
 6015 CALL ARGCVT(TEST)
 6009 CALL ARGCVT(CSPNTR)
      IF(INTOF)6010,6010,6011
 6010 CALL ARGCVT(ONEPT)
      GO TO 77
 6011 CALL ARGCVT(INTOF)
C...  RESTORE NORMAL SEETTING FOR INTOF
   77 INTOF=0
C...  ENTER IN ARELEM STACK
      CALL RLSLIN
C...  SHOW TAG MATCHED WITH CHECK SURFACE
      JMPING=.FALSE.
C,..  CHECK TO SEE IF THERE ARE ANY MORE CHECK SURFACES
      GO TO 16
   88 CALL ALARM(2023,1-ARGCNT,8,'MOTION  ')
      LERR=-1
      JMPING=.FALSE.
      GO TO 900
C...  A FORMAT ERROR WAS DETECTED, REQUIRING ARELEM RESTART.
   75 FMTERR=.FALSE.
      CALL CALLZZ(ERROR)
      CALL TWOARG(QUIDLR,83)
      GO TO 77
C...  INTOF MODIFIER DETECTED
   73 TEST=ARGSTK(ARGCNT+1)
      IF (MODE(TEST).NE.REAL) GOTO 76
C...  SPECIFICATION NOT A NUMBER OR SCALAR
   85 INTOF=TEST
      ARGCNT=ARGCNT+2
C...  CHECK FOR OTHER MODIFIERS
      GO TO 69
C...  ERROR IN INTOF FORMAT, WARNING ONLY
   76 CALL ALARM(2024,-ARGCNT-1,4,'MOTION  ')
C...  FMTERR WOULD BE SET HERE IF ARELEM RESTART WERE DESIRED.
      GO TO 50
       END
**** SOURCE FILE : M0006658.W01   ***
*
C
C              FORTRAN SUBROUTINE NAME
C
C LINKAGE      INTEGER  FUNCTION  NAME  (STR)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    COMSTR
C          INTEGER FCT.  BCDF            INTEGER FCT.  GETTMP
C                                        SUBROUTINE    GOLO
C                                        SUBROUTINE    GOPAT
C                                        SUBROUTINE    INPAT
C                                        SUBROUTINE    INPUT
C                                        SUBROUTINE    IPRLOG
C                                        SUBROUTINE    MACLBL
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    MOTION
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    RESRVZ
C                                        SUBROUTINE    VCTPRD
C
      INTEGER  FUNCTION  NAME  (STR)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMEST:      NAMTBL INDEX OF BEGIN OF THE PART PROGRAM NAME SECTION
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C*
C ARGUMENTS    STR     A CHARACTER STRING CONTAINING THE ALPHA
C                      NUMERIC CHARACTERS OF THE SYMBOL.
C
      CHARACTER*6 STR
C**
   10 J=MOD(BCDF(STR),NAMMAX-NAMEST)
      IF (J.LT.0) THEN
        J=J+NAMMAX
      ELSE
        J=J+NAMEST
      ENDIF
      DO 20 I = J,NAMMAX
      IF (NAMTBL(I).EQ.0) GOTO 40
      IF(CNAMTB(I).EQ.STR) GOTO 100
   20 CONTINUE
C
C...       SCAN TABLE FROM BOTTOM UP
C
      DO 30 I = NAMEST,J
      IF (NAMTBL(I).EQ.0) GOTO 40
      IF(CNAMTB(I).EQ.STR) GOTO 100
   30 CONTINUE
C...       TABLE FULL
      CALL ALARM(3001,0,8,'NAME    ')
      RETURN
C
C...       NOT IN TABLE
C
   40 CNAMTB(I)=STR
C...       ENTRY IF NAME FOUND
  100 NAME = I
      IF ((NAMTBL(I) .GE. 0) .OR. (I .GT. NAMMAX))  RETURN
      I = -NAMTBL(I)
      GO TO 100
C
       END
**** SOURCE FILE : M0006659.W02   ***
*
C
C              FORTRAN SUBROUTINE NUMB
C
C LINKAGE      INTEGER FUNCTION NUMB(STR)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C                                        SUBROUTINE    GOLO
C                                      SUBROUTINE    INPAT
C                                        SUBROUTINE    ISSCOD
C                                        SUBROUTINE    LCANON
C                                        SUBROUTINE    PRO021
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    SSDEF
C                                        SUBROUTINE    TSSMIL
C
      INTEGER FUNCTION NUMB(STR)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C CNUMTB:      NUMBER TABLE
C NUMBST:      INDEX OF BEGINNING OF NUMBER SECTION IN CNUMTB
C NUMBND:      INDEX OF END OF NUMBER SECTION IN CNUMTB
C
      INCLUDE (NUMBLK)    
C
C MNMBND:      LAST NAME TABLE ENTRY TO MACRO ASSIGNED NUMBER SECTION
C NUMIDX:      NAMTBL INDEX OF A NUMBER GIVEN IN THE CURRENT STATEMENT
C  NMBRS:      QUANTITY OF NUMBERS IN THE CURRENT STATEMENT
C LSTCHR:      LAST CHARACTER OF A NUMBER
C MASGND:      NAME TABLE INDEX OF SECTION END FOR NUMBERS ASSIGNMENT
C*
C ARGUMENTS    STR     A CHARACTER VARIABLE CONTAINING THE
C                      CHARACTERS OF THE NUMBER
      CHARACTER*12 STR,BLK
      DATA BLK/' '/
C**
      K=NUMIDX+1
      IF (K.LE.NUMBND) THEN
        NUMIDX=K
      ELSE
        DO 20 I=MNMBND,NUMBND
          K=K-1
          IF (CNUMTB(K).EQ.BLK) THEN
            GOTO 40
          ENDIF
   20   CONTINUE
        K=NUMBND
      ENDIF
   40 CNUMTB(K) = STR
      LSTCHR=NUMIDX
      NUMB=K
       END
**** SOURCE FILE : M0006660.V01   ***
*
C
C              FORTRAN SUBROUTINE ONEARG
C
C LINKAGE      SUBROUTINE ONEARG(I)
C
C          SUBSIDIARIES                  CALLED BY
C          NONE                          TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    ASNADZ
C                                        SUBROUTINE    BOOLIF
C                                        SUBROUTINE    CALLZZ
C                                        SUBROUTINE    CALMCX
C                                        SUBROUTINE    ISSCOD
C                                        SUBROUTINE    JUMPZZ
C                                        SUBROUTINE    LABELZ
C                                        SUBROUTINE    LARGES
C                                        SUBROUTINE    LOOP
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    MNPROC
C                                        SUBROUTINE    MOTION
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    REPLAC
C                                        SUBROUTINE    RETMCX
C                                        SUBROUTINE    SSDEF
C                                        SUBROUTINE    SUBCOD
C                                        SUBROUTINE    TSSMIL
C
      SUBROUTINE ONEARG(I)
C
      IMPLICIT INTEGER (A-Z)
C
C       19.    INTERMEDIATE LANGUAGE TEXT
C
      COMMON/ILTEXT/ILTEXT
      LOGICAL COMFIN
      DIMENSION ILTEXT(94),TEXTIN(90)
C COMFIN:      TRUE IF I.L. OPERATION CODE GIVEN
      EQUIVALENCE (COMFIN,ILTEXT(1))
C TPNTRX:      POINTER TO LAST TEXTIN ENTRY
      EQUIVALENCE (TPNTRX,ILTEXT(3))
C TEXTIN:      STORAGE FOR CURRENTLY GENERATED I.L. COMMAND ARGUM.LIST
      EQUIVALENCE (TEXTIN(1),ILTEXT(5))
C*
C ARGUMENTS    I       NAME TABLE (NAMTBL) INDEX OF ARGUMENT
C**
      IF (COMFIN) GOTO 10
      IERROR=3
      GO TO 90
   10 IF (TPNTRX.LT.90) GOTO 20
      IERROR=2
   90 CALL ALARM(IERROR,0,8,'ONEARG  ')
      GO TO 100
   20 TEXTIN(TPNTRX+1) = I
      TPNTRX = TPNTRX+1
  100 RETURN
       END
**** SOURCE FILE : M0006661.V01   ***
*
C
C              FORTRAN SUBROUTINE OPCODE
C
C LINKAGE      SUBROUTINE OPCODE(I)
C
C          SUBSIDIARIES                  CALLED BY
C          NONE                          TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    ASNADZ
C                                        SUBROUTINE    ASNJPZ
C                                        SUBROUTINE    BOOLIF
C                                        SUBROUTINE    CALLZZ
C                                        SUBROUTINE    CALMCX
C                                        SUBROUTINE    GOPAT
C                                        SUBROUTINE    INPAT
C                                        SUBROUTINE    ISSCOD
C                                        SUBROUTINE    JUMPZZ
C                                        SUBROUTINE    LABELZ
C                                        SUBROUTINE    LARGES
C                                        SUBROUTINE    LCANON
C                                        SUBROUTINE    LOOP
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    MNPROC
C                                        SUBROUTINE    MOTION
C                                        SUBROUTINE    PRO021
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    REPLAC
C                                        SUBROUTINE    RESRVZ
C                                        SUBROUTINE    RETMCX
C                                        SUBROUTINE    SSDEF
C                                        SUBROUTINE    SUBCOD
C                                        SUBROUTINE    TSSMIL
C
      SUBROUTINE OPCODE(I)
C
      IMPLICIT INTEGER (A-Z)
C
C       19.    INTERMEDIATE LANGUAGE TEXT
C
      COMMON/ILTEXT/ILTEXT
      LOGICAL COMFIN
      DIMENSION ILTEXT(94)
C COMFIN:      TRUE IF I.L. OPERATION CODE GIVEN
      EQUIVALENCE (COMFIN,ILTEXT(1))
C LENGTH:      NUMBER OF ITEMS IN CURRENT I.L. COMMAND ARGUMENT LIST
      EQUIVALENCE (LENGTH,ILTEXT(2))
C TPNTRX:      POINTER TO LAST TEXTIN ENTRY
      EQUIVALENCE (TPNTRX,ILTEXT(3))
C OPTEXT:      CONTAINS COMMAND CODE FOR CURRENT I.L. COMMAND
      EQUIVALENCE (OPTEXT,ILTEXT(4))
C*
C ARGUMENTS    I     INTEGER CODE FOR CURRENT I.L. COMMAND
C**
      IF(COMFIN)CALL ALARM(4,0,8,'OPCODE  ')
      OPTEXT = I
      LENGTH = 0
      TPNTRX = 0
      COMFIN = .TRUE.
      RETURN
       END
**** SOURCE FILE : M0006662.W01   ***
*
C
C              FORTRAN SUBROUTINE OPPAIR
C
C LINKAGE      SUBROUTINE OPPAIR(BCDPR,OPERND)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    MCXTRN          SUBROUTINE    PRTIL
C          SUBROUTINE    BINBCD
C
      SUBROUTINE OPPAIR(BCDPR,OPERND)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NUMBST:      NAMTBL INDEX OF BEGINNING OF NUMBER SECTION
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C*
C ARGUMENTS    BCDPR     OUTPUT STRING. BCD OF TYPE
C                        DESIGNATION PLACED IN (1:8)
C                        BCD OF SYMBOL (NAME OR NUMBER)
C                        PLACED IN (9:20)
C              OPERND    2 ELEMENT INPUT ARRAY.  TYPE
C                        DESIGNATION CODE IN 1ST ELEMENT.
C                        NAME TABLE (NAMTBL) INDEX OF SYMBOL
C                        IN 2ND ELEMENT.
C**
      DIMENSION OPERND(2)
      CHARACTER*20 BCDPR
      CHARACTER*8  MODIFY(8)
      CHARACTER*4  BLK
      DATA MODIFY(1)/'0'/,
     1     MODIFY(2)/'$'/,
     2     MODIFY(3)/'$$'/,
     3     MODIFY(4)/'$$$'/,
     4     MODIFY(5)/'$$$$'/,
     5     MODIFY(6)/'$$$$$'/,
     6     MODIFY(7)/'$$$$$$'/,
     7     MODIFY(8)/'$$$$$$$'/
      DATA BLK/' '/
      MODFER = OPERND(1)
      ARGMNT = OPERND(2)
      IF (MODFER) 100,200,300
C
C...  MODIFIER IS NEGATIVE (SUBSCRIPT)
C
  100 CALL BINBCD(-MODFER,BCDPR(1:8),COUNT)
      GOTO 400
C
C...  MODIFIER IS ZERO
C
  200 BCDPR(1:8)=MODIFY(1)
      GOTO 400
C
C...  MODIFIER IS POSITIVE (NO. OF DOLLAR SIGNS)
C
  300 BCDPR(1:8)=MODIFY(MODFER+1)
      GOTO (500,400,400,400,600,500,500),MODFER
C
C...  ARGUMENT IS VARIABLE OR PROCEDURE INDEX
C
  400 BCDPR(9:20) = CNAMTB(ARGMNT)
      RETURN
C
C...  ARGUMENT IS REAL OR INTEGER CONSTANT INDEX
C
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
  500 ARGMNT=ARGMNT-NAMMAX
      IF((NLAST.GT.0).AND.(ARGMNT.GE.NUMBST))
     /  CALL MCXTRN(5,ARGMNT,IDUMMY)
      BCDPR(9:20)=CNUMTB(ARGMNT)
      RETURN
C
C...  ARGUMENT IS INTEGER CONSTANT
C
  600 CALL BINBCD(ARGMNT,BCDPR(9:16),COUNT)
      BCDPR(17:20) = BLK
      RETURN
       END
**** SOURCE FILE : M0006663.V03   ***
*
C
C              FORTRAN SUBROUTINE PATH
C
C LINKAGE      SUBROUTINE PATH
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    CALMCX          SUBROUTINE    INPUT
C          SUBROUTINE    MACLBL          SUBROUTINE    PRO020
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    REPLAC
C
      SUBROUTINE PATH
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      DIMENSION MACXX1(71)
      LOGICAL SHOULD
C MCSAVP:      PRESENT NEST LEVEL DURING MACRO PROCESSING
      EQUIVALENCE (MCSAVP,MACXX1(5))
C WAY:         INDICATES TYPE OF MACRO PROCESSING
      EQUIVALENCE (WAY,MACXX1(26))
C LNUSDP:      INDEX OF LAST LINUSD ENTRY
      EQUIVALENCE (LNUSDP,MACXX1(51))
C NUMARG:      NUMBER OF MACRO VARIABLES+1 FOR CURRENT MACRO
      EQUIVALENCE (NUMARG,MACXX1(61))
C PATHLN:      CURRENT ACTUAL BRANCHING EXPRESSION. INITIALLY=NUMARG
      EQUIVALENCE (PATHLN,MACXX1(68))
C NXTLN:       POINTER TO NEXT LINUSD POSITION TO BE EXAMINED
      EQUIVALENCE (NXTLN,MACXX1(69))
C SHOULD:      MACRO INDICATOR. NORMALLY FALSE
      EQUIVALENCE (SHOULD,MACXX1(70))
C PATHCH:      CURRENT ACTUAL BRANCHING EXPRESSION. INITIALLY=NUMARG
      EQUIVALENCE (PATHCH,MACXX1(71))
C
C      26A.    MACRO PROCESSING ARRAYS
C
      COMMON/MACXX7/MACXX7
      DIMENSION MACXX7(182),LINUSD(50)
C LINUSD:      NUMBERS OF EXPRESSIONS REQUIRING BRANCHING FOR MACROS
      EQUIVALENCE (LINUSD(1),MACXX7(1))
C**
      PATHLN=PATHLN+1
      IF(NUMARG.EQ.0)GO TO 1
      IF(NXTLN.LE.LNUSDP)GO TO 3
    1 SHOULD=.TRUE.
    2 RETURN
    3 IF(PATHLN.NE.LINUSD(NXTLN))GO TO 1
      PATHCH=PATHCH+1
      CALL MACLBL(-MCSAVP,-PATHCH,I)
      NAMTBL(I)=1
      J=0
      IF(WAY.EQ.5)J=MCSAVP
      CALL CALMCX(I,J,2)
      SHOULD=.FALSE.
      NXTLN = NXTLN + 1
      RETURN
       END
**** SOURCE FILE : M0006665.W01   ***
*
C
C              FORTRAN SUBROUTINE PRO020
C
C LINKAGE      SUBROUTINE PRO020(TIP)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    MATCH           SUBROUTINE    RECOG
C          SUBROUTINE    ARGCVT
C          INTEGER FCT.  MODE
C          LOGICAL FCT.  IFTMP
C          SUBROUTINE    ARGGEN
C          SUBROUTINE    PATH
C          SUBROUTINE    PRO021
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  SEARCH
C          SUBROUTINE    SETMOD
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    TWOARG
C          SUBROUTINE    ALARM
C          INTEGER FCT.  GETTMP
C
      SUBROUTINE PRO020(TIP)
C
      IMPLICIT INTEGER (A-Z)
C
C              FUNCTION DECLARATION
C
      LOGICAL IFTMP
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),NUMBER(2),GEOM(2),TEMP(2),PERMID(2),VBL(2),I
     *          DENT(2)
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C GEOM:        (1)=CODE CLASS 16000,(2)=NAMTBL INDEX OF 'GEOM  '
      EQUIVALENCE (GEOM(1),CODE(31))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(502),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        5.    PROGRAM CONTROL FLAGS
C
      COMMON/FLAGS/FLAGS
      LOGICAL NEWSTM
      DIMENSION FLAGS(4)
C NEWSTM:      TRUE WHEN NEXT SOURCE STATEMENT REQUESTED FOR PROCESS
      EQUIVALENCE (NEWSTM,FLAGS(2))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12)
C ZERO:        NAMTBL POINTER TO '0     '
      EQUIVALENCE (ZERO,NUMPTR(1))
C ONE:         NAMTBL POINTER TO '1     '
      EQUIVALENCE (ONE,NUMPTR(3))
C
C       10.    TABLE STORAGE FOR GEOMETRIC FUNCTION PROCESSOR
C
      INCLUDE (GMTY)    
C GEOLOC:      GEOMETRIC PRODUCTION STARTING INDEX IN GEOMTB
C PMIDTB:      INTERNAL BIT REPRESENTATIONS FOR EACH ELEMENT OF GEOMTB
C ARGMXY:      CONTAINS THE NAMTBL INDICES THAT REPLACE MINOR WORDS
C GEOMTB:      GEOMETRIC FORMAT PRODUCTIONS ARRANGED BY SURFACE TYPE
C
C       12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE
      LOGICAL PARDEF
      DIMENSION CFSIZE(205),MAXSIZ(2),CANSIZ(2,100)
C CANTOP:      POINTER TO THE LAST CANSIZ ENTRY
      EQUIVALENCE (CANTOP,CFSIZE(1))
C PARDEF:      TRUE WHEN PART PROGRAM CONTAINS PARAMETRIC SURFACES
      EQUIVALENCE (PARDEF,CFSIZE(2))
C MAXSIZ:      SIZE OF THE LAST LARGEST LARGE DATA ARRAY
      EQUIVALENCE (MAXSIZ(1),CFSIZE(4))
C CANSIZ:      NUMBER OF ITEMS A. NAMTBL INDEX OF EACH LARGE DATA ARRAY
      EQUIVALENCE (CANSIZ(1,1),CFSIZE(6))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C PARSRF:      MODE CODE (15) FOR PARAMETRIC SURFACE
      EQUIVALENCE (PARSRF,MODX(15))
C REAL:        MODE CODE (24) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C BOUNDS:      MODE CODE (27) FOR BOUNDS
      EQUIVALENCE (BOUNDS,MODX(27))
C OBJECT:      MODE CODE (28) FOR OBJECT
      EQUIVALENCE (OBJECT,MODX(28))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL FINMAC,ENTRY,NESTG,SHOULD
      DIMENSION MACXX1(71)
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C MAJWRD:      CONTAINS ACTUAL MAJOR WORD
      EQUIVALENCE (MAJWRD,MACXX1(23))
C FINMAC:      TRUE IF SECOND FINAL PASS OF MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C WAY:         INDICATES TYPE OF MACRO PROCESSING
      EQUIVALENCE (WAY,MACXX1(26))
C ENTRY:       FALSE ON FIRST ENTRY TO MATCH FOR A MACRO EXPRESSION
      EQUIVALENCE (ENTRY,MACXX1(40))
C NESTG:       TRUE WHEN A NESTED GEOMETRIC EXPRESSION ENCOUNTERED
      EQUIVALENCE (NESTG,MACXX1(45))
C SHOULD:      MACRO INDICATOR. NORMALLY FALSE
      EQUIVALENCE (SHOULD,MACXX1(70))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C DBLDLR:      CONTAINS OPERAND TYPE CODE 2
      EQUIVALENCE (DBLDLR,OPMOD(3))
C QUIDLR:      CONTAINS OPERAND TYPE CODE 5
      EQUIVALENCE (QUIDLR,OPMOD(6))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136),APTXXX(120)
C APTXXX:      NAMTBL POINTERS FOR XECUTION SUBROUTINE NAMES
      EQUIVALENCE (APTXXX(1),SUBLST(1))
C UNDEF:       NAMTBL POINTER TO EXECUTION SUBROUTINE UNDEF
      EQUIVALENCE (UNDEF,SUBLST(74))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ESTACK,ERGSTK
      DIMENSION ERRPOS(302),ESTACK(100),ERGSTK(100)
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C ERGSTK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN ARGSTK
      EQUIVALENCE (ERGSTK(1),ERRPOS(203))
C*
C ARGUMENTS    TIP      CURRENT PRODUCTION NUMBER
C
      DIMENSION II(3),MM(5),QQ(3),SLL(2),NORMAL(2)
      DIMENSION  JLIST(11)
      CHARACTER*6 NODER,DERIV
      DATA NODER/'NODER'/,DERIV/'DERIV'/
C**
      K = STACK(1,TOP-1)
      IF(K.GT.NAMMAX)GO TO 50
      IF (IFTMP(K)) CALL PUTTMP(MOD(NAMTBL(K),MODULO))
      I=NAMTBL(K)/MODULO
      L=NAMTBL(K)-I*MODULO
      IF((I.EQ.IDENT(1)/MODULO).AND.(L.NE.0))
     /CALL SETMOD(TOP-1,PERMID)
C     PLACE FIRST ARGUMENT IN ARGSTK
   50 ARGSTK(ARGTOP+1)=K
      ERGSTK(ARGTOP+1)=ESTACK(TOP-1)
      MAJWRD=STACK(1,TOP-3)
      KMODE = NAMTBL(MAJWRD)-GEOM(1)
      IF (KMODE.GT.MODHLF) KMODE=KMODE-MODHLF
C... DETERMINE SIZE OF BOUNDS OR OBJECT CANONICAL FORM
      IF(KMODE.EQ.BOUNDS)TXXXX(1,KMODE)=ARGTOP+2
      IF(KMODE.EQ.OBJECT)TXXXX(1,KMODE)=2*ARGTOP+2
      IF (TIP.EQ.37) GO TO 201
      RESULT=STACK(1,TOP-5)
      K = MODULO*(NAMTBL(RESULT)/MODULO)
      IF((K.EQ.VBL(1)).OR.(K.EQ.TEMP(1))) GO TO 202
      NAMTBL(RESULT) = VBL(1)+KMODE
      CALL RESRVZ(RESULT,KMODE,TXXXX(1,KMODE),1)
      GO TO 202
  201 RESULT=GETTMP(KMODE)
      NESTG=.TRUE.
  202 ARGSTK(ARGTOP+2)=RESULT
      ARGTOP=ARGTOP+2
      IF (INTMED .NE. 1)  GO TO 206
      WAY=1
      IF(FINMAC)GO TO 204
      ERGSTK(100)=TOP-3
      CALL MATCH
      IF((.NOT.ENTRY).AND.(TIP.EQ.38))GO TO 998
  228 KMODE=NAMTBL(MAJWRD)-GEOM(1)
      IF (KMODE.GT.MODHLF) KMODE=KMODE-MODHLF
      GO TO 206
  204 CALL PATH
      IF(.NOT.SHOULD) GO TO 998
  206 L = MODE(RESULT)
      IF(L.EQ.KMODE)GO TO 207
C
C... IF THIS VARIABLE HAS BEEN PREVIOUSLY DEFINED WITH ANOTHER MODE,
C... ISSUE ERROR AND TERMINATE PROCESSING.
      CALL ALARM(1001,TOP-5,8,'PRO020  ')
      GO TO 998
C
C... IF THIS VARIABLE HAS BEEN PREVIOUSLY DEFINED WITH THE SAME MODE,
C... ISSUE WARNING AND CONTINUE PROCESSING
  207 IF((K.EQ.VBL(1)).AND.(INTMED.EQ.0))
     *                          CALL ALARM(50,TOP-5,4,'PRO020  ')
C....    BYPASS IDENTIFIER PROCESSING IF PARAMETRIC SURFACE DEFINITION
      IF(KMODE.EQ.PARSRF)GO TO 1000
      K=TOP+1
      STACK(2,K) = - 1
      DO 211 I=2,ARGTOP
      K=K+1
      L=ARGSTK(I-1)
      ERRPT=1-I
      IF (L .LE. NAMMAX)  GO TO 205
      IARG = REAL
      GOTO 208
  205 M = MODULO * (NAMTBL(L)/MODULO)
      IARG = NAMTBL(L)-M
      IF(IARG.GE.MODHLF)IARG=IARG-MODHLF
  210 IF ((M .EQ. VBL(1)) .OR. (M .EQ. TEMP(1))) GO TO 208
      IF (M .EQ. PERMID(1))  GO TO 209
      IF (M.NE.NUMBER(1)) GOTO 999
      IARG = REAL
      GOTO 208
C
C...     PLACE NAMTBL POINTER OF INTEGER EQUIVALENT OF THE IDENTIFIER
C...         (POSX,XLARGE,ETC.) IN ARGSTK. IF ARGMXY CONTAINS 0 FOR
C...         THIS IDENTIFIER LEAVE ORIGINAL POINTER IN ARGSTK.
C
  209 IF(IARG.EQ.0) GO TO 999
      IF(ARGMXY(IARG).NE.0) ARGSTK(I-1)=ARGMXY(IARG)+NAMMAX
      IARG = IARG + 50
  208 STACK(2,K)=PMIDTB(IARG)
  211 CONTINUE
   90 L=GEOLOC(KMODE)
      ERRPT=ARGTOP-1
      KT2=K*2
      I=SEARCH(STACK,KT2,GEOMTB(L),ERRPT)
C
C... BRANCH ON HUNDREDS POSITION OF GEOMETRIC ACTION NUMBER.
C
      J = I/100 + 1
      ERRP=ERRPT
      GO TO (100,100,100,1000,2000),J
  100 CALL PRO021(RESULT,I,ERRP)
  998 IF(.NOT.ENTRY)GO TO 20
      ERGSTK(100)=0
      CALL MATCH
      IF(ENTRY)GO TO 228
C
C... ADJUST STACK AND EXIT  ..........................................
C
   20 IF(TIP-38)225,226,227
  225 TOP=TOP-4
      NEST G = .FALSE.
  230 STACK(1,TOP)=RESULT
      K = NAMTBL(RESULT)/MODULO
      STACK(2,TOP)=META(K)
  231 ARGTOP=0
  995 RETURN
  226 NEWSTM = .TRUE.
      GO TO  231
  227 TOP=TOP-6
      GO TO  230
C
  999 CALL ALARM(2001,ERRPT,8,'PRO020  ')
 1001 CALL CALLZZ(UNDEF)
      CALL ARGCVT(RESULT)
      CALL RLSLIN
      ARGTOP = 0
      GO TO 998
C
C        ***************************************************
C        **** PARAMETRIC SURFACE DEFINITION PROCESSING  ****
C        ***************************************************
C
 1000 IF (TIP.EQ.37) GO TO 1057
C...     PROCESS EACH PARAMETER IN THE PARSRF DEFINITION. CHECK FOR A
C...     VARIABLE OR IDENTIFIER-OTHERWISE ISSUE DIAGNOSTIC.
 1010 DO 1040 L=2,11
      K=L
      IF (K .GE. ARGTOP) GO TO 1042
      KARG=ARGTOP-K
      J=ARGSTK(KARG)
C...     SAVE NAME TABLE POINTER FOR FINAL CALL ARGUMENT LIST
      JLIST(K)=J
      IF (K .EQ. 4) GO TO 1030
      IF(J.GT.NAMMAX)GO TO 1059
      IF (NAMTBL(J).EQ.VBL(1)+REAL)  GO TO 1040
      IF(NAMTBL(J).NE.PERMID(1).AND.NAMTBL(J).NE.IDENT(1))GOTO 1059
C...     SET MODE OF THIS PARAMETER TO REAL VARIABLE.
      NAMTBL(J) = VBL(1)+REAL
      CALL RESRVZ(J,REAL,TXXXX(1,REAL),1)
      GO TO 1040
C
C...     CHECK FOURTH ARGUMENT FOR DERIV OR NODER.
C...     FOR DERIV-PASS ONE, FOR NODER-PASS ZERO.
 1030 IF(J.GT.NAMMAX)GO TO 1060
      IF (CNAMTB(J).EQ.DERIV)
     +    JLIST(K)=ONE
      IF (CNAMTB(J).EQ.NODER)
     +    JLIST(K)=ZERO
      IF (JLIST(K).NE.ONE .AND. JLIST(K).NE.ZERO) GO TO 1060
C
 1040 CONTINUE
C...     TOO MANY PARAMETERS IN THIS DEFINITION (LIMIT IS 10)
      GO TO 1061
C
C...     PASS A TEMPORARY FOR ALL UNUSED SURFACE PARAMETERS
 1042 IF (K .EQ. 11) GO TO 1047
      IF (K .LT. 5) GO TO 1061
      DO 1045 L=K,10
      KARG=GETTMP(REAL)
      JLIST(L)=KARG
 1045 CONTINUE
C
C...     GENERATE A CALL TO APT101 WITH APPROPRIATE ARGUMENTS
 1047 CALL CALLZZ(APTXXX(95))
      CALL ARGCVT(ARGSTK(ARGTOP))
      DO 1050 L=2,10
      CALL ARGCVT(JLIST(L))
      IF (L.EQ.4) CALL TWOARG(DBLDLR,ARGSTK(ARGTOP-1))
 1050 CONTINUE
C
C...     DEFINITION PROCESSING FINISHED
      ARGTOP=0
      PARDEF=.TRUE.
      CALL RLSLIN
      GO TO 998
C
C....    ERROR PROCESSING
C
 1057 IERR=7
      ERRPT=TOP-3
      GO TO 1070
 1059 IERR=9
      GO TO 1062
 1060 IERR=10
      GO TO 1062
 1061 IERR=11
 1062 ERRPT=-KARG
C
 1070 CALL ALARM(IERR,ERRPT,8,'PRO020  ')
C....    GENERATE A CALL TO UNDEF FOR THIS SURFACE
      GO TO 1001
C
C
C ********************************************************************
C... RULED SURFACE DEFINITION STATEMENT PROCESSING
C ********************************************************************
C
C... COMPRESS ARGSTK TO REMOVE RESULT AND SET LENGTH = NUMBER OF
C... ARGUMENTS IN PART PROGRAMMING STATEMENT
C
 2000 ARGTOP = ARGTOP - 1
      LENGTH = ARGTOP
C
C... CHECK FOR VALID NUMBER OF ARGUMENTS
C
      IF (((I .EQ. 401) .AND. (LENGTH .EQ. 5)) .OR. ((I .EQ. 402) .AND.
     / (LENGTH .EQ. 8)))  GO TO 2005
      ERRPT=5+I/402*3-ARGTOP
      IF(ERRPT.GT.0)ERRPT=-1
      GO TO 999
C
C... CALCULATE THE SIZE OF THE EXTERNAL CANONICAL FORM.
C...
C... SIZE OF FORM GENERATED FROM 5 ARGUMENT STATEMENT = SIZE OF
C... SURFACE IN FIRST ARGUMENT + 39
C...
C... SIZE OF FORM GENERATED FROM 8 ARGUMENT STATEMENT = SIZE OF
C... SURFACE IN FIRST ARGUMENT + SIZE OF SURFACE IN FIFTH ARGUMENT + 48
C
 2005 NOWRDS = 42
      IF(LENGTH.EQ.5) NOWRDS = 46
      DO 2030 J = 4,ARGTOP,4
      KK = ARGSTK(J)
      ERRPT=J
      IF(LENGTH.NE.5) GOTO 2006
      KK = ARGSTK(J+1)
      ERRPT=J+1
 2006 K = MODE (KK)
      IF(K.NE.11) GO TO 2020
C
C... SURFACE IS A TABCYL. SEARCH FOR ITS SIZE IN CANSIZ.
C
      L = KK - (CANTOP*(KK/CANTOP))
      DO 2010  M = 1,CANTOP
      L = L + 1 - (CANTOP*(L/CANTOP))
      IF(CANSIZ(2,L).NE.KK) GO TO 2010
      NOWRDS = NOWRDS + CANSIZ(1,L) + 13
      GO TO 2030
 2010 CONTINUE
C
C... TABCYL NOT FOUND. CALL ALARM.
C
      CALL ALARM(1026,-ERRPT,8,'PRO020  ')
      GO TO 1001
C
C... SURFACE IS NOT A TABCYL. GET ITS SIZE FROM TXXXX.
C
 2020 NOWRDS = NOWRDS + TXXXX(1,K) + 13
 2030 CONTINUE
C
C... CHECK IF THIS RLDSRF IS ONE OF THE TWO LARGEST LARGE DATA ARRAY
C... CANONICAL FORMS ENCOUNTERED AND IF SO, SAVE ITS SIZE IN MAXSIZ.
C
      IF(NOWRDS.LE.(IABS(MAXSIZ(1))))GO TO 2050
      MAXSIZ(2) = MAXSIZ(1)
      MAXSIZ(1) = NOWRDS
      GO TO 2060
 2050 IF(NOWRDS.GT.(IABS(MAXSIZ(2))))MAXSIZ(2)=NOWRDS
C
C... GENERATE CALL TO APT033.
C
 2060 CALL CALLZZ(APTXXX(59))
      CALL ARGGEN
      IF (LENGTH .EQ. 8)  GO TO 2080
C
C... 5 ARGUMENT FORMAT - ZERO ARGUMENTS 6-8 IN CALL TO APT033.
C
      DO 2070  J = 1,3
 2070 CALL ARGCVT(ZERO)
C
C... INSERT LENGTH AND RESULT AS ARGUMENTS 9 AND 10 OF CALL.
C
 2080 CALL TWOARG(QUIDLR,LENGTH)
      CALL ARGCVT(RESULT)
      CALL RLSLIN
      GO TO 998
      END
**** SOURCE FILE : M0006666.W01   ***
*
C
C              FORTRAN SUBROUTINE PRO021
C
C LINKAGE      SUBROUTINE PRO021(RESULT,I,ERRP)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    CALLZZ          SUBROUTINE    PRO020
C          INTEGER FCT.  MODE
C          INTEGER FCT.  NUMB
C          INTEGER FCT.  GETTMP
C          SUBROUTINE    OPCODE
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    REFGEN
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  SEARCH
C          SUBROUTINE    TWOARG
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    ALARM
C          SUBROUTINE    ARGGEN
C
      SUBROUTINE PRO021(RESULT,I,ERRP)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C IFIXST:      NAMTBL INDEX OF BEGINNING OF FIXED POINT NUMBER SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),GEOM(2)
C GEOM:        (1)=CODE CLASS 16000,(2)=NAMTBL INDEX OF 'GEOM  '
      EQUIVALENCE (GEOM(1),CODE(31))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12),IARG(8)
C ZERO:        NAMTBL POINTER TO '0     '
      EQUIVALENCE (ZERO,NUMPTR(1))
C ZEROPT:      NAMTBL POINTER TO '0.    '
      EQUIVALENCE (ZEROPT,NUMPTR(2))
C ONE:         NAMTBL POINTER TO '1     '
      EQUIVALENCE (ONE,NUMPTR(3))
C ONEPT:       NAMTBL POINTER TO '1.    '
      EQUIVALENCE (ONEPT,IARG(1),NUMPTR(4))
C TWO:         NAMTBL POINTER TO '2     '
      EQUIVALENCE (TWO,NUMPTR(5))
C THREE:       NAMTBL POINTER TO '3     '
      EQUIVALENCE (THREE,NUMPTR(6))
C
C       10.    TABLE STORAGE FOR GEOMETRIC FUNCTION PROCESSOR
C
      INCLUDE (GMTY)    
C GEOLOC:      GEOMETRIC PRODUCTION STARTING INDEX IN GEOMTB
C GEOMTB:      GEOMETRIC FORMAT PRODUCTIONS ARRANGED BY SURFACE TYPE
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C FSUB:        CONTAINS COMMAND CODE ( 2) FOR FSUB COMMAND
      EQUIVALENCE (FSUB,IL(2))
C MOVE:        CONTAINS COMMAND CODE (19) FOR MOVE COMMAND
      EQUIVALENCE (MOVE,IL(19))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C LINE:        MODE CODE ( 1) FOR LINE
      EQUIVALENCE (LINE,MODX(1))
C MATRIX:      MODE CODE (18) FOR MATRIX
      EQUIVALENCE (MATRIX,MODX(18))
C POINT:       MODE CODE (19) FOR POINT
      EQUIVALENCE (POINT,MODX(19))
C VECTOR:      MODE CODE (20) FOR VECTOR
      EQUIVALENCE (VECTOR,MODX(20))
C BOUNDS:      MODE CODE (27) FOR BOUNDS
      EQUIVALENCE (BOUNDS,MODX(27))
C OBJECT:      MODE CODE (28) FOR OBJECT
      EQUIVALENCE (OBJECT,MODX(28))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136),APTXXX(120)
C APTXXX:      NAMTBL POINTERS FOR XECUTION SUBROUTINE NAMES
      EQUIVALENCE (APTXXX(1),SUBLST(1))
C UNDEF:       NAMTBL POINTER TO EXECUTION SUBROUTINE UNDEF
      EQUIVALENCE (UNDEF,SUBLST(74))
C DEFEXT:      NAMTBL POINTER TO EXECUTION SUBROUTINE DEFEXT
      EQUIVALENCE (DEFEXT,SUBLST(82))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       30.    NAMTBL POINTERS TO FIRST CANONICAL FORMS IN EACH BLOCK
C              NAMTBL POINTER TO FIRST CANONICAL FORMS IN EACH BLOCK
      COMMON/BLKCFS/FIRST
      DIMENSION FIRST(2,3)
C
C       35.    COMMON BLOCK FOR BOUNDED GEOMETRY AND CFSAVE
C
      COMMON/BGEOM/BGEOM
      DIMENSION BGEOM(4)
C IFBNDS:      VALUE 1 IF BOUNDED GEOMETRY IS INCLUDED IN PART PROGRAM
      EQUIVALENCE (IFBNDS,BGEOM(1))
C*
C ARGUMENTS    RESULT  ARRAY TO CONTAIN CANONICAL FORM WHEN
C                      I.L. IS EXECUTED
C              I       CURRENT PRODUCTION NUMBER
C**
      DIMENSION NARG(7,38),IARGZ(38),P(5),ICF(300)
      CHARACTER*12 ITWOPT
      DATA ITWOPT/'2.          '/
C
C    STEUER DATEN FUER ERWEITERTE PUNKT/VECTOR-DEFINITIONEN
      DATA NARG/
C   201: PT/IN, SC,P/F,  R       ;202:PT/IN, SC,P/F,  R,  R
     1       -12, 3, 0, 2, 1, 0, 0,       -12, 4, 0, 3, 2, 1, 0,
C   203: PT/IN, SS,  R,  R       ;204:PT/IN, SS,  R,  R,  R
     2       -14, 3, 0, 2, 1, 0, 0,       -14, 4, 0, 3, 2, 1, 0,
C   205: PT/IN, SS,P/F,  R,R,R   ;206:PT/IN,L/P, SC, PT
     3       -14, 5, 0, 3, 2, 1, 0,       -13, 2, 0, 0, 3, 1, 0,
C   207: PT/IN, SS, PT, PT       ;208:PT/IN, SS,P/F, PT, PT
     4       -16, 3, 0, 2, 0, 1, 0,       -16, 4, 0, 2, 0, 1, 0,
C   209: PT/IN, SS, PT, VT, PT   ;210:PT/IN, SS,P/F, PT, VT, PT
     5       -18, 4, 0, 3, 2, 1, 0,       -18, 5, 0, 3, 2, 1, 0,
C   211: PT/IN, SS, PT, VT       ;212:PT/IN, SS,P/F, PT, VT
     6       -17, 3, 0, 2, 1, 0, 0,       -17, 4, 0, 2, 1, 0, 0,
C   213: PT/IN, SS, PT           ;214:PT/IN, SS,P/F, PT
     7       -15, 2, 0, 1, 0, 0, 0,       -15, 3, 0, 1, 0, 0, 0,
C   215: VT/IN, SC,P/F,  R,TA1, U;216:VT/IN, SC,P/F,  R,  R,TA1, U
     8       -12, 5, 2, 4, 3, 0, 1,       -12, 6, 2, 5, 4, 3, 1,
C   217: VT/IN, SC,P/F,  R,TA1   ;218:VT/IN, SC,P/F,  R,  R,TA1
     9       -12, 4, 1, 3, 2, 0, 0,       -12, 5, 1, 4, 3, 2, 0,
C   219: VT/IN, SS,  R,  R,TA2, U;220:VT/IN, SS,  R,  R,  R,TA2, U
     A       -14, 5, 2, 4, 3, 0, 1,       -14, 6, 2, 5, 4, 3, 1,
C   221: VT/IN,SS,P/F,R,R,R,TA2,U;222:VT/IN, SS,  R,  R,TA2
     A       -14, 7, 2, 5, 4, 3, 1,       -14, 4, 1, 3, 2, 0, 0,
C   223: VT/IN, SS,  R,  R, R,TA2;224:VT/IN, SS,P/F,  R,  R,  R,TA2
     B       -14, 5, 1, 4, 3, 2, 0,       -14, 6, 1, 4, 3, 2, 0,
C   225: VT/IN,L/P, SC, PT,TA1   ;226:VT/IN,L/P, SC, PT,TA1, U
     B       -13, 3, 1, 0, 4, 2, 0,       -13, 4, 2, 0, 5, 3, 1,
C   227: VT/IN, SS, PT,TA2       ;228:VT/IN, SS, PT,TA2, U
     C       -15, 3, 1, 2, 0, 0, 0,       -15, 4, 2, 3, 0, 0, 1,
C   229: VT/IN, SS,P/F, PT,TA2   ;230:VT/IN, SS, PT, PT,TA2
     D       -15, 4, 1, 2, 0, 0, 0,       -16, 4, 1, 3, 0, 2, 0,
C   231: VT/IN, SS, PT, PT,TA2, U;232:VT/IN, SS,P/F, PT, PT,TA2
     E       -16, 5, 2, 4, 0, 3, 1,       -16, 5, 1, 3, 0, 2, 0,
C   233: VT/IN, SS, PT, VT,TA2   ;234:VT/IN, SS, PT, VT,TA2, U
     F       -17, 4, 1, 3, 2, 0, 0,       -17, 5, 2, 4, 3, 0, 1,
C   235: VT/IN, SS,P/F, PT,VT,TA2;236:VT/IN, SS, PT, VT, PT,TA2
     G       -17, 5, 1, 3, 2, 0, 0,       -18, 5, 1, 4, 3, 2, 0,
C   237: VT/IN,SS,PT,VT, PT,TA2,U;238:VT/IN, SS,P/F, PT, VT, PT,TA2
     H       -18, 6, 2, 5, 4, 3, 1,       -18, 6, 1, 4, 3, 2, 0/
C  BEDEUTUNG DER PARAMETER-KUERZEL: IN=INTOF , SC=SCURV , SS=SSURF ,
C     P/F=PARAM/FLOW , R=REAL , PT=POINT , VT=VECTOR , L/P=LINE/PLANE ,
C     TA1=TANSPL/CRSSPL/NORMAL/BINORM , TA2=TANSPL/CRSSPL/NORMAL
C   STEUER-ARGUMENT-ERZEUGUNG MITTELS ZEIGER AUS COMMON/NUMPTR/
      DATA  IARGZ/4,5,4,5,6,4,4,5,5,6,4,5,3,4,
     *          6,7,5,6,6,7,8,5,6,7,5,6,
     *          4,5,5,5,6,6,5,6,6,6,7,7/
      DATA KGT/0/,P/5*1/
C
C     ANZAHL DER ARGUMENTE
      DATA ICF/
C ICF                ( 5)           (10)           (15)           (20)
     1     4, 4, 3, 5, 5, 5, 3, 4, 4,-2, 5, 5, 5, 4, 4, 3, 4,-1,-4, 4,
C ICF                (25)           (30)           (35)           (40)
     2     4, 4, 3, 5, 4, 4, 3, 5,-3, 4, 5, 5, 6, 4, 4, 6, 6, 7,11, 5,
C ICF                (45)           (50)           (55)           (60)
     3     3, 3, 4,-1, 3, 5, 5, 5,-1, 5, 7,-4, 5, 6, 7, 7, 8, 8,-1, 4,
C ICF                (65)           (70)           (75)           (80)
     4     6, 5, 3, 4, 5,-1,-1,-1, 7, 7, 6,-1,-1,-1, 6, 5, 5, 4, 5, 3,
C ICF                (85)           (90)                         (100)
     5     5,-1, 7, 9,-1,-5,-6,-1, 7,-9,       9* -1              , 7,
C ICF               (105)          (110)
     6     4, 3, 5, 4, 7, 4, 5, 5,13, 3, 2, 2, 5, 37* -1             ,
C ICF               (155)          (160)          (165)          (170)
     7     6, 5, 4, 4, 6, 9, 8, 7, 7, 5, 8, 7, 6, 6, 4, 7, 6, 5, 5, 4,
C ICF               (175)          (180)          (185)
     8     7, 6, 5, 5, 4, 3, 4, 8,12,11,10, 6, 5, 5,-7,-8, 14* -1    ,
C ICF               (205)          (210)          (215)          (220)
     9     5, 6, 5, 6, 7, 5, 5, 6, 6, 7, 5, 6, 4, 5, 7, 8, 6, 7, 7, 8,
C ICF               (225)          (230)          (235)
     A     9, 6, 7, 8, 6, 7, 5, 6, 6, 6, 7, 7, 6, 7, 7, 7, 8, 8,62* -1 /
C     PRODUKTION NICHT GEFUNDEN
      ERRPT=-ERRP
      IF(ERRPT.GE.0)ERRPT=-1
      IF(I.EQ.200) GOTO 999
C     PRUEFEN DER ANZAHL DER ARGUMENTE
      I1=ICF(I)
      IF(I1.LT.0) GOTO 91
      IF(I1.EQ.ARGTOP) GOTO 100
      ERRPT=I1-ARGTOP
      GOTO 998
   91 I1=-I1
      GOTO (998,92,93,94,100,100,100,100,90),I1
      GOTO 998
   90 I=27
      IF(ARGTOP.EQ.5) GOTO 100
      GOTO 998
   92 IF(ARGTOP.EQ.6) GOTO 100
      GOTO 95
   93 IF(ARGTOP.EQ.3) GOTO 100
      GOTO 95
   94 IF(ARGTOP.EQ.4) GOTO 100
   95 ERRPT=7-I1/3-ARGTOP
      IF(ERRPT.GT.0)ERRPT=-1
      IF(ARGTOP.NE.5) GOTO 998
C
  100 IF(I.GE.100) GOTO 151
  101 CALL CALLZZ(APTXXX(I))
      CALL ARGCVT(RESULT)
      IF(I.GT.50) GOTO 102
      GO TO (2001,2002,2003,2004,2005,2006,2007,2008,2009,2010,
     *       2011,2012,2013,2014,2015,2016,2017,2018,2019,2020,
     *       2021,2022,2023,2024,2025,2026,2027,2028,2029,2030,
     *       2031,2032,2033,2034,2035,2036,2037,2038,2039,2040,
     *       2041,2042,2043,2044,2045,2046,2047,2048,2049,2050),I
  102 I=I-50
      GO TO (2051,2052,2053,2054,2055,2056,2057,2058,2059,2060,
     *       2061,2062,2063,2064,2065,2066,2067,2068,2069,2070,
     *       2071,2072,2073,2074,2075,2076,2077,2078,2079,2080,
     *       2081,2082,2083,2084,2085,2086,2087,2088,2089),I
C    FEHLERAUSGANG FUER PRODUKTIONSNUMMERN 91 BIS 99
      GOTO  998
C   SONDERDEFINITIONEN
  151 IF(I.GT.200)GOTO 2201
      IF(I.GT.150)GOTO 152
C
      I=I-99
      GO TO (2100,2101,2102,2103,2104,2105,2106,2107,2108,2109,
     *       2110,2111,2112,2113),I
      GOTO  999
C MACRO-DEFINITIONEN UND SONSTIGES
  152 I=I-150
      GO TO (2151,2152,2153,2154,2155,2156,2157,2158,2159,2160,
     *       2161,2162,2163,2164,2165,2166,2167,2168,2169,2170,
     *       2171,2172,2173,2174,2175,2176,2177,2178,2179,2180,
     *       2181,2182,2183,2184,2185,2186),I
      GOTO  999
C  FEHLERAUSGANG
 2018 CONTINUE
 2044 CONTINUE
 2049 CONTINUE
 2059 CONTINUE
 2066 CONTINUE
 2067 CONTINUE
 2068 CONTINUE
 2072 CONTINUE
 2073 CONTINUE
 2074 CONTINUE
 2082 CONTINUE
 2085 CONTINUE
 2088 CONTINUE
  999 CALL ALARM(2001,ERRPT,8,'PRO021  ')
  997 CALL CALLZZ(UNDEF)
      CALL ARGCVT(RESULT)
      CALL RLSLIN
      ARGTOP = 0
      RETURN
C
  998 CALL ALARM(2052,ERRPT,8,'PRO021  ')
      GOTO 997
C
C   1.ARGUMENT AUSLASSEN,SONST ALLE AUSGEBEN --- VERARBEITUNGSART A
 2001 CONTINUE
 2003 CONTINUE
 2004 CONTINUE
 2006 CONTINUE
 2014 CONTINUE
 2017 CONTINUE
 2023 CONTINUE
 2028 CONTINUE
 2030 CONTINUE
 2036 CONTINUE
 2037 CONTINUE
 2040 CONTINUE
 2042 CONTINUE
 2048 CONTINUE
 2053 CONTINUE
 2060 CONTINUE
 2062 CONTINUE
 2077 CONTINUE
 2080 CONTINUE
 2081 CONTINUE
20011 ARGTOP=ARGTOP-2
      CALL ARGGEN
      CALL RLSLIN
      RETURN
C  VORLETZTES ARGUMENT AUSLASSEN                  VERARBEITUNGSART B
 2057 CONTINUE
 2058 CONTINUE
 2084 CONTINUE
      CALL ARGCVT (ARGSTK(7))
 2056 CONTINUE
      CALL ARGCVT (ARGSTK(6))
 2055 CONTINUE
20551 CALL ARGCVT (ARGSTK(5))
 2050 CONTINUE
 2054 CONTINUE
20501 CALL ARGCVT (ARGSTK(4))
 2002 CONTINUE
 2008 CONTINUE
 2009 CONTINUE
 2012 CONTINUE
 2013 CONTINUE
 2019 CONTINUE
 2020 CONTINUE
 2022 CONTINUE
 2026 CONTINUE
 2031 CONTINUE
20571 CALL ARGCVT (ARGSTK(3))
      CALL ARGCVT (ARGSTK(1))
      ARGTOP=0
      CALL RLSLIN
      RETURN
C    ALLE ARGUMENTE AUSGEBEN                VERARBEITUNGSART C
 2005 CONTINUE
 2007 CONTINUE
 2011 CONTINUE
 2015 CONTINUE
 2016 CONTINUE
 2024 CONTINUE
 2025 CONTINUE
 2032 CONTINUE
 2033 CONTINUE
 2034 CONTINUE
 2035 CONTINUE
 2038 CONTINUE
 2039 CONTINUE
 2043 CONTINUE
 2063 CONTINUE
 2064 CONTINUE
 2078 CONTINUE
 2079 CONTINUE
 2083 CONTINUE
 2089 CONTINUE
20051 ARGTOP=ARGTOP-1
      CALL ARGGEN
      CALL RLSLIN
      RETURN
C  LINE/(ATA/SLO),R,INTERC,(XA/YA),R   VERARBEITUNGSART D
 2010 CONTINUE
      IF(ARGTOP.EQ.5) GO TO 20101
      ARGSTK(3)=ARGSTK(2)
      GO TO 20551
20101 ARGSTK(2)=TWO
      ARGTOP=ARGTOP-1
      CALL ARGGEN
      CALL RLSLIN
      RETURN
C  2. ARGUMENT ELIMINIEREN             VERARBEITUNGSART E
 2046 CONTINUE
 2047 CONTINUE
 2065 CONTINUE
 2076 CONTINUE
      ARGSTK(3)= ARGSTK(2)
      GO TO 20501
C  SPEZIAL: UMSPEICHERN DER ARGUMENTE  VERARBEITUNGSART F
 2021 CONTINUE
      ARGSTK(2)=ARGSTK(1)
      ARGSTK(1)=ARGSTK(3)
      GOTO 20011
C  SPEZIALVERARBEITUNG                 VERARBEITUNGSART G
 2029 CONTINUE
      IF (ARGTOP .GT. 3) GO TO 20571
      GO TO 20051
C  SPEZIALVERARBEITUNG                 VERARBEITUNGSART H
 2041 CONTINUE
      ARGSTK(3)=ARGSTK(2)
      ARGSTK(2)=ARGSTK(1)
      ARGSTK(1)=ONE
      CALL ARGGEN
      CALL RLSLIN
      RETURN
C  SPEZIALVERARBEITUNG                 VERARBEITUNGSART I
 2051 CONTINUE
      CALL ARGCVT(ARGSTK(6))
      GO TO 20501
C  SPEZIALVERARBEITUNG                 VERARBEITUNGSART J
 2052 CONTINUE
      IF(ARGTOP.EQ.4) GO TO 20051
      ARGSTK(1) = ARGSTK(2)
      GO TO 20501
C  SPEZIALVERARBEITUNG                 VERARBEITUNGSART K
 2061 CONTINUE
      CALL ARGCVT (ARGSTK(1))
      CALL ARGCVT (ARGSTK(4))
      CALL ARGCVT (ARGSTK(2))
      ARGTOP=0
      CALL RLSLIN
      RETURN
C  SPEZIALVERARBEITUNG                 VERARBEITUNGSART L
 2069 CONTINUE
      DO 20691 J=1,5
20691 ARGSTK(J)= ARGSTK(J+1)
      ARGTOP= 5
      CALL ARGGEN
      CALL ARGCVT(TWO)
      CALL RLSLIN
      RETURN
C  SPEZIALVERARBEITUNG                 VERARBEITUNGSART M
 2071 CONTINUE
      ARGTOP= 5
      CALL ARGGEN
      CALL ARGCVT(ONE)
      CALL RLSLIN
      RETURN
C  SPEZIALVERARBEITUNG                 VERARBEITUNGSART N
 2070 CONTINUE
      CALL ARGCVT (ARGSTK(6))
      CALL ARGCVT (ARGSTK(5))
      CALL ARGCVT (ARGSTK(3))
      CALL ARGCVT (ARGSTK(2))
      ARGTOP=0
      CALL RLSLIN
      RETURN
C  SPEZIALVERARBEITUNG                 VERARBEITUNGSART O
 2075 CONTINUE
      ARGTOP=ARGTOP-3
      CALL ARGGEN
      CALL RLSLIN
      RETURN
C  POINT/CLDATA,N  = PR. 27 ; POINT/CLDATA,N1,TP,N1  = PR. 90
C  VECTOR/CLDATA,N = PR. 27 ; VECTOR/CLDATA,N1,TV,N2= PR. 90
20271 ARGSTK(ARGTOP-1)=ZERO
C   UNTERSUCHUNG OB VECTOR
      KMODE=NAMTBL(STACK(1,TOP-3))-GEOM(1)
      IF(KMODE.GT.MODHLF)KMODE=KMODE-MODHLF
      IF(KMODE.EQ.VECTOR)ARGSTK(ARGTOP-1)=ONE
      GOTO 20051
 2027 IF(ARGTOP.EQ.3)GOTO 20272
      L=ARGSTK(2)
      ARGSTK(2)=ZERO+MOD(NAMTBL(L),10)
      GOTO 20271
20272 ARGTOP=5
      ARGSTK(5)=ARGSTK(3)
      ARGSTK(4)=ARGSTK(2)
      ARGSTK(3)=ZERO
      ARGSTK(2)=ZERO
      GOTO 20271
C   POINT/PATERN,N   PATERNPUNKT
 2045 GOTO 20051
C   VECTOR/R,R,R,R,R,R
 2100 CONTINUE
      J=RESULT
      IREF=6
      DO 21002 L=1,3
      CALL OPCODE(FSUB)
      CALL TWOARG(-L,J)
      M=4-L
      DO 21001 N=1,2
      CALL ARGCVT(ARGSTK(M))
21001 M=M+3
21002 CALL RLSLIN
      ARGTOP = 0
      CALL REFGEN(3,RESULT)
      RETURN
C    POINT/R,R,R
 2101 CALL OPCODE(MOVE)
      CALL ARGGEN
      CALL RLSLIN
      ARGTOP = 0
      CALL REFGEN(1,RESULT)
      RETURN
C    POINT/R,R
 2102 CALL OPCODE(MOVE)
      CALL ARGGEN
      CALL RLSLIN
      ARGTOP = 0
      CALL CALLZZ(APTXXX(49))
      CALL ARGCVT(RESULT)
      CALL RLSLIN
      RETURN
C   CIRCLE/R,R,R,R
 2103 CONTINUE
      J=4
21031 CALL OPCODE(MOVE)
      CALL ARGCVT (RESULT)
      CALL ARGCVT (ARGSTK(J))
      CALL ARGCVT (ARGSTK(J-1))
      CALL ARGCVT (ARGSTK(J-2))
21032 CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ONEPT)
      CALL ARGCVT (ARGSTK(1))
      CALL RLSLIN
      ARGTOP = 0
      CALL REFGEN(2,RESULT)
      RETURN
C   CIRCLE/CENTER,R,R,R,RADIUS,R
 2104 CONTINUE
      CALL OPCODE(MOVE)
      CALL ARGCVT (RESULT)
      CALL ARGCVT (ARGSTK(3))
      CALL ARGCVT (ARGSTK(2))
      CALL ARGCVT(ZEROPT)
      GO TO 21032
C   CIRCLE/R,R,R
 2105 CONTINUE
      J= 5
      GO TO 21031
C   VECTOR/R,R,R    /   VECTOR/UNIT,R,R,R
 2106 CONTINUE
 2107 CALL OPCODE (MOVE)
      CALL ARGCVT (RESULT)
      CALL ARGCVT (ARGSTK(3))
      CALL ARGCVT (ARGSTK(2))
      CALL ARGCVT (ARGSTK(1))
      CALL RLSLIN
      CALL REFGEN(3,RESULT)
      IF(ARGTOP.EQ.4)GOTO 21071
      CALL CALLZZ (APTXXX(23))
      CALL ARGCVT (RESULT)
      CALL ARGCVT (RESULT)
      CALL RLSLIN
21071 ARGTOP = 0
      RETURN
C    SPHERE/R,R,R,R
 2108 CALL OPCODE (MOVE)
      CALL ARGGEN
      CALL RLSLIN
      CALL REFGEN(1,RESULT)
      RETURN
C    MATRIX/R,R,R,R,R,R,R,R,R,R,R,R
 2109 CALL OPCODE (MOVE)
      CALL ARGGEN
      CALL RLSLIN
21091 CALL CALLZZ(DEFEXT)
      CALL ARGCVT(RESULT)
      CALL RLSLIN
      RETURN
C    MATRIX/SCALE,R
 2110 CALL OPCODE (MOVE)
      CALL ARGCVT (RESULT)
      CALL ARGCVT (ARGSTK(1))
      DO 21102 J=1,2
      DO 21101 L=1,4
21101 CALL ARGCVT(ZEROPT)
21102 CALL ARGCVT(ARGSTK(1))
      CALL ARGCVT(ZEROPT)
      CALL RLSLIN
      ARGTOP=0
      GOTO 21091
C    LINE/XAXIS
 2111 CALL OPCODE (MOVE)
      CALL ARGCVT (RESULT)
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ONEPT)
21111 CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ZEROPT)
      CALL RLSLIN
      CALL REFGEN(4,RESULT)
      ARGTOP=0
      RETURN
C    LINE/YAXIS
 2112 CALL OPCODE (MOVE)
      CALL ARGCVT (RESULT)
      CALL ARGCVT(ONEPT)
      CALL ARGCVT(ZEROPT)
      GOTO 21111
C    LINE/PT,ATANGL/SLOPE,R,YAXIS
 2113 ARGSTK(1)=GETTMP(LINE)
      CALL OPCODE (MOVE)
      CALL ARGCVT (ARGSTK(1))
      CALL ARGCVT(ONEPT)
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ZEROPT)
      CALL RLSLIN
      CALL REFGEN(4,ARGSTK(1))
      CALL PUTTMP(LINE)
      I=11
      GOTO 100
C **********************************************************************
C   MEHRFACHTRANSFORMATION
C... BEHANDLUNG DER 2. MATRIX:
C
C  2.MATRIX SCHON DEFINIERT
 2155 CONTINUE
 2160 CONTINUE
 2165 CONTINUE
 2170 IZRES2=ARGSTK(1)
C  MULTIPLIKATIONSSCHALTER AUF NORMAL STELLEN
      I66=ONE
      GOTO 701
C  2.MATRIX : TRANSL,X,Y,Z
 2151 CONTINUE
 2156 CONTINUE
 2161 CONTINUE
 2166 CONTINUE
 2171 IZRES2=GETTMP(MATRIX)
C   MATRIXMULTIPLIKATIONSSCHALTER VORLAEUFIG AUF SONDERBEHANDLUNG STELLE
      I66=ZERO
      CALL CALLZZ(APTXXX(40))
      CALL ARGCVT(IZRES2)
      CALL ARGCVT(ARGSTK(3))
      CALL ARGCVT(ARGSTK(2))
      CALL ARGCVT(ARGSTK(1))
      GOTO 702
C  2.MATRIX : TRANSL,X,Y
 2152 CONTINUE
 2157 CONTINUE
 2162 CONTINUE
 2167 CONTINUE
 2172 IZRES2=GETTMP(MATRIX)
C   MATRIXMULTIPLIKATIONSSCHALTER VORLAEUFIG AUF SONDERBEHANDLUNG STELLE
      I66=ZERO
      CALL CALLZZ(APTXXX(40))
      CALL ARGCVT(IZRES2)
      CALL ARGCVT(ARGSTK(2))
      CALL ARGCVT(ARGSTK(1))
      CALL ARGCVT(ZEROPT)
      GOTO 702
C  2.MATRIX : XYROT/YZROT/ZXROT,ALPH
 2153 CONTINUE
 2158 CONTINUE
 2163 CONTINUE
 2168 CONTINUE
 2173 IZRES2=GETTMP(MATRIX)
C   MATRIXMULTIPLIKATIONSSCHALTER VORLAEUFIG AUF SONDERBEHANDLUNG STELLE
      I66=ZERO
      CALL CALLZZ(APTXXX(63))
      CALL ARGCVT(IZRES2)
      CALL ARGCVT(ARGSTK(2))
      CALL ARGCVT(ARGSTK(1))
      GOTO 702
C  2.MATRIX : SCALE,F
 2154 CONTINUE
 2159 CONTINUE
 2164 CONTINUE
 2169 CONTINUE
 2174 IZRES2=GETTMP(MATRIX)
      CALL OPCODE(MOVE)
      CALL ARGCVT(IZRES2)
      CALL ARGCVT(ARGSTK(1))
      DO 21542 J=1,2
      DO 21541 L=1,4
21541 CALL ARGCVT(ZEROPT)
21542 CALL ARGCVT(ARGSTK(1))
      CALL ARGCVT(ZEROPT)
      CALL RLSLIN
      CALL CALLZZ(DEFEXT)
      CALL ARGCVT(IZRES2)
C    MULTIPLIKATION AUF NORMAL STELLEN
      I66=ONE
C   SETZEN DES ZAEHLERS FUER MATRIX-ZWISCHENSPEICHER
  702 KGT=1
C  ABSCHLUSS DER BEFEHLSFOLGE FUER 2. MATRIX
      CALL RLSLIN
C  BEHANDLUNG DER 1. MATRIX
  701 GOTO (4151,4152,4153,4154,4155,4156,4157,4158,4159,4160,
     *      4161,4162,4163,4164,4165,4166,4167,4168,4169,4170,
     *      4171,4172,4173,4174),I
C  1.MATRIX SCHON DEFINIERT
 4151 CONTINUE
 4152 CONTINUE
 4153 CONTINUE
 4154 IZRES1=ARGSTK(ARGTOP-1)
C  MULTIPLIKATIONSSCHALTER AUF NORMAL STELLEN
      I66=ONE
      GOTO 711
C  1.MATRIX : TRANSL,X,Y,Z
 4155 CONTINUE
 4156 CONTINUE
 4157 CONTINUE
 4158 CONTINUE
 4159 IZRES1=GETTMP(MATRIX)
      CALL CALLZZ(APTXXX(40))
      CALL ARGCVT(IZRES1)
      CALL ARGCVT(ARGSTK(ARGTOP-2))
      CALL ARGCVT(ARGSTK(ARGTOP-3))
      CALL ARGCVT(ARGSTK(ARGTOP-4))
      GOTO 712
C  1.MATRIX : TRANSL,X,Y
 4160 CONTINUE
 4161 CONTINUE
 4162 CONTINUE
 4163 CONTINUE
 4164 IZRES1=GETTMP(MATRIX)
      CALL CALLZZ(APTXXX(40))
      CALL ARGCVT(IZRES1)
      CALL ARGCVT(ARGSTK(ARGTOP-2))
      CALL ARGCVT(ARGSTK(ARGTOP-3))
      CALL ARGCVT(ZEROPT)
      GOTO 712
C  1.MATRIX : XYROT/YZROT/ZXROT,ALPH
 4165 CONTINUE
 4166 CONTINUE
 4167 CONTINUE
 4168 CONTINUE
 4169 IZRES1=GETTMP(MATRIX)
      CALL CALLZZ(APTXXX(63))
      CALL ARGCVT(IZRES1)
      CALL ARGCVT(ARGSTK(ARGTOP-1))
      CALL ARGCVT(ARGSTK(ARGTOP-2))
      GOTO 712
C  1.MATRIX : SCALE,F
 4170 CONTINUE
 4171 CONTINUE
 4172 CONTINUE
 4173 CONTINUE
 4174 IZRES1=GETTMP(MATRIX)
      CALL OPCODE(MOVE)
      CALL ARGCVT(IZRES1)
      CALL ARGCVT(ARGSTK(ARGTOP-2))
      DO 41702 J=1,2
      DO 41701 L=1,4
41701 CALL ARGCVT(ZEROPT)
41702 CALL ARGCVT(ARGSTK(ARGTOP-2))
      CALL ARGCVT(ZEROPT)
      CALL RLSLIN
      CALL CALLZZ(DEFEXT)
      CALL ARGCVT(IZRES1)
C    MULTIPLIKATION AUF NORMAL STELLEN
      I66=ONE
C   LOSLASSEN DES EBEN BENUTZTEN MATRIX-ZWISCHENSPEICHERS
  712 CALL PUTTMP(MATRIX)
C  ABSCHLUSS DER BEFEHLSFOLGE FUER 1. MATRIX
      CALL RLSLIN
C  GGF ZWISCHENSPEICHER FUER 2.MATRIX LOSLASSEN
  711 IF(KGT.EQ.0)GOTO 720
      KGT=0
      CALL PUTTMP(MATRIX)
C   MATRIX-ENDVERARBEITUNG
  720 CALL CALLZZ(APTXXX(41))
      CALL ARGCVT(RESULT)
      CALL ARGCVT(IZRES1)
      CALL ARGCVT(IZRES2)
      CALL ARGCVT(I66)
      CALL RLSLIN
      ARGTOP=0
      RETURN
C **********************************************************************
C   MATRIX/TRANSL,R,R
 2175 ARGSTK(5)=ARGSTK(4)
      ARGSTK(4)=ARGSTK(3)
      ARGSTK(3)=ARGSTK(2)
      ARGSTK(2)=ARGSTK(1)
      ARGSTK(1)=ZEROPT
      ARGTOP=5
      I=40
      GO TO 100
C    MATRIX/MIRROR,XYPLAN/YZPLAN/ZXPLAN
 2176 ARGSTK(5)=ARGSTK(3)
      ARGSTK(4)=ARGSTK(2)
      ARGSTK(3)=ARGSTK(1)
      ARGSTK(2)=ZERO
      ARGSTK(1)=ZERO
      ARGTOP=5
      I=81
      GO TO 100
C    MATRIX/MIRROR,XYPLAN/YZPLAN/ZXPLAN,XYPLAN/YZPLAN/ZXPLAN
 2177 ARGSTK(5)=ARGSTK(4)
      ARGSTK(4)=ARGSTK(3)
      ARGSTK(3)=ARGSTK(2)
      ARGSTK(2)=ARGSTK(1)
      ARGSTK(1)=ZERO
      ARGTOP=5
      I=81
      GO TO 100
C **********************************************************************
C    LOFT-CONIC-VERARBEITUNG
C   LCONIC/5PT,X1,Y1,X2,Y2,X3,Y3,X4,Y4,X5,Y5
C  ARGSTK (11, 10, 9, 8, 7, 6, 5, 4, 3, 2, 1)
 2179 GOTO 801
C   LCONIC/4PT1SL,X1,Y1,SL,X2,Y2,X3,Y3,X4,Y4
C  ARGSTK ( 10   , 9, 8, 7, 6, 5, 4, 3, 2, 1)
 2180 P(4)=-1
      GOTO 801
C   LCONIC/3PT2SL,X1,Y1,SL,X2,Y2,SL,X3,Y3
C  ARGSTK (  9   , 8, 7, 6, 5, 4, 3, 2, 1)
 2181 P(2)=-1
      P(4)=-1
      GOTO 801
C  LCONIC-BERECHNUNG
  801 J1=1
      DO 802 J=1,5
C  PUNKTBERECHNUNG: Z=0 ERGAENZEN,RUECKTRANSFORMATION
      IF(P(J).LT.0) GOTO 803
      P(J)=GETTMP(POINT)
      CALL OPCODE(MOVE)
      CALL ARGCVT(P(J))
      CALL ARGCVT(ARGSTK(J1+1))
      CALL ARGCVT(ARGSTK(J1))
      CALL ARGCVT(ZEROPT)
      CALL RLSLIN
      CALL REFGEN(1,P(J))
      ARGSTK(J)=P(J)
      J1=J1+2
      GOTO 802
C   STEIGUNG UMSPEICHERN
  803 ARGSTK(J)=ARGSTK(J1)
      J1=J1+1
  802 CONTINUE
C   DEFINITIONSART UND RESULTATZEIGER UMSPEICHERN
      ARGSTK(6)=ARGSTK(J1)
      ARGSTK(7)=ARGSTK(J1+1)
      ARGTOP=7
C   HILFSZEIGER LOSLASSEN
      DO 804 J=1,5
      IF(P(J).NE.-1)CALL PUTTMP(POINT)
  804 P(J)=1
C NORMALE VERARBEITUNG
      I=83
      GOTO 100
C **********************************************************************
C ... CYLNDR/X,Y,Z,V1,RADIUS
 2182 I = 34
      ISAV=RESULT
      RESULT = GETTMP(POINT)
      CALL OPCODE(MOVE)
      CALL ARGCVT(RESULT)
      CALL ARGCVT(ARGSTK(5))
      CALL ARGCVT(ARGSTK(4))
      CALL ARGCVT(ARGSTK(3))
      CALL RLSLIN
      CALL PUTTMP(POINT)
      CALL REFGEN(1,RESULT)
      ARGSTK(3) = RESULT
      RESULT=ISAV
      ARGTOP = ARGTOP - 2
      GO TO 100
C ... CYLNDR/X,Y,Z,I,J,K,RADIUS
 2178 I = 33
      ISAV=RESULT
      RESULT = GETTMP(POINT)
      CALL OPCODE(MOVE)
      CALL ARGCVT(RESULT)
      CALL ARGCVT(ARGSTK(7))
      CALL ARGCVT(ARGSTK(6))
      CALL ARGCVT(ARGSTK(5))
      CALL RLSLIN
      CALL PUTTMP(POINT)
      CALL REFGEN(1,RESULT)
      ARGSTK(5) = RESULT
      RESULT=ISAV
      ARGTOP = ARGTOP - 2
      GO TO 100
C ... PLANE/P1,P2,PERPTO,PL1
 2183 I=28
      ARGSTK(2) = ARGSTK(4)
      ISAV = ARGSTK(3)
      ARGSTK(3) = ARGSTK(1)
      ARGSTK(1) = ISAV
      GO TO 101
C ... POINT/THETAR,**,ANGLE,RADIUS
 2184 I = 48
      ISAV = ARGSTK(1)
      ARGSTK(1)=ARGSTK(2)
      ARGSTK(2)=ISAV
      GO TO 101
C...  PROCESS BOUNDS STATEMENT
C
C     CALL GENERATED TO APT102        (I=86)
C
C     TEST IF THIS IS FIRST CALL TO APT102.  IF SO GENERATE EXTRA CALL
C     TO ALLOW INITIALIZATION OF BLOCK 1 POINTER.
C
 2086 IF (IFBNDS .NE.  0) GO TO 1305
      TWOPT=NUMB(ITWOPT)
      IFBNDS=1
      DO 1302 I=1,3
      IF (FIRST(2,I) .NE. 0) GO TO 1303
 1302 CONTINUE
 1303 CALL ARGCVT(FIRST(1,I))
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ONE)
      CALL RLSLIN
      CALL CALLZZ(APTXXX(86))
      CALL ARGCVT(RESULT)
C
 1305 CALL ARGCVT(ARGSTK(ARGTOP-1))
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT (ONE)
      CALL RLSLIN
      L = GEOLOC(BOUNDS)
      K = TOP + ARGTOP - 1
      ERRPT=ARGTOP-1
 1306 ARGTOP = ARGTOP - 2
      J = 0
      KT2=K*2
      I = SEARCH(STACK,KT2,GEOMTB(L),ERRPT)
      ERRPT=-ERRPT
      IF(ERRPT.GE.0)ERRPT=-1
      IF (I .EQ. 185) GO TO 1308
      IF (I .NE. 186) GO TO 999
C
C     BOUNDN/...,SURF,POINT OR POSX OR NEGX OR POSY OR NEGY OR POSZ ETC.
C
      CALL CALLZZ(APTXXX(86))
      CALL ARGCVT(RESULT)
      CALL ARGCVT(ARGSTK(ARGTOP))
      I = ARGSTK(ARGTOP - 1)
      IF (I .LT. IFIXST) GO TO 1319
      M = I - ONE + 1
      I = ONEPT
      GO TO (1307,1307,1307,1310,1310,1310), M
 1307 I = TWOPT
      GO TO 1310
C
C     BOUNDS/...,SURF,IN OR OUT OR REAL,...
C
 1308 CALL CALLZZ(APTXXX(86))
      CALL ARGCVT(RESULT)
      CALL ARGCVT(ARGSTK(ARGTOP))
      I = ARGSTK(ARGTOP - 1)
      IF (I .EQ. ONE) I = ONEPT
      IF (I .EQ. TWO) I = TWOPT
 1310 CALL ARGCVT(I)
      IF (ARGTOP .EQ. 2) GO TO 1315
      CALL ARGCVT(TWO + J)
      CALL RLSLIN
      K = K - 2
      GO TO 1306
 1315 CALL ARGCVT(THREE + J)
 1318 CALL RLSLIN
      ARGTOP=0
      RETURN
C
C     EMBEDDED POINT.
C
 1319 J = 2
      GO TO 1310
C
C     ERROR EXIT WHEN PRIMARY SURFACE NOT SPECIFIED.
C
 2185 CONTINUE
 2186 GO TO 999
C
C... PROCESS OBJECT STATEMENT
C
C     CALL GENERATED TO APT103               (I=87)
 2087 CALL ARGCVT (ARGSTK(ARGTOP-1))
      J = 0
      KK=ARGTOP-2
      IF (KK .LT. 1) GO TO 1330
      CALL ARGCVT (ONE)
      CALL RLSLIN
      DO 1325 K=1,KK
      CALL CALLZZ(APTXXX(87))
      CALL ARGCVT(RESULT)
      L=KK-K+1
      M = MODE(ARGSTK(L))
      ERRPT=-L
      IF (M .NE. BOUNDS .AND. M .NE. OBJECT) GO TO 999
      CALL ARGCVT(ARGSTK(L))
      IF (K .EQ. KK) GO TO 1315
      CALL ARGCVT(TWO)
 1325 CALL RLSLIN
 1330 CALL ARGCVT(ZERO)
      GO TO 1318
C  PUNKT UND VECTOR-ABGRIFF VUN SSURF UND SCURV
 2201 I=I-200
      IF(I.GT.38)GOTO 999
      NA=I
      ERRPT=1-ARGTOP
      IF(ARGTOP-1.NE.IARGZ(NA))GOTO 999
      CALL CALLZZ(APTXXX(91))
      CALL ARGCVT(RESULT)
      DO 3300 NB=1,7
      NARG1=NARG(NB,NA)
      IF(NARG1)3310,3320,3330
C STEUERVARIABLE 'II' FUER ROUTINE APT109 WIRD AUSGEGEBEN
 3310 CALL ARGCVT(IARG(-10-NARG1))
      GOTO 3300
C AUSGABE EINER REAL-ZAHL 0.0D0
 3320 CALL ARGCVT(ZEROPT)
      GOTO 3300
C AUSGABE EINER ARGSTK-ANGABE (ARGUMENT DER GEOMETRIE-DEFINITION)
 3330 CALL ARGCVT(ARGSTK(NARG1))
 3300 CONTINUE
      ARGTOP=0
      CALL RLSLIN
      RETURN
      END
**** SOURCE FILE : M0007341.W06   ***
*
C
C              FORTRAN SUBROUTINE PRO026
C
C LINKAGE      SUBROUTINE PRO026
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    JUMPZZ          SUBROUTINE    RECOG
C          SUBROUTINE    LABCON
C          SUBROUTINE    ARGGEN
C          SUBROUTINE    MACLBL
C          SUBROUTINE    MATCH
C          INTEGER FCT.  CLMODE
C          SUBROUTINE    MCXTRN
C          SUBROUTINE    MNPROC
C          INTEGER FCT.  MODE
C          INTEGER FCT.  GETTMP
C          SUBROUTINE    MOTION
C          SUBROUTINE    ALARM
C          INTEGER FCT.  NAME
C          INTEGER FCT.  NUMB
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    OPCODE
C          SUBROUTINE    GOPAT
C          SUBROUTINE    PATH
C          SUBROUTINE    PRO027
C          SUBROUTINE    PRO028
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    EPILOG
C          SUBROUTINE    READ
C          SUBROUTINE    REFGEN
C          SUBROUTINE    REFREF
C          SUBROUTINE    RESERV
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    TSSMIL
C          SUBROUTINE    TWOARG
C          SUBROUTINE    BCDBIN
C
      SUBROUTINE PRO026
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C IFIXST:      NAMTBL INDEX OF BEGINNING OF FIXED POINT NUMBER SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),TEMP(2),PROCED(2),PERMID(2),LABEL(2),IMPLAB(
     *          2),VBL(2)
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C PROCED:      (1)=CODE CLASS 19000,(2)=NAMTBL INDEX OF 'PROCED'
      EQUIVALENCE (PROCED(1),CODE(37))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C IMPLAB:      (1)=CODE CLASS 23000,(2)=NAMTBL INDEX OF 'IMPLAB'
      EQUIVALENCE (IMPLAB(1),CODE(45))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(501),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        5.    PROGRAM CONTROL FLAGS
C
      COMMON/FLAGS/FLAGS
      LOGICAL NEWSTM,APTRAN
      DIMENSION FLAGS(4)
C NEWSTM:      TRUE WHEN NEXT SOURCE STATEMENT REQUESTED FOR PROCESS
      EQUIVALENCE (NEWSTM,FLAGS(2))
C APTRAN:      TRUE IF APTRAN CARD READ AND IN EFFECT
      EQUIVALENCE (APTRAN,FLAGS(3))
C
C        8.    NAME TABLE POINTERS TO BCD LITERALS
C
      COMMON/BCDPTR/BCDPTR
      DIMENSION BCDPTR(7)
C DOTAC:       NAMTBL POINTER TO ALPHAMERIC LITERAL '.AC.  '
      EQUIVALENCE (DOTAC,BCDPTR(1))
C FEDRAT:      NAMTBL POINTER TO ALPHAMERIC LITERAL 'FEDRAT'
      EQUIVALENCE (FEDRAT,BCDPTR(2))
C TO:          NAMTBL POINTER TO ALPHAMERIC LITERAL 'TO'
      EQUIVALENCE (TO,BCDPTR(3))
C ERASB:       NAMTBL POINTER TO ALPHAMERIC LITERAL 'APTER'
      EQUIVALENCE (ERASB,BCDPTR(5))
C DOTTAB:      NAMTBL POINTER TO ALPHAMERIC LITERAL '$$TAB'
      EQUIVALENCE (DOTTAB,BCDPTR(7))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12),ZERO(1)
C ZERO:        NAMTBL POINTER TO '0     '
      EQUIVALENCE (ZERO(1),NUMPTR(1))
C ZEROPT:      NAMTBL POINTER TO '0.    '
      EQUIVALENCE (ZEROPT,NUMPTR(2))
C ONE:         NAMTBL POINTER TO '1     '
      EQUIVALENCE (ONE,NUMPTR(3))
C ONEPT:       NAMTBL POINTER TO '1.    '
      EQUIVALENCE (ONEPT,NUMPTR(4))
C TWO:         NAMTBL POINTER TO '2     '
      EQUIVALENCE (TWO,NUMPTR(5))
C THREE:       NAMTBL POINTER TO '3     '
      EQUIVALENCE (THREE,NUMPTR(6))
C FOUR:        NAMTBL POINTER TO '4     '
      EQUIVALENCE (FOUR,NUMPTR(7))
C FIVE:        NAMTBL POINTER TO '5     '
      EQUIVALENCE (FIVE,NUMPTR(8))
C SIX:         NAMTBL POINTER TO '6     '
      EQUIVALENCE (SIX,NUMPTR(9))
C NINE:        NAMTBL POINTER TO '9     '
      EQUIVALENCE (NINE,NUMPTR(12))
C
C       11.    SEQUENCE NUMBER STORAGE
C
      COMMON/SEQCOM/SEQCOM
      DIMENSION SEQCOM(3)
C SEQNO:       INTERNALLY GENERATED STATEMENT NUMBER
      EQUIVALENCE (SEQNO,SEQCOM(1))
C
C       12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE
      DIMENSION CFSIZE(205),MAXSIZ(2)
C MAXSIZ:      SIZE OF THE LAST LARGEST LARGE DATA ARRAY
      EQUIVALENCE (MAXSIZ(1),CFSIZE(4))
C
C       13.    NAMTBL POINTERS TO NEGATIVE NUMBERS
C              NAMTBL POINTER TO -1.
      COMMON/NEGPTR/NONEPT
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL CILPRT,ILPRT,PRTERR
      DIMENSION PRT(7)
C CILPRT:      TRUE WHEN COMPRESSED I.L. PRINTING REQUESTED
      EQUIVALENCE (CILPRT,PRT(1))
C ILPRT:       TRUE INDICATES I.L. PRINTING (PPOPTN/INTLNG,ON)
      EQUIVALENCE (ILPRT,PRT(2))
C PRTERR:      TRUE IF PPOPTN/PRTER,ON. PRINTOUT OF STACK OR ARGSTK
      EQUIVALENCE (PRTERR,PRT(6))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C REPL:        CONTAINS COMMAND CODE (17) FOR REPL COMMAND
      EQUIVALENCE (REPL,IL(17))
C MOVE:        CONTAINS COMMAND CODE (19) FOR MOVE COMMAND
      EQUIVALENCE (MOVE,IL(19))
C VBLJMP:      CONTAINS COMMAND CODE (20) FOR VBLJMP COMMAND
      EQUIVALENCE (VBLJMP,IL(20))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C PLANE:       MODE CODE ( 2) FOR PLANE SURFACE
      EQUIVALENCE (PLANE,MODX(2))
C POINT:       MODE CODE (19) FOR POINT
      EQUIVALENCE (POINT,MODX(19))
C VECTOR:      MODE CODE (20) FOR VECTOR
      EQUIVALENCE (VECTOR,MODX(20))
C REAL:        MODE CODE (24) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C PATERN:      MODE CODE (26) FOR PATTERN
      EQUIVALENCE (PATERN,MODX(26))
C OBJECT:      MODE CODE (28) FOR OBJECT
      EQUIVALENCE (OBJECT,MODX(28))
C SSURF:       MODE CODE (29) FOR SSURF
      EQUIVALENCE (SSURF,MODX(29))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL ILHLT,MACRED,FINMAC,ENTRY,MACEND,SHOULD
      DIMENSION MACXX1(71)
C MACDFP:      POINTER TO LAST ENTRY IN MACDF1 AND MACDF2 ARRAYS
      EQUIVALENCE (MACDFP,MACXX1(1))
C ILHLT:       TRUE IF I.L. SHOULD NOT BE PLACED IN ILFILE
      EQUIVALENCE (ILHLT,MACXX1(14))
C MACRED:      SET TRUE TO INDICATE INPUT FROM MCBUFF TABLE
      EQUIVALENCE (MACRED,MACXX1(18))
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C MAJWRD:      CONTAINS ACTUAL MAJOR WORD
      EQUIVALENCE (MAJWRD,MACXX1(23))
C FINMAC:      TRUE IF SECOND FINAL PASS OF MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C WAY:         INDICATES TYPE OF MACRO PROCESSING
      EQUIVALENCE (WAY,MACXX1(26))
C ENTRY:       FALSE ON FIRST ENTRY TO MATCH FOR A MACRO EXPRESSION
      EQUIVALENCE (ENTRY,MACXX1(40))
C MAJOR:       CURRENT CALL ASSIGNED VALUE IF MAYWRD IS MACRO VARIABLE
      EQUIVALENCE (MAJOR,MACXX1(44))
C MACEND:      TRUE WHEN ALL MACRO PROCESSING IS FINISHED
      EQUIVALENCE (MACEND,MACXX1(62))
C WHCHMN:      EQUAL TO NUMBER OF CURRENT MACRO BEING PROCESSED
      EQUIVALENCE (WHCHMN,MACXX1(63))
C SHOULD:      MACRO INDICATOR. NORMALLY FALSE
      EQUIVALENCE (SHOULD,MACXX1(70))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(8)
C NOUGHT:      CONTAINS OPERAND TYPE 0
      EQUIVALENCE (NOUGHT,OPMOD(1))
C DLR:         CONTAINS OPERAND TYPE CODE 1
      EQUIVALENCE (DLR,OPMOD(2))
C DBLDLR:      CONTAINS OPERAND TYPE CODE 2
      EQUIVALENCE (DBLDLR,OPMOD(3))
C QUIDLR:      CONTAINS OPERAND TYPE CODE 5
      EQUIVALENCE (QUIDLR,OPMOD(6))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136),APTXXX(120)
C APT200:      NAMTBL POINTER FOR APT200
      EQUIVALENCE (APT200,SUBLST(127))
C APT298:      NAMTBL POINTER FOR APT298
      EQUIVALENCE (APT298,SUBLST(130))
C APT299:      NAMTBL POINTER FOR APT299
      EQUIVALENCE (APT299,SUBLST(131))
C ERROR:       NAMTBL POINTER TO EXECUTION SUBROUTINE ERROR
      EQUIVALENCE (ERROR,SUBLST(132))
C PSIS:        NAMTBL POINTER FOR XECUTION SUBROUTINE PSIS
      EQUIVALENCE (PSIS,SUBLST(133))
C TLAXIS:      NAMTBL POINTER FOR XECUTION SUBROUTINE TLAXIS
      EQUIVALENCE (TLAXIS,SUBLST(135))
C APTXXX:      NAMTBL POINTERS FOR XECUTION SUBROUTINE NAMES
      EQUIVALENCE (APTXXX(1),SUBLST(1))
C APT001:      NAMTBL POINTER FOR APT001
      EQUIVALENCE (APT001,SUBLST(49))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       31.    COMMON BLOCK FOR PRO026 AND MOTION
C
      COMMON/COMP26/COMP26
      LOGICAL FMTERR
      DIMENSION COMP26(16)
C ARGCNT:      POINTER FOR CURRENT ARGSTK ELEMENT
      EQUIVALENCE (ARGCNT,COMP26(2))
C CSPNTR:      CONTAINS NAMTBL POINTER TO CS
      EQUIVALENCE (CSPNTR,COMP26(3))
C NUMBCS:      NUMBER OF CHECK SURFACES
      EQUIVALENCE (NUMBCS,COMP26(5))
C TEST:        NAMTBL INDEX OF CURRENT ARGUMENT
      EQUIVALENCE (TEST,COMP26(6))
C TEST1:       CLASS OF CURRENT ARGUMENT
      EQUIVALENCE (TEST1,COMP26(7))
C FMTERR:      ERROR FLAG FOR CERTAIN MOTION STATEMENTS
      EQUIVALENCE (FMTERR,COMP26(9))
C K:           NAMTBL POINTER TO MAJOR WORD
      EQUIVALENCE (K,COMP26(12))
C LERR:        ERROR TYPE INDICATOR
      EQUIVALENCE (LERR,COMP26(13))
C
C       35.    COMMON BLOCK FOR BOUNDED GEOMETRY AND CFSAVE
C
      COMMON/BGEOM/BGEOM
      DIMENSION BGEOM(4)
C IFDUMP:      VALUE 0=NO CFSAVE COMMAND,1=ALL,2=SCALAR,3=GEOM PROGRAM
      EQUIVALENCE (IFDUMP,BGEOM(2))
C J:           PASSES PUNCH/ARGUMENT FROM PRO026 TO PRO027
      EQUIVALENCE (J,BGEOM(3))
C L:           PASSES PUNCH/LISTON OR NOLIST FROM PRO026 TO PRO027
      EQUIVALENCE (L,BGEOM(4))
C
C       40.    PARAMETERS REQUIRED BY SUPERVISOR
C
      COMMON/SUPER/SUPER
      LOGICAL CFLAGS,FINI
      DIMENSION SUPER(36),CFLAGS(4)
C CFLAGS:      CONDITION OF TERMINATION OF THE PHASES
      EQUIVALENCE (CFLAGS(1),SUPER(1))
C FINI:        FLAG ON INDICATES A FINI CARD HAS BEEN READ
      EQUIVALENCE (FINI,SUPER(7))
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C
C       43.    DO LOOP CONTROL VALUES
C
      COMMON/DOLOOP/DOLOOP
      DIMENSION DOLOOP(8)
C JUMPTO:      MARKER SET AFTER JUMPTO OR IF FOR LABEL CONTROL
      EQUIVALENCE (JUMPTO,DOLOOP(1))
C DOJUMP:      VBL FOR COMPUTED GOTO AT LOOP PROCESSING
      EQUIVALENCE (DOJUMP,DOLOOP(6))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ESTACK,ERGSTK
      DIMENSION ERRPOS(302),ESTACK(100),ERGSTK(100)
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C ERGSTK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN ARGSTK
      EQUIVALENCE (ERGSTK(1),ERRPOS(203))
C
C       45.    NUMBER TABLE INDICES
C
      INCLUDE (NUMBLK)    
C LSTCHR:      LAST CHARACTER OF A NUMBER
C*
C...           PROGRAM VARIABLES
C
      CHARACTER*6 ICNTRL(4)
      CHARACTER*6 IPPOPT(5),START,NOMORE,NORMAL
      LOGICAL   LTEMP
      CHARACTER*6 DON
      LOGICAL DSFIND,PSFIND
      LOGICAL ERAS,ODD,ODD1,ODD2
      CHARACTER*6 SRPRNT,FINIT,BLK,CONTIN
      CHARACTER*6 HALL,HON,HOFF,HAT,HPS
      CHARACTER*6 HOUT,HIN,GOLO,PLOT
      DATA DON/'ON    '/
      DATA SRPRNT,START,NOMORE/'PRINT ','START ','NOMORE'/
      DATA ERAS/.FALSE./,ODD,ODD1,ODD2/3*.TRUE./,NORMAL/'NORMAL'/
      DATA FINIT/'FINI'/,BLK/'    '/,CONTIN/'CONT'/
      DATA ICNTRL/'ERR ','TR  ','XC  ','CL  '/
      DATA IPPOPT(1)/'INTLNG'/,
     1     IPPOPT(2)/'PRTER '/,
     2     IPPOPT(3)/'REFMOT'/,
     3     IPPOPT(4)/'ALTMLT'/,
     4     IPPOPT(5)/'CILPRT'/
      DATA HALL,HON,HOFF,HAT,HPS/'ALL   ','ON    ','OFF   ','AT    ',
     1     'PS    '/
      DATA HOUT,HIN,GOLO,PLOT/'OUT   ','IN    ','GOLOFT','PLOTFT'/
C*********************************************************************
      K=STACK(1,TOP-1)
      IF(INTMED.NE.1)GO TO 6052
      WAY=2
      IF(FINMAC)GO TO 6051
      ERGSTK(100)=TOP-1
      MAJWRD=K
 6002 CALL MATCH
      IF(.NOT.ENTRY)GO TO 6053
      K=MAJOR
      GO TO 6052
 6051 CALL PATH
      IF(.NOT.SHOULD)GO TO 6053
 6052 HOP=NAMTBL(K)-PROCED(1)
      IF(HOP.GE.MODHLF)HOP=HOP-MODHLF
      IF(HOP.EQ.0)GO TO 30
C... TLLFT, TLRGT, TLON, TLONPS, TLOFPS, MULTAX, NOPS, AUTOPS, CUT,
C    DNTCUT, NDTEST, COMP3D, GOUGCK
      IF(HOP.LE.13)GO TO 10
      HOP=HOP-13
C           CLPRNT APTRAN
      GO TO (   80,  1918,
C
C           APTREN REFSYS   FINI RESERV CONTRL    SYN DYNDMP  ZSURF
     2          22,  1923,  1924,  1926,   500,  2800,   180,     1,
C
C           JUMPTO
C           TRANTO     GO GODLTA  TOLER  INTOL OUTTOL CUTTER  MAXDP
     3        1925,  1904,   700,  1909,  1909,  1909,  1912,   200,
C
C                         GOBACK
C                         GODOWN
C                          GOFWD
C                          GOLFT
C                          GORGT
C           NUMPTS  THICK   GOUP   GOTO   FROM INDIRV SRFVCT TLAXIS
     4         190,  1909,  1901,   800,   801,  1922,  1922,  1913,
C
C           INDIRP   PSIS  PRINT   CALL LOOPST LOOPND MACHIN NOPOST
     5        1921,  1914,  1942,  4300,    22,    23,   100,   110,
C
C           POCKET TITLES  PUNCH 2DCALC 3DCALC TLNDON CFSAVE PPOPTN
     6        1968,  8200,  8100,    11,    12,     3,  8100,   600,
C                                         GOLOFT
C           PTONLY                 INTSEC PLOTFT
C           REMARK                 GCLEAR GOMILL
C           TUNEUP   READ  UNITS   SCON   SMIL  UNUSED TLPROJ CLDAT
     7          22,  5700,  5800,  9100,  9100,     1,  2100,  2000,
C           CHKSRF AVCTRL REGION
     8        2200,  9100, 2100),HOP
C
C... PICK UP NAMTBL POINTER TO TLON
    3 K=APTXXX(98)
   10 IF ((HOP.NE.6).AND.(HOP.NE.13)) GOTO 9
      IF(ARGTOP.GT.1) CALL ALARM(2002,1-ARGTOP,4,'PRO026  ')
      IF(ARGTOP.NE.0) GOTO 8
      ARGTOP=1
      ARGSTK(1)=NAME(DON)
    8 IF(CNAMTB(ARGSTK(ARGTOP)).NE.HON .AND.CNAMTB(ARGSTK(ARGTOP)).
     * NE.HOFF)CALL ALARM(2002,-ARGTOP,4,'PRO026  ')
      GOTO 3000
    9 IF (ARGTOP.NE.0) CALL ALARM(2028,-ARGTOP,4,'PRO026  ')
      GO TO 3000
C... PICK UP NAMTBL POINTER TO NDTEST
   11 K=APTXXX(96)
      GO TO 10
C... PICK UP NAMTBL POINTER TO COMP3D
   12 K=APTXXX(97)
      GO TO 10
    1 ASSIGN 22 TO IRET
      IF(ARGTOP-1)9991,2,9989
    2 IF (MODE(ARGSTK(1)) .EQ. PLANE) GO TO 3000
      CALL ALARM(2029,-1,8,'PRO026  ')
      GO TO 22
 9100 IF (CNAMTB(K).EQ.GOLO.OR.CNAMTB(K).EQ.PLOT) THEN
        CALL GOLOFT
      ELSE
        CALL TSSMIL
      ENDIF
      GO TO 7080
C
C     *************** PROCESS POST PROCESSOR STATEMENT *****************
C
C
C... SET L = NUMBER OF CALLS TO APT299 TO BE GENERATED.
C
   30 SUB=APT299
   35 L = 1 + (ARGTOP/2)
C
C... GENERATE CALLS.
C
      DO 70  I = 1,L
      CALL CALLZZ(SUB)
C
C... INSERT TWO PAIRS OF ARGUMENTS IN ARGUMENT LIST.
C
      DO 60  J = 1,2
C
C... THE FIRST PAIR IN THE FIRST CALL CONSISTS OF THE TOTAL NUMBER OF
C... ARGUMENT PAIRS EXCLUSIVE OF THE FIRST PAIR AND THE MAJOR WORD IN
C... PART PROGRAM STATEMENT.
C
      IF ((I+J) .GT. 2)  GO TO 40
      CALL TWOARG(QUIDLR,ARGTOP)
      CALL ARGCVT(K)
      GO TO 60
C
C... IF ARGSTK HAS BEEN EXHAUSTED,FILL OUT ARGUMENT LIST WITH ZEROS.
C
   40 IF (ARGTOP .GT. 0)  GO TO 50
      CALL TWOARG(DLR,ZERO)
      CALL TWOARG(DLR,ZERO)
      GO TO 60
C
C... DETERMINE THE CLASS AND MODE OF THE NEXT ARGSTK ELEMENT AND SET
C... N = THE CORRESPONDING CLMODE. IF THE ELEMENT IS INVALID,ISSUE A
C... WARNING MESSAGE AND TREAT IT AS A PERMANENT IDENTIFIER.
C
   50 N = CLMODE(ARGSTK(ARGTOP))
      IF (N .NE. 2)  GO TO 52
      IF (MOD(NAMTBL(ARGSTK(ARGTOP)),MODHLF).EQ.0)GOTO 53
   52 IF (N .NE. 0)  GO TO 55
   53 IF(HOP.NE.61.AND.HOP.NE.33)CALL ALARM(2002,-ARGTOP,8,'PRO026  ')
      N = 2
C
C... INSERT CLMODE AND ARGSTK ELEMENT AS THE NEXT PAIR IN THE
C... ARGUMENT LIST.
C
   55 CALL TWOARG(QUIDLR,N)
      CALL ARGCVT(ARGSTK(ARGTOP))
      ARGTOP = ARGTOP - 1
   60 CONTINUE
C
C... RELEASE GENERATED I.L.
C
      CALL RLSLIN
   70 CONTINUE
      GO TO 22
C
C *********** SPECIAL PATH FOR CLPRNT,MACHIN AND NOPOST COMANDS ********
C
C... CLPRNT COMMAND
C... IF THERE ARE NO ARGUMENTS,CALL APT298, IF THERE IS A SINGLE
C... ARGUMENT WHICH IS EITHER ON OR OFF,PROCESS LIKE A POSTPROCESSOR
C... COMMAND. OTHERWISE CALL ALARM.
C
   80 IF (ARGTOP .EQ. 0) GO TO 90
      ERRPT=1-ARGTOP
      IF(ARGTOP.GT.1)GOTO 85
      L = ARGSTK(1)
      IF(L.GT.NAMMAX)GOTO 84
      IF (CNAMTB(L) .EQ. HON .OR. CNAMTB(L) .EQ. HOFF)  GO TO 30
   84 ERRPT=-1
   85 CALL ALARM(2001,ERRPT,8,'PRO026  ')
      GO TO 22
   90 N = ONE
      GO TO 120
C
C... MACHIN COMMAND
C... IF THERE ARE NO ARGUMENTS,CALL ALARM. OTHERWISE CALL APT298
C
  100 ERRPT=TOP-1
      IF (ARGTOP .EQ. 0) GO TO 85
      N = THREE
      IF (ARGTOP .GT. 1)  GO TO 130
      ARGTOP = 2
      ARGSTK(2) = ARGSTK(1)
      ARGSTK(1) = 0
      GO TO 130
C... NOPOST COMMAND
  110 IF (ARGTOP .GT. 0)  CALL ALARM(2002,-ARGTOP,4,'PRO026  ')
      N = TWO
  120 ARGSTK(1) = ZEROPT
      ARGSTK(2) = ZEROPT
      ARGTOP = 2
  130 CALL CALLZZ(APT298)
      CALL TWOARG(DLR,N)
      CALL ARGCVT(ARGSTK(ARGTOP))
      CALL ARGCVT(ARGSTK(ARGTOP-1))
      CALL RLSLIN
C... IF COMMAND IS MACHIN, GO TO POSTPROCESSOR PROCESSING NEXT.
C... OTHERWISE TAKE NORMAL EXIT.
C
      IF(HOP.EQ.33)GO TO 30
      GO TO 22
C
C... CONTRL STATEMENT
C
  500 IF(JUMPTO.NE.0)JUMPTO=SEQNO+2
      IF(ARGTOP.EQ.0)GO TO 550
      DO 540 I=1,ARGTOP
      K=ARGSTK(I)
      IF(K.GT.NAMMAX)GO TO 530
      DO 520 J=1,4
      IF(CNAMTB(K).NE.ICNTRL(J))GO TO 520
      CFLAGS(J)=.TRUE.
      GO TO 540
  520 CONTINUE
  530 CALL ALARM(2042,-I,4,'PRO026  ')
  540 CONTINUE
      GO TO 22
  550 CALL ALARM(2030,TOP-1,4,'PRO026  ')
      GO TO 22
C
C... PPOPTN STATEMENT
C
  600 IF(JUMPTO.NE.0)JUMPTO=SEQNO+2
      IF(ARGTOP.EQ.0)GO TO 550
      ERRPT=-1
      IF(2*(ARGTOP/2).NE.ARGTOP)GO TO 690
C        CHECK EACH ARGUMENT PAIR
      DO 680 I=2,ARGTOP,2
      K=ARGSTK(I-1)
      ERRPT=1-I
      IF(K.GT.NAMMAX)GO TO 690
      IF(CNAMTB(K).NE.HON)GO TO 605
      LTEMP=.TRUE.
      GO TO 610
  605 IF(CNAMTB(K).NE.HOFF)GO TO 690
      LTEMP=.FALSE.
  610 K=ARGSTK(I)
      ERRPT=-I
C
      DO 620 J=1,5
      IF(CNAMTB(K).NE.IPPOPT(J))GOTO 620
      HOP=J
      GO TO 625
  620 CONTINUE
      GO TO 690
C
  625 GO TO (630,640,650,660,670),HOP
C        INTLNG
  630 ILPRT=LTEMP
      GO TO 680
C        PRTER
  640 PRTERR=LTEMP
      GO TO 680
C        REFMOT
  650 J=TWO
      IF(LTEMP)J=ONE
      GO TO 665
C        ALTMLT
  660 J=FOUR
      IF(LTEMP)J=THREE
      GO TO 665
C         CILPRT
  670 CONTINUE
      J=SIX
      IF(LTEMP) J=FIVE
C---     COMPRESSED IL PRINT IS TURNED ON FROM -ON- INPUT.
      IF(LTEMP) CILPRT=.TRUE.
  665 CALL CALLZZ(APTXXX(18))
      CALL TWOARG(DLR,J)
      CALL RLSLIN
  680 CONTINUE
      GO TO 22
C
C        ERROR IN PPOPTN STATEMENT
  690 CALL ALARM(2039,ERRPT,8,'PRO026  ')
      GO TO 22
C
C... CALLED MACRO HAS NOT BEEN DEFINED.  CHECK FOR SYSTEM MACRO.
C
 4300 IGOTO=5
      GO TO 99
C
C...  DYNDMP , NUMPTS OR MAXDP STATEMENT
C
  180 J=3
      GOTO 201
  200 J=2
      IF(ARGTOP.NE.1)GOTO 201
      ARGSTK(2)=ARGSTK(1)
      ARGSTK(1)=ZEROPT
      ARGTOP=2
      GOTO 202
  190 J=1
  201 IF(ARGTOP.EQ.0)GO TO 209
      IF(ARGTOP.LE.J)GO TO 202
      ERRPT=J-ARGTOP
      GOTO 210
  202 DO 203 I=1,ARGTOP
      ERRPT=-I
      IF(MODE(ARGSTK(I)).NE.REAL)GOTO 205
  203 CONTINUE
      GOTO 3000
  205 CALL ALARM(2021,ERRPT,8,'PRO026  ')
      GOTO 22
  209 ERRPT=TOP-1
  210 CALL ALARM(2052,ERRPT,8,'PRO026  ')
      GOTO 22
C
 3000 CALL CALLZZ(K)
      IF (ARGTOP .NE. 0)  CALL ARGGEN
 7080 CALL RLSLIN
      IF(CNAMTB(K).EQ.FINIT)GOTO 151
   22 IF(ENTRY)GO TO 6002
 6053 NEWSTM=.TRUE.
      ARGTOP=0
      RETURN
   23 IF(CNAMTB(STACK(1,TOP-1)).NE.CONTIN)GOTO 22
      DOJUMP=3
      CALL LOOP
      GOTO 22
C
C... GODLTA STATEMENT
C
  700 ASSIGN 22 TO IRET
      IF(ARGTOP.LT.1)GO TO 9991
      ERRPT=4-ARGTOP
      IF(ARGTOP.GT.4)GO TO 9990
      GO TO(750,720,730,720),ARGTOP
  720 TEST=ARGSTK(1)
      ILIST=1
      IF(MODE(TEST).NE.REAL)GO TO 9992
      ASSIGN 725 TO ASNVAR
      GO TO 7002
C
  725 ARGTOP=ARGTOP-1
      DO 728 I=1,ARGTOP
      ERGSTK(I)=ERGSTK(I+1)
  728 ARGSTK(I)=ARGSTK(I+1)
      IF(ARGTOP.EQ.1)GO TO 750
C
  730 L=ZEROPT
  732 J=GETTMP(VECTOR)
      CALL OPCODE(MOVE)
      CALL ARGCVT(J)
      DO 740 I=1,3
      IF(ARGTOP.EQ.0)GO TO 735
      TEST=ARGSTK(ARGTOP)
      ILIST=ARGTOP
      IF(MODE(TEST).NE.REAL)GO TO 9992
      ARGTOP=ARGTOP-1
      GO TO 736
  735 TEST=ZEROPT
  736 CALL ARGCVT(TEST)
  740 CONTINUE
      CALL RLSLIN
      IF(L.EQ.ZEROPT)CALL REFGEN(3,J)
      GO TO 760
C
  750 J=ARGSTK(ARGTOP)
      ARGTOP=ARGTOP-1
      ILIST=ARGTOP
      L=MODE(J)
      IF(L.NE.REAL)GO TO 755
      L=J
      GO TO 732
C
  755 IF(L.NE.VECTOR)GO TO 790
      L=ZEROPT
  760 CALL CALLZZ(K)
      CALL ARGCVT(J)
      CALL ARGCVT(L)
      CALL RLSLIN
      GO TO 22
C
  790 CALL ALARM(2003,-ILIST,8,'PRO026  ')
      GO TO 22
C
C...  ENTRY FOR*FROM* AND*GOTO*
C                             IF FIRST ELEMENT IS PATERN, PROCESS
C                             GOTO/PATERN STATEMENT.
  800 IF(MODE(ARGSTK(ARGTOP)).NE.PATERN)GO TO 801
      CALL GOPAT
      GO TO 22
C
  801 ASSIGN 22 TO IRET
      IF(ARGTOP.LT.1)GO TO 9991
      ERRPT=7-ARGTOP
      IF(ARGTOP.GT.7)GO TO 9990
      TEST=ARGSTK(1)
      N=MODE(TEST)
      ILIST=1
      GO TO(860,830,825,820,805,845,805),ARGTOP
C
C... FEEDRATE RECOGNITION
C
  805 IF(N.NE.REAL)GO TO 9992
  810 ASSIGN 815 TO ASNVAR
      GO TO 7002
  815 ARGTOP=ARGTOP-1
      DO 818 I=1,ARGTOP
      ERGSTK(I)=ERGSTK(I+1)
  818 ARGSTK(I)=ARGSTK(I+1)
      TEST=ARGSTK(1)
      N=MODE(TEST)
      GO TO(870,842,863,840,9997,845),ARGTOP
C
  820 IF(N.NE.REAL)GO TO 840
      IF(MODE(ARGSTK(ARGTOP)).NE.REAL)GO TO 845
      GO TO 810
  825 IF(N.NE.REAL)GO TO 9992
      IF(MODE(ARGSTK(2)).NE.VECTOR)GO TO 863
      GO TO 810
  830 IF(N.EQ.VECTOR)GO TO 842
      IF(N.NE.REAL)GO TO 9992
      IF(MODE(ARGSTK(ARGTOP)).NE.POINT)GO TO 863
      GO TO 810
C
C... TLAXIS RECOGNITION
C
  840 IF(N.NE.VECTOR)GO TO 845
  842 KK=K
      K=TLAXIS
      DSTYPE=3
      ASSIGN 848 TO ASNVAR
      GO TO 1988
  845 KK=K
      K=TLAXIS
      DSTYPE=3
      ASSIGN 850 TO ASNVAR
      GO TO 1952
  848 DSTYPE=1
  850 K=KK
      ARGTOP=ARGTOP-DSTYPE
      DO 855 I=1,ARGTOP
      L=I+DSTYPE
      ERGSTK(I)=ERGSTK(L)
  855 ARGSTK(I)=ARGSTK(L)
C
C... GENERATE CALL TO FROM OR GOTO
C
      IF(ARGTOP.NE.1)GO TO 862
      TEST=ARGSTK(1)
      N=MODE(TEST)
  860 ERRPT=-1
      IF(N.NE.POINT)GO TO 890
      GO TO 870
  862 ILIST=ARGTOP
      IF(ARGTOP.NE.3)GO TO 9997
  863 L=GETTMP(POINT)
      CALL OPCODE(MOVE)
      CALL ARGCVT(L)
      CALL PUTTMP(POINT)
      J=3
      IF(ARGTOP.EQ.2)J=2
      DO 865 I=1,J
      TEST=ARGSTK(ARGTOP)
      ILIST=ARGTOP
      IF(MODE(TEST).NE.REAL)GO TO 9992
      CALL ARGCVT(TEST)
  865 ARGTOP=ARGTOP-1
      CALL RLSLIN
      TEST=L
      IF(J.NE.2)GO TO 867
      CALL CALLZZ(APT001)
      CALL ARGCVT(L)
      CALL RLSLIN
      GO TO 870
  867 CALL REFGEN(1,TEST)
  870 CALL CALLZZ(K)
      CALL ARGCVT(TEST)
      CALL RLSLIN
      ARGTOP=0
      GO TO 22
C
  890 CALL ALARM(2011,ERRPT,8,'PRO026  ')
      GO TO 22
C
C...  GO UP/
C...  INITIALIZE CHECK SURFACE COUNT
 1901 CALL MOTION
      IF(LERR) 9999,7080,7080
C...  GO/ COMMAND
C     INITIALIZATION
 1904 ARGCNT=ARGTOP
      DSFIND=.FALSE.
      PSFIND=.FALSE.
      FMTERR=.FALSE.
      NUMBCS=0
      IDRECT=0
C...  TEST FOR EXHAUSTION OF AGRUMENT LIST
  400 IF(ARGTOP.GE.1)GO TO 401
C...  THE ARGUMENT LIST IS EXHAUSTED. IF A DS WAS FOUND, TAKE NORMAL OUT
      IF(DSFIND) GO TO 415
C...  ARGUMENT LIST EXHAUSTED WITHOUT FINDING A DRIVE SURFACE.
      CALL ALARM(2004,TOP-1,8,'PRO026  ')
C...  TAKE RESTART ERROR EXIT
      FMTERR=.TRUE.
      IERROR=2001
      GO TO 499
  401 TEST=ARGSTK(ARGTOP)
      TEST1 = MODE(TEST)
      IF (TEST1.EQ.REAL) GOTO 5000
      IF ((NAMTBL(TEST)/MODULO).EQ.(PERMID(1)/MODULO)) GOTO 402
C...  NOT PERMANENT IDENTIFIER (TO,ON,PAST). TRY FOR SURFACE.
      IF((TEST1.GE.1.AND. TEST1.LE.17) .OR.
     1   (TEST1.GE.29 .AND. TEST1.LE.30)) GO TO 406
 5000 IF (.NOT.DSFIND) GOTO 420
      IF(TEST1.NE.REAL)GO TO 414
      ASSIGN 415 TO ASNVAR
      GO TO 7002
  414 CALL ALARM(2005,-ARGTOP,8,'PRO026  ')
      IF(FMTERR)GO TO 415
      IERROR=2002
      FMTERR=.TRUE.
      GO TO 415
C...  ITEM IS PERMANENT IDENTIFIER MAY BE TO,ON OR PAST
  402 IF (((NAMTBL(TEST)-PERMID(1)).EQ.3) .OR. ((NAMTBL(TEST)-PERMID
     /(1)).EQ.503)) GOTO 404
C...  NO MATCH,ILLEGAL FORMAT. TO ASSUMED
      CALL ALARM(2006,-ARGTOP,8,'PRO026  ')
      IF(FMTERR) GO TO 405
      IERROR=2003
      FMTERR=.TRUE.
      GO TO 405
C...  TO,ON OR PAST. SET IDRECT TO INDICATE MODE OF THIS SURFACE.
  404 IDRECT=TEST
C...  INCREMENT POINTER TO NEXT ITEM. THEN INSPECT REST OF STATEMENT
  405 ARGTOP=ARGTOP-1
      GO TO 400
C...  A SURFACE HAS BEEN DETECTED. IF THE FIRST, STORE DATA FOR LATER OU
C     TPUT. IF NOT, SEND OUT PART AND CHECK SURFACE CALLS
C
C...  CONVERT SURFACE TYPE TO BCD
C...  IF DRIVE SURFACE WAS FOUND ALREADY, THIS MAY BE A PART SURFACE.
  406 IF(DSFIND)GO TO 407
C...  FIRST SURFACE NOTED IS DRIVE SURFACE
      DSFIND=.TRUE.
      HMOD=IDRECT
      CSPNTR=TEST
C...  GO BACK FOR REST OF STATEMENT
      GO TO 6006
C...  IF PART SURFACE WAS FOUND ALREADY, THIS IS A CHECK SURFACE
  407 IF(PSFIND)GO TO 409
C...  SECOND SURFACE NOTED IS PART SURFACE
      PSFIND=.TRUE.
      CALL CALLZZ(PSIS)
      IF(IDRECT)6012,6012,6013
 6012 CALL TWOARG(DBLDLR,TO)
      GO TO 6014
 6013 CALL ARGCVT(IDRECT)
 6014 CALL ARGCVT(TEST)
  408 CALL RLSLIN
 6006 IDRECT=0
      GO TO 405
C...  CHECK SURFACES
  409 NUMBCS=NUMBCS+1
      IF (NUMBCS.EQ.1) GOTO 410
      CALL ALARM(2008,-ARGTOP,8,'PRO026  ')
      GOTO 6006
  410 CALL CALLZZ(APT200)
      IF(IDRECT)6015,6015,6016
 6015 CALL TWOARG(DBLDLR,TO)
      GO TO 6017
 6016 CALL ARGCVT(IDRECT)
 6017 CALL ARGCVT(TEST)
      CALL ARGCVT(ONEPT)
      GO TO 408
C...  NESTED FEDRAT
 7002 CALL CALLZZ (APT299)
      CALL TWOARG (QUIDLR,1)
      CALL TWOARG(DBLDLR,FEDRAT)
      CALL TWOARG (QUIDLR,1)
      CALL ARGCVT(TEST)
      CALL RLSLIN
      GO TO ASNVAR,(415,725,815)
C...  STATEMENT SHOULD NOW BE COMPLETELY PROCESSED
  415 IF(ARGTOP.GT.1)CALL ALARM(2007,1-ARGTOP,4,'PRO026  ')
C...  ANY FORMAT ERRORS ENCOUNTERED
      IF(FMTERR) GO TO 499
C...  OUTPUT GO/ CALL
 7007 CALL CALLZZ(K)
      IF(HMOD)6018,6018,6019
 6018 CALL TWOARG(DBLDLR,TO)
      GO TO 6020
 6019 CALL ARGCVT(HMOD)
 6020 CALL ARGCVT(CSPNTR)
      IF(HMOD.GE.0)GOTO 7080
      CALL ARGCVT(ARGSTK(2))
      CALL ARGCVT(ARGSTK(1))
      GO TO 7080
  420 CALL ALARM(2009,-ARGTOP,8,'PRO026  ')
      IF(FMTERR) GO TO 405
      FMTERR=.TRUE.
      IERROR=2004
      GO TO 405
C...  ERROR IN GO/ COMMAND SIGNAL RESTART WITH FIRST UNRECOVERABLE ERROR
  499 CALL CALLZZ(ERROR)
      CALL TWOARG(QUIDLR,IERROR)
      GO TO 7080
C
C...     TLAXIS
 1913 CALL PRO028(ERAS)
      GOTO 22
C
 1952 TEST=GETTMP(VECTOR)
      CALL OPCODE(MOVE)
      CALL TWOARG(NOUGHT,TEST)
      DO 1954 I=1,3
      ILIST=4-I
      M=ARGSTK(ILIST)
      IF(MODE(M).NE.REAL)GO TO 9992
 1954 CALL ARGCVT(M)
      CALL RLSLIN
      CALL REFGEN(3,TEST)
      CALL PUTTMP(VECTOR)
      GO TO 1988
C
C...     CUTTER
 1912 ERRPT=7-ARGTOP
      ASSIGN 9999 TO IRET
      IF(ARGTOP.GT.7)GO TO 9990
      IF(ARGTOP.LT.1)GO TO 9991
      GO TO 1970
C
C...     INTOL, OUTTOL, THICK, TOLER
 1909 ERRPT=4-ARGTOP
      ASSIGN 9999 TO IRET
      IF(ARGTOP.GT.4) GOTO 9990
      IF (ARGTOP.EQ.4) GOTO 1970
      IF(ARGTOP.LT.1)GO TO 9991
      DO 1911 I=1,4
        N=ARGTOP+1-I
        IF (N.LE.0) THEN
          N=1
          IF (ARGSTK(1).GT.NAMMAX) THEN
            LSTCHR=0
            ARGSTK(1)=NUMB(CNUMTB(ARGSTK(1)-NAMMAX))+NAMMAX
          ENDIF
        ENDIF
        ARGSTK(5-I)=ARGSTK(N)
 1911 CONTINUE
      ARGTOP=4
 1970 DSTYPE=ARGTOP
      N=ARGTOP
C...     CHECK FOR SCALARS
      DO 1980 ILIST=1,N
      TEST=ARGSTK(ILIST)
      IF(MODE(TEST).NE.REAL)GO TO 9992
 1980 CONTINUE
C...     MOVE ARGUMENTS TO APTER ARRAY
      IF(ERAS)GO TO 1982
      CALL RESRVZ(ERASB,0,9,1)
      ERAS=.TRUE.
 1982 CALL OPCODE(MOVE)
      CALL TWOARG(NOUGHT,ERASB)
      CALL ARGGEN
      CALL RLSLIN
      TEST=ERASB
      ASSIGN 22 TO ASNVAR
C...     GENERATE CALL TO SUBROUTINE
 1988 CALL CALLZZ(K)
      CALL TWOARG(QUIDLR,DSTYPE)
      IF (K.EQ.TLAXIS) CALL TWOARG(QUIDLR,7)
      CALL ARGCVT(TEST)
      CALL RLSLIN
      GO TO ASNVAR,(22,848,850)
C...     PARAMETER LIST TOO LONG
 9989 ERRPT=1-ARGTOP
 9990 CALL ALARM(2012,ERRPT,8,'PRO026  ')
 9999 CALL CALLZZ(ERROR)
      CALL TWOARG(QUIDLR,83)
      CALL RLSLIN
      ARGTOP=0
      GO TO 22
C...     NO PARAMETERS GIVEN
 9991 CALL ALARM(12,TOP-1,8,'PRO026  ')
      GO TO  9200
C...     ILLEGAL ARGUMENT
 9992 CALL ALARM(2013,-ILIST,8,'PRO026  ')
      GO TO  9200
C...     WRONG CLDAT SEQUENCE
 9995 CALL ALARM(2046,-ARGTOP,8,'PRO026  ')
      GO TO  9200
C...  TOOL TO SURFACE RELATIONSHIPS
 1923 CALL REFREF
      GO TO 22
 9997 CALL ALARM(2052,-ILIST,8,'PRO026  ')
 9200 GOTO IRET,(22,9999)
C
C...     CLDAT/.....................
 2000 ASSIGN 22 TO IRET
      IF(ARGTOP.EQ.0)GOTO 9991
 2002 J=ARGSTK(ARGTOP)
      L=ARGSTK(1)
      IF(MODE(J).NE.REAL)GOTO 2004
C...     IT MUST BE CLDAT/0.,1.,3.,(ON-OFF)
      ERRPT=-1
      IF(ARGTOP.LT.4)GOTO 9997
      ERRPT=4-ARGTOP
      IF(ARGTOP.GT.4)GOTO 9990
      ILIST=1
      IF(CNAMTB(L).NE.HON.AND.CNAMTB(L).NE.HOFF)GOTO 9992
      DO 2003 I=2,3
      ILIST=ARGTOP-I
      IF(MODE(ARGSTK(I)).NE.REAL)GOTO 9992
 2003 CONTINUE
      GOTO 30
C...
 2004 SUB=K
      IF(CNAMTB(J).NE.START)GOTO 2012
C...     IT MUST BE CLDAT/START,INDEX,.........
      ERRPT=11-ARGTOP
      IF(ARGTOP.GT.11)GOTO 9990
      IF(.NOT.ODD1.OR..NOT.ODD2)GOTO 9995
      ODD=.FALSE.
 2005 ILIST=ARGTOP
      IF(ARGTOP.LT.2)GOTO 9997
      ILIST=ARGTOP-1
      IF(MODE(ARGSTK(ILIST)).NE.REAL)GOTO 9992
      J=ARGTOP-2
      IF(J.LT.1)GOTO 2009
 2006 DO 2008 ILIST=1,J
      N=NAMTBL(ARGSTK(ILIST))-PERMID(1)
      IF(N.GT.MODHLF)N=N-MODHLF
      IF(N.LT.180.OR.N.GT.188)GOTO 9992
 2008 CONTINUE
 2009 IF(J.EQ.ARGTOP)GOTO 2010
      ODD1=ODD
      GOTO 35
 2010 ODD2=.FALSE.
      GOTO 35
C...
 2012 IF(CNAMTB(J).NE.NOMORE)GOTO 2014
C...     IT MUST BE CLDAT/NOMORE,INDEX,.........
      IF(ODD1)CALL ALARM(2046,-ARGTOP,4,'PRO026  ')
      ODD=.TRUE.
      GOTO 2005
C...
 2014 IF(CNAMTB(J).NE.NORMAL)GOTO 2016
C...     IT MUST BE CLDAT/NORMAL
      IF(ODD2)CALL ALARM(2046,-ARGTOP,4,'PRO026  ')
      IF(ARGTOP.GT.1)GOTO 9989
      ODD2=.TRUE.
      GOTO 35
C...     IT MUST BE CLDAT/TP,TA,TV,PDS,PPS,NDS,NPS,UVPDS,UVPPS
 2016 ILIST=ARGTOP
      IF(.NOT.ODD1.OR..NOT.ODD2)GOTO 9995
      ERRPT=9-ARGTOP
      IF(ARGTOP.GT.9)GOTO 9990
      J=ARGTOP
      GOTO 2006
C
C...     TLPROJ/....................
C...     REGION/....................
 2100 IF(ARGTOP.EQ.0)GOTO 9991
      ERRPT=2-ARGTOP
      IF(ARGTOP-2)2110,2120,9990
 2110 ARGTOP=2
      ARGSTK(ARGTOP)=ZEROPT
      IF(ARGSTK(1).LE.NAMMAX) THEN
        IF (CNAMTB(ARGSTK(1)).EQ.HOFF) GOTO 3000
      ENDIF
      GOTO 2130
 2120 ILIST=ARGTOP
      J=ARGSTK(ARGTOP)
      IF (J.LE.NAMMAX) THEN
        IF(CNAMTB(J).EQ.HON.OR.CNAMTB(J).EQ.HAT)GOTO 2130
      ENDIF
      IF (MODE(J).NE.REAL) GOTO 9992
      ILIST=1
      J=ARGSTK(ILIST)
      IF (J.LE.NAMMAX) THEN
        IF(CNAMTB(J).EQ.HIN.OR.CNAMTB(J).EQ.HOUT) GOTO 3000
      ENDIF
      GOTO 9992
 2130 ILIST=1
      J=ARGSTK(ILIST)
      IF(MODE(J).EQ.VECTOR)GOTO 3000
      IF (J.LE.NAMMAX)THEN
       IF(CNAMTB(J).EQ.NORMAL)GOTO 3000
      ENDIF
      GOTO 9992
C
C... CHKSRF/....
C
 2200 IF (ARGTOP.EQ.0) GOTO 9991
      ERRPT=-1
      IF (MOD(ARGTOP,2).NE.0) THEN
        CALL ALARM(2055,ERRPT,8,'PRO026')
      ELSE
C... CHECK ARGUMENT PAIRS
        DO 2280 I=2,ARGTOP,2
C... 2ND ARGUMENT OF PAIR SHOULD BE 'ON' OR 'OFF'
          J=ARGSTK(I-1)
          ERRPT=1-I
          IF (J.GT.NAMMAX) THEN
            CALL ALARM(2056,ERRPT,8,'PRO026')
            GOTO 22
          ELSE IF ((CNAMTB(J).EQ.HON).OR.(CNAMTB(J).EQ.HOFF)) THEN
            JMOD=J
          ELSE
            CALL ALARM(2056,ERRPT,8,'PRO026')
            GOTO 22
          ENDIF
C... 1ST ARGUMENT OF PAIR SHOULD BE 'PS' OR A SSURF
          J=ARGSTK(I)
          ERRPT=-I
          IF (J.GT.NAMMAX) THEN
            CALL ALARM(2057,ERRPT,8,'PRO026')
            GOTO 22
          ELSE
            TEST1=MODE(J)
            IF ((CNAMTB(J).EQ.HPS).OR.(TEST1.EQ.SSURF)) THEN
              CALL CALLZZ(K)
              CALL ARGCVT(J)
              CALL ARGCVT(JMOD)
              CALL RLSLIN
            ELSE
              CALL ALARM(2057,ERRPT,8,'PRO026')
              GOTO 22
            ENDIF
          ENDIF
 2280   CONTINUE
      ENDIF
      GOTO 22
C
C... RESERVE SPACE FOR THE TWO LARGEST LARGE DATA ARRAYS.
C
 1924 CALL LABCON(0)
      DOJUMP=5
      CALL LOOP
      IF(MAXSIZ(1) .EQ. 0) GO TO 1920
C
      MAXTWO=IABS(MAXSIZ(1))+IABS(MAXSIZ(2))
C
C
      CALL RESRVZ(DOTTAB,-1,MAXTWO,1)
 1920 IF (IFDUMP .NE. 0) GO TO 8300
      GO TO 3000
C... INDICATE FINI STATEMENT HAS BEEN PROCESSED
  151 FINI = .TRUE.
C
      IF(MACDFP.EQ.0) GOTO 7777
      CALL MNPROC
      IF(MACEND)GO TO 7777
      MACRED = .TRUE.
      INTMED = 1
      GO TO 6053
 7777 CALL EPILOG
      GOTO 6053
 1918 APTRAN = .TRUE.
C     CALL READ         CAUSES ABNORMAL END
      GO TO 22
C...  PSIS/SURFACE
 1914 IF(ARGTOP.GT.0)GOTO 1400
      CALL ALARM(13,TOP-1,8,'PRO026  ')
      GO TO 22
 1400 ILIST=ARGTOP-3
      IF(ARGTOP.GT.3)GOTO 9997
C...  COMPUTE POINTER AND MODE
      CSPNTR=ARGSTK(ARGTOP)
      CSTYPE=MODE(CSPNTR)
C...  IS THE FIRST ITEM A LEGITIMATE SURFACE
      IF((CSTYPE.GE.1 .AND. CSTYPE.LE.17) .OR.
     1   (CSTYPE.GE.29 .AND. CSTYPE.LE.30)) GO TO 1401
      CALL ALARM(2015,-ARGTOP,8,'PRO026  ')
      GO TO 22
 1401 HMOD=-1
      IF(ARGTOP.GT.1)GOTO 1402
C...  FORMAT OK
      ARGSTK(2)=ZERO(1)
 1404 ARGSTK(1)=ZERO(1)
      ARGSTK(3)=CSPNTR
      GO TO 7007
C     MORE THAN ONE ITEM FOLLOW THE SLASH
 1402 ILIST=ARGTOP-1
      J=ARGSTK(ILIST)
      IF(ARGTOP.EQ.3)GOTO 1405
      IF(NAMTBL(J).NE.20029)GOTO 9992
      ARGSTK(2)=ARGSTK(1)
      GO TO 1404
C     LIMIT AND SCALAR SHOULD FOLLOW
 1405 IF(NAMTBL(J).NE.20139)GOTO 9992
      ILIST=ARGTOP-2
      IF(MODE(ARGSTK(1)).NE.REAL)GOTO 9992
      GO TO 7007
C
 1925 ERRPT=TOP-1
      IF(ARGTOP.LT.1)GOTO 2411
      ERRPT=1-ARGTOP
      M=1
      IF(ARGTOP-2)6040,2411,6038
 6038 J=ARGSTK(1)
      M=2
      IF (J.LE.NAMMAX) THEN
        IF (NAMTBL(J)/MODULO*MODULO.EQ.TEMP(1)) GOTO 6039
      ENDIF
      IF(MODE(J).NE.REAL)GOTO 1928
 6039 CALL RESRVZ(DOTAC,REAL,1,1)
      CALL OPCODE(REPL)
      CALL ONEARG(1)
      CALL ARGCVT(DOTAC)
      CALL ARGCVT(J)
      CALL RLSLIN
      CALL OPCODE(VBLJMP)
      CALL ARGCVT(DOTAC)
 6040 DO 6045 I=M,ARGTOP
      ERRPT=ARGTOP+M-I
      CSPNTR=ARGSTK(ERRPT)
      IF (CSPNTR.GT.NAMMAX) GOTO 5001
      TEST1=MODULO*(NAMTBL(CSPNTR)/MODULO)
      IF((TEST1.EQ.TEMP(1)).OR.(TEST1.EQ.VBL(1)))GO TO 2410
      IF(TEST1.NE.LABEL(1) .AND. TEST1.NE.IMPLAB(1))
     / NAMTBL(CSPNTR)=IMPLAB(1)
      IF(WHCHMN.EQ.0)GO TO 6044
      GO TO 6046
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
 5001 CSPNTR=CSPNTR-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,CSPNTR,IDUMMY)
      CALL BCDBIN(CNUMTB(CSPNTR),KK,ICOUNT)
      CSPNTR=KK+10000
 6046 CALL MACLBL(CSPNTR,-WHCHMN,CSPNTR)
      IF(NAMTBL(CSPNTR).EQ.0)NAMTBL(CSPNTR)=IMPLAB(1)+WHCHMN
 6044 IF(ARGTOP.GT.1)GOTO 6041
      CALL JUMPZZ(CSPNTR)
      GOTO 6042
 6041 CALL ONEARG(CSPNTR)
 6042 CALL LABCON(CSPNTR)
 6045 CONTINUE
      IF(ARGTOP.GT.1)CALL RLSLIN
      GOTO 22
 2410 IF(ARGTOP.GT.1)CALL RLSLIN
 2411 CALL ALARM(2017,-ERRPT,8,'PRO026  ')
      GO TO 22
 1928 CALL ALARM(1008,-1,8,'PRO026  ')
      GO TO 22
C
C...     UNITS STATEMENT
 5800 ERRPT=1-ARGTOP
      IF(ARGTOP-1)5801,3000,5802
 5801 ERRPT=TOP-1
 5802 CALL ALARM(2052,ERRPT,8,'PRO026  ')
      GOTO 22
C
 8100 IF (ARGTOP .GT. 0) GO TO 8120
      CALL ALARM(2030,TOP-1,4,'PRO026  ')
      GO TO 22
 8200 K=NAME(SRPRNT)
      CALL CALLZZ(K)
      CALL TWOARG(QUIDLR,9)
      CALL ARGCVT(ARGSTK(ARGTOP))
      CALL TWOARG(QUIDLR,1)
      CALL RLSLIN
      GO TO 22
 1926 IF(FINMAC)GOTO 1927
      IF(.NOT.ILHLT)CALL RESERV
      GO TO 22
 1927 CALL ALARM(2045,0,8,'PRO026  ')
      GO TO 22
 2800 IGOTO=1
      GO TO 99
 1942 IGOTO=2
      GO TO 99
 1968 IGOTO=3
      GO TO 99
C
C     PUNCH
C
 8110 IGOTO=4
      GO TO 99
 1921 IGOTO=7
      GO TO 99
 1922 IGOTO=8
      GO TO 99
 5700 IGOTO=6
   99 CALL PRO027(IGOTO)
      GO TO 22
C
C...  P R O C E S S I N G   F O R   C F S A V E   A N D   P U N C H
C
 8120 I = ARGSTK(ARGTOP)
C
C     CHECK IF FIRST ARGUMENT IS A DIGIT.
C
      L=I
      IF (I .LE. NAMMAX) GO TO 8150
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
      I=I-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,I,IDUMMY)
      CALL BCDBIN(CNUMTB(I),J,L)
C
C     FIRST ARGUMENT IS A DIGIT.  CHECK IF IT IS LEGAL.
C
      IF (J .LE. 3) GO TO 8140
 8130 CALL ALARM(2031,-ARGTOP,4,'PRO026  ')
      GO TO 22
C
 8140 IF(ARGTOP.EQ.1)GOTO 8130
      ARGTOP=ARGTOP-1
      I = ARGSTK(ARGTOP)
C
C     CHECK IF SECOND ARGUMENT IS 'ALL'.
C
      IF(CNAMTB(I).NE.HALL)GOTO 8130
      GOTO 8180
C
C     DETERMINE THE FIRST ARGUMENT
C  PUNCH/ALL
 8150 J=1
      IF(CNAMTB(I).EQ.HALL)GOTO 8180
C  PUNCH/SCALAR , PUNCH/GEOM  ,  PUNCH/LISTON  , PUNCH/NOLIST
      M=MOD(NAMTBL(I),MODHLF)
      J=M-124
      IF(J.GT.1.AND.J.LT.6)GOTO 8180
C  PUNCH/RANDOM,...
      J=7
      IF(M.EQ.56)GOTO 8180
C  PUNCH/RETAIN,...
      J=8
      IF(M.EQ.65)GOTO 8180
C  MUST BE A LIST OF VARIABLE NAMES.
      J=6
C
C     CHECK IF PUNCH WAS SPECIFIED.
C
 8180 IF(HOP.EQ.37)GO TO 8110
C
C     CFSAVE
C
      GO TO (8240,8240,8240,8130,8130,8220), J
 8220 IF  (MODE(I) .NE. OBJECT) GO TO 8130
      J = I
C
 8240 IFDUMP = J
      GO TO 22
C
C...  GENERATE CALL TO APT104 IF IFDUMP IS INDEX TO OBJECT.
C
 8300 IF (IFDUMP .LE. 3) GO TO 3000
      CALL CALLZZ(APTXXX(85))
      CALL ARGCVT (IFDUMP)
      CALL RLSLIN
      GO TO 3000
      END
**** SOURCE FILE : M0006668.W05   ***
*
C
C              FORTRAN SUBROUTINE PRO027
C
C LINKAGE      SUBROUTINE PRO027(IGOTO)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    PRO026
C          SUBROUTINE    FOUTXX          SUBROUTINE    RECOG
C          SUBROUTINE    LIBOPC
C          SUBROUTINE    LIBRD
C          SUBROUTINE    LIBSCH
C          SUBROUTINE    MACLBL
C          SUBROUTINE    MCXTRN
C          INTEGER FCT.  MODE
C          INTEGER FCT.  NAME
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    BCDBIN
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    REFGEN
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  GETTMP
C          SUBROUTINE    TWOARG
C
      SUBROUTINE PRO027(IGOTO)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),SLASH(2),NUMBER(2),TEMP(2),PERMID(2),VBL(2),
     *          IDENT(2)
C SLASH:       (1)=CODE CLASS  5000,(2)=NAMTBL INDEX OF '/     '
      EQUIVALENCE (SLASH(1),CODE(9))
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(502),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12)
C ZEROPT:      NAMTBL POINTER TO '0.    '
      EQUIVALENCE (ZEROPT,NUMPTR(2))
C ONE:         NAMTBL POINTER TO '1     '
      EQUIVALENCE (ONE,NUMPTR(3))
C ONEPT:       NAMTBL POINTER TO '1.    '
      EQUIVALENCE (ONEPT,NUMPTR(4))
C THREE:       NAMTBL POINTER TO '3     '
      EQUIVALENCE (THREE,NUMPTR(6))
C
C       11.    SEQUENCE NUMBER STORAGE
C
      COMMON/SEQCOM/SEQCOM
      DIMENSION SEQCOM(3)
C SEQNO:       INTERNALLY GENERATED STATEMENT NUMBER
      EQUIVALENCE (SEQNO,SEQCOM(1))
C
C       12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE
      DIMENSION CFSIZE(1106),MAXSIZ(2),CANSIZ(2,100),KSC(3,300)
C CANTOP:      POINTER TO THE LAST CANSIZ ENTRY
      EQUIVALENCE (CANTOP,CFSIZE(1))
C MAXSIZ:      SIZE OF THE LAST LARGEST LARGE DATA ARRAY
      EQUIVALENCE (MAXSIZ(1),CFSIZE(4))
C CANSIZ:      NUMBER OF ITEMS A. NAMTBL INDEX OF EACH LARGE DATA ARRAY
      EQUIVALENCE (CANSIZ(1,1),CFSIZE(6))
C ISC:         POINTER TO LAST KSC ENTRY
      EQUIVALENCE (ISC,CFSIZE(206))
C KSC:         CONTAINS SYMBOL,SIZE AND NUMBER OF SEQMENTS OF SS-DEFIN.
      EQUIVALENCE (KSC(1,1),CFSIZE(207))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C REPL:        CONTAINS COMMAND CODE (17) FOR REPL COMMAND
      EQUIVALENCE (REPL,IL(17))
C MOVE:        CONTAINS COMMAND CODE (19) FOR MOVE COMMAND
      EQUIVALENCE (MOVE,IL(19))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C POINT:       MODE CODE (19) FOR POINT
      EQUIVALENCE (POINT,MODX(19))
C VECTOR:      MODE CODE (20) FOR VECTOR
      EQUIVALENCE (VECTOR,MODX(20))
C REAL:        MODE CODE (21) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C BOOL:        MODE CODE (23) FOR BOOLEAN TYPE
      EQUIVALENCE (BOOL,MODX(23))
C
C      25A.    MACRO PROCESSING ARRAY
C
      COMMON/MACXX5/MACXX5
      DIMENSION MACXX5(135),ITMPSV(135)
C ITMPSV:      TEMPORARY STORAGE DURING FINAL MACRO PROCESSING
      EQUIVALENCE (ITMPSV(1),MACXX5(1))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C NOUGHT:      CONTAINS OPERAND TYPE 0
      EQUIVALENCE (NOUGHT,OPMOD(1))
C DLR:         CONTAINS OPERAND TYPE CODE 1
      EQUIVALENCE (DLR,OPMOD(2))
C QUIDLR:      CONTAINS OPERAND TYPE CODE 5
      EQUIVALENCE (QUIDLR,OPMOD(6))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       30.    NAMTBL POINTERS TO FIRST CANONICAL FORMS IN EACH BLOCK
C
      COMMON/BLKCFS/FIRST
      DIMENSION FIRST(2,3)
C
C       31.    COMMON BLOCK FOR PRO026 AND MOTION
C
      COMMON/COMP26/COMP26
      DIMENSION COMP26(16)
C ARGCNT:      POINTER FOR CURRENT ARGSTK ELEMENT
      EQUIVALENCE (ARGCNT,COMP26(2))
C TEST:        NAMTBL INDEX OF CURRENT ARGUMENT
      EQUIVALENCE (TEST,COMP26(6))
C K:           NAMTBL POINTER TO MAJOR WORD
      EQUIVALENCE (K,COMP26(12))
C
C       33.    SYMBOLIC FILE DEFINITIONS
C
      INCLUDE (SYMFIL)    
C ELFIL1:      OUTPUT OF PACKING FACTOR FOR CREATING PAGES (INTERPRETER)
C
C       35.    COMMON BLOCK FOR BOUNDED GEOMETRY AND CFSAVE
C
      COMMON/BGEOM/BGEOM
      DIMENSION BGEOM(4)
C J:           PASSES PUNCH/ARGUMENT FROM PRO026 TO PRO027
      EQUIVALENCE (J,BGEOM(3))
C L:           PASSES PUNCH/LISTON OR NOLIST FROM PRO026 TO PRO027
      EQUIVALENCE (L,BGEOM(4))
C
C       36.    SYSTEM MACRO AND SEGMENT READ VARIABLES
C
      COMMON/MACSEG/MACSEG
      LOGICAL ALOPN,LMRSTR
      DIMENSION MACSEG(6)
C ALOPN:       TRUE AFTER MACRO OR PART PROGRAM SEGMENT LIBRARY OPENED
      EQUIVALENCE (ALOPN,MACSEG(1))
C NMSEG:       NAMTBL POINTER TO THE NAME OF THE PART PROGRAM SEGMENT
      EQUIVALENCE (NMSEG,MACSEG(2))
C NMMAC:       NAMTBL POINTER TO SYSTEM MACRO NAME
      EQUIVALENCE (NMMAC,MACSEG(3))
C LMRSTR:      FLAG ON STARTS READING IN A SYSTEM MACRO
      EQUIVALENCE (LMRSTR,MACSEG(4))
C ITMPCT:      NUMBER OF INTERNAL SYMBOLS GENERATED IN TRANSLATION
      EQUIVALENCE (ITMPCT,MACSEG(5))
C
C       39.    COMMON BLOCK LIBRARY PRINTING FLAG
C              FLAG ON CAUSE PRINTING OF INPUT LIBRARIES
      COMMON/LIBPRT/LIBPRT
      LOGICAL LIBPRT
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C
C       43.    DO LOOP CONTROL VALUES
C
      COMMON/DOLOOP/DOLOOP
      DIMENSION DOLOOP(8)
C JUMPTO:      MARKER SET AFTER JUMPTO OR IF FOR LABEL CONTROL
      EQUIVALENCE (JUMPTO,DOLOOP(1))
C*
C ARGUMENTS    IGOTO   INTEGER USED BY PRO027 TO BRANCH
C                      TO APPROPRIATE CODING
C
      CHARACTER*6 SYNLST(10)
      CHARACTER*6 SRFNAM(3),SURF
      DIMENSION INP(20)
      LOGICAL POINTX
      CHARACTER*6 HDOLPC,LRARG
      CHARACTER*6 SRPRNT,HON,HOFF,HALL
      CHARACTER*6 IEJECT,EJECT
      CHARACTER*6 HTABP,HSSPR,HSSTT,HAVPR
      DATA SRPRNT/'PRINT '/
      DATA     HON/'ON  '/,HOFF/'OFF '/,HALL/'ALL '/
      DATA  SYNTOP,SYNLST /10,'APTRAN','APTREN','CLOCK ',
     /'CLPRNT','CONTRL','FINI  ','MACRO ','PRINT',
     /'SYN   ','TERMAC'/
      DATA IEJECT/'1'/,EJECT/'EJECT '/
C
      DATA              SRFNAM/'DS    ' ,'PS    ','CS    '/
      DATA             HTABP/'TABPRT'/
      DATA             HSSPR/'SSPRT '/
      DATA             HSSTT/'SSTEST'/
      DATA             HAVPR/'AVPRT '/
      DATA ITBPRT/20130/
      DATA ILBPRT/20160/
      DATA HDOLPC/'$PCRTH'/
C
C*********************************************************************
C              SYN  PRINT POCKET  PUNCH   CALL   READ
      GO TO(  2800,  1942,  1968,  8110,  5700,  5700,4000,3800),IGOTO
C
C...     **** SYNONYM PROCESSING ****
C
C... CALL ALARM IF THE SYN STATEMENT HAS NO ARGUMENTS OR AN ODD NUMBER
C... OF ARGUMENTS
C
 2800 N = ARGTOP/2
      IF(ARGTOP.NE.0)GOTO 2805
      CALL ALARM(2018,TOP-1,8,'PRO027  ')
      GO TO 22
 2805 IF(ARGTOP .EQ. 2*N)GOTO 2810
      CALL ALARM(2018,-1,8,'PRO027  ')
      GO TO 22
C   ENTSCHEIDUNG WIE DIE SYN/-PAARE ZU INTERPRETIREN SIND
C   ANNAHME: SYN/SYNONYM,SPRACHWORT
 2810 I1=0
      I2=-1
C   ANDERNFALLS:WERTE VON I1 UND I2 VERTAUSCHEN
      IF(NAMTBL(ARGSTK(ARGTOP)).EQ.PERMID(1))GOTO 2812
      I1=-1
      I2= 0
C
C... PROCESS EACH PAIR OF ARGUMENTS
C
 2812 DO 2850  I=1,N
      K1= 2*I+I1
      K = ARGSTK(K1)
      L1= 2*I+I2
      L = ARGSTK(L1)
      IF(K.EQ.L)GOTO 2850
      IF(NAMTBL(L)/MODULO .NE. TEMP(1)/MODULO)GO TO 2815
      ITMPCT=ITMPCT+1
      CALL MACLBL(L,-ITMPCT,J)
      NAMTBL(J)=VBL(1)+REAL
      CALL RESRVZ(J,REAL,TXXXX(1,REAL),1)
      CALL OPCODE(REPL)
      CALL ONEARG(1)
      CALL ARGCVT(J)
      CALL ARGCVT(L)
      CALL RLSLIN
      L=J
C
C... IF THE SYNONYM IS A NUMBER,A SYNONYM FOR ITSELF, OR A SYNONYM FOR
C... A SPECIAL APT WORD FOR WHICH SYNONYMS ARE NOT ALLOWED,CALL ALARM
C
 2815 JJ=L
      LL=L1
 2825 IF(JJ.GT.NAMMAX)GO TO 2836
      DO 2820  J = 1,SYNTOP
      IF (CNAMTB(JJ).EQ. SYNLST(J))GOTO 2830
 2820 CONTINUE
 2836 IF(JJ.EQ.K)GOTO 2840
      JJ=K
      LL=K1
      GOTO 2825
 2830 CALL ALARM(2019,-LL,8,'PRO027  ')
      GO TO 2850
C
C... IF THE SYNONYM IS NOT A PERMANENT IDENTIFIER,ISSUE A WARNING
C
 2840 IF(NAMTBL(K).EQ.PERMID(1))GOTO 2845
      IF(K.GT.NAMMAX.AND.L.GT.NAMMAX)GOTO 2830
      K = ARGSTK(L1)
      L = ARGSTK(K1)
      K1=L1
      IF (NAMTBL(K).NE.PERMID(1))GOTO 2846
      GOTO 2849
 2845 IF (NAMTBL(L).NE.PERMID(1))GOTO 2849
 2846 CALL ALARM(2035,-K1,4,'PRO027  ')
C
C... SET THE FIRST ITEM OF THE SYNONYMS NAMTBL ENTRY = MINUS THE NAMTBL
C... INDEX OF THE ASSOCIATED WORDS ENTRY
C
 2849 NAMTBL(K) = -L
 2850 CONTINUE
      GO TO 22
C
C...       PRINT STATEMENT
C
 1942 IF (ARGTOP .GT. 0)  GO TO 8010
      ERRPT=TOP-1
      IF (CNAMTB(STACK(1,TOP-1)).NE.EJECT)GOTO 8015
      CALL FOUTXX(ELFIL1,IEJECT,1)
      IF(JUMPTO.NE.0)JUMPTO=SEQNO+2
      GO TO 22
 8015 CALL ALARM(2030,ERRPT,4,'PRO027  ')
      GO TO 22
 8008 ERRPT=1-ARGTOP
 8009 CALL ALARM(2031,ERRPT,4,'PRO027  ')
      GO TO 22
 8010 J = ARGSTK(ARGTOP)
      ERRPT=-ARGTOP
      IF (CNAMTB(STACK(1,TOP-1)).EQ.EJECT)GOTO 8009
      II=1
      IF(J.LE.NAMMAX) GOTO 8011
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
      J=J-NAMMAX
      IF (NLAST.GT.0)CALL MCXTRN(5,J,IDUMMY)
      I = 7
      IF(CNUMTB(J).EQ.CNUMTB(ZEROPT-NAMMAX))GOTO 8020
      IF(CNUMTB(J).EQ.CNUMTB(ONEPT-NAMMAX)) GOTO 8020
      GOTO 8030
 8011 I = 8
      IF(NAMTBL(J).EQ.ILBPRT.OR.
     X   NAMTBL(J)-MODHLF.EQ.ILBPRT) GO TO 6000
      IF(NAMTBL(J).EQ.ITBPRT.OR.NAMTBL(J)-MODHLF.EQ.ITBPRT)GOTO 8025
      I = 11
 8019 IF (CNAMTB(J) .EQ. HON )GOTO 8020
      I = I + 1
      IF (CNAMTB(J) .EQ. HOFF )GOTO 8020
      GOTO(8030,8008),II
 8020 CALL CALLZZ(K)
      CALL TWOARG(QUIDLR,I)
      CALL ARGCVT(J)
      CALL TWOARG(QUIDLR,1)
      CALL RLSLIN
      ERRPT=II-ARGTOP
      IF(ARGTOP.GT.II)GOTO 8009
      GO TO 22
 8025 JJ=J
      II=2
      J=ARGSTK(ARGTOP-1)
      I = 16
C     PRINT/TABPRT,ON/OFF
      IF(CNAMTB(JJ).EQ.HTABP)GOTO 8019
      I=18
C     PRINT/SSPRT ,ON/OFF
      IF(CNAMTB(JJ).EQ.HSSPR)GOTO 8019
      I=20
C     PRINT/SSTEST,ON/OFF
      IF(CNAMTB(JJ).EQ.HSSTT)GOTO 8019
      I=22
C     PRINT/AVPRT,ON/OFF
      IF(CNAMTB(JJ).EQ.HAVPR)GOTO 8019
      IF(ARGTOP.EQ.1)GOTO 8035
      GOTO 8009
 8030 CALL BCDBIN(CNUMTB(J),M,N)
      IF (M.EQ. 2 .OR. M .EQ. 3)  GO TO 8032
      GOTO 8009
 6000 J=ARGSTK(ARGTOP-1)
      IF(CNAMTB(J).NE.HON)GOTO 6010
      LIBPRT=.TRUE.
      GOTO 6020
 6010 IF(CNAMTB(J).NE.HOFF)GOTO 8008
      LIBPRT=.FALSE.
 6020 ERRPT=2-ARGTOP
      IF(ARGTOP.GT.2)GOTO 8009
      GO TO 22
 8032 IF(ARGTOP.GT.1)GOTO 8033
 8035 CALL ALARM(2052,ERRPT,4,'PRO027  ')
      GO TO 22
 8033 ARGTOP=ARGTOP-1
      J = ARGSTK(ARGTOP)
      IF (CNAMTB(J).NE.HALL)GOTO 8036
      J = 0
      IF (M .EQ. 2) J = 3
      DO 8034  I = 1,3
      J = J + 1
      IF(FIRST(2,I).EQ.0) GO TO 8034
      CALL CALLZZ(K)
      CALL TWOARG(QUIDLR,J)
      CALL ARGCVT(FIRST(1,I))
      CALL TWOARG(QUIDLR,FIRST(2,I))
      CALL RLSLIN
 8034 CONTINUE
      IF(ARGTOP.GT.1)GOTO 8008
      GO TO 6020
 8036 DO 8060  I = 1,ARGTOP
      L = ARGTOP + 1 - I
      J = ARGSTK(L)
      N = 10
      IF (J .GT. NAMMAX)  GO TO 8050
      L=MOD(NAMTBL(J),MODULO)
      JJ=(NAMTBL(J)/MODULO)*MODULO
      IF(JJ.NE.VBL(1))GO TO 8038
      IF(L.GT.MODHLF)L=L-MODHLF
      GO TO 8040
 8038 IF(JJ.EQ.TEMP(1))GO TO 8040
      IF(JJ.EQ.NUMBER(1) .AND. L.EQ.MODHLF)GO TO 8050
      CALL ALARM(2031,I-1-ARGTOP,4,'PRO027  ')
      GO TO 8060
 8040 N=1
      IF (L .EQ. REAL .OR. L .EQ. BOOL)  GO TO 8045
      N = 2
      IF (L .EQ. REAL+MODHLF .OR. L .EQ. BOOL+MODHLF)  GO TO 8045
      N = 3
 8045 IF (M.EQ.2) N=N+3
 8050 CALL CALLZZ(K)
      CALL TWOARG(QUIDLR,N)
      CALL ARGCVT(J)
      CALL TWOARG(QUIDLR,1)
      CALL RLSLIN
 8060 CONTINUE
      GO TO 22
C...       POCKET STATEMENT
C
 1968 ERRPT=-1
      IF(ARGTOP.LT.1)ERRPT=TOP-1
      IF(ARGTOP.LT.11)GOTO 1974
      ERRPT=28-ARGTOP
      IF(ARGTOP.GT.28)GOTO 1974
      DO 1969 IPC=1,8
      ARGCNT=ARGTOP+1-IPC
      ERRPT=-ARGCNT
      TEST=MODE(ARGSTK(ARGCNT))
      IF(TEST.NE.REAL)GO TO 1974
 1969 CONTINUE
      JARG=ARGTOP-8
      DO 1970 IPC=1,JARG
      ARGCNT=JARG+1-IPC
      TEST=MODE(ARGSTK(ARGCNT))
      ERRPT=-ARGCNT
      IF(TEST.NE.POINT)GO TO 1974
 1970 CONTINUE
      KPCRTH=NAME(HDOLPC)
      IF (NAMTBL(KPCRTH).NE.0) GO TO 1972
      NAMTBL(KPCRTH)=VBL(1)
      CALL RESRVZ(KPCRTH,0,98,1)
 1972 DO 1973 IPC=1,JARG
      ARGCNT=JARG+1-IPC
      LPC=2-3*IPC
      CALL OPCODE(REPL)
      CALL ONEARG(3)
      CALL TWOARG(LPC,KPCRTH)
      CALL ARGCVT(ARGSTK(ARGCNT))
 1973 CALL RLSLIN
      CALL CALLZZ(K)
      DO 1971 IPC=1,8
 1971 CALL ARGCVT(ARGSTK(ARGTOP+1-IPC))
      CALL TWOARG(QUIDLR,JARG)
      CALL TWOARG(NOUGHT,KPCRTH)
      CALL RLSLIN
      GO TO 22
 1974 CALL ALARM(2034,ERRPT,8,'PRO027  ')
      GO TO 22
C
C
C ***************** P U N C H   P R O C E S S I N G ******************
C
 8110 JJ=J
      IF(J.GT.5)GOTO 8112
      IF(ARGTOP.GT.1)CALL ALARM(2031,-ARGTOP,4,'PRO027  ')
 8112 GO TO (8160,8160,8180,8115,8115,8140,7100,7100),J
C            1    2    3    4    5    6
C
C ... J IS 4 OR 5 FOR LISTON OR NOLIST.  GENERATE CALL TOPRINT
C     WITH CODE=J+9.
C
 8115 K=NAME(SRPRNT)
      I=J+9
      J=L
      II=ARGTOP
      GO TO 8020
C
C ... INVALID ARGUMENT.
 8120 CALL ALARM(2031,ERRPT,4,'PRO027  ')
      GO TO 8150
C
C...  VALIDATE LIST ITEMS AND GENERATE CALL I.L.
C
 8140 DO 8150 I=1,ARGTOP
      J = ARGTOP + 1 - I
      ERRPT=-J
      L = ARGSTK(J)
      IF(L.GT.NAMMAX)GO TO 8120
      IF (NAMTBL(L)/MODULO .NE. VBL(1)/MODULO .AND.
     / (NAMTBL(L)/MODULO .NE. TEMP(1)/MODULO .OR.
     / (NAMTBL(L)/MODULO .EQ. TEMP(1)/MODULO .AND.
     / NAMTBL(L)-TEMP(1) .LE. MODHLF)))  GO TO 8120
C
C... SET J = THE NUMBER OF THE BLOCK WHICH
C... CONTAINS THE CANONICAL FORM.
C
      J = 3
      IF (MOD(NAMTBL(L),MODULO) .EQ. REAL)  J = 1
      IF (NAMTBL(L)-TEMP(1) .EQ. MODHLF+REAL)  J = 2
      IF(JJ.LE.6)GOTO 7200
      J=JJ-3
      JJJ=NAMTBL(L)-VBL(1)
      IF(NAMTBL(L)/MODULO.EQ.TEMP(1)/MODULO)JJJ=NAMTBL(L)-TEMP(1)
     * -MODHLF
      IF(JJJ.EQ.11.OR.JJJ.EQ.12.OR.JJJ.EQ.26.OR.JJJ.EQ.29.OR.JJJ.EQ.30)
     /  GOTO 7200
      GOTO 8120
 7200 CALL CALLZZ(K)
      CALL TWOARG(QUIDLR,J)
      CALL ARGCVT(L)
      CALL TWOARG(QUIDLR,1)
      CALL RLSLIN
 8150 CONTINUE
      GO TO 22
C
C... PUNCH ALL SCALARS
C
 8160 DO 8170  I = 1,2
      IF (FIRST(2,I) .EQ. 0)  GO TO 8170
      CALL CALLZZ(K)
      CALL TWOARG(QUIDLR,I)
      CALL ARGCVT(FIRST(1,I))
      CALL TWOARG(QUIDLR,FIRST(2,I))
      CALL RLSLIN
 8170 CONTINUE
      IF (J .EQ. 2) GO TO 22
C
C... PUNCH ALL SURFACES
C
 8180 IF (FIRST(2,3) .EQ. 0)  GO TO 22
      CALL CALLZZ(K)
      CALL TWOARG(QUIDLR,3)
      CALL ARGCVT(FIRST(1,3))
      CALL TWOARG(QUIDLR,FIRST(2,3))
      CALL RLSLIN
      GO TO 22
C
C...     SYSTEM MACRO AND SEGMENT READ
C
 5700 IF(NMSEG.NE.0 .OR. NMMAC.NE.0)GO TO 5770
      IF (ARGTOP.EQ.0) THEN
        J=0
      ELSE
        J=ARGSTK(ARGTOP)
      ENDIF
      ERRPT=-ARGTOP
      IF(TOP.LT.9)GOTO 5705
      J=STACK(1,TOP-5)
      ERRPT=TOP-5
 5705 IF(J.GT.NAMMAX)GOTO 7000
      IF(ALOPN)GO TO 5710
      CALL LIBOPC(1,IFLAG)
      IF(IFLAG.NE.0)GO TO 5760
      ALOPN=.TRUE.
 5710 LRARG=CNAMTB(J)
      CALL LIBSCH(LRARG,IFLAG)
      IF(IGOTO.EQ.5)GO TO 5720
      IF(IFLAG.NE.0)GO TO 5780
      NMSEG=J
      IF(NAMTBL(NMSEG)/MODULO .EQ. PERMID(1)/MODULO)
     /     NAMTBL(NMSEG)=IDENT(1)
      GO TO 22
 5720 IF(IFLAG.NE.0)GO TO 5785
      NMMAC=J
      LMRSTR=.TRUE.
      ITMPSV(2)=TOP+1
      IF(TOP.GE.9)ITMPSV(2)=TOP-1
      K=TOP-1
      DO 5730 I=1,K
      ITMPSV(2*I+1)=STACK(1,I)
      ITMPSV(2*I+2)=STACK(2,I)
 5730 CONTINUE
      IF(TOP.GE.9)GO TO 5740
      ITMPSV(7)=SLASH(2)
      I=SLASH(1)/MODULO
      ITMPSV(8)=META(I)
      ITMPSV(9)=NMMAC
 5735 IF(NAMTBL(NMMAC)/MODULO .EQ. PERMID(1)/MODULO)
     /     NAMTBL(NMMAC)=IDENT(1)
      GO TO 22
 5740 I=STACK(1,TOP-1)
      IF(I.GT.NAMMAX)GO TO 5735
      J=NAMTBL(I)
      IF(J/MODULO.NE.TEMP(1)/MODULO)GO TO 5735
      IF((J-TEMP(1)).NE.REAL)GO TO 5755
      ITMPCT=ITMPCT+1
      CALL MACLBL(I,-ITMPCT,II)
      NAMTBL(II)=VBL(1)+REAL
      CALL RESRVZ(II,REAL,TXXXX(1,REAL),1)
      CALL OPCODE(REPL)
      CALL ONEARG(1)
      CALL ARGCVT(II)
      CALL ARGCVT(I)
      CALL RLSLIN
      CALL PUTTMP(REAL)
      ITMPSV(17)=II
      I=VBL(1)/MODULO
      ITMPSV(18)=META(I)
      GO TO 5735
C
 5750 IERROR=2001
      GO TO 5790
 5755 IERROR=1023
      ERRPT=TOP-1
      NMMAC=0
      LMRSTR=.FALSE.
      GO TO 5790
 5760 IERROR=72
      GO TO 5790
 5770 IERROR=71
      GO TO 5790
 5780 IERROR=73
      GO TO 5790
 5785 IERROR=17
 5790 CALL ALARM(IERROR,ERRPT,8,'PRO027  ')
C
   22 RETURN
C
C...  INDIRP  ENTRY
 4000 POINTX=.TRUE.
      GOTO 4001
C.....................................
C...  INDIRV  ENTRY
C...  SRFVCT  ENTRY
 3800 POINTX=.FALSE.
C...   SET UP IMPLIED SURFACES  DS,PS,CS.
 4001 DO 4090 IPARM=1,3
      SURF=SRFNAM(IPARM)
      IDECT=NAME(SURF)
C...  IS FIRST ITEM PERMID
      TEST=ARGSTK(ARGTOP)
      IF(TEST.GT.NAMMAX)GOTO 4007
      IF(NAMTBL(TEST)/MODULO.NE.PERMID(1)/MODULO) GOTO 4007
C...  IS FIRST WORD PS,DS, OR CS
      ARGTOP=ARGTOP-1
      IF(((NAMTBL(TEST)-PERMID(1)).EQ.1).OR.
     1   (NAMTBL(TEST)-PERMID(1)).EQ.501) GOTO 3719
C...  IMPROPER PERMID
      CALL ALARM(2010,-ARGTOP-1,4,'PRO027  ')
      GOTO 4007
C
 3719 IDECT=TEST
C...  SYMBOLIC OR NESTED DEFINITION OF VECTOR OR POINT YES,NO.
 4007 TEST=MODE(ARGSTK(ARGTOP))
      IF((POINTX.AND.(TEST.EQ.POINT)).OR.(.NOT.POINTX.AND.
     1   (TEST.EQ.VECTOR)))GOTO 4008
C...  NO.    CHECK  FOR THREE SCALARS.
      DO 4010 I=1,3
      ITOP=ARGTOP-I+1
      ERRPT=-ITOP
      IF(MODE(ARGSTK(ITOP)).NE.REAL)GOTO 4017
 4010 CONTINUE
C...  GET A TEMPORARY FOR A POINT OR VECTOR
      IF(.NOT.POINTX)GOTO 3705
      TEST=GETTMP(POINT)
      GOTO 3706
 3705 TEST=GETTMP(VECTOR)
C...  ASSIGN TEMPORARY STORAGE
 3706 CALL OPCODE(MOVE)
      CALL ARGCVT(TEST)
      CALL ARGCVT(ARGSTK(ARGTOP))
      CALL ARGCVT(ARGSTK(ARGTOP-1))
      CALL ARGCVT(ARGSTK(ARGTOP-2))
      CALL RLSLIN
      NEWTOP=ARGTOP-3
      GOTO 3721
 4008 TEST=ARGSTK(ARGTOP)
      NEWTOP=ARGTOP-1
C...  OUTPUT PROCEDURE CALL
 3721 IF(NEWTOP.NE.ARGTOP-3)GO TO 4026
      IF(POINTX)GO TO 4022
      M=VECTOR
      N=3
      GO TO 4024
 4022 M=POINT
      N=1
 4024 CALL REFGEN(N,TEST)
      CALL PUTTMP(M)
 4026 CALL CALLZZ(K)
      CALL ARGCVT(IDECT)
      CALL ARGCVT(TEST)
      CALL RLSLIN
 4028 ARGTOP=NEWTOP
      IF(ARGTOP.EQ.0) GOTO 22
 4090 CONTINUE
      ERRPT=-ARGTOP
 4017 CALL ALARM(2011,ERRPT,8,'PRO027  ')
      GOTO 22
C    TEST AUF READ/1,...
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
 7000 J=J-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,J,IDUMMY)
      CALL BCDBIN(CNUMTB(J),M,N)
      IF(M.NE.1) GOTO 5750
      ARGTOP=ARGTOP-1
      IF(ARGTOP.EQ.0)GOTO 5750
 7001 J=ARGSTK(ARGTOP)
      K5=(NAMTBL(J)/MODULO)*MODULO
      IF(K5.NE.VBL(1).AND.K5.NE.TEMP(1)) GOTO 7010
C   EINLESEUEBERPRUEFUNG FUER INDIZIERTE VARIABLE IN RESRED
      IF(K5.EQ.TEMP(1).AND.NAMTBL(J)-K5.GT.MODHLF)GOTO 7060
      CALL ALARM(1001,-ARGTOP,8,'PRO027  ')
      GO TO 22
C  LESEN VON 'APTLIB'
 7010 IF(ALOPN)GOTO 7020
      CALL LIBOPC(1,IFLAG)
      IF(IFLAG.NE.0)GOTO 5760
      ALOPN=.TRUE.
 7020 LRARG=CNAMTB(J)
      CALL FINDME(LDAFIL,LRARG,IFLAG)
      IF(IFLAG.NE.0)GOTO 5780
C    READ THE FIRST RECORD
      CALL RDSATZ(LDAFIL,INP,IDUM1,IDUM2,IFLAG)
      IF(IFLAG.NE.0)GOTO 5780
C FLAECHEN-ART
      M=INP(5)
C  GEOMETRIE QUALIFIZIEREN
      NAMTBL(J)=VBL(1)+M
C   SPEICHER RESERVIEREN
      CALL RESRVZ(J,M,TXXXX(1,M),1)
C IN INP(8) IST DIE LAENGE DER KANONISCHEN FORM GESPEICHERT
C  MAXSIZ,WENN NOETIG AENDERN
      IF(INP(8).LE.(IABS(MAXSIZ(2))))GOTO 7040
      IF(INP(8).LE.(IABS(MAXSIZ(1))))GOTO 7030
      MAXSIZ(2)=MAXSIZ(1)
      MAXSIZ(1)=INP(8)
      GOTO7040
 7030 MAXSIZ(2)=INP(8)
C NACH FREIEM PLATZ ABFRAGEN
 7040 DO 7045 I=4,ISC
      IF(J.EQ.KSC(1,I))GOTO 7048
 7045 CONTINUE
      ISC=ISC+1
      IF(ISC.LE.300)GOTO 7047
      CALL ALARM(34,-ARGTOP,8,'PRO027  ')
      GOTO 22
 7047 KSC(1,ISC)=J
      KSC(2,ISC)=INP(8)
 7048 JJ=MOD(J,CANTOP)
      DO 7050 I=1,CANTOP
      JJ=MOD(JJ,CANTOP)+1
      IF(CANSIZ(1,JJ).NE.0.AND.CANSIZ(2,JJ).NE.J)GOTO 7050
      CANSIZ(1,JJ)=INP(8)
      CANSIZ(2,JJ)=J
      GOTO 7060
 7050 CONTINUE
      CALL ALARM(53,-ARGTOP,8,'PRO027  ')
      GOTO 22
C  AUSGABE DES BEFEHLES 'READ/1,NAME'
 7060 CALL CALLZZ(K)
      CALL TWOARG(QUIDLR,1)
      CALL ARGCVT(J)
      CALL TWOARG(DLR,ONE)
      CALL RLSLIN
C SCHLIESSEN DES PDS-LESENS
      IF(ALOPN) CALL CLOSPE(LDAFIL,IFLAG)
      ALOPN=.FALSE.
      ARGTOP=ARGTOP-1
      ERRPT=-ARGTOP
      IF(ARGTOP.GT.0)GOTO 7001
      GOTO 22
C     VERARBEITUNG DER SONDER-PUNCH-ANWEISUNG
 7100 J=6
      ARGTOP=ARGTOP-1
      IF(ARGTOP.NE.0)GOTO 8140
      CALL ALARM(2030,TOP-1,4,'PRO027  ')
      GOTO 22
      END
**** SOURCE FILE : M0006669.V10   ***
*
C
C              FORTRAN SUBROUTINE PRTIL
C
C LINKAGE      SUBROUTINE PRTIL(LINE)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    FOUTXX          SUBROUTINE    RLSLIN
C          SUBROUTINE    OPPAIR
C          SUBROUTINE    BINBCD
C
      SUBROUTINE PRTIL(LINE)
C
      IMPLICIT INTEGER (A-Z)
C
C        0.    SYSTEM DEPENDENT PARAMETERS
C
      INCLUDE (SDP)    
C IWRD:        NO. OF BYTES PER INTEGER WORD
C IFAC:        BYTE LEFT SHIFT MULTIPLICATION FACTOR
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C
C       19.    INTERMEDIATE LANGUAGE TEXT
C
      COMMON/ILTEXT/ILTEXT
      DIMENSION ILTEXT(94),TEXTIN(90)
C TPNTRX:      POINTER TO LAST TEXTIN ENTRY
      EQUIVALENCE (TPNTRX,ILTEXT(3))
C OPTEXT:      CONTAINS COMMAND CODE FOR CURRENT I.L. COMMAND
      EQUIVALENCE (OPTEXT,ILTEXT(4))
C TEXTIN:      STORAGE FOR CURRENTLY GENERATED I.L. COMMAND ARGUM.LIST
      EQUIVALENCE (TEXTIN(1),ILTEXT(5))
C
C       33.    SYMBOLIC FILE DEFINITIONS
C
      INCLUDE (SYMFIL)    
C VLFILE:      VERIFICATION LISTING FILE
C*
C ARGUMENTS    LINE     OUTPUT ARRAY TO CONTAIN ALPHA-
C                       NUMERIC EQUIVALENT OF BINARY I.L..
C
      CHARACTER*6 OPBCD(21)
      CHARACTER*4 BLK,NEG
      CHARACTER*124  LINE
      DATA OPBCD( 1)/'FADD'/,
     1     OPBCD( 2)/'FSUB'/,
     2     OPBCD( 3)/'FMPY'/,
     3     OPBCD( 4)/'FDIV'/,
     4     OPBCD( 5)/'PEXP'/,
     5     OPBCD( 6)/'LABEL'/,
     6     OPBCD( 7)/'ENTRY'/,
     7     OPBCD( 8)/'JUMP'/,
     8     OPBCD( 9)/'SEQNCE'/,
     9     OPBCD(10)/'RETMC'/
      DATA OPBCD(11)/'CONJMP'/,
     1     OPBCD(12)/'RESRV'/,
     2     OPBCD(13)/'CVTSUB'/,
     3     OPBCD(14)/'CALMC'/,
     4     OPBCD(15)/'ASNADD'/,
     5     OPBCD(16)/'ASNJMP'/,
     6     OPBCD(17)/'REPL'/,
     7     OPBCD(18)/'CALL'/,
     8     OPBCD(19)/'MOVE'/,
     9     OPBCD(20)/'VBLJMP'/
      DATA OPBCD(21)/'HOLDAT'/
      DATA BLK/' '/,NEG/'   -'/
C**
      LINE(5:)=OPBCD(OPTEXT)
      GOTO (100,100,100,100,100,600,600,600,900,1000,1100,1200,1300,
     /1400,1500,1600,1700,1800,1900,2000,2100),OPTEXT
C
C...  FADD,FSUB,FMPY,FDIV,FEXP
C
  100 L=13
      DO 101 I=1,5,2
      CALL OPPAIR(LINE(L:),TEXTIN(I))
  101 L=L+20
      K=69
      GOTO 9000
C
C...  LABEL,ENTRY,JUMP
C
  600 ITEXT = TEXTIN(1)
      LINE(13:)=CNAMTB(ITEXT)
      K=21
      GOTO 9000
C
C...     SEQNCE
C
  900 LINE(13:)=BLK
      IF (TEXTIN(1)) 901,902,902
  901 LINE(13:)=NEG
  902 CALL BINBCD(IABS(TEXTIN(1)),LINE(17:),COUNT)
      K=25
      GOTO 9000
C
C...     RETMC
C
 1000 CALL BINBCD(TEXTIN(1),LINE(13:),COUNT)
      K=21
      GOTO 9000
C
C...  CONJMP
C
 1100 CALL OPPAIR(LINE(13:),TEXTIN(1))
      DO 1101 I=1,3
      ITEXT=TEXTIN(I+2)
      I1=I*8+25
      LINE(I1:)=CNAMTB(ITEXT)
 1101 CONTINUE
      K=57
      GOTO 9000
C
C...  RESRV
C
 1200 ITEXT = TEXTIN(1)
      LINE(13:)=CNAMTB(ITEXT)
      DO 1201 I=2,4
 1201 CALL BINBCD(TEXTIN(I),LINE(I*8+5:),COUNT)
      K=41
      GOTO 9000
C
C...  CVTSUB
C
 1300 L=13
      DO 1301 I=1,5,2
      CALL OPPAIR(LINE(L:),TEXTIN(I))
 1301 L=L+20
      CALL BINBCD(TEXTIN(7),LINE(65:),COUNT)
      K=81
      GOTO 9000
C
C...  CALMC
C
 1400 ITEXT = TEXTIN(1)
      LINE(13:)=CNAMTB(ITEXT)
      CALL BINBCD(TEXTIN(2),LINE(21:),COUNT)
      CALL BINBCD(TEXTIN(3),LINE(29:),COUNT)
      K=33
      GOTO 9000
C
C...  ASNADD
C
 1500 ITEXT = TEXTIN(1)
      LINE(13:)=CNAMTB(ITEXT)
      CALL OPPAIR(LINE(25:),TEXTIN(2))
      K=41
      GOTO 1601
C
C...  ASNJMP
C
 1600 ITEXT = TEXTIN(1)
      LINE(13:)=CNAMTB(ITEXT)
      ITEXT = TEXTIN(2)
      LINE(25:)=CNAMTB(ITEXT)
      K=33
 1601 LINE(21:)=BLK
      GOTO 9000
C
C...  REPL
C
 1700 CALL BINBCD(TEXTIN(1),LINE(13:),COUNT)
      CALL OPPAIR(LINE(21:),TEXTIN(2))
      CALL OPPAIR(LINE(41:),TEXTIN(4))
      K=61
      GOTO 9000
C
C...  CALL
C
 1800 ITEXT = TEXTIN(1)
      LINE(13:)=CNAMTB(ITEXT)
      LINE(21:32)=BLK
      LIMIT=TPNTRX-9
      J = 2
      L=33
      IF (LIMIT) 1804,1804,1801
 1801 DO 1803 I=1,LIMIT,10
      DO 1802 II=L,100,20
      CALL OPPAIR(LINE(II:),TEXTIN(J))
 1802 J = J+2
      CALL FOUTXX (VLFILE,LINE,116)
      L=13
      LINE(9:)=BLK
 1803 LINE(5:) = BLK
 1804 IF (TPNTRX.EQ.1) GOTO 1807
      DO 1805 I=J,TPNTRX,2
      CALL OPPAIR(LINE(L:),TEXTIN(I))
 1805 L=L+20
 1807 K = L
      GOTO 9000
C
C...  MOVE
C
 1900 LIMIT=TPNTRX-11
      J = 1
      L=13
      IF (LIMIT) 1804,1804,1801
C
C...  VBLJMP
C
 2000 CALL OPPAIR(LINE(13:),TEXTIN(1))
      ITEXT = TEXTIN(2)
      LINE(21:)=CNAMTB(ITEXT)
      L=29
 2006 J = 3
      LIMIT=TPNTRX-20+L/4
      IF (LIMIT) 2004,2004,2001
 2001 DO 2003 I=1,LIMIT,13
      DO 2002 II=L,112,8
      IF (OPTEXT.GT.20) GOTO 2007
      ITEXT = TEXTIN(J)
      LINE(II:)=CNAMTB(ITEXT)
      GOTO 2002
 2007 CALL HOLFRM(TEXTIN(J),LINE,II,IWRD,NWD)
      LINE(II+4:II+7)=BLK
 2002 J = J+1
      CALL FOUTXX (VLFILE,LINE,120)
      L=13
      LINE(9:12)=BLK
 2003 LINE(5:8) = LINE(1:4)
 2004 DO 2005 I=J,TPNTRX
      IF (OPTEXT.GT.20) GOTO 2008
      ITEXT = TEXTIN(I)
      LINE(L:) = CNAMTB(ITEXT)
      GOTO 2005
 2008 CALL HOLFRM(TEXTIN(I),LINE,L,IWRD,NWD)
      LINE(L+4:L+7)=BLK
 2005 L=L+8
      K = L
 9000 IF(K.GT.120)GOTO 9002
 9001 LINE(K:) = BLK
 9002 CALL FOUTXX(VLFILE,LINE,120)
      RETURN
C
C...  HOLDAT
C
 2100 ITEXT = TEXTIN(1)
      LINE(13:)=BLK
      LINE(17:)=CNAMTB(ITEXT)
      LINE(25:)=BLK
      CALL BINBCD(TEXTIN(2),LINE(29:),COUNT)
      L=37
      GOTO 2006
       END
**** SOURCE FILE : M0006670.V03   ***
*
C
C              FORTRAN SUBROUTINE PUTTMP
C
C LINKAGE      SUBROUTINE PUTTMP(MODE)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    BINBCD          SUBROUTINE    BOOLIF
C          SUBROUTINE    FOUTXX          SUBROUTINE    INPAT
C                                        SUBROUTINE    LARGES
C                                        SUBROUTINE    LCANON
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    PRO020
C                                        SUBROUTINE    PRO021
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    REPLAC
C                                        SUBROUTINE    SSDEF
C                                        SUBROUTINE    SUBCOD
C
      SUBROUTINE PUTTMP(MODE)
C
      IMPLICIT INTEGER (A-Z)
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C       33.    SYMBOLIC FILE DEFINITIONS
C
      INCLUDE (SYMFIL)    
C ELFIL1:      OUTPUT OF PACKING FACTOR FOR CREATING PAGES (INTERPRETER)
C*
C ARGUMENT     MODE      MODE OF TEMPORARY STORAGE NAME TO BE RELEASED
C
      CHARACTER INAM*24
      DATA INAM/' PUTTMP ERROR   '/
C**
      IF (TXXXX(2,MODE) .EQ. 0)    GO  TO  999
      TXXXX(2,MODE) = TXXXX(2,MODE)-1
      RETURN
C
C     ERROR
  999 CALL BINBCD(MODE,INAM(17:),I)
      CALL FOUTXX (ELFIL1,INAM,24)
      RETURN
       END
**** SOURCE FILE : M0006671.W01   ***
*
C
C              FORTRAN SUBROUTINE READ
C
C LINKAGE      SUBROUTINE READ (INCHAR)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ICONV           SUBROUTINE    INPUT
C          SUBROUTINE    CREAD           SUBROUTINE    PRO026
C          SUBROUTINE    LIBRD
C          SUBROUTINE    CPRINT
C          SUBROUTINE    ALARM
C          SUBROUTINE    CFORM
C
      SUBROUTINE READ (INCHAR)
C
      IMPLICIT INTEGER (A-Z)
C
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),RTERM(2),SLASH(2),QUOTE(2)
C RTERM:       (1)=CODE CLASS  4000,(2)=NAMTBL INDEX OF 'RTERM '
      EQUIVALENCE (RTERM(1),CODE(7))
C SLASH:       (1)=CODE CLASS  5000,(2)=NAMTBL INDEX OF '/     '
      EQUIVALENCE (SLASH(1),CODE(9))
C QUOTE:       (1)=CODE CLASS 12000,(2)=NAMTBL INDEX OF ''     '
      EQUIVALENCE (QUOTE(1),CODE(23))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(502),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        5.    PROGRAM CONTROL FLAGS
C
      COMMON/FLAGS/FLAGS
      LOGICAL NEWSTM
      DIMENSION FLAGS(4)
C NEWSTM:      TRUE WHEN NEXT SOURCE STATEMENT REQUESTED FOR PROCESS
      EQUIVALENCE (NEWSTM,FLAGS(2))
C
C        7.    STRING STORAGE AREA
C              POINTER TO THE LAST PROCESSED CHARACTER OF A STATEMENT
      COMMON/INPTR/CNT
C
C       11.    SEQUENCE NUMBER STORAGE
C
      INCLUDE (SEQCOM)    
C SEQNO:       INTERNALLY GENERATED STATEMENT NUMBER
C
C       20.    IO - ARRAY
C              I/O ARRAY
      INCLUDE (DARRAY)    
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL MACLDD
      DIMENSION MACXX1(71)
C MACLDD:      TRUE WHEN MACRO TEXT IS TO BE LOAD INTO MCBUFF TABLE
      EQUIVALENCE (MACLDD,MACXX1(7))
C
C      25A.    MACRO PROCESSING ARRAY
C
      COMMON/MACXX5/MACXX5
      DIMENSION MACXX5(135),ITMPSV(135)
C ITMPSV:      TEMPORARY STORAGE DURING FINAL MACRO PROCESSING
      EQUIVALENCE (ITMPSV(1),MACXX5(1))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C
C       36.    SYSTEM MACRO AND SEGMENT READ VARIABLES
C
      COMMON/MACSEG/MACSEG
      LOGICAL LMRSTR,LMREND
      DIMENSION MACSEG(6)
C NMSEG:       NAMTBL POINTER TO THE NAME OF THE PART PROGRAM SEGMENT
      EQUIVALENCE (NMSEG,MACSEG(2))
C NMMAC:       NAMTBL POINTER TO SYSTEM MACRO NAME
      EQUIVALENCE (NMMAC,MACSEG(3))
C LMRSTR:      FLAG ON STARTS READING IN A SYSTEM MACRO
      EQUIVALENCE (LMRSTR,MACSEG(4))
C LMREND:      FLAG ON AFTER COMPLETION READING A SYSTEM MACRO
      EQUIVALENCE (LMREND,MACSEG(6))
C
C       39.    COMMON BLOCK LIBRARY PRINTING FLAG
C              FLAG ON CAUSE PRINTING OF INPUT LIBRARIES
      COMMON/LIBPRT/LIBPRT
      LOGICAL LIBPRT
C
C       40.    PARAMETERS REQUIRED BY SUPERVISOR
C
      INCLUDE (SUPER)    
C END:         FLAG TO INDICATE LAST PART PROGRAM
C IRDSAV:      SAVE AREA FOR FIRST CARD IN PART PROGRAM
C
C       43.    DO LOOP CONTROL VALUES
C
      COMMON/DOLOOP/DOLOOP
      LOGICAL DLRFLG
      DIMENSION DOLOOP(8)
C DLRFLG:      FLAG IS ON WHEN CONTINUATION CARD EXPECTED
      EQUIVALENCE (DLRFLG,DOLOOP(8))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ERRPNT
      DIMENSION ERRPOS(302),ERRPNT(100)
C ERRPNT:      CONTAINS POINTERS TO INPUT STATEMENT TEXT POSITIONS
      EQUIVALENCE (ERRPNT(1),ERRPOS(3))
C*
      PARAMETER (NVLD=80)
      CHARACTER RDCHAR*80,VALIDC*(NVLD)
      DIMENSION INCHAR(76),CONV(NVLD)
      CHARACTER*6 IA(5),LRARG
      CHARACTER*4 IBLK,CFINI
      LOGICAL QTFLG,READFG,LIBFLG
      DATA          READFG /.TRUE./
      DATA  II,IBLK,CFINI,LINEST /0,'    ','FINI',13/
      DATA IA/'PARTNO','TITLES','PPRINT','INSERT','REMARK'/
C
C     LIST OF VALID CHARACTERS
C
      DATA VALIDC( 1:10)/'0123456789'/
      DATA VALIDC(11:36)/'ABCDEFGHIJKLMNOPQRSTUVWXYZ'/
      DATA VALIDC(37:48)/' +-*/=.,''()$'/
C  ASCII/EBCDIC REPRESENTATION OF BCDIC CHARACTERS ()+='
      DATA VALIDC(49:53)/'%<&#@'/
C  SEMI-COLON
      DATA VALIDC(54:54)/';'/
C  LOWER CASE CHARACTERS
      DATA VALIDC(55:80)/'abcdefghijklmnopqrstuvwxyz'/
C
C                   CONV TABLE
C
C                 0   1   2   3   4   5   6   7   8   9
      DATA CONV/  2,  3,  4,  5,  6,  7,  8,  9, 10, 11,
C                 A   B   C   D   E   F   G   H   I
     1           15, 16, 17, 18, 19, 20, 21, 22, 23,
C                 J   K   L   M   N   O   P   Q   R
     2           27, 28, 29, 30, 31, 32, 33, 34, 35,
C                 S   T   U   V   W   X   Y   Z
     3           40, 41, 42, 43, 44, 45, 46, 47,
C                SP   +   -   *   /   =   .   ,   '   (   )   $
     4           38, 14, 26, 37, 39, 12, 24, 48, 13, 49, 25, 36,
C                 %   <   &   #   @   ;
     5           49, 25, 26, 12, 13,  0,
C                 a   b   c   d   e   f   g   h   i
     6           15, 16, 17, 18, 19, 20, 21, 22, 23,
C                 j   k   l   m   n   o   p   q   r
     7           27, 28, 29, 30, 31, 32, 33, 34, 35,
C                 s   t   u   v   w   x   y   z
     8           40, 41, 42, 43, 44, 45, 46, 47/
C**
      IF(.NOT.DLRFLG)INLIN=0
      IF(.NOT.READFG) GO TO 110
      NUMCHR = 72
      NUMI = 0
C
C...   IF END IS FALSE, FIRST CARD FOR THIS PROGRAM IS IN IRDSAV
C
      LIBFLG=.TRUE.
      IF(END)GO TO 15
      RDCHAR=IRDSAV
      END=.TRUE.
      GO TO 25
C
C                   READ CARD IMAGE
C
   15 IF(NMSEG.EQ.0)GO TO 16
      LRARG=CNAMTB(NMSEG)
      CALL LIBRD(LRARG,IFLAG,RDCHAR)
      IF(IFLAG.EQ.0) GO TO 27
      IF(IFLAG.NE.1)CALL ALARM(74,0,8,'READ    ')
      NMSEG=0
      GO TO 19
   16 IF(NMMAC.NE.0)GO TO 32
   19 CALL CREAD (RDCHAR,IEND)
      IF (IEND.EQ.1) GO TO 50
   25 LIBFLG=.FALSE.
   26 CNT=0
      GO TO 34
   27 IF(LIBPRT) GO TO 25
      GO TO 26
   32 IF(.NOT.LMRSTR)GO TO 38
      IRDSAV=RDCHAR
      ITMPSV(1)=CNT-1
      LMRSTR=.FALSE.
   38 LRARG=CNAMTB(NMMAC)
      CALL LIBRD(LRARG,IFLAG,RDCHAR)
      IF(IFLAG.EQ.0) GO TO 27
      IF(IFLAG.NE.1)CALL ALARM(74,0,8,'READ    ')
      RDCHAR=IRDSAV
      CNT=ITMPSV(1)
      TOP=ITMPSV(2)
      DO 37 I=1,TOP
      STACK(1,I)=ITMPSV(2*I+1)
      STACK(2,I)=ITMPSV(2*I+2)
   37 CONTINUE
      I=NAMTBL(NMMAC)/MODULO
      STACK(2,4)=META(I)
      NMMAC=0
      LMREND=.TRUE.
C
   34 QTFLG=.FALSE.
C        CHECK FOR PARTNO, TITLES, PPRINT, INSERT, REMARK
      DO 90 I=1,5
      IF(RDCHAR(1:6).NE.IA(I))GO TO 90
      J=0
      IF(I.EQ.5)GO TO 80
      GO TO 98
   90 CONTINUE
   40 J=0
      DLRFLG=.FALSE.
      READFG = .TRUE.
      L = NUMI + 1
      DO 70 I=L,72
C...FOR EACH CHARACTER INPUT CHECK IF A VALID CHARACTER
C   INCHAR(I)=0 INVALID CHARACTER
C   OTHERWISE LOCATION OF CHARACTER IN NAME TABLE
      II=INDEX(VALIDC,RDCHAR(I:I))
      IF (II.EQ.0) THEN
        INCHAR(I)=0
      ELSE
        INCHAR(I)=CONV(II)
      ENDIF
C   DOLLAR GESETZT?
      IF(DLRFLG)GOTO 75
C   HOCHKOMMA?
      IF(II.NE.45)GO TO 43
      IF(QTFLG)GOTO42
      IF(J.EQ.0)GOTO41
C  VORHERGEHENDES ZEICHEN HOCHKOMMA? :FORTSETZUNG EINER ZEICHENKETTE
      IF(INCHAR(J).NE.13)GOTO41
      QTFLG=.TRUE.
      J=J-1
      GOTO 61
C  NEUER START EINER ZEICHENKETTE
   41 QTFLG=.TRUE.
      GOTO 60
   42 QTFLG=.FALSE.
      GO TO 60
   43 IF(.NOT.QTFLG)GO TO 45
C AUSGABE EINES NEGATIVEN BUCHSTABEN-WERTES,DA ZEICHENKETTE
   61 J=J+1
      INCHAR(J)=-CONV(II)
      GOTO 70
C     AUF BLANK PRUEFEN
   45 IF(II.EQ.37)GO TO 70
C
C     STRICHPUNKT  = ENDE EINES APT-SATZES
C
      IF(II.EQ.54) GOTO 105
C
C        AUF DOLLAR PRUEFEN
      IF(II.EQ.48)DLRFLG=.TRUE.
C    AUSGABE DES NAMENSTAFEL-INDEX
   60 J=J+1
      INCHAR(J)=CONV(II)
      ERRPNT(J)=I+INLIN
   70 CONTINUE
      IF(NUMI .NE. 0) NUMCHR = 85 - LINEST
C  VERHINDERUNG VON UEBER KARTENGRENZE REICHENDER ZEICHENKETTE
      IF(.NOT.QTFLG)GOTO 80
      J=J+1
      INCHAR(J)=QUOTE(2)
C
C        END OF CARD - SET POINTER TO RTERM
   80 INCHAR(J+1)=RTERM(2)
   82 IF(LIBFLG) GO TO 100
      CALL ICONV(SEQNO ,DARRAY,5,4)
      CALL CFORM('.',DARRAY,9,1)
      CALL CFORM(RDCHAR,DARRAY,LINEST,NUMCHR)
      CALL CFORM(RDCHAR(73:80),DARRAY,85,8 )
      CALL CPRINT (DARRAY)
  100 RETURN
  105 READFG = .FALSE.
      NUMCHR = I
      NUMI = I
      GOTO 80
  110 RDCHAR(1:NUMI)=IBLK
      GO TO 26
C        IS THIS $$
   75 NUMCHR = 72
      INLIN=INLIN+100
      IF(II.EQ.48)GOTO 78
      GO TO 80
   78 J = J - 1
      DLRFLG = .FALSE.
      GO TO 80
C        MISSING FINI - INSERT FINI AND COMPLETE PROCESSING
   50 IFLAG=55
      IF(MACLDD)IFLAG=56
      CALL ALARM(IFLAG,0,4,'READ    ')
      END=.FALSE.
      IF(MACLDD)GO TO 56
      RDCHAR = CFINI
      GO TO 25
   56 IRDSAV=CFINI
      MACLDD=.FALSE.
      NEWSTM=.TRUE.
      INCHAR(1)=RTERM(2)
      CNT=0
      GO TO 100
C        CHANGE PARTNO, TITLES, PPRINT, INSERT TO NEW FORMAT
   98 DO 91 I=7,72
        II=INDEX(VALIDC,RDCHAR(I:I))
        IF (II.EQ.0) THEN
          INCHAR(I)=0
        ELSE
          INCHAR(I)=CONV(II)
        ENDIF
        IF(INCHAR(I).EQ.SLASH(2))GO TO 40
        IF(II.NE.37)GO TO 92
   91 CONTINUE
   92 QTFLG=.FALSE.
      DO 96 K=1,72
      I=73-K
        II=INDEX(VALIDC,RDCHAR(I:I))
        IF (II.EQ.0) THEN
          INCHAR(I)=0
        ELSE
          INCHAR(I)=CONV(II)
        ENDIF
      IF(QTFLG)GO TO 94
   93 IF(II.EQ.37 .AND. I.NE.7)GO TO 96
      QTFLG=.TRUE.
      INCHAR(I+4)=RTERM(2)
      INCHAR(I+3)=QUOTE(2)
   94 IF (II.EQ.0) THEN
        IF(I.GE.7)INCHAR(I+2)=0
        IF(I.LE.7)INCHAR(I)=0
      ELSE
        IF(I.GE.7)INCHAR(I+2)=-CONV(II)
        IF(I.LE.7)INCHAR(I)=CONV(II)
      ENDIF
   96 CONTINUE
      QTFLG=.FALSE.
      INCHAR(7)=SLASH(2)
      INCHAR(8)=QUOTE(2)
      GO TO 82
      END
**** SOURCE FILE : M0006672.W05   ***
*
C
C              FORTRAN SUBROUTINE RECOG
C
C LINKAGE      SUBROUTINE  RECOG
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    LARGES          SUBROUTINE    START
C          SUBROUTINE    LCANON
C          SUBROUTINE    BINBCD
C          SUBROUTINE    MACLBL
C          SUBROUTINE    MACREC
C          LOGICAL FCT.  IFTMP
C          SUBROUTINE    MATCH
C          SUBROUTINE    MCXTRN
C          SUBROUTINE    INPUT
C          SUBROUTINE    ISSCOD
C          INTEGER FCT.  NAME
C          INTEGER FCT.  NUMB
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          INTEGER FCT.  GETTMP
C          SUBROUTINE    PATH
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    PRO020
C          SUBROUTINE    PRO026
C          SUBROUTINE    PRO027
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    RECOGN
C          SUBROUTINE    REPLAC
C          SUBROUTINE    RESRED
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  SEARCH
C          SUBROUTINE    LABELZ
C          SUBROUTINE    SETCHR
C          SUBROUTINE    SETMOD
C          SUBROUTINE    INPAT
C          SUBROUTINE    ARGGEN
C          SUBROUTINE    SSDEF
C          SUBROUTINE    SUBCOD
C          SUBROUTINE    ALARM
C          SUBROUTINE    TWOARG
C          SUBROUTINE    CONCAT
C          SUBROUTINE    BCDBIN
C          SUBROUTINE    LABCON
C          SUBROUTINE    LOOP
C          SUBROUTINE    BOOLIF
C          SUBROUTINE    KONAST
C          SUBROUTINE    VCTPRD
C          INTEGER FCT.  BCDF
C          SUBROUTINE    HOLFRM
C
      SUBROUTINE  RECOG
C
      IMPLICIT INTEGER (A-Z)
C
C              FUNCTION DECLARATION
      LOGICAL IFTMP
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C NUMBST:      NAMTBL INDEX OF BEGINNING OF NUMBER SECTION
C NUMBND:      NAMTBL INDEX OF END OF NUMBER SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),COMMA(2),RTERM(2),SLASH(2),MINUS(2),PLUS(2),
     *          ASTER(2),LETTER(2),QUOTE(2),NUMBER(2),GEOM(2),TEMP(2),F
     *          CN(2),PROCED(2),PERMID(2),LABEL(2),IMPLAB(2),LTERM(2),V
     *          BL(2),DBLAST(2),IDENT(2),MCLTRM(2),CANON(2),BIGGEO(2),L
     *          PAREN(2),RPAREN(2),DOT(2),KREUZ(2),RELAT(2),CONAST(2),N
     *          OT(2),CONGEO(2),CONPRO(2),DECMAL(2),DOLLAR(2)
C COMMA:       (1)=CODE CLASS  1000,(2)=NAMTBL INDEX OF ',     '
      EQUIVALENCE (COMMA(1),CODE(1))
C LPAREN:      (1)=CODE CLASS  2000,(2)=NAMTBL INDEX OF '(     '
      EQUIVALENCE (LPAREN(1),CODE(3))
C RPAREN:      (1)=CODE CLASS  3000,(2)=NAMTBL INDEX OF ')     '
      EQUIVALENCE (RPAREN(1),CODE(5))
C RTERM:       (1)=CODE CLASS  4000,(2)=NAMTBL INDEX OF 'RTERM '
      EQUIVALENCE (RTERM(1),CODE(7))
C SLASH:       (1)=CODE CLASS  5000,(2)=NAMTBL INDEX OF '/     '
      EQUIVALENCE (SLASH(1),CODE(9))
C MINUS:       (1)=CODE CLASS  6000,(2)=NAMTBL INDEX OF '-     '
      EQUIVALENCE (MINUS(1),CODE(11))
C PLUS:        (1)=CODE CLASS  7000,(2)=NAMTBL INDEX OF '+     '
      EQUIVALENCE (PLUS(1),CODE(13))
C ASTER:       (1)=CODE CLASS  9000,(2)=NAMTBL INDEX OF '*     '
      EQUIVALENCE (ASTER(1),CODE(17))
C LETTER:      (1)=CODE CLASS 11000,(2)=NAMTBL INDEX OF 'LETTER'
      EQUIVALENCE (LETTER(1),CODE(21))
C QUOTE:       (1)=CODE CLASS 12000,(2)=NAMTBL INDEX OF ''     '
      EQUIVALENCE (QUOTE(1),CODE(23))
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C DOLLAR:      (1)=CODE CLASS 15000,(2)=NAMTBL INDEX OF '$     '
      EQUIVALENCE (DOLLAR(1),CODE(29))
C GEOM:        (1)=CODE CLASS 16000,(2)=NAMTBL INDEX OF 'GEOM  '
      EQUIVALENCE (GEOM(1),CODE(31))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C FCN:         (1)=CODE CLASS 18000,(2)=NAMTBL INDEX OF 'FCN   '
      EQUIVALENCE (FCN(1),CODE(35))
C PROCED:      (1)=CODE CLASS 19000,(2)=NAMTBL INDEX OF 'PROCED'
      EQUIVALENCE (PROCED(1),CODE(37))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C DECMAL:      (1)=CODE CLASS 21000,(2)=NAMTBL INDEX OF '.     '
      EQUIVALENCE (DECMAL(1),CODE(41))
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C IMPLAB:      (1)=CODE CLASS 23000,(2)=NAMTBL INDEX OF 'IMPLAB'
      EQUIVALENCE (IMPLAB(1),CODE(45))
C LTERM:       (1)=CODE CLASS 24000,(2)=NAMTBL INDEX OF 'LTERM '
      EQUIVALENCE (LTERM(1),CODE(47))
C DOT:         (1)=CODE CLASS 25000,(2)=NAMTBL INDEX OF 'DOT   '
      EQUIVALENCE (DOT(1),CODE(49))
C KREUZ:       (1)=CODE CLASS 26000,(2)=NAMTBL INDEX OF 'KREUZ '
      EQUIVALENCE (KREUZ(1),CODE(51))
C RELAT:       (1)=CODE CLASS 27000,(2)=NAMTBL INDEX OF 'RELAT '
      EQUIVALENCE (RELAT(1),CODE(53))
C NOT:         (1)=CODE CLASS 28000,(2)=NAMTBL INDEX OF 'NOT   '
      EQUIVALENCE (NOT(1),CODE(55))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C DBLAST:      (1)=CODE CLASS 32000,(2)=NAMTBL INDEX OF 'DBLAST'
      EQUIVALENCE (DBLAST(1),CODE(63))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C MCLTRM:      (1)=CODE CLASS 38000,(2)=NAMTBL INDEX OF 'MCLTRM'
      EQUIVALENCE (MCLTRM(1),CODE(75))
C CONGEO:      (1)=CODE CLASS 39000,(2)=NAMTBL INDEX OF 'CONGEO'
      EQUIVALENCE (CONGEO(1),CODE(77))
C CONPRO:      (1)=CODE CLASS 40000,(2)=NAMTBL INDEX OF 'CONPRO'
      EQUIVALENCE (CONPRO(1),CODE(79))
C CANON:       (1)=CODE CLASS 42000,(2)=NAMTBL INDEX OF 'CANON '
      EQUIVALENCE (CANON(1),CODE(83))
C BIGGEO:      (1)=CODE CLASS 44000,(2)=DNAMTBL INDEX OF 'BIGGEO'
      EQUIVALENCE (BIGGEO(1),CODE(87))
C CONAST:      (1)=CODE CLASS 45000,(2)=NAMTBL INDEX OF 'CONAST'
      EQUIVALENCE (CONAST(1),CODE(89))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(1482),PRODTB(1430),META(50)
C BRKPNT:      END OF MACRO TEXT TRANSFER PRODUCTION IN PRODTB
      EQUIVALENCE (BRKPNT,SRCTBL(1))
C MBKPNT:      END OF CHARACTER CONCATENATION AND STRING PRODUCTION
      EQUIVALENCE (MBKPNT,SRCTBL(2))
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C PRODTB:      CONTAINS BASIC PRODUCTIONS
      EQUIVALENCE (PRODTB(1),SRCTBL(53))
C
C        5.    PROGRAM CONTROL FLAGS
C
      COMMON/FLAGS/FLAGS
      LOGICAL ENDFLG,NEWSTM
      DIMENSION FLAGS(4)
C ENDFLG:      TRUE WHEN SOURCE STATEMENT TOTALLY IN STACK
      EQUIVALENCE (ENDFLG,FLAGS(1))
C NEWSTM:      TRUE WHEN NEXT SOURCE STATEMENT REQUESTED FOR PROCESS
      EQUIVALENCE (NEWSTM,FLAGS(2))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C        7.    STRING STORAGE AREA
C              POINTER TO THE LAST PROCESSED CHARACTER OF A STATEMENT
      COMMON/INPTR/CNT
C
C        8.    NAME TABLE POINTERS TO BCD LITERALS
C
      COMMON/BCDPTR/BCDPTR
      DIMENSION BCDPTR(7)
C DOTAC:       NAMTBL POINTER TO ALPHAMERIC LITERAL '.AC.'
      EQUIVALENCE (DOTAC,BCDPTR(1))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(13)
C ZEROPT:      NAMTBL POINTER TO '0.    '
      EQUIVALENCE (ZEROPT,NUMPTR(2))
C ONEPT:       NAMTBL POINTER TO '1.    '
      EQUIVALENCE (ONEPT,NUMPTR(4))
C TENPT:       NAMTBL POINTER TO '10.   '
      EQUIVALENCE (TENPT,NUMPTR(13))
C
C       10.    TABLE STORAGE FOR GEOMETRIC FUNCTION PROCESSOR
C
      INCLUDE (GMTY)    
C GEOLOC:      GEOMETRIC PRODUCTION STARTING INDEX IN GEOMTB
C PMIDTB:      INTERNAL BIT REPRESENTATIONS FOR EACH ELEMENT OF GEOMTB
C GEOMTB:      GEOMETRIC FORMAT PRODUCTIONS ARRANGED BY SURFACE TYPE
C
C       11.    SEQUENCE NUMBER STORAGE
C
      INCLUDE (SEQCOM)    
C SEQNO:       INTERNALLY GENERATED STATEMENT NUMBER
C SEQNUM:      ALPHANUMERIC REPRESENTATION OF CURRRENT STATEMENT NUMBER
C
C       13.    NAMTBL POINTERS TO NEGATIVE NUMBERS
C              NAMTBL POINTER TO -1.
      COMMON/NEGPTR/NONEPT
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL INTERP
      DIMENSION PRT(7)
C INTERP:      NORMALLY TRUE,INDICATING INTERPRETIVE APPROACH DEFAULT
      EQUIVALENCE (INTERP,PRT(3))
C
C       15.    ARRAY LIMIT STORAGE
C
      COMMON/SBSCPT/SBSCPT
      DIMENSION SBSCPT(101),RANGE(100)
C RNGPT:       POINTER TO NEXT RANGE ENTRY
      EQUIVALENCE (RNGPT,SBSCPT(1))
C RANGE:       STORAGE FOR APT RESERVE STATEMENT INFORMATION
      EQUIVALENCE (RANGE(1),SBSCPT(2))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C FADD:        CONTAINS COMMAND CODE ( 1) FOR FADD COMMAND
      EQUIVALENCE (FADD,IL(1))
C FSUB:        CONTAINS COMMAND CODE ( 2) FOR FSUB COMMAND
      EQUIVALENCE (FSUB,IL(2))
C FMPY:        CONTAINS COMMAND CODE ( 3) FOR FMPY COMMAND
      EQUIVALENCE (FMPY,IL(3))
C FDIV:        CONTAINS COMMAND CODE ( 4) FOR FDIV COMMAND
      EQUIVALENCE (FDIV,IL(4))
C FEXP:        CONTAINS COMMAND CODE ( 5) FOR FEXP COMMAND
      EQUIVALENCE (FEXP,IL(5))
C SEQNCE:      CONTAINS COMMAND CODE ( 9) FOR SEQNCE COMMAND
      EQUIVALENCE (SEQNCE,IL(9))
C CONJMP:      CONTAINS COMMAND CODE (11) FOR CONJMP COMMAND
      EQUIVALENCE (CONJMP,IL(11))
C HOLDAT:      CONTAINS COMMAND CODE (21) FOR HOLDAT COMMAND
      EQUIVALENCE (HOLDAT,IL(21))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C TABCYL:      MODE CODE (11) FOR TABULATED CYLINDER
      EQUIVALENCE (TABCYL,MODX(11))
C POINT:       MODE CODE (19) FOR POINT
      EQUIVALENCE (POINT,MODX(19))
C VECTOR:      MODE CODE (20) FOR VECTOR
      EQUIVALENCE (VECTOR,MODX(20))
C REAL:        MODE CODE (21) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C BOOL:        MODE CODE (23) FOR BOOLEAN TYPE
      EQUIVALENCE (BOOL,MODX(23))
C SUBSCR:      MODE CODE (24) FOR SUBSCRIPT
      EQUIVALENCE (SUBSCR,MODX(24))
C STRING:      MODE CODE (25) FOR STRING
      EQUIVALENCE (STRING,MODX(25))
C PATERN:      MODE CODE (26) FOR PATTERN
      EQUIVALENCE (PATERN,MODX(26))
C BOUNDS:      MODE CODE (27) FOR BOUNDS
      EQUIVALENCE (BOUNDS,MODX(27))
C OBJECT:      MODE CODE (28) FOR OBJECT
      EQUIVALENCE (OBJECT,MODX(28))
C SSURF:       MODE CODE (29) FOR SCULPTURED SURFACE
      EQUIVALENCE (SSURF,MODX(29))
C SCURV:       MODE CODE (30) FOR SCULPTURED CURVE
      EQUIVALENCE (SCURV,MODX(30))
C
C       18.    STRING STORAGE AREA
C              STORAGE OF INTERNAL REPRESENTATION OF STRING OR SYMBOL
      COMMON/CHRX/CHR
      CHARACTER CHR*400
C FIRST 3 BYTES CONTAIN CHARACTER REPRESENTATION OF NUMBER OF
C CHARACTERS IN STRING, REMAINING BYTES CONTAIN STRING
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL MACLDD,ILHLT,MACRED,FINMAC,ENTRY,SHOULD
      DIMENSION MACXX1(71)
C MACLDD:      TRUE WHEN MACRO TEXT IS TO BE LOAD INTO MCBUFF TABLE
      EQUIVALENCE (MACLDD,MACXX1(7))
C ILHLT:       TRUE IF I.L. SHOULD NOT BE PLACED IN ILFILE
      EQUIVALENCE (ILHLT,MACXX1(14))
C TEXTST:      POINTER TP MCBUFF OF MACRO TEXT WORD BEING PROCESSED
      EQUIVALENCE (TEXTST,MACXX1(15))
C MACRED:      SET TRUE TO INDICATE INPUT FROM MCBUFF TABLE
      EQUIVALENCE (MACRED,MACXX1(18))
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C MAJWRD:      CONTAINS ACTUAL MAJOR WORD
      EQUIVALENCE (MAJWRD,MACXX1(23))
C FINMAC:      TRUE IF SECOND FINAL PASS OF MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C WAY:         INDICATES TYPE OF MACRO PROCESSING
      EQUIVALENCE (WAY,MACXX1(26))
C ENTRY:       FALSE ON FIRST ENTRY TO MATCH FOR A MACRO EXPRESSION
      EQUIVALENCE (ENTRY,MACXX1(40))
C MAJOR:       CURRENT CALL ASSIGNED VALUE IF MAYWRD IS MACRO VARIABLE
      EQUIVALENCE (MAJOR,MACXX1(44))
C WHCHMN:      EQUAL TO NUMBER OF CURRENT MACRO BEING PROCESSED
      EQUIVALENCE (WHCHMN,MACXX1(63))
C SHOULD:      MACRO INDICATOR. NORMALLY FALSE
      EQUIVALENCE (SHOULD,MACXX1(70))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136)
C UNDEF:       NAMTBL POINTER TO EXECUTION SUBROUTINE UNDEF
      EQUIVALENCE (UNDEF,SUBLST(74))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       36.    SYSTEM MACRO AND SEGMENT READ VARIABLES
C
      COMMON/MACSEG/MACSEG
      LOGICAL LMREND
      DIMENSION MACSEG(6)
C LMREND:      FLAG ON AFTER COMPLETION READING A SYSTEM MACRO
      EQUIVALENCE (LMREND,MACSEG(6))
C
C       37.    INCLUSIVE SUBSCRIPT VARIABLES
C
      COMMON/ISSCOM/ISSCOM
      LOGICAL ISSFL,ISSEND
      DIMENSION ISSCOM(9),ISSTRM(2)
C ISSA:        LOWEST SUBSCRIPT OF AN INCLUSIVE SUBSCRIPT STRING
      EQUIVALENCE (ISSA,ISSCOM(1))
C ISSB:        HIGHEST SUBSCRIPT OF AN INCLUSIVE SUBSCRIPT STRING
      EQUIVALENCE (ISSB,ISSCOM(2))
C ISSC:        INCREMENT OR DECREMENT FOR INCLUSIVE SUBSCRIPT STRING
      EQUIVALENCE (ISSC,ISSCOM(3))
C ISSVBL:      NAMTBL POINTER TO THE INCLUSIVE SUBSCRIPTED VARIABLE
      EQUIVALENCE (ISSVBL,ISSCOM(4))
C ISSFL:       TRUE DURING INCLUSIVE SUBSCRIPT PROCESSING
      EQUIVALENCE (ISSFL,ISSCOM(6))
C ISSEND:      END OF INCLUSIVE SUBSCRIPT PROCESSING
      EQUIVALENCE (ISSEND,ISSCOM(7))
C ISSTRM:      SAVES THE STACK TOP ITEMS DURING SUBSCRIPT PROCESSING
      EQUIVALENCE (ISSTRM(1),ISSCOM(8))
C
C       38.    COMMON BLOCK MACRO CALL STATEMENT
C              INDICATES A MACRO CALL BEING PROCESSED
      COMMON/CALFLG/ICALLF
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C
C       42.    COMMON BLOCK FOR CANON AND OBTAIN ARGUMENT STORAGE
C
      COMMON/CANSTR/CANSTR
      DIMENSION CANSTR(18)
C CANPTR:      POINTER TO LAST CANSTK ENTRY
      EQUIVALENCE (CANPTR,CANSTR(1))
C
C       43.    DO LOOP CONTROL VALUES
C
      COMMON/DOLOOP/DOLOOP
      LOGICAL DOFLAG,IFFLAG
      DIMENSION DOLOOP(9)
C JUMPTO:      MARKER SET AFTER JUMPTO OR IF FOR LABEL CONTROL
      EQUIVALENCE (JUMPTO,DOLOOP(1))
C RELDO:       CURRENTLY NESTED DO LOOPS
      EQUIVALENCE (RELDO,DOLOOP(3))
C DOJUMP:      VBL FOR COMPUTED GOTO AT LOOP PROCESSING
      EQUIVALENCE (DOJUMP,DOLOOP(6))
C DOFLAG:      FLAG IS ON DURING OPENED LOOP
      EQUIVALENCE (DOFLAG,DOLOOP(7))
C IFFLAG:      FLAG ON WHEN LOGICAL IF OCCURS
      EQUIVALENCE (IFFLAG,DOLOOP(9))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ESTACK,ERGSTK
      LOGICAL NOWARN
      DIMENSION ERRPOS(302),ESTACK(100),ERGSTK(100)
C NOWARN:      FLAG TRUE IS SUPPRESSING OUTPUT OF WARNING NR. 50
      EQUIVALENCE (NOWARN,ERRPOS(1))
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C ERGSTK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN ARGSTK
      EQUIVALENCE (ERGSTK(1),ERRPOS(203))
C
C       45.    NUMBER TABLE INDICES
C
      INCLUDE (NUMBLK)    
C MNMBND:      LAST NAME TABLE ENTRY TO MACRO ASSIGNED NUMBER SECTION
C NUMIDX:      NAMTBL INDEX OF A NUMBER GIVEN IN THE CURRENT STATEMENT
C  NMBRS:      QUANTITY OF NUMBERS IN THE CURRENT STATEMENT
C LSTCHR:      LAST CHARACTER OF A NUMBER
C*
      CHARACTER IICHR*20
      DIMENSION ARGX(2),ICNUM(3)
      EQUIVALENCE(ARGX(1),ARG1),(ARGX(2),ARG2)
C      IMPLEMENTATION DEPENDENT  NAME $21T$1                       ..CD.
      CHARACTER*6  ICD21
      CHARACTER*6 BLK,ISEQ1,ON,OFF,ZERO*3,TRUE,FALSE
      LOGICAL OPDFLG
      INCLUDE (SDP)    
      INTEGER BCDF
      EXTERNAL BCDF
      DATA LBKPNT/1/
      DATA BLK/'    '/,CLDATA/69/
      DATA  ISEQ1/' 1  '/,TRUE/'.TRUE.'/,FALSE/'.FALSE'/
      DATA STRCNT /0/,ON/'ON  '/,OFF/'OFF '/
      DATA ICD21/'$21T$1'/
      DATA ZERO/'  0'/
C**
      SEQNUM=ISEQ1
      MNMBND=NUMBST
      NUMIDX=NUMBST
C      PUT IMPLEMENTATION DEPENDENT NAME INTO NAMTBL              ..CD.
      I=NAME(ICD21)
      NAMTBL(I)=TEMP(1)+REAL
C      PUT FIRST ITEM IN CANONICAL FORM BLOCK 3.
      I=GETTMP(POINT)
C      GENERATE I.L. TO STORE -1.0 IN PERMANENT LOCATION.
C        (USE OF TEMPORARY CAN CAUSE INCORRECT I.L.)
C        STORE NAMTBL POINTER TO LOCATION OF -1.0 IN NONEPT.
      CALL MACLBL(ONEPT,0,NONEPT)
      NAMTBL(NONEPT)=VBL(1)+REAL
      CALL RESRVZ(NONEPT,REAL,TXXXX(1,REAL),1)
      CALL OPCODE(FSUB)
      CALL ARGCVT(NONEPT)
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ONEPT)
      CALL RLSLIN
C  GENERATE IL TO RESERVE LOCATION FOR .AC. IN CANONICAL FORM BLOCK
C  TO OVERCOME IMPEMENTATION DEPENDENCY OF USE OF AC
      CALL RESRVZ(DOTAC,REAL,TXXXX(1,REAL),1)
      GO TO 11
C
    1 IF(.NOT.NEWSTM) GO TO 20
C...  IF INTERP FALSE, TRANSLATION IS COMPLETE
      IF(.NOT.INTERP) RETURN
C
C... SET LARGE SURFACE ARGUMENT COUNT = 0
C
    3 BIGCNT = 0
      IBR=0
      IF (STACK(1,TOP) .NE. RTERM(2) ) GO TO 11
    5 IF (IFFLAG)CALL BOOLIF(0)
      OPDFLG=.FALSE.
      NUMIDX=MNMBND
      NMBRS=0
      IF (.NOT.DOFLAG)GOTO 6
      DOJUMP=3
      CALL LOOP
    6 IF(.NOT.ILHLT)GO TO 10
      IF(INTMED.NE.1)GO TO 11
   10 SEQNO=SEQNO+1
      CALL BINBCD(SEQNO,SEQNUM,TOP)
      IF(MACLDD.OR.ILHLT)GO TO 11
      CALL OPCODE(SEQNCE)
      CALL ONEARG(SEQNO)
      CALL RLSLIN
      IF(JUMPTO.NE.SEQNO)GOTO 11
      CALL BINBCD(SEQNO-1,SEQNUM,TOP)
      CALL ALARM(1009,0,4,'RECOG   ')
      CALL BINBCD(SEQNO,SEQNUM,TOP)
      JUMPTO=0
C...  NEW STATEMENT
C
   11 NEWSTM = .FALSE.
      TOP=1
      IF(.NOT.MACLDD) GO TO 12
      STACK(1,1) = MCLTRM(2)
      L = MCLTRM(1)/MODULO
      BKPT=MBKPNT
      GO TO  13
   12 STACK(1,1) = LTERM(2)
      L = LTERM(1)/MODULO
      BKPT=BRKPNT
C
      DO 15 I=1,30
   15 TXXXX(2,I) = 0
      ARGTOP = 0
      CANPTR=0
   13 STACK(2,1)=META(L)
      GO TO 2900
C...  FIND MATCHING PRODUCTION
   20 IF((.NOT.LMREND).AND.(.NOT.ISSFL).AND.(.NOT.ISSEND))GO TO 21
      LBKPNT=BKPT
      ISSEND=.FALSE.
      LMREND=.FALSE.
   21 IF(MACRED)LBKPNT=BKPT
   25 ERRP=TOP
      TOPT2=TOP*2
      I=SEARCH(STACK,TOPT2,PRODTB(LBKPNT),ERRP)
      LBKPNT=1
C
      IF(I.GT.50)GO TO 50
      GOTO ( 100, 200, 300, 400, 500, 600, 700, 800, 900,1000,
     1      1100,2950,1300,1450,1500,1600,1700,1800,1900,2000,
     2      2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
     3      3100,3200,3300,3400,3500,3600,3700,3700,3700,4000,
     4      5000,5000,5000,5000,5000,5000,5000,5000,5000,1200),I
   50 IF(I.LT.70)GO TO 5100
      J=I-70
      GOTO(7100,3500,2000,2000,7500,7500,7500,7800),J
      GO TO 5200
C
C          SET I TO G
  100 CALL SETMOD (TOP-1,GEOM)
      GOTO 220
C     IDENTIFIER TO PROCEDURE
  200 CALL SETMOD (TOP-1,PROCED)
  220 LBKPNT = BKPT
      GO TO 25
C...       GENERATE CODE FOR STRING
C
  300 CHR=ZERO//BLK
  310 CALL INPUT
      I=STACK(1,TOP)
      IF(I.EQ.QUOTE(2))GO TO 320
      I=-I
      CALL CONCAT(CHR,CNAMTB(I))
      TOP=TOP-1
      GO TO 310
  320 STRCNT=STRCNT+1
      CALL MACLBL(QUOTE(2),-STRCNT,I)
C              ENTER STRING NAME IN NAMTBL
C
C              ENTER STRING NAME IN STACK
C
      STACK(1,TOP-1) = I
      NAMTBL(I) = VBL(1)+STRING
      L = VBL(1)/MODULO
      STACK(2,TOP-1) = META(L)
C
C              WRITE DATA STATEMENT
C
      CALL OPCODE(HOLDAT)
C... NUMBER OF CHARACTERS
      READ (CHR,'(I3)') NCHR
      CALL TWOARG(I,NCHR)
C... WRITE CHARACTER STRING TO IL , BY CONVERTING
C    IWRD CHARACTERS AT A TIME TO INTEGER FOR TRANSFER
      IF (MOD(NCHR,IWRD).NE.0) NCHR=(NCHR/IWRD+1)*IWRD
      DO 303 J=4,NCHR,IWRD
        CALL ONEARG(BCDF(CHR(J:J+IWRD-1)))
  303 CONTINUE
      CALL RLSLIN
      TOP=TOP-1
      GO TO 2900
C     CHECK FOR CLDATA(N), OTHERWISE ERROR
  400 J=STACK(1,TOP-4)
      K=NAMTBL(J)
      L=K/MODULO
      IF(K-L*MODULO.NE.CLDATA)GO TO 420
      IF(L.EQ.IDENT(1)/MODULO)CALL SETMOD(TOP-4,PERMID)
      L=COMMA(1)/MODULO
      STACK(1,TOP-1)=STACK(1,TOP)
      STACK(2,TOP-1)=STACK(2,TOP)
      ESTACK(TOP-1)=ESTACK(TOP)
      STACK(1,TOP-3)=COMMA(2)
      STACK(2,TOP-3)=META(L)
      TOP=TOP-1
      GO TO 220
  420 CALL ALARM(1111,TOP-4,8,'RECOG   ')
      GO TO 2810
C     IMPLIED LABEL OR IDENTIFIER TO LABEL
  500 DOJUMP=2
      IF (RELDO.GT.0) CALL LOOP
      K = STACK(1,TOP-1)
      IF (K.LE.NAMMAX) GOTO 530
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
      K=K-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,K,IDUMMY)
      CALL BCDBIN(CNUMTB(K),KK,ICOUNT)
      K=KK+10000
  505 CALL MACLBL(K,-WHCHMN,K)
      STACK(1,TOP-1) = K
      IF(NAMTBL(K)/MODULO .EQ. LABEL(1)/MODULO)GO TO 710
  506 IF((.NOT.FINMAC).AND.(WHCHMN.NE.0))GO TO 510
      NAMTBL(K) = LABEL(1)+WHCHMN
      L = LABEL(1)/MODULO
  507 STACK(2,TOP-1) = META(L)
      CALL LABELZ(K)
      CALL LABCON(-K)
C     ERASE FROM STACK
  520 TOP=TOP-2
      GO TO 2900
  530 IF(WHCHMN.EQ.0)GO TO 506
      IF(NAMTBL(K)/MODULO.NE.LABEL(1)/MODULO)NAMTBL(K)=IMPLAB(1)
      GO TO 505
  510 NAMTBL(K) = IMPLAB(1)+WHCHMN
      L = IMPLAB(1)/MODULO
      GO TO 507
  600 IF(JUMPTO.NE.0)JUMPTO=SEQNO+2
       GO  TO    5
  700 IF(WHCHMN.NE.0)GO TO 500
  710 CALL ALARM(1003,TOP-1,8,'RECOG   ')
      GO TO 520
C...       BINARY OPERATION GENERATIR
  800 ARG1=STACK(1,TOP-3)
      ARG2=STACK(1,TOP-1)
      OP=STACK(1,TOP-2)
      DO 810 L=1,2
      J = MODE(ARGX(L))
      IF(J.EQ.REAL) GO TO 810
      K=2*L-5
      CALL ALARM(1004,TOP+K,8,'RECOG   ')
  810 IF(IFTMP(ARGX(L))) CALL PUTTMP(J)
      RSLT = GETTMP(REAL)
      IF (NAMTBL(OP).NE.SLASH(1)) GOTO 801
      CALL OPCODE (FDIV)
      GO  TO  850
  801 IF (NAMTBL(OP).NE.MINUS(1)) GOTO 802
      CALL OPCODE (FSUB)
      GO  TO  850
  802 IF (NAMTBL(OP).NE.PLUS(1))  GOTO 803
      CALL OPCODE (FADD)
      GO  TO  850
  803 IF (NAMTBL(OP).NE.ASTER(1)) GOTO 804
      CALL OPCODE (FMPY)
      GO  TO  850
  804 CALL OPCODE(FEXP)
  850 CALL ARGCVT(RSLT)
      CALL ARGCVT(ARG1)
      CALL ARGCVT(ARG2)
      CALL RLSLIN
      STACK(1,TOP-3) = RSLT
      L = NAMTBL(RSLT)/MODULO
      STACK(2,TOP-3)=META(L)
  860 STACK(1,TOP-2)=STACK(1,TOP)
      ESTACK(TOP-2)=ESTACK(TOP)
      STACK(2,TOP-2) = STACK(2,TOP)
      TOP = TOP-2
      GO TO 220
C...       INITIALIZE STRING, THEN READ
  900 I = STACK(1,TOP)
      CHR = ZERO//BLK
      CALL CONCAT(CHR,CNAMTB(I))
      GO TO 2900
C
C...     SUBSCRIPT ON RIGHT
 1000 IF(ISSFL)GO TO 1030
      I=STACK(1,TOP-2)
      IF (I.GT.NAMMAX) THEN
        J=NUMBER(1)/MODULO
      ELSE
      J=NAMTBL(I)/MODULO
      ENDIF
      IF(ARGTOP.GT.0)GO TO 1050
      IF(I.GT.NAMMAX)GO TO 1030
      IF(J.EQ.IDENT(1)/MODULO .OR. J.EQ.PERMID(1)/MODULO)GO TO 1050
C    LIEGT EIN   READ-BEFEHL VOR ?
 1030 IF (STACK(1,2).LE.NAMMAX) THEN
        IF(NAMTBL(STACK(1,2)).EQ.19057)CALL  RESRED
      ENDIF
      CALL SUBCOD (TOP-4)
C        MODIFY STACK
 1010 STACK(1,TOP-3)=STACK(1,TOP)
      STACK(2,TOP-3)=STACK(2,TOP)
      ESTACK(TOP-3)=ESTACK(TOP)
      TOP=TOP-3
      GO TO 220
C
C...     CHECK FOR INCLUSIVE SUBSCRIPT FORMAT
C
 1050 IF(J.EQ.IDENT(1)/MODULO)CALL SETMOD(TOP-2,PERMID)
C        PLACE BIT PATTERNS IN TOP OF STACK FOR SEARCH
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=STACK(1,TOP-2)
      ERGSTK(ARGTOP)=ESTACK(TOP-2)
      K=TOP+1
      N5=TOP
      STACK(2,K)=-1
      ATP=1
      IF(ARGTOP.GT.5)ATP=ARGTOP-4
      DO 1060 I=ATP,ARGTOP
      K=K+1
      L=ARGSTK(I)
      IF(L.LE.NAMMAX)GO TO 1052
      IARG=REAL
      GO TO 1058
 1052 M=MODULO*(NAMTBL(L)/MODULO)
      IARG=NAMTBL(L)-M
      IF(IARG.GE.MODHLF)IARG=IARG-MODHLF
      IF (IARG.EQ.0) GOTO 1092
      IF(M.EQ.VBL(1) .OR. M.EQ.TEMP(1))GO TO 1058
      IF(M.EQ.PERMID(1))GO TO 1056
      IF (M.NE.NUMBER(1)) GO TO 1092
      IARG=REAL
      GO TO 1058
 1056 IARG=IARG+50
 1058 STACK(2,K)=PMIDTB(IARG)
 1060 CONTINUE
C        SEARCH SUBSCR PRODUCTIONS
      L=GEOLOC(SUBSCR)
      ERRP=ARGTOP
      KT2=K*2
      I=SEARCH(STACK,KT2,GEOMTB(L),ERRP)
      IF (I.EQ.200) GO TO 1090
      IF (ERRP.GE.ATP) GO TO 1091
      ISSC=1
      J=1
      IF(I.LT.6) GO TO 1070
      II=ARGSTK(ATP)
      I=I-5
 1062 IF(II.LE.NAMMAX)GO TO 1094
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
      II=II-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,II,IDUMMY)
      CALL BCDBIN(CNUMTB(II),III,IDUMMY)
      GO TO (1068,1080,1085),J
C
C        PREPARE AND STORE ISSC
 1068 ISSC=III
 1070 K=ARGSTK(ATP+1)
      IF (K.LE.NAMMAX) THEN
        IF (NAMTBL(K)-NAMTBL(K)/MODHLF*MODHLF.EQ.60)ISSC=-ISSC
      ENDIF
C        PREPARE AND STORE ISSB
      J=2
      IF(I.NE.3 .AND. I.NE.5 )GO TO 1072
      II=ARGSTK(ARGTOP-I/2)
      GOTO 1062
 1072 IF(RNGPT.EQ.1)GO TO 1096
      II=STACK(1,TOP-4)
      III=RNGPT-2
      DO 1075 M=1,III,2
      IF(RANGE(M).EQ.II)GO TO 1076
 1075 CONTINUE
      GO TO 1096
 1076 ISSB=RANGE(M+1)
      GO TO 1082
 1080 ISSB=III
C
C        PREPARE AND STORE ISSA
 1082 J=3
      ISSA=1
      IF (I.LT.4)GOTO 1084
      II=ARGSTK(ARGTOP)
      GOTO 1062
 1085 ISSA=III
C
 1084 IF((ISSB-ISSA)*ISSC.GT.0) GO TO 1086
      II=ISSB
      ISSB=ISSA
      ISSA=II
C        PLACE ISSA IN STACK AND SET FLAG, ETC. IF STRING CONTAINS
C          MORE THAN ONE ITEM
 1086 IF(ISSA.NE.1)GO TO 1088
      STACK(1,TOP-2)=ONEPT
      GO TO 1089
 1088 IICHR=BLK
      CALL BINBCD(ISSA,IICHR,K)
      IICHR(K+1:K+1)='.'
C
      I=NUMB(IICHR(:K+1))
C....ADD OFFSET OF NAMMAX TO CNUMTB ADDRESS FOR COMPATIBILITY
C....WITH PREVIOUS METHOD OF STORING NUMBERS IN NAMTBL
      STACK(1,TOP-2)=I + NAMMAX
 1089 II=NUMBER(1)/MODULO
      ARGTOP=ATP-1
      STACK(2,TOP-2)=META(II)
      ISSA=ISSA+ISSC
      IF(ISSC.LE.0 .AND. (ISSA.LT.ISSB .OR. ISSC.GT.-1))GO TO 1030
      IF(ISSC.GE.0 .AND. (ISSA.GT.ISSB .OR. ISSC.LT.1))GO TO 1030
      ISSVBL=STACK(1,TOP-4)
      ISSTRM(1)=STACK(1,TOP)
      ISSTRM(2)=STACK(2,TOP)
      STACK(1,TOP)=COMMA(2)
      II=COMMA(1)/MODULO
      STACK(2,TOP)=META(II)
      ISSFL=.TRUE.
      GO TO 1030
C
C     'FALSCHE INDIZIERUNGSANGABE'
 1090 IF (ERRP.EQ.ATP)ERRP=ATP
      GOTO 1091
 1092 ERRP=I
 1091 IERROR=2053
      IF (ERRP.EQ.ARGTOP) GOTO 1097
      GO TO 1095
C     'UNZULAESSIGE SYMBOLISCHE ZAHLANGABE'
 1094 IERROR=2054
      IF (J.EQ.3) GOTO 1097
      ERRP=ATP
      IF (J.EQ.2)ERRP=ARGTOP-I/2
 1095 TOP=TOP-2
      ARGTOP=ARGTOP-1
      GO TO 1098
 1097 ERRP=2-TOP
      GO TO 1098
C     'VARIABLE NICHT RESERVIERT'
 1096 IERROR=1013
      ERRP=4-TOP
 1098 CALL ALARM(IERROR,-ERRP,8,'RECOG   ')
      TOP=N5
      GO TO 2810
C
C...     SUBSCRIPT ON LEFT
C          DOES LEFT SIDE HAVE MODE
C
 1100 II=MODE(STACK(1,TOP-1))
 1101 IF(MODE(STACK(1,TOP-6)).NE.0) GO TO 1130
      I=STACK(1,TOP-6)
      NAMTBL(I) = NAMTBL(I)+II
C
C     FIND ARRAY LENGTH IN RANGE
      III=1
 1110 IF(III.GE.RNGPT)GO TO 1130
      IF(RANGE(III).EQ.STACK(1,TOP-6))GO TO 1120
      III=III+2
      GO TO 1110
C
C     RESERVE STORAGE
 1120 CALL RESRVZ(I,II,TXXXX(1,II),RANGE(III+1))
C
C
 1130 IF(II.EQ.BOUNDS .OR. II.EQ.OBJECT) GO TO 1805
      CALL SUBCOD(TOP-6)
C
C     MODIFY STACK
      STACK (1,TOP-5)=STACK(1,TOP-2)
      STACK (2,TOP-5)=STACK(2,TOP-2)
      ESTACK (TOP-5)=ESTACK(TOP-2)
      STACK (1,TOP-4)=STACK(1,TOP-1)
      STACK (2,TOP-4)=STACK(2,TOP-1)
      ESTACK (TOP-4)=ESTACK(TOP-1)
      GO TO 1010
C
 1200 K=STACK (1,TOP-1)
      IF(CNAMTB(K).NE.ON)GOTO 1210
      NOWARN=.TRUE.
      GOTO 1220
 1210 IF(CNAMTB(K).NE.OFF)GOTO 1230
      NOWARN=.FALSE.
 1220 IF (K.LE.NAMMAX) THEN
      IF(NAMTBL(K)/MODULO.EQ.IDENT(1)/MODULO)CALL SETMOD(TOP-1,PERMID)
      ENDIF
      GOTO 5
 1230 CALL ALARM(1008,TOP-1,8,'RECOG   ')
      GOTO 5
C
 1300 IF (STACK(1,TOP-2).LE.NAMMAX) THEN
        IF (NAMTBL(STACK(1,TOP-2)).EQ.MINUS(1)) GOTO 1400
      ENDIF
C     UNARY PLUS
      STACK(1,TOP-2) = STACK(1,TOP-1)
      STACK(2,TOP-2) = STACK(2,TOP-1)
      ESTACK(TOP-2) = ESTACK(TOP-1)
C
      GO TO 1420
C...       UNARY MINUS
 1400 ARG = STACK(1,TOP-1)
      J = MODE(ARG)
      IF(J.EQ.REAL) GO TO 1410
      CALL ALARM(1005,TOP-1,8,'RECOG   ')
 1410 IF(IFTMP(ARG)) CALL PUTTMP(J)
      RSLT = GETTMP(REAL)
      CALL OPCODE (FSUB)
      CALL ARGCVT(RSLT)
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ARG)
      CALL RLSLIN
      STACK(1,TOP-2) = RSLT
      L = TEMP(1)/MODULO
      STACK(2,TOP-2)=META(L)
 1420 STACK(1,TOP-1)=STACK(1,TOP)
      STACK(2,TOP-1) = STACK(2,TOP)
      ESTACK(TOP-1) = ESTACK(TOP)
      TOP = TOP-1
      GO TO 220
C...
 1450 IF (STACK(1,TOP).NE.NUMBST+NAMMAX)GOTO 2900
      K=NUMIDX+1
      IF(K.GT.NUMBND)GOTO 1480
      NUMIDX=K
 1460 DO 1470 J=1,3
        TEXTST=TEXTST+1
        CALL MCXTRN(2,TEXTST,ICNUM(J))
 1470 CONTINUE
      CALL HOLFRM(ICNUM,CNUMTB(K),1,12,NWD)
C... INCREMENT FOR NUMBER TABLE ADDRESS
      STACK(1,TOP)=K+NAMMAX
      GOTO 2900
 1480 DO 1490 J=MNMBND,NUMBND
       K=K-1
       IF (CNUMTB(K).EQ.' ') GOTO 1460
 1490 CONTINUE
      K=NUMBND
      GOTO 1460
C...       VECTOR PRODUCTS
 1500 CALL INPUT
      CALL INPUT
      IF (ENDFLG.AND.(STACK(1,TOP-1).NE.DOLLAR(2)) ) GOTO 3
      IF(STACK(1,TOP).EQ.RPAREN(2))GOTO 1530
 1510 CNT=CNT-2
 1520 TOP=TOP-2
      GOTO 3215
 1530 IF(STACK(1,TOP-1).NE.ASTER(2))GOTO 1550
      CALL SETCHR(TOP-2,KREUZ)
      GOTO 1520
 1550 IF(STACK(1,TOP-1).NE.DECMAL(2))GOTO 1510
      CALL SETCHR(TOP-2,DOT)
      GOTO 1520
C...       ARGUMENT LIST
 1600 K=STACK(1,TOP-1)
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=K
      ERGSTK(ARGTOP)=ESTACK(TOP-1)
      IF(K.GT.NAMMAX)GO TO 860
      IF(IFTMP(K)) CALL PUTTMP(MODE(K))
      J=NAMTBL(K)/MODULO
      IF(J.EQ.IDENT(1)/MODULO)
     /CALL SETMOD(TOP-1,PERMID)
      GO TO 860
C...       FUNCTION CALL GENERATOR
 1700 ARGTOP=ARGTOP+1
      I = STACK(1,TOP-1)
      ARGSTK(ARGTOP) = I
      IF(IFTMP(I)) CALL PUTTMP(MODE(I))
      J = GETTMP(REAL)
      MAJOR=STACK(1,TOP-3)
      IF(INTMED.NE.1)GO TO 1703
      WAY=3
      IF(FINMAC)GO TO 1702
      MAJWRD=MAJOR
 1701 ERGSTK(100)=TOP-3
      CALL MATCH
      IF(.NOT.ENTRY)GO TO 1705
      IF(MAJOR.LE.NAMMAX)GO TO 1706
      CALL ALARM(2025,TOP-3,8,'RECOG   ')
      GO TO 1703
 1706 IF(NAMTBL(MAJOR)/MODULO.NE.FCN(1)/MODULO)CALL ALARM(2025,TOP-3,
     * 8,'RECOG   ')
      GO TO 1703
 1702 CALL PATH
      IF(.NOT.SHOULD)GO TO 1705
 1703 CALL CALLZZ(MAJOR)
      CALL ARGCVT(J)
      CALL ARGGEN
      CALL RLSLIN
      IF(ENTRY)GO TO 1701
 1705 STACK(1,TOP-3)=J
      L = TEMP(1)/MODULO
      STACK(2,TOP-3)=META(L)
      ARGTOP=0
      TOP = TOP-3
      CALL VCTPRD(L)
      IF (L.EQ.1) GOTO 2900
      GOTO 220
C     STACK ARGUMENT
 1800 II = STACK(1,TOP-1)
      II = MOD(NAMTBL(II),MODULO)
      IF(II.GE.MODHLF)II=II-MODHLF
      GOTO 1101
C
C...  ERROR 1029:  'BOUNDED GEOMETRY MUST NOT BE SUBSCRIPTED.  STATE-
C                   MENT IGNORED.'
C
 1805 CALL ALARM(1029,TOP-4,8,'RECOG   ')
      CALL CALLZZ(UNDEF)
      CALL ARGCVT(STACK(1,TOP-6))
      CALL RLSLIN
      GOTO 2810
C...       SCAN PAST RIGHT TERMINATOR
 1900 CALL INPUT
      IF(STACK(1,TOP).EQ.RTERM(2))GO TO 520
      TOP=TOP-1
      GO TO 1900
C     REMOVE PARENTHESIS
C
 2100 STACK(1,TOP-2)=STACK(1,TOP-1)
      STACK(2,TOP-2)=STACK(2,TOP-1)
      ESTACK(TOP-2)=ESTACK(TOP-1)
      TOP=TOP-2
      GO TO 2900
C
C...       CONCATINATE TOP TO STRING, SET STACK TO 'LTR'
 2200 CALL SETCHR(TOP-1,LETTER)
 2500 K=STACK(1,TOP)
 2510 CALL CONCAT(CHR,CNAMTB(K))
      LSTCHR=STACK(1,TOP)
      TOP=TOP-1
      CALL INPUT
      GO TO 25
 2900 CALL INPUT
      IF (STACK(1,TOP).GT.NAMMAX)GOTO 1
      IF(NAMTBL(STACK(1,TOP)).NE.MCLTRM(1))GOTO 1
      BKPT=MBKPNT
      GO TO 1
 2950 IF (.NOT.ISSFL) GOTO 2900
      CALL ISSCOD
      GO TO 20
C...       NESTED ASSIGNMENT
 2300 IF (MODE(STACK(1,TOP-1)).EQ.BOOL)CALL BOOLIF(5)
      CALL REPLAC
      GO TO 860
C...       ASSIGNMENT STATEMENT
 2400 IF (MODE(STACK(1,TOP-1)).EQ.BOOL)CALL BOOLIF(5)
      CALL REPLAC
      GO TO 5
 2600 CALL PRO026
      GO  TO  1
 2700 DOJUMP = 1
      CALL LOOP
      GOTO 6
C     STACK ARGUMENT
 2800 CALL ALARM(1007,ERRP,8,'RECOG   ')
      IF (ICALLF.EQ.1) CALL MACREC(12)
 2810 BIGCNT = 0
      IBR=0
      IF(STACK(1,TOP).EQ.RTERM(2)) GO TO 5
      TOP=99
      CALL INPUT
      GO TO 5
C
C...       IS MODE OF JUMP VARIABLE 'REAL'
C
 3000 IF(ARGTOP.GT.0)CALL ALARM(2052,-ARGTOP,8,'RECOG   ')
      K = STACK(1,TOP-7)
      L = MODE(K)
      IF(L.NE.REAL)
     1CALL ALARM(1008,TOP-7,8,'RECOG   ')
      IF(IFTMP(K)) CALL PUTTMP(L)
      CALL OPCODE (CONJMP)
C
C...       VARIABLE
C
      CALL ARGCVT(K)
C
C...   LABELS
C
      DO 3001 I=1,5,2
      K = TOP-6+I
      K = STACK(1,K)
      IF (K.GT.NAMMAX) GOTO 3004
      J = MODULO*(NAMTBL(K)/MODULO)
      IF(J.NE.LABEL(1) .AND. J.NE.IMPLAB(1))NAMTBL(K)=IMPLAB(1)
      IF(WHCHMN.EQ.0)GO TO 3002
      GO TO 3003
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
 3004 K=K-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,K,IDUMMY)
      CALL BCDBIN(CNUMTB(K),KK,ICOUNT)
      K=KK+10000
 3003 CALL MACLBL(K,-WHCHMN,K)
      IF(NAMTBL(K).EQ.0)NAMTBL(K)=IMPLAB(1)+WHCHMN
 3002 CALL LABCON(K)
 3001 CALL ONEARG(K)
      CALL RLSLIN
      GO TO 6
C
 3200 CALL INPUT
      IF (ENDFLG) GOTO 3
      ERRP=TOP-1
      IF(STACK(1,TOP).NE.ASTER(2))GO TO 3210
C                  **  TO  'DBLAST'
      TOP=ERRP
      CALL SETCHR (TOP,DBLAST)
      GO TO 25
 3210 TOP=ERRP
      CNT=CNT-1
 3215 LBKPNT=MBKPNT-6
      GO TO 25
C           VECTOR PRODUCT (STACK PREPARATION)
 3300 IF (STACK(1,TOP-2).LE.NAMMAX) THEN
        IF (NAMTBL(STACK(1,TOP-2)).EQ.DOT(1))GOTO 3320
      ENDIF
      DO 3310 J=1,3,2
      IF (STACK(1,TOP-J).LE.NAMMAX) THEN
      IF(MOD(NAMTBL(STACK(1,TOP-J)),MODHLF).NE.VECTOR)GOTO 3330
      ENDIF
 3310 CONTINUE
 3320 I=-1
      CALL VCTPRD(I)
      GOTO 220
 3330 CALL ALARM(1008,TOP-J,8,'RECOG   ')
      GOTO 2810
C
C...       ENTER DIGIT STRING IN NAME TABLE
 3400 CALL CONCAT(CHR,'.')
      LSTCHR=NUMIDX
 2000 IICHR=CHR(4:15)
      K=I
      I = NUMB(IICHR)
 3405 L = NUMBER(1)/MODULO
C....ADD OFFSET OF NAMMAX TO CNUMTB ADDRESS FOR COMPATIBILITY
C....WITH PREVIOUS METHOD OF STORING NUMBERS IN NAMTBL
      I= I + NAMMAX
 3410 STACK(1,TOP-1) = I
      STACK(2,TOP-1) = META (L)
      ERRP=TOP-1
      IF(K.LT.70)GOTO 220
      IF (K-73)7200,7300,7400
 3500 L = IDENT(1)
      K=I
      READ (CHR,'(I3)') NCHR
      IF(NCHR.GT.6) CALL ALARM(16,TOP-1,4,'RECOG   ')
      IICHR = CHR(4:NCHR+3)
      I = NAME(IICHR)
      IF (NAMTBL(I).EQ.0) NAMTBL(I)=L
      L = NAMTBL(I)/MODULO
      GO TO 3410
C...       SET PERIOD AND CONCATINATE TOP TO DIGIT STRING
 3600 CALL SETCHR(TOP-1,NUMBER)
      GO TO 2500
 3700 CALL PRO020(I)
      IF (I.NE. 38) GO TO 2900
      GO TO 1
C
 4000 CALL KONAST(TENPT)
      GOTO 220
C
C...  MACRO PROCESSING
C
 5100 J = I - 50
      IF(J.EQ.9)CALL LABCON(0)
      CALL MACREC(J)
      GO TO (220,220,1,1,2900,1,5110,1,5110,2900,1),J
 5110 DOJUMP=J-3
      CALL LOOP
      GOTO 1
C
C... LARGE SURFACE PRODUCTIONS  ****************************************
C... IF ACTION NUMBER EQUALS 101, CHANGE STACK FROM CONBIG / TO
C... BIGGEO /.
C... IF ACTION NUMBER IS NOT EQUAL TO 101, ADD 1 TO LARGE SURFACE
C... ARGUMENT COUNT AND CALL LCANON, LARGES OR INPAT
C
 5200 IF(I.NE.101)GO TO 5210
      CALL SETMOD(TOP-1,BIGGEO)
      GO TO 5205
C
 5210 BIGCNT=BIGCNT+1
      IF(IBR.NE.0)GO TO 5250
C
      N3=STACK(1,TOP-3)
      IF(N3.GT.NAMMAX)GO TO 5240
      IF(NAMTBL(N3).NE.CANON(1))GO TO 5240
      IBR=1
      GO TO 5250
 5240 N5=STACK(1,TOP-5)
      M5=NAMTBL(N5)-BIGGEO(1)
      IF(M5.GE.MODHLF)M5=M5-MODHLF
      IF(M5.NE.TABCYL)GO TO 5245
      IBR=2
      GO TO 5250
 5245 IF(M5.NE.PATERN)GO TO 5248
      IBR=3
      GO TO 5250
 5248 ERRP=TOP-5
      IF(M5.NE.SSURF.AND.M5.NE.SCURV)GO TO 2800
      IBR=4
C
 5250 GO TO (5255,5270,5280,5290),IBR
 5255 CALL LCANON(I,BIGCNT)
      GO TO 5205
 5270 CALL LARGES(I,BIGCNT)
      GO TO 5205
 5280 CALL INPAT(I,BIGCNT)
      GO TO 5205
 5290 CALL SSDEF(I,BIGCNT)
C
C... START PRODUCTION SEARCH AT BRKPNT IF CALLED FOR BY PREVIOUS
C... PRODUCTION. IF PREVIOUS PRODUCTION RESULTED IN A NULL STACK, SET
C... NEW STATEMENT FLAG EQUAL TO .TRUE.  IF PREVIOUS PRODUCTION CALLED
C... FOR A NEW CHARACTER TO BE ADDED TO THE STACK, CALL INPUT.
C
C
 5205 IF (I .LE. 102)  LBKPNT = BKPT
      I = I-100
      GO TO (25,1,3,5220,5220) ,I
 5220 CALL INPUT
      GO TO 1
C
 5000 CALL RECOGN(I,IASNRT)
      GO TO(25,220,600,1000,2900),IASNRT
C
 3100 CALL PRO027(5)
      GO TO 5
C
 7100 STACK(1,TOP-1)=STACK(1,TOP)
      STACK(2,TOP-1) = STACK(2,TOP)
      ESTACK(TOP-1) = ESTACK(TOP)
      OPDFLG=.TRUE.
      GOTO 2500
C
 7200 IF(NAMTBL(I).NE.RELAT(1))GOTO 7210
      TOP=TOP+2
      STACK(1,TOP-1)=ZEROPT
      IF(CNAMTB(I).EQ.TRUE)STACK(1,TOP-1)=ONEPT
      NAMTBL(I)=IDENT(1)
      CALL REPLAC
      NAMTBL(I)=VBL(1)+BOOL
      TOP=TOP-3
      GOTO 2900
 7210 IF(OPDFLG)GOTO 7230
 7215 CNT=CNT-1
 7220 TOP=TOP-1
      GOTO 220
C
 7230 OPDFLG=.FALSE.
      IF (L.GT.26.AND.L.LT.31) GOTO 7220
      IF (STACK(1,TOP).LE.NAMMAX) THEN
        IF (CNAMTB(I).EQ.TRUE.OR.CNAMTB(I).EQ.FALSE)GOTO 7220
      ENDIF
      IF (MACLDD)GOTO 7215
      ERRP=TOP
      GOTO 2800
C
 7300 IF (MACLDD)GOTO 7215
      GOTO 900
C
 7400 CALL INPUT
      IF (STACK(1,TOP).LE.NAMMAX) THEN
      IF(NAMTBL(STACK(1,TOP)).EQ.LETTER(1))GOTO 7420
      IF((CNAMTB(STACK(1,TOP-1)).NE.'E   ').AND.
     *   (CNAMTB(STACK(1,TOP-1)).NE.'D   '))GOTO 7420
      ENDIF
      CALL SETCHR(TOP-1,CONAST)
      GOTO 7215
 7420 CHR=ZERO//BLK
      CALL CONCAT(CHR,'.')
      CNT=CNT-1
      K=STACK(1,TOP-1)
      OPDFLG=.TRUE.
      GOTO 2510
C
 7800 IF (STACK(1,TOP-1).LE.NAMMAX) THEN
        IF(MOD(NAMTBL(STACK(1,TOP-1)),MODHLF).NE.BOOL)GOTO 2900
      ENDIF
 7500 J=I-74
      CALL BOOLIF(J)
      IF(TOP)2810,11,220
C
      END
**** SOURCE FILE : M0006673.V06   ***
*
C
C              FORTRAN SUBROUTINE RECOGN
C
C LINKAGE      SUBROUTINE RECOGN(I,IASNRT)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    MACLBL          SUBROUTINE    RECOG
C          SUBROUTINE    ARGCVT
C          INTEGER FCT.  NAME
C          SUBROUTINE    ALARM
C          INTEGER FCT.  GETTMP
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    REFGEN
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          SUBROUTINE    SETMOD
C          LOGICAL FCT.  IFTMP
C          SUBROUTINE    TWOARG
C
      SUBROUTINE RECOGN(I,IASNRT)
C
      IMPLICIT INTEGER (A-Z)
C
C              FUNCTION DECLARATION
C
      LOGICAL IFTMP
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),SLASH(2),GEOM(2),TEMP(2),VBL(2),IDENT(2),
     *          CONGEO(2),CONPRO(2),CONBIG(2),CANON(2),BIGGEO(2)
C SLASH:       (1)=CODE CLASS  5000,(2)=NAMTBL INDEX OF '/     '
      EQUIVALENCE (SLASH(1),CODE(9))
C GEOM:        (1)=CODE CLASS 16000,(2)=NAMTBL INDEX OF 'GEOM  '
      EQUIVALENCE (GEOM(1),CODE(31))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C CONGEO:      (1)=CODE CLASS 39000,(2)=NAMTBL INDEX OF 'CONGEO'
      EQUIVALENCE (CONGEO(1),CODE(77))
C CONPRO:      (1)=CODE CLASS 40000,(2)=NAMTBL INDEX OF 'CONPRO'
      EQUIVALENCE (CONPRO(1),CODE(79))
C CONBIG:      (1)=CODE CLASS 43000,(2)=NAMTBL INDEX OF 'CONBIG'
      EQUIVALENCE (CONBIG(1),CODE(85))
C CANON:       (1)=CODE CLASS 42000,(2)=NAMTBL INDEX OF 'CANON '
      EQUIVALENCE (CANON(1),CODE(83))
C BIGGEO:      (1)=CODE CLASS 44000,(2)=NAMTBL INDEX OF 'BIGGEO'
      EQUIVALENCE (BIGGEO(1),CODE(87))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(502),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        5.    PROGRAM CONTROL FLAGS
C
      COMMON/FLAGS/FLAGS
      LOGICAL REFFLG
      DIMENSION FLAGS(4)
C REFFLG:      TRUE WHEN A REFSYS COMMAND ENCOUNTERED
      EQUIVALENCE (REFFLG,FLAGS(4))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12)
C ZERO:        NAMTBL POINTER TO '0     '
      EQUIVALENCE (ZERO,NUMPTR(1))
C ONE:         NAMTBL POINTER TO '1     '
      EQUIVALENCE (ONE,NUMPTR(3))
C TWO:         NAMTBL POINTER TO '2     '
      EQUIVALENCE (TWO,NUMPTR(5))
C THREE:       NAMTBL POINTER TO '3     '
      EQUIVALENCE (THREE,NUMPTR(6))
C FOUR:        NAMTBL POINTER TO '4     '
      EQUIVALENCE (FOUR,NUMPTR(7))
C FIVE:        NAMTBL POINTER TO '5     '
      EQUIVALENCE (FIVE,NUMPTR(8))
C
C       15.    ARRAY LIMIT STORAGE
C
      COMMON/SBSCPT/SBSCPT
      DIMENSION SBSCPT(101),RANGE(100)
C RNGPT:       POINTER TO NEXT RANGE ENTRY
      EQUIVALENCE (RNGPT,SBSCPT(1))
C RANGE:       STORAGE FOR APT RESERVE STATEMENT INFORMATION
      EQUIVALENCE (RANGE(1),SBSCPT(2))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C REPL:        CONTAINS COMMAND CODE (17) FOR REPL COMMAND
      EQUIVALENCE (REPL,IL(17))
C MOVE:        CONTAINS COMMAND CODE (19) FOR MOVE COMMAND
      EQUIVALENCE (MOVE,IL(19))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C RLDSRF:      MODE CODE (12) FOR RULED SURFACE
      EQUIVALENCE (RLDSRF,MODX(12))
C POINT:       MODE CODE (19) FOR POINT
      EQUIVALENCE (POINT,MODX(19))
C REAL:        MODE CODE (24) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      DIMENSION MACXX1(71)
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C TRPDLR:      CONTAINS OPERAND TYPE CODE 3
      EQUIVALENCE (TRPDLR,OPMOD(4))
C QUIDLR:      CONTAINS OPERAND TYPE CODE 5
      EQUIVALENCE (QUIDLR,OPMOD(6))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136),APTXXX(120)
C APTXXX:      NAMTBL POINTERS FOR XECUTION SUBROUTINE NAMES
      EQUIVALENCE (APTXXX(1),SUBLST(1))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       42.    COMMON BLOCK FOR CANON AND OBTAIN ARGUMENT STORAGE
C
      COMMON/CANSTR/CANSTR
      DIMENSION CANSTR(18),CANSTK(16)
C CANPTR:      POINTER TO LAST CANSTK ENTRY
      EQUIVALENCE (CANPTR,CANSTR(1))
C CANCHK:      CONTAINS DIMENSION OF ARRAY CANSTK
      EQUIVALENCE (CANCHK,CANSTR(2))
C CANSTK:      ARGUMENT STACK FOR CANON AND OBTAIN STATEMENTS
      EQUIVALENCE (CANSTK(1),CANSTR(3))
C*
C ARGUMENTS    I       CURRENT PRODUCTION NUMBER
C              IASNRT  INTEGER USED BY RECOG TO BRANCH TO THE
C              APPROPRIATE CODING AFTER RETURN FROM RECOGN
C
      LOGICAL CANFLG,ERRFLG
      CHARACTER*6 PPOINT
      DATA CANFLG/.FALSE./,STMTYP,CANDAT/2*0/
      DATA PPOINT /'POINT'/
C**
      INDEX=I-40
      GO TO(4100,4200,4300,4400,4500,4600,4700,4800,4900),INDEX
C
C...  STORE NEXT ELEMENT
C
 4100 N5=STACK(1,TOP-5)
      IF(CANPTR.NE.0)GO TO 4150
      J=NAMTBL(N5)-GEOM(1)
      IF(J.EQ.RLDSRF)GO TO 4110
      J=J-MODHLF
      IF(J.NE.RLDSRF)GO TO 4150
 4110 N5=GETTMP(RLDSRF)
      NAMTBL(N5)=BIGGEO(1)+J
      STACK(1,TOP-5)=N5
      J=BIGGEO(1)/MODULO
      STACK(2,TOP-5)=META(J)
      GO TO 220
 4150 CANPTR=CANPTR+1
      CANDAT=CANDAT+1
      IF(CANPTR.EQ.1)GOTO 4175
 4155 IF(CANPTR.NE.CANERR)GOTO 4156
      CALL ALARM(III,TOP-1,8,'RECOGN  ')
      GOTO 4403
 4156 IF(CANPTR.LE.CANCHK)GO TO 4160
      IF(CANPTR.EQ.CANCH)CALL ALARM(19,TOP-1,8,'RECOGN  ')
      GO TO 4170
 4160 J=STACK(1,TOP-1)
      KK=MODE(J)
      IF(STMTYP.NE.3)GOTO 4161
      IF(J.GT.NAMMAX)GOTO 4172
      JJ=NAMTBL(J)/MODULO*MODULO
      IF(JJ.NE.VBL(1).AND.JJ.NE.TEMP(1))GOTO 4165
 4161 IF(KK.NE.REAL)GOTO 4172
 4165 CANSTK(CANPTR) = STACK(1,TOP-1)
 4170 STACK(1,TOP-2) = STACK(1,TOP)
      STACK(2,TOP-2) = STACK(2,TOP)
      TOP = TOP-2
      GOTO 220
 4172 CALL ALARM(KKK,TOP-1,8,'RECOGN  ')
      ERRFLG=.TRUE.
      GOTO(4165,4212),INDEX
C
C...  STORE NEGATIVE MODIFIER
C
 4200 CANPTR=CANPTR+1
      IF(CANPTR.EQ.1)GOTO 4175
 4205 IF(CANPTR.NE.CANMAX)GOTO 4206
 4207 CALL ALARM(III,TOP,8,'RECOGN  ')
      GOTO 4403
 4206 IF(CANPTR.LE.CANCHK)GO TO 4210
      IF(CANPTR.EQ.CANCH)CALL ALARM(19,TOP,8,'RECOGN  ')
      GO TO 4220
 4210 IF(STMTYP.EQ.1)GOTO 4230
 4212 CANSTK(CANPTR) = -CANPTR
 4220 STACK(1,TOP-1)=STACK(1,TOP)
      STACK(2,TOP-1)=STACK(2,TOP)
      TOP = TOP-1
      GOTO 220
 4230 III=1008
      GOTO 4207
C
 4175 TP=TOP-6+INDEX
      ERRFLG=.FALSE.
      IF(STACK(1,TP+1).EQ.SLASH(2))GOTO 4180
      TP=TP-2
      STMTYP=2
      GOTO 4185
 4180 STMTYP=3
      IF(NAMTBL(STACK(1,TP+2)).EQ.CANON(1))STMTYP=1
 4185 MODC=MOD(NAMTBL(STACK(1,TP)),MODHLF)
      CANMAX=TXXXX(1,MODC)
      CANERR=CANMAX+1
      CANCH =CANCHK+1
      III=2032
      KKK=2033
      IF(STMTYP.NE.3)GOTO 4190
      III=1035
      KKK=2051
 4190 GOTO(4155,4205),INDEX
C
C...  REMOVE VARIABLE NAME FROM CANON DEFINITION
C
 4300 CANNAM = STACK(1,TOP-3)
      J = STACK(1,TOP-5)
      JJ=MODE(CANNAM)
      MODC=MOD(NAMTBL(J),MODULO)
      IF (JJ.EQ.MODC)GOTO 4301
      CALL ALARM(1024,TOP-3,8,'RECOGN  ')
      GOTO 4403
 4301 CANFLG = .TRUE.
      CANMAX=TXXXX(1,MODC)
      STACK(1,TOP-3) = STACK(1,TOP-1)
      STACK(2,TOP-3) = STACK(2,TOP-1)
      STACK(1,TOP-2) = STACK(1,TOP)
      STACK(2,TOP-2) = STACK(2,TOP)
      TOP = TOP-2
      GOTO 220
C
C...  END OF CANON DEFINITION STATEMENT
C
 4400 CANEND=1
 4401 IF(ERRFLG)GOTO 4403
      IF(ARGTOP.GT.0)GOTO 4415
      IF(STMTYP.EQ.2.OR.CANDAT.EQ.CANMAX)GOTO 4411
      IF(CANDAT.EQ.0)GOTO 4416
 4402 CALL ALARM(2032,0,8,'RECOGN  ')
      GOTO 4403
 4415 CALL ALARM(2013,-ARGTOP,8,'RECOGN  ')
      GOTO 4403
 4416 CALL ALARM(2032,0,4,'RECOGN  ')
 4411 J = STACK(1,TOP-5)
      JJ = MODULO*(NAMTBL(J)/MODULO)
      K = STACK(1,TOP-3)
      KK = NAMTBL(K)-GEOM(1)
      IF(KK.GE.MODHLF)KK=KK-MODHLF
 4420 IF(JJ.NE.VBL(1). AND .JJ.NE.TEMP(1))GO TO 4425
      IF(MODE(J).EQ.KK)GO TO 4404
      CALL ALARM(1001,TOP-5,8,'RECOGN  ')
 4403 CANFLG = .FALSE.
      GOTO 600
C
 4425 CALL RESRVZ(J,KK,CANMAX,1)
      CALL SETMOD(TOP-5,VBL(1))
      NAMTBL(J) = NAMTBL(J)+KK
C
C...  CHECK FOR REFSYS
C
 4404 IF(JJ.EQ.VBL(1).AND.INTMED.EQ.0)CALL ALARM(50,TOP-5,4,'RECOGN  ')
      IREF=0
      REFSAV=0
      IF(.NOT.REFFLG)GO TO 4445
      IF(KK.LT.1.OR.KK.GT.20)GO TO 4445
      GO TO(4431,4431,4432,4432,4433,4434,4434,4434,4435,4434,4445,
     /      4445,4445,4434,4445,4445,4445,4445,4433,4436),KK
 4431 IR=FOUR
      IREF=4
      GO TO 4440
 4432 IR=FIVE
      IREF=2
      GO TO 4440
 4433 IR=TWO
      IREF=1
      GO TO 4440
 4434 IR=ONE
      IREF=5
      GO TO 4440
 4435 IR=FIVE
      IREF=2
      GO TO 4440
 4436 IR=THREE
      IREF=3
 4440 IF(.NOT.CANFLG)GO TO 4445
C
C...  GENERATE CALL TO TRANSF TO MOVE REFERENCED C.F. TO LOCAL SYSTEM
C
      REFSAV=CANNAM
      CANNAM=GETTMP(KK)
      CALL CALLZZ(APTXXX(103))
      CALL ARGCVT(CANNAM)
      CALL ARGCVT(REFSAV)
      CALL ARGCVT(IR)
      CALL TWOARG(QUIDLR,CANMAX)
      CALL ARGCVT(ZERO)
      CALL RLSLIN
 4445 CALL OPCODE(MOVE)
      CALL ARGCVT(J)
      IF(CANPTR.EQ.0)GO TO 4414
      DO 4405 II=1,CANPTR
      IF(CANSTK(II))4406,4406,4407
 4406 IF (CANFLG) GOTO 4408
      III=2033
      GOTO 4403
 4408 CALL TWOARG(CANSTK(II),CANNAM)
      GOTO 4405
 4407 CALL ARGCVT(CANSTK(II))
      IF(IFTMP(CANSTK(II)))CALL PUTTMP(MODE(CANSTK(II)))
 4405 CONTINUE
      IF(.NOT.CANFLG)GO TO 4410
      IF(CANPTR.EQ.CANMAX)GO TO 4480
 4414 JJ=CANPTR+1
      DO 4409 II=JJ,CANMAX
 4409 CALL TWOARG(-II,CANNAM)
 4480 IF(IFTMP(CANNAM))CALL PUTTMP(MODE(CANNAM))
      IF(REFSAV.EQ.0)GO TO 4410
      IF(IFTMP(REFSAV))CALL PUTTMP(MODE(REFSAV))
 4410 CALL RLSLIN
C
C...  IF REFSYS APPLIES,GENERATE I.L. TO MOVE RESULT TO BASE SYSTEM
C
      IF(IREF.NE.0)CALL REFGEN(IREF,J)
      GO TO(600,4412,4413),CANEND
 4412 STACK(1,TOP-6) = STACK(1,TOP-5)
      STACK(2,TOP-6) = STACK(2,TOP-5)
      TOP = TOP-6
      GOTO 2900
 4413 STACK(1,TOP-4) = CANTMP
      L = TEMP(1)/MODULO
      STACK(2,TOP-4) = META(L)
      TOP = TOP-4
      GOTO 2900
C
C...  END OF NESTED NAMED CANON DEFINITION
C
 4500 CANEND=2
      GOTO 4401
C
C...  END OF NESTED UNNAMED CANON DEFINITION
C
C
 4600 K = STACK(1,TOP-3)
      KK=NAMTBL(K)-GEOM(1)
      IF(KK.GE.MODHLF)KK=KK-MODHLF
      J = GETTMP(KK)
      JJ = TEMP(1)
      CANTMP = J
      CANEND = 3
      GOTO 4420
C
C **********   O B T A I N   P R O C E S S I N G   **********
C
 4700 J = STACK(1,TOP-1)
      IF(ARGTOP.GT.0)GO TO 7015
      IF(CANDAT.GT.0)GO TO 7010
      CALL ALARM(18,0,8,'RECOGN  ')
      GO TO 7080
 7010 IF(MODE(J).EQ.MODC) GO TO 7020
C
C... VARIABLE ASSIGNED WRONG MODE.
C
      CALL ALARM(1050,TOP-1,8,'RECOGN  ')
      GO TO 7080
 7015 CALL ALARM(2013,-ARGTOP,8,'RECOGN  ')
      GO TO 7080
 7020 IF(ERRFLG)GOTO 7080
      IF (MOD(NAMTBL(J),MODULO) .LE. MODHLF)  GO TO 7030
      J = GETTMP(MODE(J))
      CALL OPCODE(REPL)
      CALL ONEARG(TXXXX(1,MODC))
      CALL TWOARG(0,J)
      CALL TWOARG(TRPDLR,STACK(1,TOP-1))
      CALL RLSLIN
C
C...  IF REFSYS APPLIES,MOVE C.F. TO LOCAL SYSTEM
C
 7030 REFSAV=0
      IF(.NOT.REFFLG)GO TO 7032
      JJ=MODE(J)
      IF(JJ.LT.1.OR.JJ.GT.20)GO TO 7032
      GO TO(7061,7061,7062,7062,7063,7064,7064,7064,7062,7064,7032,
     /      7032,7032,7064,7032,7032,7032,7032,7063,7066),JJ
 7061 IR=FOUR
      GO TO 7070
 7062 IR=FIVE
      GO TO 7070
 7063 IR=TWO
      GO TO 7070
 7064 IR=ONE
      GO TO 7070
 7066 IR=THREE
 7070 REFSAV=J
      J=GETTMP(JJ)
      CALL CALLZZ(APTXXX(103))
      CALL ARGCVT(J)
      CALL ARGCVT(REFSAV)
      CALL ARGCVT(IR)
      CALL TWOARG(QUIDLR,TXXXX(1,JJ))
      CALL ARGCVT(ZERO)
      CALL RLSLIN
C
 7032 DO 7050 N=1,CANPTR
      K=CANSTK(N)
      IF(K.LT.0)GO TO 7050
      L=(NAMTBL(K)/MODULO)*MODULO
      IF((L.NE.IDENT(1)).AND.(L.NE.CONGEO(1)).AND.
     /   (L.NE.CONBIG(1)).AND.(L.NE.CONPRO(1)))GO TO 7035
      CALL RESRVZ(K,REAL,TXXXX(1,REAL),1)
      NAMTBL(K)=VBL(1)+REAL
      GO TO 7040
 7035 IF((L.EQ.VBL(1)).AND.(MODE(K).EQ.REAL))GO TO 7040
      IF((MOD(NAMTBL(K),MODULO).GT.MODHLF)
     / .AND.(MODE(K).EQ.REAL))GO TO 7045
 7040 CALL OPCODE(MOVE)
      CALL TWOARG(0,K)
 7043 CALL TWOARG(-N,J)
      CALL RLSLIN
      GO TO 7050
 7045 CALL OPCODE(MOVE)
      CALL TWOARG(TRPDLR,K)
      GO TO 7043
 7050 CONTINUE
      IF(REFSAV.EQ.0)GO TO 7080
      IF(IFTMP(REFSAV))CALL PUTTMP(MODE(REFSAV))
 7080 IF(IFTMP(J))CALL PUTTMP(MODE(J))
      GO TO 600
C
C
C... SUBSCRIPTED ARGUMENT IN OBTAIN STATEMENT
C
 4800 I=STACK(1,TOP-4)
      IF(MODE(I).NE.0)GO TO 1000
      NAMTBL(I)=NAMTBL(I)+REAL
      III=1
 7110 IF(III.GE.RNGPT)GO TO 1000
      IF(RANGE(III).EQ.I)GO TO 7120
      III=III+2
      GO TO 7110
 7120 CALL RESRVZ(I,REAL,TXXXX(1,REAL),RANGE(III+1))
      GO TO 1000
C
C... RETURN TO RECOG
C
  220 IASNRT=2
      GO TO 9000
  600 IASNRT=3
      GO TO 8900
 1000 IASNRT=4
      GO TO 9000
 2900 IASNRT=5
      CANFLG = .FALSE.
 8900 CANPTR=0
      STMTYP=0
      CANDAT=0
 9000 RETURN
C
C...  SPECIAL POINT DEFINITION
C
 4900 K=STACK(1,TOP-1)
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=K
      IF(IFTMP(K))CALL PUTTMP(MODE(K))
      STACK(1,TOP-1)=STACK(1,TOP-3)
      STACK(2,TOP-1)=STACK(2,TOP-3)
      K=NAME(PPOINT)
      CALL MACLBL(K,0,K)
      NAMTBL(K)=GEOM(1)+POINT
      STACK(1,TOP-3)=K
      K=GEOM(1)/MODULO
      STACK(2,TOP-3)=META(K)
      STACK(1,TOP-2)=SLASH(2)
      K=SLASH(1)/MODULO
      STACK(2,TOP-2)=META(K)
      GO TO 220
C
      END
**** SOURCE FILE : M0006674.V01   ***
*
C
C              FORTRAN SUBROUTINE REFGEN
C
C LINKAGE      SUBROUTINE REFGEN (IREF,NAMPTR)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ARGCVT          SUBROUTINE    PRO021
C          SUBROUTINE    CALLZZ          SUBROUTINE    PRO026
C          SUBROUTINE    RLSLIN          SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOGN
C
      SUBROUTINE REFGEN (IREF,NAMPTR)
C
      IMPLICIT INTEGER (A-Z)
C
C       13.    NAMTBL POINTERS TO NEGATIVE NUMBERS
C              NAMTBL POINTER TO -1.
      COMMON/NEGPTR/NONEPT
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136),APTYYY(5)
C APTYYY:      NAMTBL POINTERS FOR XECUTION SUBROUTINE NAMES
      EQUIVALENCE (APTYYY(1),SUBLST(121))
C DEFEXT:      NAMTBL POINTER FOR XECUTION SUBROUTINE DEFEXT
      EQUIVALENCE (DEFEXT,SUBLST(82))
C*
C ARGUMENTS    IREF       APTYYY INDEX CONTAINING NAME TABLE
C                         (NAMTBL) INDEX OF TRANSFORMATION ROUTINE.
C              NAMPTR    NAME TABLE (NAMTBL) INDEX OF VARIABLE
C                        TO BE TRANSFORMED.
C NOTES        FOLLOWING IS A LIST OF EACH IREF VALUE WITH
C              ITS ASSOCIATED SURFACE AND TRANSFORMATION ROUTINE NAME.
C              IREF       VARIABLE MODE         TRANSFORMATION
C              1             POINT, SPHERE         APT081
C              2             CIRCLE                APT083
C              3             VECTOR                ATP078
C              4             LINE, PLANE           APT077
C              5             QUADRIC SURFACE       APT079
C**
  380 CALL CALLZZ(APTYYY(IREF))
      CALL ARGCVT(NAMPTR)
      CALL ARGCVT(NONEPT)
      CALL RLSLIN
      CALL CALLZZ(DEFEXT)
      CALL ARGCVT(NAMPTR)
      CALL RLSLIN
      RETURN
       END
**** SOURCE FILE : M0006675.V03   ***
*
C
C              FORTRAN SUBROUTINE REFREF
C
C LINKAGE      SUBROUTINE REFREF
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    CALLZZ          SUBROUTINE    PRO026
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    ALARM
C          SUBROUTINE    RLSLIN
C
      SUBROUTINE REFREF
C
      IMPLICIT INTEGER (A-Z)
C
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),ARGSTK(99)
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        5.    PROGRAM CONTROL FLAGS
C
      COMMON/FLAGS/FLAGS
      LOGICAL REFFLG
      DIMENSION FLAGS(4)
C REFFLG:      TRUE WHEN A REFSYS COMMAND ENCOUNTERED
      EQUIVALENCE (REFFLG,FLAGS(4))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C MATRIX:      MODE CODE (18) FOR MATRIX
      EQUIVALENCE (MATRIX,MODX(18))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136)
C APT085:      NAMTBL POINTER FOR APT085
      EQUIVALENCE (APT085,SUBLST(126))
C REFSYS:      NAMTBL POINTER FOR XECUTION SUBROUTINE REFSYS
      EQUIVALENCE (REFSYS,SUBLST(134))
C**
      CHARACTER*6 CNMORE
      DATA CNMORE/'NOMORE'/
      EP=-1
      IF(ARGTOP-1)20,40,30
   20 EP=TOP
      GOTO 35
   30 EP=1-ARGTOP
   35 CALL ALARM(2052,EP,8,'REFREF  ')
   40 IF (REFFLG) GO TO 1000
C     REFSYS NOT IN EFFECT
C     ARE PARAMETERS CORRECT
      IF(MODE(ARGSTK(ARGTOP)).NE.MATRIX)
     *CALL ALARM(1010,-ARGTOP,8,'REFREF  ')
      REFFLG = .TRUE.
    5 CALL CALLZZ(REFSYS)
      CALL ARGCVT (ARGSTK(ARGTOP))
   10 CALL RLSLIN
   50 RETURN
C     REFSYS IN EFFECT
 1000 I=ARGSTK(ARGTOP)
      IF (MODE(ARGSTK(ARGTOP)).EQ.MATRIX) GO TO 5
      IF (CNAMTB(I).NE.CNMORE) CALL ALARM(1011,
     *-ARGTOP,8,'REFREF  ')
      REFFLG=.FALSE.
      CALL CALLZZ(APT085)
      GO TO 10
       END
**** SOURCE FILE : M0006676.V03   ***
*
C
C              FORTRAN SUBROUTINE REPLAC
C
C LINKAGE      SUBROUTINE  REPLAC
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ARGCVT          SUBROUTINE    RECOG
C          SUBROUTINE    MATCH           SUBROUTINE    LOOP
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          SUBROUTINE    PATH
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    ALARM
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          SUBROUTINE    SETMOD
C          LOGICAL FCT.  IFTMP
C
      SUBROUTINE  REPLAC
C
      IMPLICIT INTEGER (A-Z)
C
C              FUNCTION DECLARATION
C
      LOGICAL IFTMP
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),VBL(2),IDENT(2),CONGEO(2),CONPRO(2),RELAT(2)
C RELAT:       (1)=CODE CLASS 27000,(2)=NAMTBL INDEX OF 'RELAT '
      EQUIVALENCE (RELAT(1),CODE(53))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C CONGEO:      (1)=CODE CLASS 39000,(2)=NAMTBL INDEX OF 'CONGEO'
      EQUIVALENCE (CONGEO(1),CODE(77))
C CONPRO:      (1)=CODE CLASS 40000,(2)=NAMTBL INDEX OF 'CONPRO'
      EQUIVALENCE (CONPRO(1),CODE(79))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C REPL:        CONTAINS COMMAND CODE (17) FOR REPL COMMAND
      EQUIVALENCE (REPL,IL(17))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL FINMAC,ENTRY,SHOULD
      DIMENSION MACXX1(71)
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C MAJWRD:      CONTAINS ACTUAL MAJOR WORD
      EQUIVALENCE (MAJWRD,MACXX1(23))
C FINMAC:      TRUE IF SECOND FINAL PASS OF MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C WAY:         INDICATES TYPE OF MACRO PROCESSING
      EQUIVALENCE (WAY,MACXX1(26))
C ENTRY:       FALSE ON FIRST ENTRY TO MATCH FOR A MACRO EXPRESSION
      EQUIVALENCE (ENTRY,MACXX1(40))
C SHOULD:      MACRO INDICATOR. NORMALLY FALSE
      EQUIVALENCE (SHOULD,MACXX1(70))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ESTACK,ERGSTK
      DIMENSION ERRPOS(302),ESTACK(100),ERGSTK(100)
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C ERGSTK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN ARGSTK
      EQUIVALENCE (ERGSTK(1),ERRPOS(203))
C**
      K = STACK(1,TOP-1)
      MAJWRD=STACK(1,TOP-3)
      ERGSTK(100)=TOP-3
      IF(INTMED.NE.1)GO TO 30
      WAY=4
      IF(FINMAC)GO TO 20
      ARGTOP=1
      ARGSTK(1)=K
   10 CALL MATCH
      K=ARGSTK(1)
      IF(.NOT.ENTRY)GO TO 210
      GO TO 30
   20 CALL PATH
      IF (.NOT.SHOULD) GOTO 210
   30 MODXX=MODE(K)
C          CHANGE CLASS IF IDENTIFIER
      J = MODULO*(NAMTBL(MAJWRD)/MODULO)
       IF((J.NE.IDENT(1)).AND.(J.NE.CONPRO(1)).AND.(J.NE.CONGEO(1)).AND.
     /(J.NE.RELAT(1)))GOTO 100
  150 CALL RESRVZ(MAJWRD,MODXX,TXXXX(1,MODXX),1)
      CALL SETMOD(TOP-3,VBL(1))
      NAMTBL(MAJWRD) = NAMTBL(MAJWRD)+MODXX
      GO  TO  200
  100 IF(MODE(MAJWRD).EQ.MODXX)GO TO 200
      CALL ALARM(1012,TOP-1,8,'REPLAC  ')
C
  200 CALL OPCODE(REPL)
      CALL ONEARG(TXXXX(1,MODXX))
      CALL ARGCVT(MAJWRD)
      CALLARGCVT(K)
      CALL RLSLIN
      IF(ENTRY)GO TO 10
  210 ARGTOP=0
      IF(IFTMP(K))CALL PUTTMP(MODE(K))
  300 RETURN
       END
**** SOURCE FILE : M0006677.W02   ***
*
C
C              FORTRAN SUBROUTINE RESERV
C
C LINKAGE      SUBROUTINE RESERV
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    MCXTRN          SUBROUTINE    PRO026
C          SUBROUTINE    BCDBIN
C          SUBROUTINE    ALARM
C
      SUBROUTINE RESERV
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),PERMID(2),VBL(2)
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C
C       15.    ARRAY LIMIT STORAGE
C
      COMMON/SBSCPT/SBSCPT
      DIMENSION SBSCPT(401),RANGE(400)
C RNGPT:       POINTER TO NEXT RANGE ENTRY
      EQUIVALENCE (RNGPT,SBSCPT(1))
C RANGE:       STORAGE FOR APT RESERVE STATEMENT INFORMATION
      EQUIVALENCE (RANGE(1),SBSCPT(2))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C*
C PURPOSE      TO RECORD DATA FROM RESERV SOURCE STATEMENT.
C
C
C NOTES        RANGE TABLE IS DIMENSIONED 100 AND HAS ROOM
C              FOR 25 ENTRIES (4 WORDS PER ENTRY).
C
C...       CHECK FOR END OF TABLE
C**
      IF(MOD(ARGTOP,2).NE.0)GOTO 98
      II=ARGSTK(ARGTOP)
   10 IF(RNGPT.GE.401)GO TO 90
C
C...       SET UP RANGE TABLE
C
      IF(ARGTOP-1)96,92,40
   40 II=ARGSTK(ARGTOP)
      III=ARGSTK(ARGTOP-1)
      IF(II.GT.NAMMAX)GOTO 92
      IF(III.LE.NAMMAX)GOTO 91
      IF(NAMTBL(II)/MODULO.NE.PERMID(1)/MODULO)GO TO 94
      NAMTBL(II)=VBL(1)
      RANGE(RNGPT)=II
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
      III=III-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,III,IDUMMY)
      CALL BCDBIN(CNUMTB(III),RANGE(RNGPT+1),CNT)
      IF(RANGE(RNGPT+1).EQ.1) RANGE(RNGPT+1)=2
      RNGPT=RNGPT+2
      ARGTOP=ARGTOP-2
      IF(ARGTOP.GT.0)GO TO 10
C
   99 RETURN
C
C...       TOO MANY SUBSCRIPTED VARIABLES IN PART PROGRAM
C...       RANGE TABLE FILLED
C
   90 CALL ALARM(2026,-ARGTOP,8,'RESERV  ')
      GO TO 99
C
C...       INCORRECT FORMAT FOR RESERV STATEMENT
C...       MUST BE SYMBOL, NUMBER
C
   91 ARGTOP=ARGTOP-1
   92 CALL ALARM(2027,-ARGTOP,8,'RESERV  ')
      GO TO 99
C
C...       DUPLICATE NAME OF DIMENSIONED VARIABLE
C
   94 CALL ALARM(2044,-ARGTOP,8,'RESERV  ')
      GO TO 99
C
C...       NO ARGUMENTS OR ODD NUMBER OF ARGUMENTS
C
   96 EP=1-TOP
      GO TO 100
   98 EP=1
  100 CALL ALARM(2018,-EP,8,'RESERV  ')
      GO TO 99
C
      END
**** SOURCE FILE : M0006678.W01   ***
*
C
C              FORTRAN SUBROUTINE RESRED
C
C LINKAGE      SUBROUTINE RESRED
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ICONV           SUBROUTINE    RECOG
C          SUBROUTINE    LIBOPC
C          SUBROUTINE    LIBRD
C          SUBROUTINE    LIBSCH
C          SUBROUTINE    BCDBIN
C          SUBROUTINE    MCXTRN
C          SUBROUTINE    ALARM
C          SUBROUTINE    CFORM
C          SUBROUTINE    RESRVZ
C
      SUBROUTINE RESRED
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C       12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE
      DIMENSION CFSIZE(205),MAXSIZ(2),CANSIZ(2,100)
C CANTOP:      POINTER TO THE LAST CANSIZ ENTRY
      EQUIVALENCE (CANTOP,CFSIZE(1))
C MAXSIZ:      SIZE OF THE LAST LARGEST LARGE DATA ARRAY
      EQUIVALENCE (MAXSIZ(1),CFSIZE(4))
C CANSIZ:      NUMBER OF ITEMS A. NAMTBL INDEX OF EACH LARGE DATA ARRAY
      EQUIVALENCE (CANSIZ(1,1),CFSIZE(6))
C
C       15.    ARRAY LIMIT STORAGE
C
      COMMON/SBSCPT/SBSCPT
      DIMENSION SBSCPT(101),RANGE(100)
C RNGPT:       POINTER TO NEXT RANGE ENTRY
      EQUIVALENCE (RNGPT,SBSCPT(1))
C RANGE:       STORAGE FOR APT RESERVE STATEMENT INFORMATION
      EQUIVALENCE (RANGE(1),SBSCPT(2))
C
C       36.    SYSTEM MACRO AND SEGMENT READ VARIABLES
C
      COMMON/MACSEG/MACSEG
      LOGICAL ALOPN
      DIMENSION MACSEG(6)
C ALOPN:       TRUE AFTER MACRO OR PART PROGRAM SEGMENT LIBRARY OPENED
      EQUIVALENCE (ALOPN,MACSEG(1))
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C**
      CHARACTER*6 NAM1,NAM2,BLA*1
      INTEGER INP(20)
      DATA BLA/' '/
C    CREATION OF AN INDICATED NAME
      I=STACK(1,TOP-2)
      IF(I.GT.NAMMAX)GOTO 10
C   ILLEGAL SYMBOLIC NUMBER-STATEMENT AS IDNEX ON READ-COMMAND
      CALL ALARM(2054,TOP-2,8,'RESRED  ')
      RETURN
C   CONSTRUCT STORAGE NAME
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
   10 I=I-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,I,IDUMMY)
      CALL BCDBIN (CNUMTB(I),M,N)
      CALL ICONV (M+10000000,NAM2,0,8)
      CALL CFORM (CNAMTB(STACK(1,TOP-4)),NAM1,0,8)
      DO 20 J=1,8
      IF(NAM1(J:J).EQ.BLA)GOTO 20
      NAM2(J:J)=NAM1(J:J)
   20 CONTINUE
C   POSSIBLY OPEN THE PDS
      IF(ALOPN) GOTO 30
      CALL LIBOPC(1,IFLAG)
      IF(IFLAG.EQ.0) GOTO 25
      IERROR=72
   24 CALL ALARM(IERROR,0,8,'RESRED  ')
      GOTO 41
   25 ALOPN=.TRUE.
   30 CALL LIBSCH(NAM2,IFLAG)
      IF(IFLAG.EQ.0)GOTO 40
   32 IERROR=73
      GOTO 24
C   READ FIRST CARD
   40 CALL LIBRD(NAM2,IFLAG,INP)
      IF(IFLAG.NE.0)GOTO 32
   41 CALL LIBOPC(2,IFLA)
      ALOPN=.FALSE.
      IF(IFLAG.NE.0)RETURN
C  TRANSFER MODE AND RESERVE VARIABLE, IF NECESSARY
      J=STACK(1,TOP-4)
      IF(MODE(J).NE.0)GOTO 7000
      NAMTBL(J)=NAMTBL(J)+INP(5)
C  SEARCH VARIABLE IN RESERV STORAGE
      N1=RNGPT-2
      DO 50 N=1,N1,2
      IF(RANGE(N).EQ.J)GOTO 60
   50 CONTINUE
C   THE ERROR IS REPORTED BY THE FOLLOWING CALL SUBCOD
      RETURN
C  RESERVE STORAGE
   60 CALL RESRVZ(J,INP(5),TXXXX(1,INP(5)),RANGE(N+1))
C THE LENGTH OF THE CANONICAL FORM IS STORED IN INP(8)
C  CHANGE MAXSIZ IF NECESSARY
 7000 IF(INP(8).LE.(IABS(MAXSIZ(2))))GOTO 7040
      IF(INP(8).LE.(IABS(MAXSIZ(1))))GOTO 7030
      MAXSIZ(2)=MAXSIZ(1)
      MAXSIZ(1)=INP(8)
      GOTO7040
 7030 MAXSIZ(2)=INP(8)
C INTERROGATE FOR FREE SPACE
 7040 JJ=MOD(J,CANTOP)
      DO 7050 I=1,CANTOP
      JJ=MOD(JJ,CANTOP)+1
      IF(CANSIZ(2,JJ).EQ.J)GOTO 7060
      IF(CANSIZ(1,JJ).NE.0)GOTO 7050
      CANSIZ(1,JJ)=INP(8)
      CANSIZ(2,JJ)=J
      RETURN
 7050 CONTINUE
      RETURN
 7060 CANSIZ(1,JJ)=INP(8)+CANSIZ(1,JJ)
      RETURN
      END
**** SOURCE FILE : M0006679.W01   ***
*
C
C              FORTRAN SUBROUTINE RESRVZ
C
C LINKAGE      SUBROUTINE RESRVZ(INDEX,MODE,ISIZE,NNNBER)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          INTEGER FCT.  NAME            INTEGER FCT.  GETTMP
C          SUBROUTINE    OPCODE          SUBROUTINE    GOPAT
C          SUBROUTINE    RLSLIN          SUBROUTINE    INPAT
C          SUBROUTINE    TWOARG          SUBROUTINE    LARGES
C                                        SUBROUTINE    LCANON
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    PRO020
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    REPLAC
C                                        SUBROUTINE    RESRED
C                                        SUBROUTINE    SSDEF
C
      SUBROUTINE RESRVZ(INDEX,MODE,ISIZE,NNNBER)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),VBL(2)
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C RESRV:       CONTAINS COMMAND CODE (12) FOR RESRV COMMAND
      EQUIVALENCE (RESRV,IL(12))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C REAL:        MODE CODE (21) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C BOOL:        MODE CODE (23) FOR BOOLEAN TYPE
      EQUIVALENCE (BOOL,MODX(23))
C
C       30.    NAMTBL POINTERS TO FIRST CANONICAL FORMS IN EACH BLOCK
C
      COMMON/BLKCFS/FIRST
      DIMENSION FIRST(2,3)
C*
C ARGUMENT     INDEX     NAME TABLE (NAMTBL) INDEX OF
C                        VARIABLE FOR WHICH OBJECT TIME
C                        CANONICAL FORM SPACE IS BEING ALLOCATED.
C              MODE      MODE OF VARIABLE.
C              ISIZE     NUMBER OF ELEMENTS IN CANONICAL FORM
C                        EXCLUDING SUBSCRIPT AND BCD NAME.
C              NNNBER    UPPER SUBSCRIPT LIMIT (1 IF NON-
C                        SUBSCRIPTED VARIABLE).
C
      CHARACTER*6  DLRBLK(3)
      DATA  DLRBLK /'      ','$$BLK2','$$BLK3'/
C**
C... DETERMINE WHICH BLOCK THE VARIABLE BELONGS IN
C
      BLOCK = 4
      MD = MODE
      IF(MD.EQ.BOOL)MD=REAL
      IF (MD .EQ. REAL   .AND. NNNBER .EQ. 1)  BLOCK = 1
      IF (MD .EQ. REAL   .AND. NNNBER .GT. 1)  BLOCK = 2
      IF ((MD .LT. REAL  .AND.  MD .GT. 0) .OR. (MD .GE. 24)
     1  ) BLOCK = 3
C
      IF(BLOCK.NE.2 .OR. FIRST(2,2).NE.0)GO TO 5
C... PUT FIRST ITEM IN CANONICAL FORM BLOCK 2.
      I=NAME(DLRBLK(2))
      NAMTBL(I)=VBL(1)+MODE
      CALL OPCODE(RESRV)
      CALL TWOARG(I,MODE)
      CALL TWOARG(1,2)
      CALL RLSLIN
      FIRST(1,2)=I
      FIRST(2,2)=1
C
    5 CALL OPCODE(RESRV)
      CALL TWOARG(INDEX,MODE)
      CALL TWOARG(ISIZE,NNNBER)
      CALL RLSLIN
      IF(BLOCK.EQ.4)GO TO 20
C... IF FIRST CANONICAL FORM FOR THIS BLOCK, SAVE NAMTBL INDEX.
      IF(FIRST(2,BLOCK).NE.0)GO TO 10
      FIRST(1,BLOCK)=INDEX
C... INCREMENT COUNT OF NUMBER OF FORMS IN THIS BLOCK
C
   10 FIRST(2,BLOCK) = FIRST(2,BLOCK) + NNNBER
   20 RETURN
      END
**** SOURCE FILE : M0006680.V01   ***
*
C
C              FORTRAN SUBROUTINE RETMCX
C
C LINKAGE      SUBROUTINE RETMCX(INDX)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ONEARG          SUBROUTINE    COMSTR
C          SUBROUTINE    OPCODE          SUBROUTINE    MATCH
C          SUBROUTINE    RLSLIN
C
      SUBROUTINE RETMCX(INDX)
C
      IMPLICIT INTEGER (A-Z)
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C RETMC:       CONTAINS COMMAND CODE (10) FOR RETMC COMMAND
      EQUIVALENCE (RETMC,IL(10))
C*
C ARGUMENTS    INDX     INDEX REGISTER NUMBER
C**
      CALL OPCODE(RETMC)
      CALL ONEARG(INDX)
      CALL RLSLIN
      RETURN
       END
**** SOURCE FILE : M0006682.V05   ***
*
C
C              FORTRAN SUBROUTINE RLSLIN
C
C LINKAGE      SUBROUTINE RLSLIN
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    FOUTXX          SUBROUTINE    ASNADZ
C          SUBROUTINE    COMPRS          SUBROUTINE    ASNJPZ
C          SUBROUTINE    PRTIL           SUBROUTINE    BOOLIF
C          SUBROUTINE    BINBCD          SUBROUTINE    CALMCX
C                                        SUBROUTINE    COMSTR
C                                        SUBROUTINE    GOLO
C                                        SUBROUTINE    GOPAT
C                                        SUBROUTINE    INPAT
C                                        SUBROUTINE    ISSCOD
C                                        SUBROUTINE    JUMPZZ
C                                        SUBROUTINE    LABELZ
C                                        SUBROUTINE    LARGES
C                                        SUBROUTINE    LCANON
C                                        SUBROUTINE    LOOP
C                                        SUBROUTINE    MACREC
C                                        SUBROUTINE    MNPROC
C                                        SUBROUTINE    MOTION
C                                        SUBROUTINE    PRO020
C                                        SUBROUTINE    PRO021
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    REFGEN
C                                        SUBROUTINE    REFREF
C                                        SUBROUTINE    REPLAC
C                                        SUBROUTINE    RESRVZ
C                                        SUBROUTINE    RETMCX
C                                        SUBROUTINE    SSDEF
C                                        SUBROUTINE    SUBCOD
C                                        SUBROUTINE    TSSMIL
C
      SUBROUTINE RLSLIN
C
      IMPLICIT INTEGER (A-Z)
C
C       11.    SEQUENCE NUMBER STORAGE
C
      INCLUDE (SEQCOM)    
C
C SEQNO:       INTERNALLY GENERATED STATEMENT NUMBER
C SEQNUM:      ALPHANUMERIC REPRESENTATION OF CURRRENT STATEMENT NUMBER
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL ILPRT,MCHDNG
      DIMENSION PRT(7)
C ILPRT:       TRUE INDICATES I.L. PRINTING (PPOPTN/INTLNG,ON)
      EQUIVALENCE (ILPRT,PRT(2))
C MCHDNG:      TRUE IF START OF NEW MACRO PROCESSING
      EQUIVALENCE (MCHDNG,PRT(7))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C RESRV:       CONTAINS COMMAND CODE (12) FOR RESRV COMMAND
      EQUIVALENCE (RESRV,IL(12))
C
C       19.    INTERMEDIATE LANGUAGE TEXT
C
      COMMON/ILTEXT/ILTEXT
      LOGICAL COMFIN
      DIMENSION ILTEXT(94)
C COMFIN:      TRUE IF I.L. OPERATION CODE GIVEN
      EQUIVALENCE (COMFIN,ILTEXT(1))
C OPTEXT:      CONTAINS COMMAND CODE FOR CURRENT I.L. COMMAND
      EQUIVALENCE (OPTEXT,ILTEXT(4))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL ILHLT
      DIMENSION MACXX1(71)
C ILHLT:       TRUE IF I.L. SHOULD NOT BE PLACED IN ILFILE
      EQUIVALENCE (ILHLT,MACXX1(14))
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C
C       33.    SYMBOLIC FILE DEFINITIONS
C
      INCLUDE (SYMFIL)    
C VLFILE:      VERIFICATION LISTING FILE
C*
      LOGICAL  HEADNG
      CHARACTER LINE*124,M1*36,M2*44
      DATA  LINE(1:4),HEADNG/' ',.TRUE./
      DATA M1/'0 ** FINAL MACRO I.L. PROCESSING ** '/
      DATA M2/'0GENERATED I.L. FOR MACRO AT SEQNCE '/
C**
      COMFIN=.FALSE.
      IF (ILHLT) GOTO 6
    1 IF (.NOT.ILPRT) GOTO 3
C...CHECK FOR FINAL MACRO PROCESSING
      IF (INTMED) 2,2,4
    2 LINE(121:124)=SEQNUM(1:4)
      CALL PRTIL(LINE)
    3 CALL COMPRS
      GO TO 7
C...CHECK IF HEADING SHOULD BE PRINTED ON VLFILE
    4 IF (.NOT.HEADNG) GOTO 5
      CALL FOUTXX(VLFILE,M1,36)
      HEADNG=.FALSE.
C
C...CHECK FOR START OF NEW MACRO I.L.
    5 IF (.NOT.MCHDNG) GOTO 2
      CALL BINBCD(SEQNO,SEQNUM,N)
      M2(37:44)=SEQNUM
      CALL FOUTXX(VLFILE,M2,44)
      MCHDNG=.FALSE.
      GOTO 2
    6 IF (OPTEXT.EQ.RESRV) GOTO 1
    7 RETURN
      END
**** SOURCE FILE : SEARCH00.ORG   ***
*
*
*  *  SEARCH  *   INTEGER FUNCTION   25.6.86   E.MCLELLAN
*
*  PURPOSE     TO COMPARE SOURCE STRUCTURE TO A LIST OF
*              PRODUCTIONS AND TO DETERMINE WHICH PRODUCTION
*              IS 'MATCHED' BY THE SOURCE STRUCTURE
*
*  CALLING SEQUENCE
*              INTEGER= SEARCH (SOURCE,IADR,PRODCT,ERRPT)
*
*  ARGUMENTS   SOURCE   ARRAY CONTAINING SOURCE STRUCTURE.
*              IADR     ADDRESS OF FIRST ELEMENT.
*                       THE REMAINING ELEMENTS ARE STORED
*                       IN SUCCESSIVELY LOWER CORE LOCATIONS
*              PRODCT   ADDRESS OF THE FIRST ELEMENT OF THE
*                       FIRST PRODUCTION. THE REMAINING
*                       ELEMENTS ARE STORED IN SUCCESSIVELY
*                       HIGHER CORE LOCATIONS
*              ERRPT    ADDRESS OF THE PRODCT POSITION IN WHICH
*                       A MISMATCHED PRODUCTION WAS DETECTED
*
*  CALLED BY            GOPAT,INPAT,LARGES,PRO020,PRO021,RECOG,
*                       SSDEF,TSSMIL
*
*  SUBSIDIARIES         NONE
*
      INTEGER FUNCTION SEARCH(SOURCE,IADR,PRODCT,ERRPT)
C
      INTEGER SOURCE,IADR,PRODCT,ERRPT,IADSAV,ORIGIN,SUBPAT
      DIMENSION SOURCE(*),PRODCT(*)
      INTEGER ANDF
      INTEGER Z9999,ZAAAA,ZCCCC,ZFFFF
C
      INCLUDE (SDP)    
C     IWRD: NO. OF BYTES PER WORD
C
      DATA Z9999/-1718026240/,ZAAAA/-1431699456/,
     +     ZCCCC/-859045888/,ZFFFF/-65536/
C
C.... SAVE INITIAL STACK ADDRESS
      IADSAV=IADR
C.... PRODCT ADDRESS
      J=1
C.... INITIAL VALUE OF ERRPT
   5  K=ERRPT
C.... INITIAL STACK ADDRESS
      I=IADSAV
C.... IS ADDRESS IN PRODCT A BREAK POINT ?
      SUBPAT=ANDF(PRODCT(J),ZFFFF)
      IF (SUBPAT.EQ.Z9999) THEN
C.... YES - STORE THE BASIC ADDRESS, INCREMENT PRODCT ADDRESS BY 1
        ORIGIN=J
        J=J+1
      ELSE
C.... NOT A BREAK POINT - DECREASE STACK ADDRESS BY 2
C                         DECREASE ERRPT BY 1
        I=I-2
        K=K-1
      ENDIF
C
C.... NEW PRODUCTION
C
  10  CONTINUE
      IF (PRODCT(J).GE.0) THEN
C.... COMPARE IF NEXT INFORMATION IS AN ARGUMENT,
C     IF SO CHANGE TO SEQUENTIAL MODE
        IF (PRODCT(J+1).GT.0) GOTO 50
C....COMPARE STACK AND PRODCT
        SUBPAT=ANDF(SOURCE(I),PRODCT(J))
        IF (SOURCE(I).EQ.SUBPAT) THEN
C.... PRODUCTION STILL OK, INCREMENT PRODCT BY 1
C                          DECREMENT STACK BY 2
          J=J+1
          I=I-2
C.... DECREMENT ERRPT
          K=K-1
        ELSE
C.... MAINTAIN STACK ADDRESS CONSTANT, INCREMENT PRODCT BY 2
C     AND SEARCH NEW PRODUCTION
          J=J+2
        ENDIF
        GOTO 10
C
      ELSE
C.... IS PRODCT A PRODUCTION NUMBER
        SUBPAT=ANDF(PRODCT(J),ZFFFF)
        IF (SUBPAT.EQ.ZCCCC) THEN
          GOTO 80
C
C.... IS IT A DISPLACEMENT
        ELSE IF (SUBPAT.EQ.ZAAAA) THEN
C.... YES
          J=(PRODCT(J)-ZAAAA)/IWRD
          J=J+ORIGIN
          GOTO 10
        ELSE
          GOTO 5
        ENDIF
      ENDIF
C
C.... SEQUENTIAL SEARCHING
C
  50  SUBPAT=ANDF(SOURCE(I),PRODCT(J))
      IF (SOURCE(I).EQ.SUBPAT) THEN
C.... NEXT HIGHER PRODCT ADDRESS, NEXT LOWER STACK ADDRESS
        J=J+1
        I=I-2
C.... DECREMENT ERRPT
        K=K-1
C.... IS PRODCT A PRODUCTION NUMBER
        SUBPAT=ANDF(PRODCT(J),ZFFFF)
        IF (SUBPAT.EQ.ZCCCC) THEN
          GOTO 80
        ELSE
          GOTO 50
        ENDIF
      ELSE
C.... SEARCHING FAILED. FINAL PROCESS.
C     SEARCH FOR NEXT FINAL PRODUCTION NUMBER
  60    J=J+1
        SUBPAT=ANDF(PRODCT(J),ZFFFF)
        IF (SUBPAT.EQ.ZCCCC) THEN
          J=J+1
          GOTO 80
        ELSE
          GOTO 60
        ENDIF
      ENDIF
C
C.... PRODUCTION NUMBER
C
  80  SEARCH=PRODCT(J)-ZCCCC
      ERRPT=K
      RETURN
      END
**** SOURCE FILE : M0006684.V01   ***
*
C
C              FORTRAN SUBROUTINE SETBIT
C
C LINKAGE      SUBROUTINE SETBIT (WORD,N)
C
C          SUBSIDIARIES                  CALLED BY
C          NONE                          TYPE          ENTRY
C                                        SUBROUTINE    MATCH
C
      SUBROUTINE SETBIT (WORD,N)
C
      IMPLICIT INTEGER (A-Z)
C
C       32.    COMMON BLOCK FOR SETBIT AND BITMCH
C              CONTAINS ONE WORD FOR EACH BIT WITH ONLY THAT BIT SET
      COMMON/BITCOM/BIT
      DIMENSION BIT(32)
C*
C ARGUMENTS    WORD    CELL WHOSE BIT POSITION IS REFERENCED
C              N       BIT POSITION OF WORD TO BE SET
      REAL WORD,WORDR,ALLBIT
      LOGICAL WORDL,BIT
      EQUIVALENCE (WORDR,WORDL)
C**
      WORDR=WORD
      WORDL=WORDL.OR.BIT(N+1)
      WORD=WORDR
      GOTO 1040
 1040 RETURN
       END
**** SOURCE FILE : M0006685.V01   ***
*
C
C              FORTRAN SUBROUTINE SETCHR
C
C LINKAGE      SUBROUTINE SETCHR(PNTR,CLASS)
C
C          SUBSIDIARIES                  CALLED BY
C          NONE                          TYPE          ENTRY
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    KONAST
C                                        SUBROUTINE    LOOP
C                                        SUBROUTINE    VCTPRD
C
      SUBROUTINE SETCHR(PNTR,CLASS)
C
      IMPLICIT INTEGER (A-Z)
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99)
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(502),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C*
C ARGUMENTS    PNTR      STACK INDEX OF ENTRY
C              CLASS     TWO ELEMENT ARRAY WHERE CLASS(2)
C                        CONTAINS NAME TABLE (NAMTBL) INDEX OF
C                        DESIRED META-CHARACTER.
C     CHANGE A CHARACTER
C**
      DIMENSION CLASS(2)
      STACK(1,PNTR)=CLASS(2)
      I = CLASS(1)/MODULO
      STACK(2,PNTR) = META(I)
      RETURN
       END
**** SOURCE FILE : M0006686.V03   ***
*
C
C              FORTRAN SUBROUTINE SETMOD
C
C LINKAGE      SUBROUTINE SETMOD(PNTR,CLASS)
C
C          SUBSIDIARIES                  CALLED BY
C          NONE                          TYPE          ENTRY
C                                        SUBROUTINE    LARGES
C                                        SUBROUTINE    PRO020
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    REPLAC
C
      SUBROUTINE SETMOD(PNTR,CLASS)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99)
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),GEOM(2),FCN(2),PROCED(2),PERMID(2),BIGGEO(2)
C GEOM:        (1)=CODE CLASS 16000,(2)=NAMTBL INDEX OF 'GEOM  '
      EQUIVALENCE (GEOM(1),CODE(31))
C FCN:         (1)=CODE CLASS 18000,(2)=NAMTBL INDEX OF 'FCN   '
      EQUIVALENCE (FCN(1),CODE(35))
C PROCED:      (1)=CODE CLASS 19000,(2)=NAMTBL INDEX OF 'PROCED'
      EQUIVALENCE (PROCED(1),CODE(37))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C BIGGEO:      (1)=CODE CLASS 44000,(2)=NAMTBL INDEX OF 'BIGGEO'
      EQUIVALENCE (BIGGEO(1),CODE(87))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(502),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C*
C ARGUMENTS    PNTR      WORKING STACK (STACK) POINTER OF
C                        ITEM WHOSE CLASS IS TO BE CHANGED.
C              CLASS     NEW META-LINQUISTIC CLASS ASSIGNMENT.
C
C NOTES        IF CLASS IS PERMID, PROCED, OR GEOM, IT IS
C              ASSUMED THAT PREVIOUS CLASS WAS IDENT, CONPRO,
C              OR CONGEO, RESPECTIVELY, IN WHICH CASE THE
C              ORIGINAL MODE IS RETAINED.
C
C     CHANGE THE CLASS OF A CHARACTER
C**
      DIMENSION CLASS(2)
      I=STACK(1,PNTR)
      J = CLASS(1)
       IF ((J .EQ. PERMID(1)) .OR. (J .EQ. GEOM(1)) .OR.
     /(J .EQ. BIGGEO(1)) .OR. (J .EQ. PROCED(1)))  GO TO 1
      IF(J.EQ.FCN(1))GO TO 1
      NAMTBL(I) = J
      GO TO 2
    1 NAMTBL(I) = J+(NAMTBL(I)-MODULO*(NAMTBL(I)/MODULO))
    2 J = J/MODULO
      STACK(2,PNTR)=META(J)
      RETURN
       END
**** SOURCE FILE : M0006687.W03   ***
*
C
C              FORTRAN SUBROUTINE SSDEF
C
C LINKAGE      SUBROUTINE SSDEF(ACTNO,BIGCNT)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    RECOG
C          SUBROUTINE    CALLZZ
C          LOGICAL FCT.  IFTMP
C          INTEGER FCT.  NUMB
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    CONCAT
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  GETTMP
C          SUBROUTINE    TWOARG
C          SUBROUTINE    BINBCD
C
      SUBROUTINE SSDEF(ACTNO,BIGCNT)
C
      IMPLICIT INTEGER (A-Z)
C
C              FUNCTION DECLARATION
C
      LOGICAL IFTMP
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),NUMBER(2),TEMP(2),PERMID(2),VBL(2),IDENT(2),
     *          COMMA(2)
C COMMA:       (1)=CODE CLASS  1000,(2)=NAMTBL INDEX OF 'COMMA '
      EQUIVALENCE (COMMA(1),CODE(1))
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(502),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        8.    NAME TABLE POINTERS TO BCD LITERALS
C
      COMMON/BCDPTR/BCDPTR
      DIMENSION BCDPTR(7)
C DOTTAB:      NAMTBL POINTER TO ALPHAMERIC LITERAL '$$TAB'
      EQUIVALENCE (DOTTAB,BCDPTR(7))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12)
C ZEROPT:      NAMTBL POINTER TO '0.    '
      EQUIVALENCE (ZEROPT,NUMPTR( 2))
C ONE:PT:      NAMTBL POINTER TO '1     '
      EQUIVALENCE (ONE,NUMPTR( 3))
C TWO:         NAMTBL POINTER TO '2     '
      EQUIVALENCE (TWO,NUMPTR( 5))
C FOUR:        NAMTBL POINTER TO '4     '
      EQUIVALENCE (FOUR,NUMPTR(7))
C
C       10.    TABLE STORAGE FOR GEOMETRIC FUNCTION PROCESSOR
C
      INCLUDE (GMTY)    
C GEOLOC:      GEOMETRIC PRODUCTION STARTING INDEX IN GEOMTB
C PMIDTB:      INTERNAL BIT REPRESENTATIONS FOR EACH ELEMENT OF GEOMTB
C GEOMTB:      GEOMETRIC FORMAT PRODUCTIONS ARRANGED BY SURFACE TYPE
C
C       12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE
      DIMENSION CFSIZE(1106),MAXSIZ(2),KSC(3,300)
C MAXSIZ:      SIZE OF THE LAST LARGEST LARGE DATA ARRAY
      EQUIVALENCE (MAXSIZ(1),CFSIZE(4))
C ISC:         POINTER TO LAST KSC ENTRY
      EQUIVALENCE (ISC,CFSIZE(206))
C KSC:         CONTAINS SYMBOL,SIZE AND NUMBER OF SEQMENTS OF SS-DEFIN.
      EQUIVALENCE (KSC(1,1),CFSIZE(207))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C REPL:        CONTAINS COMMAND CODE (17) FOR REPL COMMAND
      EQUIVALENCE (REPL,IL(17))
C MOVE:        CONTAINS COMMAND CODE (19) FOR MOVE COMMAND
      EQUIVALENCE (MOVE,IL(19))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C MATRIX:      MODE CODE (18) FOR MATRIX
      EQUIVALENCE (MATRIX,MODX(18))
C POINT:       MODE CODE (19) FOR POINT
      EQUIVALENCE (POINT,MODX(19))
C VECTOR:      MODE CODE (20) FOR VECTOR
      EQUIVALENCE (VECTOR,MODX(20))
C REAL:        MODE CODE (21) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C SSURF:       MODE CODE (29) FOR SCULPTURED SURFACE
      EQUIVALENCE (SSURF,MODX(29))
C SCURV:       MODE CODE (30) FOR SCULPTURED CURVE
      EQUIVALENCE (SCURV,MODX(30))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      DIMENSION MACXX1(71)
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C NOUGHT:      CONTAINS OPERAND TYPE 0
      EQUIVALENCE (NOUGHT,OPMOD(1))
C DLR:         CONTAINS OPERAND TYPE CODE 1
      EQUIVALENCE (DLR,OPMOD(2))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(135),APTXXX(120)
C APTXXX:      NAMTBL POINTERS FOR XECUTION SUBROUTINE NAMES
      EQUIVALENCE (APTXXX(1),SUBLST(1))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ESTACK,ERRPOS
      DIMENSION ERRPOS(302),ESTACK(100)
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C*
C       TYPE   MODE  SIZE
C       ****************************************************************
C SCURV/CURSEG 140  NPS=2  SEGMS=0                    *
C       SPLINE  30  NOWRDS=24*(NPS+1)                 * =72
C                   NPS=2  SEGMS.GT.0                 *
C       SEG    150  NOWRDS=54*(NPS+1)-18+6*SEGMS      * =144+6*SEGMS
C                           I=N
C       COMBIN 141   NOWRDS=SUMME(NOWRDS(SS )-24) + 24
C                           I=1            I
C       ****************************************************************
C SSURF/SMESH,XYZ,...132   KN=59   NOWRDS=10+KN*(SPL-1)*(NPS-1)
C       GMESH,XYZ,...125   KN=59
C       SMESH,XYPLAN,132   KN=35
C       COMBIN,......141                  I=N
C       RULED,.......143           NOWRDS=SUMME(NOWRDS(SS )-10) + 10
C       TRANSL,......133                  I=1            I
C       SCALE,....... 36
C       XYROT,....... 34
C       REVOLV,......142           NOWRDS=74+222*NOWRDS/24
C       GENCUR,......148           NOWRDS=NOWRDS+10
C       PATCH,PNTSON,131
C       PATCH,PNTVEC,131           NOWRDS=8+65*NPATCH
C       PATCH,POLYGN,131
C       ****************************************************************
      LOGICAL FOULUP,CRSFLG,MINDEF,WTFLAG,NOMTRX
      DIMENSION ITMP(2,3)
      CHARACTER IBUFF*15,IBLANK
      DIMENSION STK(2,30),SAVE(2,27),SPLARY(16)
      DIMENSION TCURV(4),TSURF(11)
C
      EQUIVALENCE(STK(1, 1),    TP),(STK(1, 2),NOMTRX)
      EQUIVALENCE(STK(1, 3),FOULUP),(STK(1, 4),MINDEF)
      EQUIVALENCE(STK(1, 5),CRSFLG),(STK(1, 6),WTFLAG)
      EQUIVALENCE(STK(1, 7), INDEX),(STK(1, 8),  MOUT)
      EQUIVALENCE(STK(1, 9),NOWRDS),(STK(1,10), MMODE)
      EQUIVALENCE(STK(1,11),   SPM),(STK(1,12),   PTM)
      EQUIVALENCE(STK(1,13),   PNT),(STK(1,14),   SPL)
      EQUIVALENCE(STK(1,15),   PMS),(STK(1,16), COUNT)
      EQUIVALENCE(STK(1,17),   CNT),(STK(1,18),   JMP)
      EQUIVALENCE(STK(1,19),   NPS),(STK(1,20),    KN)
      EQUIVALENCE(STK(1,21),  MTOP),(STK(1,22),ITMP(1,1))
C
C...  LOCAL VARIABLES WHICH MUST BE SAVED UNTIL THIS SSURF DEF IS
C      COMPLETELY TRANSLATED.
C
      DATA IBLANK/' '/,JSAVE/0/
C                CURSEG SPLINE COMBIN SEG
      DATA TCURV/   190,    80,   191,   200/
C                PATCH  SMESH  COMBIN GENCUR REVOLV RULED
      DATA TSURF/   181,   182,   191,   198,   192,   193,
C                TRANSL SCALE  XYROT  YZROT  ZXROT
     *               83,    86,    84,    87,    98/
C**
      IRET=1
      IND=1
      IF(BIGCNT.NE.1)GOTO 10
C
      TP=2
    1 MTOP=TOP
      ISS=MOD(NAMTBL(STACK(1,TOP-5)),MODHLF)
      FOULUP=.FALSE.
      MINDEF=.FALSE.
      CRSFLG=.FALSE.
      WTFLAG=.FALSE.
      NOMTRX =.FALSE.
      INDEX=-9
      NOWRDS=0
      NPS=0
      SPM=31
      PTM=31
      PMS=31
      PNT=1
      SEGMS=0
      SPL=0
      COUNT=0
      CNT=0
      SPLARY(1)=0
      DO 5 I=1,3
      ITMP(1,I)=1
    5 ITMP(2,I)=REAL
      STK(2,1)=-1
      KN=35
      JMP=5
      MOUT=1
      FLOWS=-1
      NPATCH=0
      L=STACK(1,TOP-3)
      M=STACK(1,TOP-1)
      ERRPT=TOP-3
      GOTO 200
C
C         STORE INTERNAL BIT REPRESENTATION IN STK
C
   10 IF(ACTNO.GT.102)GOTO 500
      IF(FOULUP)GOTO 140
      IF(TOP.GT.MTOP)GOTO 900
   20 L=STACK(1,TOP-1)
      ERRPT=TOP-1
      IF(L.GT.NAMMAX)GOTO 50
      CLASS=MODULO*(NAMTBL(L)/MODULO)
      MODE=NAMTBL(L)-CLASS
      IF(MODE.GT.MODHLF)MODE=MODE-MODHLF
      IF(CLASS.NE.IDENT(1))GOTO 40
      CLASS=PERMID(1)
      NAMTBL(L)=NAMTBL(L)-IDENT(1)+PERMID(1)
   40 IF(CLASS.EQ.PERMID(1))MODE=MODE+50
      IF(CLASS.EQ.VBL(1).OR.CLASS.EQ.PERMID(1).OR.CLASS.EQ.TEMP(1))
     *                                                      GOTO 60
      IF(CLASS.NE.NUMBER(1))GOTO 80
   50 MODE=REAL
      CLASS=NUMBER(1)
   60 IF(WTFLAG)GOTO 1000
      TP=TP+1
      ERROR=1227
      IF(TP.GT.30)GOTO 100
      STK(2,TP)=PMIDTB(MODE)
      GEOPOS=GEOLOC(ISS)
      TPT2=TP*2
      PROD=SEARCH(STK,TPT2,GEOMTB(GEOPOS),ERRPT)
C
      GOTO(1100,1200,1300,1400,1500,1600,1700,1800,1900,2000,
     1     2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
     2     3100,3200,3300,3400,3500,3600,3700),PROD
C
C                ERROR OUTPUT
C
   80 ERRPT=TOP-1
   90 ERROR=1007
      IF(CLASS.EQ.PERMID(1))GOTO 100
      J=MOD(MODE-9,10)
      IF(MODE.LT.19.OR.J.GT.2)GOTO 100
      ERROR=1203+MODE
  100 FOULUP=.TRUE.
      MINDEF=.TRUE.
  110 TP=TP-1
      CALL ALARM(ERROR,ERRPT,8,'SSDEF   ')
  140 STACK(1,TOP-2)=STACK(1,TOP)
      STACK(2,TOP-2)=STACK(2,TOP)
      ESTACK( TOP-2)=ESTACK( TOP)
      TOP=TOP-2
  150 RETURN
C
C                I.L.  OUTPUT
C
C           SPECIAL CONTROL AND OUTPUT OF THE SUBTYPE
C
  200 ASSIGN 1110 TO TSEG
      MODE=MOD(NAMTBL(L),MODHLF)
      CLASS=NAMTBL(L)-MODE
      IF(CLASS.NE.IDENT(1))GOTO 201
      CLASS=PERMID(1)
      NAMTBL(L)=NAMTBL(L)-IDENT(1)+PERMID(1)
  201 IF(CLASS.NE.PERMID(1))GOTO 202
      ITMP(1,1)=L
      MODE=MODE+50
  202 MMODE=MODE
      STK(2,TP)=PMIDTB(MMODE)
      HMODE=MOD(NAMTBL(M),MODHLF)
      TYP=NAMTBL(M)-HMODE
      IF(TYP.NE.PERMID(1).AND.TYP.NE.IDENT(1))GOTO 204
      HMODE=HMODE+50
      IF(HMODE.NE.188.AND.HMODE.NE.189)ITMP(1,3)=M
  204 IF(ISS.EQ.29)GOTO 215
C
      DO 210 TYP=1,4
      IF(TCURV(TYP).EQ.MMODE)GOTO 225
  210 CONTINUE
      GOTO 90
C
  215 DO 216 TYP=1,11
      IF(TSURF(TYP).EQ.MMODE)GOTO 217
  216 CONTINUE
      GOTO 90
  217 TYP=TYP+4
C
  225 IRET=2
      TOP=TOP-2
      GOTO(230,232,234,236,
     *     244,270,246,270,320,248,320,320,320,320,320),TYP
C            CURSEG
  230 NPS=1
      PTM=6
C            SPLINE
  232 SPL=1
      NPS=NPS+1
      JMP=6
      GOTO 320
C            COMBIN
  234 NPS=1
      JMP=7
      GOTO 270
C            SEG
  236 SPL=1
      NPS=2
      PNT=2
      JMP=6
      ASSIGN 1910 TO TSEG
      GOTO 270
C            PATCH
  244 MOUT=2
      JMP=2
      GOTO 270
C            SSURF/COMBIN
  246 JMP=3
      GOTO 270
C            SSURF/RULED
  248 SPL=1
      GOTO 320
C
  270 IRET=1
      TOP=TOP+2
      GOTO 20
C
  280 JJ=ISS-28
      IF(CLASS.EQ.TEMP(1))GOTO 290
      DO 285 JJ=4,ISC
      IF(L.EQ.KSC(1,JJ))GOTO 290
  285 CONTINUE
      ERRPT=TOP-1
      ERROR=1235
      GOTO 100
  290 K=24
      IF(MODE.NE.SCURV)K=10
      NOWRDS=NOWRDS+KSC(2,JJ)-K
      IF(JMP.EQ.5)NOWRDS=NOWRDS+KSC(2,JJ)+24*KSC(3,JJ)
      GOTO 330
C
C                MOVE COUPLER TO LINE
C
  300 GOTO(310,330),MOUT
  310 IF(CLASS.EQ.PERMID(1))MODE=MODE-50
      IBUFF(8:15)=IBLANK
      CALL BINBCD(MODE,IBUFF(4:),NCH)
      WRITE (IBUFF(1:3),'(I3)') NCH
      CALL CONCAT(IBUFF,'.')
      JN=NUMB(IBUFF(4:15))+NAMMAX
      CALL OPCODE(MOVE)
      CALL TWOARG(INDEX,DOTTAB)
      CALL TWOARG(DLR,JN)
      CALL RLSLIN
      INDEX=INDEX-1
      IF(IND.GT.1)GOTO 330
C
  320 CALL OPCODE(MOVE)
      GOTO 340
  330 CALL OPCODE(REPL)
      CALL ONEARG(IND)
  340 CALL TWOARG(INDEX,DOTTAB)
      CALL ARGCVT(STACK(1,TOP-1))
      CALL RLSLIN
      INDEX=INDEX-IND
      GOTO(140,270),IRET
C
C                PROCESS END OF DEFINITION
C
  500 IF(MINDEF.AND.FLOWS.NE.0)GOTO 510
      CALL ALARM(1204,TOP,8,'SSDEF   ')
      FOULUP=.TRUE.
      GOTO 520
  510 IF(MMODE.EQ.182.AND.PNT.NE.NPS)CALL ALARM(1225,0,8,'SSDEF   ')
  520 ISS=MOD(NAMTBL(STACK(1,TOP-3)),MODHLF)
      IF(ACTNO.NE.105)GOTO 530
      RESULT=GETTMP(ISS)
      GOTO 560
  530 RESULT=STACK(1,TOP-5)
      CLASS=MODULO*(NAMTBL(RESULT)/MODULO)
      MODE=MOD(NAMTBL(RESULT),MODHLF)
      IF(CLASS.EQ.VBL(1).OR.CLASS.EQ.TEMP(1))GOTO 540
      NAMTBL(RESULT)=VBL(1)+ISS
      CALL RESRVZ(RESULT,ISS,TXXXX(1,ISS),1)
      MODE=MOD(NAMTBL(RESULT),MODHLF)
  540 IF(MODE.NE.ISS)GOTO 800
      IF(CLASS.EQ.VBL(1).AND.INTMED.EQ.0)
     *                      CALL ALARM(52,TOP-5,4,'SSDEF   ')
  560 IF(FOULUP)GOTO 810
      IF(.NOT.WTFLAG)GOTO 570
      CALL ALARM(1200+WTMODE,TOP,8,'SSDEF   ')
  570 DO 590 I=3,5
      J=-I
      IF(I-4)573,574,575
  573 NMU=SPL
      GOTO 580
  574 NMU=NPS
      GOTO 580
  575 NMU=-INDEX
  580 IBUFF(8:15)=IBLANK
      CALL BINBCD(NMU,IBUFF(4:),NCH)
      WRITE (IBUFF(1:3),'(I3)') NCH
      CALL CONCAT(IBUFF,'.')
      JN=NUMB(IBUFF(4:))+NAMMAX
      CALL OPCODE(MOVE)
      CALL TWOARG(J,DOTTAB)
      CALL TWOARG(DLR,JN)
  590 CALL RLSLIN
      IF(ISS.EQ.30)GOTO 585
      CALL CALLZZ(APTXXX(88))
      GOTO 595
  585 I=90
      IF(MMODE.EQ.200)I=86
      CALL CALLZZ(APTXXX(I))
  595 CALL ARGCVT(RESULT)
      DO 600 I=1,3
  600 CALL ARGCVT(ITMP(1,I))
      CALL RLSLIN
C
C                STORAGE OF THE SIZE
C
      GOTO(610,620,630,640,650,660,670),JMP
C**** SSURF/                   SMESH
  610 IF(SPL.EQ.2.OR.NPS.EQ.2)KN=47
      NOWRDS=10+KN*(SPL-1)*(NPS-1)
      GOTO 700
C**** SSURF/                   PATCH
  620 NOWRDS=8+65*NPATCH
      GOTO 700
C**** SSURF/                   COMBIN
  630 NOWRDS=NOWRDS+10
      GOTO 700
C**** SSURF/                   REVOLV
  640 NOWRDS=10+222*NOWRDS/24
      GOTO 700
C**** SSURF/                   GENCUR,RULED
C****                          TRANSL,SCALE,XYROT,YZROT,ZXROT
  650 NOWRDS=10+NOWRDS
      GOTO 700
  660 IF(NOWRDS.GT.0)GOTO 670
C**** SCURV/                   CURSEG,SPLINE,SEG
      NOWRDS=72
      IF(SEGMS.GT.0)NOWRDS=144+6*SEGMS
      GOTO 700
C**** SCURV/                   COMBIN
  670 NOWRDS=NOWRDS+24
C
  700 IF(CLASS.NE.TEMP(1))GOTO 720
      J=ISS-28
      IF(NOWRDS.GT.KSC(2,J))KSC(2,J)=NOWRDS
      IF(SEGMS.GT.KSC(3,J))KSC(3,J)=SEGMS
      GOTO 760
  720 ISC=ISC+1
      IF(ISC.LE.300)GOTO 740
      CALL ALARM(34,TOP-5,8,'SSDEF   ')
      GOTO 810
  740 KSC(1,ISC)=RESULT
      KSC(2,ISC)=NOWRDS
      KSC(3,ISC)=SEGMS
  760 IF(NOWRDS.LE.MAXSIZ(2)) GOTO 820
      IF(NOWRDS.GE.MAXSIZ(1)) GOTO 780
      MAXSIZ(2)=NOWRDS
      GOTO 820
  780 MAXSIZ(2)=MAXSIZ(1)
      MAXSIZ(1)=NOWRDS
      GOTO 820
C
C                ERROR PROCESSING GENERATE CALL TO APT094
C
  800 CALL ALARM(1001,TOP-5,8,'SSDEF   ')
  810 CALL CALLZZ(APTXXX(68))
      CALL TWOARG(DLR,FOUR)
      CALL ARGCVT(RESULT)
      CALL TWOARG(NOUGHT,DOTTAB)
      CALL RLSLIN
C
C                IF NESTED DEFINITION LOAD SAVED DATA
C
  820 IF(ACTNO-104)150,830,840
  830 TOP=TOP-6
      GOTO 860
  840 TOP=TOP-4
  860 STACK(1,TOP)=RESULT
      CLASS=NAMTBL(RESULT)/MODULO
      STACK(2,TOP)=META(CLASS)
      IF(JSAVE.EQ.0)GOTO 890
      IF(TOP.GT.SAVE(JSAVE,21))GOTO 890
      DO 880 I=1,27
  880 STK(1,I)=SAVE(JSAVE,I)
      JSAVE=JSAVE-1
      GOTO 150
  890 BIGCNT=0
      GOTO 150
C
C                NESTED DEFINITION, SAVE DATA
C
  900 IF(JSAVE.LT.2)GOTO 910
      CALL ALARM(1228,TOP-5,8,'SSDEF   ')
      FOULUP=.TRUE.
      MINDEF=.TRUE.
      GOTO 140
  910 JSAVE=JSAVE+1
      DO 920 I=1,27
  920 SAVE(JSAVE,I)=STK(1,I)
      TP=TP+1
      GOTO 1
C
C       ****  POINT,VECTOR,SCALAR OR SURFACES EXPECTED ****
C
 1000 COUNT=COUNT+1
      IF(COUNT.EQ.MAXCNT)WTFLAG=.FALSE.
      IF(MAXCNT-10)1030,1005,1020
 1005 IF(MMODE.NE.193)GOTO 1010
      IF(MODE.EQ.POINT)GOTO 1025
      WTMODE=VECTOR
      WTFLAG=.FALSE.
      GOTO 1025
 1010 IF(COUNT.EQ.9)GOTO 1030
      IF(MODE.EQ.WTMODE)GOTO 1025
      WTMODE=VECTOR
      IF(MMODE.NE.192)WTMODE=SSURF
      GOTO 1025
 1020 WTMODE=SPLARY(COUNT)
 1025 IF(.NOT.WTFLAG)MAXCNT=1
 1030 ERROR=1200+WTMODE
      IF(MODE.NE.WTMODE)CALL ALARM(ERROR,TOP-1,8,'SSDEF   ')
      IF(MODE.NE.MATRIX)GOTO 1040
      IF(NOMTRX)CALL ALARM(1216,TOP-1,4,'SSDEF   ')
      IND=12
      IF(STACK(1,TOP).NE.COMMA(2))GOTO 330
      FOULUP=.TRUE.
      CALL ALARM(1217,TOP,8,'SSDEF   ')
      GOTO 330
 1040 GOTO TSEG,(1100,1910)
C
C       ****  SCURV/CURSEG-SPLINE  ****
C
 1080 COUNT=0
      WTFLAG=.TRUE.
 1090 TP=TP-1
      GOTO 1110
C
 1100 CNT=0
      SPLARY(1)=0
 1110 IND=1
      IF(CLASS.NE.PERMID(1))IND=TXXXX(1,MODE)
      IF(IND.EQ.2)GOTO 280
      GOTO 300
C
 1200 IF(.NOT.CRSFLG.OR.PNT.LT.2)GOTO 1210
      ESTACK(TOP-1)=ERRPOS(102)
      CALL ALARM(1211,TOP-1,4,'SSDEF   ')
 1210 CRSFLG=.FALSE.
      GOTO 1310
C
 1300 NPS=NPS+1
 1310 MINDEF=.TRUE.
 1320 PNT=PNT+1
      IF(PNT.EQ.PTM)CALL ALARM(1201,TOP-1,4,'SSDEF   ')
      CNT=0
      SPLARY(1)=0
      GOTO 1090
C
 1400 WTMODE=VECTOR
      ERROR=1210
      IF(MODE.NE.187)GOTO 1510
      ERRPOS(102)=ESTACK(TOP-1)
      CRSFLG=.TRUE.
      GOTO 1510
C
 1500 WTMODE=REAL
      ERROR=1209
 1510 DO 1520 I=1,CNT
      IF(SPLARY(I).NE.MODE)GOTO 1520
      CALL ALARM(ERROR,TOP-1,4,'SSDEF   ')
      GOTO 1530
 1520 CONTINUE
      CNT=CNT+1
      SPLARY(CNT)=MODE
 1530 MAXCNT=1
      GOTO 1080
C
C                   **** SCURV-SSURF/COMBIN  ****
C
 1600 MINDEF=.TRUE.
      GOTO 1110
C
 1700 IF(ISS.EQ.SSURF)GOTO 1090
      NPS=NPS+1
      PNT=NPS+1
      IF(NPS.EQ.PTM)CALL ALARM(1213,TOP-1,4,'SSDEF   ')
      GOTO 1090
C
C                   ****  SCURV/SEG  ****
C
 1800 CNT=CNT+1
      ERROR=1212
      ERRPT=TOP-1
      GOTO(1810,1820,1830,110),CNT
 1810 CALL CALLZZ(APTXXX(86))
      CALL ARGCVT(STACK(1,TOP-7))
      CALL ARGCVT(STACK(1,TOP-1))
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ONE)
      CALL RLSLIN
 1820 II=STACK(1,TOP-1)
      GOTO 140
 1830 MINDEF=.TRUE.
      IF(COUNT.GT.0)GOTO 1820
      COUNT=COUNT+1
 1840 COUNT=COUNT+1
 1850 CALL CALLZZ(APTXXX(86))
      CALL ARGCVT(STACK(1,TOP-7))
      CALL ARGCVT(II)
      CALL ARGCVT(STACK(1,TOP-1))
      CALL ARGCVT(TWO)
      CALL RLSLIN
      II=-II
      GOTO 140
C
 1900 TP=TP-2
      IF(COUNT.GE.2)GOTO 1820
      GOTO 1840
 1910 IF(II.LT.0)GOTO 1820
      GOTO 1850
C
C                   ****  FLOW AND SEG SECTION ****
C
 2000 FLOWS=0
 2010 IF(MINDEF)GOTO 2020
      FOULUP=.TRUE.
      CALL ALARM(1204,TOP-1,8,'SSDEF   ')
 2020 GOTO TSEG,(1080,1100,1910)
C
 2100 FLWARG=2
      IF(MODE.EQ.117)FLWARG=3
      GOTO 2210
C
 2200 FLWARG=5
      IF(MODE.EQ.204)FLWARG=6
      IF(JMP.EQ.5)CALL ALARM(1206,TOP-1,8,'SSDEF   ')
      JMP=FLWARG
 2210 FLOWS=FLOWS+1
      IF(FLOWS.EQ.PNT)CALL ALARM(1205,TOP-1,4,'SSDEF   ')
 2220 COUNT=0
      MAXCNT=2
 2240 WTMODE=REAL
 2250 WTFLAG=.TRUE.
      GOTO 2640
C
 2300 IF(COUNT.NE.2.OR.FLWARG.LT.3)CALL ALARM(1206,TOP-1,8,'SSDEF   ')
      COUNT=2
      MAXCNT=3
      WTMODE=REAL
      GOTO 2410
C
 2400 IF(COUNT.GT.3.OR.FLWARG.LT.5)CALL ALARM(1206,TOP-1,8,'SSDEF   ')
      IF((FLWARG+MODE).EQ.223)CALL ALARM(1206,TOP-1,8,'SSDEF   ')
      JMP=0
      WTMODE=POINT
      COUNT=3
      MAXCNT=COUNT+MODE/110
 2410 WTFLAG=.TRUE.
      TP=TP-1
      GOTO 140
C
 2500 IF(FLWARG.LT.5.OR.FLWARG.LE.COUNT)CALL ALARM(1206,TOP-1,8,
     *                                  'SSDEF   ')
      WTMODE=VECTOR
      MAXCNT=FLWARG
      COUNT=MAXCNT-1
      GOTO 2410
C
 2600 IF(MODE-VECTOR)2610,2620,2630
 2610 COUNT=COUNT+1
      IF(COUNT.LT.4)COUNT=4
      JMP=0
      IF(COUNT.GT.(FLWARG-1))CALL ALARM(1207,TOP-1,4,'SSDEF   ')
      GOTO 2640
 2620 IF(FLWARG.LT.5)CALL ALARM(1207,TOP-1,4,'SSDEF   ')
      IF(FLWARG.EQ.6.AND.COUNT.EQ.4)CALL ALARM(1207,TOP-1,4,'SSDEF   ')
      COUNT=COUNT+1
      IF(COUNT.LT.FLWARG)COUNT=FLWARG
      IF(COUNT.GT.FLWARG)CALL ALARM(1207,TOP-1,4,'SSDEF   ')
      GOTO 2640
 2630 IF(COUNT.GT.2.OR.FLWARG.LT.3)CALL ALARM(1207,TOP-1,4,'SSDEF   ')
      COUNT=3
 2640 TP=TP-1
      GOTO TSEG,(1100,1910)
C
 2700 SEGMS=0
      MINDEF=.FALSE.
      IF(MODE.EQ.MMODE)GOTO 140
      GOTO 1110
C
 2800 SEGMS=SEGMS+1
      MINDEF=.TRUE.
      IF(SEGMS.EQ.PNT)CALL ALARM(1208,TOP-1,4,'SSDEF   ')
      GOTO 2220
C
C                   ****  TRFORM,MATRIX  ****
C
 2900 WTMODE=MATRIX
      ITMP(1,2)=L
      MAXCNT=1
      MOUT=1
      ASSIGN 1080 TO TSEG
      GOTO 2010
C
C                   ****  SSURF/SMESH  ****
C
 3000 IF(MMODE.EQ.181)GOTO 140
      IF(MODE.EQ.193)SPM=3
      IF(HMODE.GT.83.AND.HMODE.LT.99)NOMTRX=.TRUE.
      JMP=1
      GOTO 140
C
 3100 MINDEF=.FALSE.
      SPL=SPL+1
      CNT=0
      SPLARY(1)=0
      IF(SPL-2)320,3110,3120
 3110 NPS=PNT
      IF(NPS.LT.2)CALL ALARM(1225,TOP-1,8,'SSDEF   ')
      GOTO 3130
 3120 IF(SPL.EQ.SPM)CALL ALARM(1203,TOP-1,4,'SSDEF   ')
      IF(PNT.NE.NPS)CALL ALARM(1225,TOP-1,8,'SSDEF   ')
 3130 PNT=1
      TP=TP-2
      GOTO 320
C
 3200 IF((PNT+1).EQ.NPS)GOTO 1310
      GOTO 1320
C
C                   ****  SSURF/PATCH  ****
C
 3300 NPATCH=NPATCH+1
      MINDEF=.TRUE.
      DO 3310 I=1,16
 3310 SPLARY(I)=POINT
      IF(HMODE-184)3320,3360,3350
 3320 SPLARY(3)=VECTOR
      SPLARY(4)=VECTOR
      DO 3340 I=7,16
 3340 SPLARY(I)=VECTOR
      GOTO 3360
 3350 IF(NPATCH.EQ.2)CALL ALARM(1215,TOP-1,4,'SSDEF   ')
 3360 MAXCNT=16
      COUNT=0
      WTFLAG=.TRUE.
      TP=TP-1
      SPL=NPATCH
      GOTO 320
C
C                   ****  SSURF/REVOLV-RULED  ****
C
 3400 IF(MMODE.EQ.192)GOTO 3430
      SPL=0
      MINDEF=.TRUE.
      GOTO 3440
 3430 JMP=4
      STK(2,TP-1)=STK(2,TP)
 3440 TP=TP-1
      WTMODE=POINT
      COUNT=8
      MAXCNT=10
      WTFLAG=.TRUE.
      GOTO 1110
C
 3500 WTMODE=REAL
      MAXCNT=2
      MINDEF=.TRUE.
      CNT=0
      GOTO 1080
C
C                   ****  SSURF/GENCUR  ****
C
 3600 IF(CLASS.EQ.PERMID(1))GOTO 3610
      PNT=PNT+1
      IF(PNT.EQ.PTM.AND.MMODE.EQ.205)CALL ALARM(1201,TOP-1,4,'SSDEF   ')
      TP=TP-1
      GOTO 1600
 3610 MINDEF=.FALSE.
      IF(CNT.EQ.TP)CALL ALARM(1212,TOP-1,4,'SSDEF   ')
      CNT=TP
      GOTO 1090
C
C               ****  SSURF/TRANSL,SCALE,XYTRANS,YZTRANS,ZXTRANS ***
C
 3700 WTMODE=SCURV
      MINDEF=.TRUE.
      MAXCNT=1
      GOTO 1080
C
      END
**** SOURCE FILE : M0006688.V09   ***
*
C
C              FORTRAN SUBROUTINE START
C
C LINKAGE      SUBROUTINE  START
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           MAIN
C          SUBROUTINE    FOUTXX
C          SUBROUTINE    RECOG
C          SUBROUTINE    TAPOP
C
      SUBROUTINE  START
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NUMBST:      NAMTBL INDEX OF BEGINNING OF NUMBER SECTION
C NUMBND:      NAMTBL INDEX OF END OF NUMBER SECTION
C
C       33.    SYMBOLIC FILE DEFINITIONS
C
      INCLUDE (SYMFIL)    
C VLFILE:      VERIFICATION LISTING FILE
C
C       35.    COMMON BLOCK FOR BOUNDED GEOMETRY AND CFSAVE
C
      COMMON/BGEOM/BGEOM
      DIMENSION BGEOM(4)
C IFBNDS:      VALUE 1 IF BOUNDED GEOMETRY IS INCLUDED IN PART PROGRAM
      EQUIVALENCE (IFBNDS,BGEOM(1))
C IFDUMP:      VALUE 0=NO CFSAVE COMMAND,1=ALL,2=SCALAR,3=GEOM PROGRAM
      EQUIVALENCE (IFDUMP,BGEOM(2))
C
C       40.    PARAMETERS REQUIRED BY SUPERVISOR
C
      INCLUDE (SUPER)    
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NMOD:        NUMBER OF ENTRIES PERMITTED IN INTERNAL NUMBER TABLE
      EQUIVALENCE (NMOD,NTBL(1))
C NNDX:        CONVERSION BETWEEN ABS. AND VIRTUAL NUMBER TABLE POINTER
      EQUIVALENCE (NNDX,NTBL(3))
C*
      CHARACTER*12 B
      DATA B/'0       ISN' /
C**
C
      DO 10 I=NUMBST,NUMBND
   10 CNUMTB(I)=' '
      NMOD=NUMBND-NUMBST+1
      NNDX=0
      IFDUMP=0
      IFBNDS=0
C...     PUT APPROPRIATE HEADINGS ON VLFILE AND DIAGNOSTIC FILE
      CALL FOUTXX(VLFILE,B,12)
C
      CALL TAPOP(ELFIL1,-1)
      CALL TAPOP(ELFIL2,-1)
      CALL RECOG
C
C....    INDICATE NORMAL ENDING
      ABEND=.FALSE.
C
      RETURN
       END
**** SOURCE FILE : M0006689.V03   ***
*
C
C              FORTRAN SUBROUTINE SUBCOD
C
C LINKAGE      SUBROUTINE SUBCOD (TPX)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          LOGICAL FCT.  IFTMP           SUBROUTINE    RECOG
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  GETTMP
C          SUBROUTINE    ALARM
C          INTEGER FCT.  MODE
C          SUBROUTINE    ARGCVT
C
      SUBROUTINE SUBCOD (TPX)
C
      IMPLICIT INTEGER (A-Z)
C
C              FUNCTION DECLARATION
C
      LOGICAL IFTMP
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),TEMP(2),VBL(2)
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C       15.    ARRAY LIMIT STORAGE
C
      COMMON/SBSCPT/SBSCPT
      DIMENSION SBSCPT(101),RANGE(100)
C RNGPT:       POINTER TO NEXT RANGE ENTRY
      EQUIVALENCE (RNGPT,SBSCPT(1))
C RANGE:       STORAGE FOR APT RESERVE STATEMENT INFORMATION
      EQUIVALENCE (RANGE(1),SBSCPT(2))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C CVTSUB:      CONTAINS COMMAND CODE (13) FOR CVTSUB COMMAND
      EQUIVALENCE (CVTSUB,IL(13))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C SUBSCR:      MODE CODE (24) FOR SUBSCRIPT
      EQUIVALENCE (SUBSCR,MODX(24))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL ILHLT
      DIMENSION MACXX1(71)
C ILHLT:       TRUE IF I.L. SHOULD NOT BE PLACED IN ILFILE
      EQUIVALENCE (ILHLT,MACXX1(14))
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       37.    INCLUSIVE SUBSCRIPT VARIABLES
C
      COMMON/ISSCOM/ISSCOM
      LOGICAL ISSFL
      DIMENSION ISSCOM(9),ISSTRM(2)
C ISSMOD:      MODE OF THE INCLUSIVE SUBSCRIPTED VARIABLE
      EQUIVALENCE (ISSMOD,ISSCOM(5))
C ISSFL:       TRUE DURING INCLUSIVE SUBSCRIPT PROCESSING
      EQUIVALENCE (ISSFL,ISSCOM(6))
C ISSTRM:      SAVES THE STACK TOP ITEMS DURING SUBSCRIPT PROCESSING
      EQUIVALENCE (ISSTRM(1),ISSCOM(8))
C*
C ARGUMENTS    TPX       WORKING STACK (STACK) INDEX WHICH
C                        POINTS TO THE VARIABLE NAME OF A
C**                      SUBSCRIPTED VARIABLE.
C
C     GET RESULT CELL
      RSLT=GETTMP(SUBSCR)
      NAMTBL(RSLT)=TEMP(1)+SUBSCR
C
C     FIND POSITION IN RANGE TABLE
      IF(RNGPT.EQ.1)GO TO 62
      J=RNGPT-2
      N=STACK(1,TPX)
      DO 10 I=1,J,2
      IF(RANGE(I).EQ.N)GO TO 20
   10 CONTINUE
      GO TO 60
C
C     GENERATE CODE
   20 II=STACK(1,TPX+2)
      IF(II.GT.NAMMAX)GO TO 30
      IF(IFTMP(II))CALL PUTTMP(MOD(NAMTBL(II),MODULO))
   30 I=MODE(N)
      IF(I.EQ.0)GO TO 65
      IF(ISSFL)ISSMOD=I
      CALL OPCODE(CVTSUB)
      CALL ARGCVT (RSLT)
      CALL ARGCVT(N)
      CALL ARGCVT (STACK(1,TPX+2))
      CALL ONEARG(TXXXX(1,I))
      CALL RLSLIN
C
C...       MODIFY NAMTBL ENTRY TO MODE + 50
C
      NAMTBL(RSLT) = TEMP(1)+I+MODHLF
C
C     MODIFY STACK
      STACK (1,TPX)=RSLT
   90 RETURN
C
C     ERROR
   60 IF(INTMED)61,62,63
   61 ILHLT=.FALSE.
      CALL ALARM(1013,TPX,8,'SUBCOD  ')
      ILHLT=.TRUE.
      GO TO 72
   63 M=NAMTBL(N)
      J=(M/MODULO)*MODULO
      IF(J.EQ.VBL(1).AND.(M-J).GT.MODHLF)GO TO 20
   62 IERROR=1013
      GO TO 70
   65 IERROR=1014
   70 CALL ALARM(IERROR,TPX,8,'SUBCOD  ')
   72 IF(.NOT.ISSFL) GO TO 90
      STACK(1,TOP)=ISSTRM(1)
      STACK(2,TOP)=ISSTRM(2)
      ISSFL=.FALSE.
      GO TO 90
       END
**** SOURCE FILE : M0004613.W03   ***
*
C
C     FORTRAN SUBROUTINE ERRWRD
C
      BLOCK DATA TRERRW
C
      INCLUDE (ERRTXT)    
C
      INTEGER A,B
      CHARACTER*4 E
      DIMENSION A(ERND),B(ERND),E(ERRDM)
      EQUIVALENCE (A(1),ERRAD1(1))
      EQUIVALENCE (B(1),ERRAD2(1))
      EQUIVALENCE (E(1),ERRTXT(1))
                                                                        00001400
C
C
      DATA A(  1),A(  2),A(  3),A(  4)/      1,      2,      3,      4/
      DATA A(  5),A(  6),A(  7),A(  8)/      7,      9,     10,     12/
      DATA A(  9),A( 10),A( 11),A( 12)/     13,     14,     15,     16/
      DATA A( 13),A( 14),A( 15),A( 16)/     17,     18,     19,     20/
      DATA A( 17),A( 18),A( 19),A( 20)/     21,     22,     24,     26/
      DATA A( 21),A( 22),A( 23),A( 24)/     27,     28,     29,     31/
      DATA A( 25),A( 26),A( 27),A( 28)/     32,     34,     35,     36/
      DATA A( 29),A( 30),A( 31),A( 32)/     37,     38,     40,     50/
      DATA A( 33),A( 34),A( 35),A( 36)/     52,     53,     55,     56/
      DATA A( 37),A( 38),A( 39),A( 40)/     71,     72,     73,     74/
      DATA A( 41),A( 42),A( 43),A( 44)/   1001,   1002,   1003,   1004/
      DATA A( 45),A( 46),A( 47),A( 48)/   1005,   1007,   1008,   1009/
      DATA A( 49),A( 50),A( 51),A( 52)/   1010,   1011,   1012,   1013/
      DATA A( 53),A( 54),A( 55),A( 56)/   1014,   1015,   1016,   1017/
      DATA A( 57),A( 58),A( 59),A( 60)/   1018,   1019,   1020,   1021/
      DATA A( 61),A( 62),A( 63),A( 64)/   1022,   1023,   1024,   1025/
      DATA A( 65),A( 66),A( 67),A( 68)/   1026,   1028,   1029,   1032/
      DATA A( 69),A( 70),A( 71),A( 72)/   1035,   1036,   1037,   1038/
      DATA A( 73),A( 74),A( 75),A( 76)/   1039,   1040,   1041,   1050/
      DATA A( 77),A( 78),A( 79),A( 80)/   1111,   1201,   1203,   1204/
      DATA A( 81),A( 82),A( 83),A( 84)/   1205,   1206,   1207,   1208/
      DATA A( 85),A( 86),A( 87),A( 88)/   1209,   1210,   1211,   1212/
      DATA A( 89),A( 90),A( 91),A( 92)/   1213,   1215,   1216,   1217/
      DATA A( 93),A( 94),A( 95),A( 96)/   1218,   1219,   1220,   1221/
      DATA A( 97),A( 98),A( 99),A(100)/   1222,   1223,   1224,   1225/
      DATA A(101),A(102),A(103),A(104)/   1227,   1228,   1229,   1230/
      DATA A(105),A(106),A(107),A(108)/   1232,   1233,   1235,   2001/
      DATA A(109),A(110),A(111),A(112)/   2002,   2003,   2004,   2005/
      DATA A(113),A(114),A(115),A(116)/   2006,   2007,   2008,   2009/
      DATA A(117),A(118),A(119),A(120)/   2010,   2011,   2012,   2013/
      DATA A(121),A(122),A(123),A(124)/   2015,   2017,   2018,   2019/
      DATA A(125),A(126),A(127),A(128)/   2020,   2021,   2022,   2023/
      DATA A(129),A(130),A(131),A(132)/   2024,   2025,   2026,   2027/
      DATA A(133),A(134),A(135),A(136)/   2028,   2029,   2030,   2031/
      DATA A(137),A(138),A(139),A(140)/   2032,   2033,   2034,   2035/
      DATA A(141),A(142),A(143),A(144)/   2036,   2037,   2038,   2039/
      DATA A(145),A(146),A(147),A(148)/   2041,   2042,   2044,   2045/
      DATA A(149),A(150),A(151),A(152)/   2046,   2051,   2052,   2053/
      DATA A(153),A(154),A(155),A(156)/   2054,   2055,   2056,   2057/
      DATA A(157),A(158),A(159)       /   2058,   3001,   3002 /
      DATA B(  1),B(  2),B(  3),B(  4)/     11,     25,     37,     50/
      DATA B(  5),B(  6),B(  7),B(  8)/     64,     80,     98,    106/
      DATA B(  9),B( 10),B( 11),B( 12)/    119,    131,    145,    158/
      DATA B( 13),B( 14),B( 15),B( 16)/    178,    188,    206,    225/
      DATA B( 17),B( 18),B( 19),B( 20)/    244,    266,    284,    302/
      DATA B( 21),B( 22),B( 23),B( 24)/    317,    340,    361,    380/
      DATA B( 25),B( 26),B( 27),B( 28)/    401,    416,    421,    428/
      DATA B( 29),B( 30),B( 31),B( 32)/    435,    457,    472,    499/
      DATA B( 33),B( 34),B( 35),B( 36)/    522,    537,    551,    565/
      DATA B( 37),B( 38),B( 39),B( 40)/    590,    609,    622,    643/
      DATA B( 41),B( 42),B( 43),B( 44)/    670,    683,    687,    690/
      DATA B( 45),B( 46),B( 47),B( 48)/    697,    704,    709,    719/
      DATA B( 49),B( 50),B( 51),B( 52)/    724,    729,    732,    738/
      DATA B( 53),B( 54),B( 55),B( 56)/    744,    757,    763,    772/
      DATA B( 57),B( 58),B( 59),B( 60)/    781,    790,    796,    804/
      DATA B( 61),B( 62),B( 63),B( 64)/    810,    821,    835,    842/
      DATA B( 65),B( 66),B( 67),B( 68)/    853,    864,    879,    892/
      DATA B( 69),B( 70),B( 71),B( 72)/    918,    930,    940,    946/
      DATA B( 73),B( 74),B( 75),B( 76)/    950,    961,    970,    985/
      DATA B( 77),B( 78),B( 79),B( 80)/    999,   1009,   1019,   1028/
      DATA B( 81),B( 82),B( 83),B( 84)/   1038,   1049,   1061,   1068/
      DATA B( 85),B( 86),B( 87),B( 88)/   1077,   1088,   1101,   1110/
      DATA B( 89),B( 90),B( 91),B( 92)/   1120,   1131,   1143,   1159/
      DATA B( 93),B( 94),B( 95),B( 96)/   1166,   1173,   1180,   1184/
      DATA B( 97),B( 98),B( 99),B(100)/   1196,   1209,   1219,   1235/
      DATA B(101),B(102),B(103),B(104)/   1244,   1253,   1260,   1267/
      DATA B(105),B(106),B(107),B(108)/   1279,   1291,   1304,   1316/
      DATA B(109),B(110),B(111),B(112)/   1327,   1334,   1347,   1366/
      DATA B(113),B(114),B(115),B(116)/   1381,   1404,   1426,   1445/
      DATA B(117),B(118),B(119),B(120)/   1455,   1471,   1477,   1482/
      DATA B(121),B(122),B(123),B(124)/   1500,   1512,   1530,   1542/
      DATA B(125),B(126),B(127),B(128)/   1562,   1568,   1579,   1595/
      DATA B(129),B(130),B(131),B(132)/   1613,   1620,   1637,   1653/
      DATA B(133),B(134),B(135),B(136)/   1663,   1674,   1694,   1711/
      DATA B(137),B(138),B(139),B(140)/   1723,   1733,   1739,   1755/
      DATA B(141),B(142),B(143),B(144)/   1766,   1780,   1800,   1817/
      DATA B(145),B(146),B(147),B(148)/   1825,   1836,   1846,   1854/
      DATA B(149),B(150),B(151),B(152)/   1868,   1878,   1891,   1900/
      DATA B(153),B(154),B(155),B(156)/   1917,   1924,   1933,   1945/
      DATA B(157),B(158),B(159)       /   1961,   1973,   1985/
      DATA E(   1),E(   2),E(   3),E(   4)/'INVA','LID ','CHAR','ACTE'/
      DATA E(   5),E(   6),E(   7),E(   8)/'R IN',' PRE','CEDI','NG S'/
      DATA E(   9),E(  10),E(  11),E(  12)/'TATE','MENT','    ','I.L.'/
      DATA E(  13),E(  14),E(  15),E(  16)/' STO','RAGE',' EXH','AUST'/
      DATA E(  17),E(  18),E(  19),E(  20)/'ED. ','FURT','HER ','CALL'/
      DATA E(  21),E(  22),E(  23),E(  24)/'S CA','USE ','DATA',' LOS'/
      DATA E(  25),E(  26),E(  27),E(  28)/'S   ','ARGU','MENT','S CA'/
      DATA E(  29),E(  30),E(  31),E(  32)/'NNOT',' PRE','CEDE',' OPC'/
      DATA E(  33),E(  34),E(  35),E(  36)/'ODE.',' CAL','L IG','NORE'/
      DATA E(  37),E(  38),E(  39),E(  40)/'D   ','OPCO','DE C','ALL '/
      DATA E(  41),E(  42),E(  43),E(  44)/'PREC','EDED',' REL','EASE'/
      DATA E(  45),E(  46),E(  47),E(  48)/'. PR','EVIO','US L','INE '/
      DATA E(  49),E(  50),E(  51),E(  52)/'LOST','    ','PARA','METR'/
      DATA E(  53),E(  54),E(  55),E(  56)/'IC S','URFA','CE I','S NO'/
      DATA E(  57),E(  58),E(  59),E(  60)/'T NA','MED.',' SUR','FACE'/
      DATA E(  61),E(  62),E(  63),E(  64)/' IS ','UNDE','FINE','D   '/
      DATA E(  65),E(  66),E(  67),E(  68)/'PARA','METR','IC S','URFA'/
      DATA E(  69),E(  70),E(  71),E(  72)/'CE V','ARIA','BLE ','IS N'/
      DATA E(  73),E(  74),E(  75),E(  76)/'OT A',' SCA','LAR.','SURF'/
      DATA E(  77),E(  78),E(  79),E(  80)/'ACE ','IS U','NDEF','INED'/
      DATA E(  81),E(  82),E(  83),E(  84)/'PARA','METR','IC S','URFA'/
      DATA E(  85),E(  86),E(  87),E(  88)/'CE M','ODIF','IER ','IS N'/
      DATA E(  89),E(  90),E(  91),E(  92)/'OT D','ERIV',' OR ','NODE'/
      DATA E(  93),E(  94),E(  95),E(  96)/'R. S','URFA','CE I','S UN'/
      DATA E(  97),E(  98),E(  99),E( 100)/'DEFI','NED ','NO P','ARAM'/
      DATA E( 101),E( 102),E( 103),E( 104)/'ETER','S FO','LLOW',' COM'/
      DATA E( 105),E( 106),E( 107),E( 108)/'MAND','    ','NO S','URFA'/
      DATA E( 109),E( 110),E( 111),E( 112)/'CE I','S NA','MED.',' COM'/
      DATA E( 113),E( 114),E( 115),E( 116)/'MAND',' IGN','ORED',', CO'/
      DATA E( 117),E( 118),E( 119),E( 120)/'NTIN','UING','    ','TAGT'/
      DATA E( 121),E( 122),E( 123),E( 124)/'BL M','AY O','VERF','LOW.'/
      DATA E( 125),E( 126),E( 127),E( 128)/' TOO',' MAN','Y CH','ECK '/
      DATA E( 129),E( 130),E( 131),E( 132)/'SURF','ACES','    ','TOO '/
      DATA E( 133),E( 134),E( 135),E( 136)/'MANY',' SYS','TEM-','GENE'/
      DATA E( 137),E( 138),E( 139),E( 140)/'RATE','D LA','BELS','; TA'/
      DATA E( 141),E( 142),E( 143),E( 144)/'BLE ','LENG','TH E','XCEE'/
      DATA E( 145),E( 146),E( 147),E( 148)/'DED ','SYMB','OL E','XCEE'/
      DATA E( 149),E( 150),E( 151),E( 152)/'DS S','IX C','HARA','CTER'/
      DATA E( 153),E( 154),E( 155),E( 156)/'S; I','T MA','Y BE',' TRU'/
      DATA E( 157),E( 158),E( 159),E( 160)/'NCAT','ED  ','NAME',' FOL'/
      DATA E( 161),E( 162),E( 163),E( 164)/'LOWI','NG C','ALL/',' IS '/
      DATA E( 165),E( 166),E( 167),E( 168)/'NOT ','A PR','EVIO','USLY'/
      DATA E( 169),E( 170),E( 171),E( 172)/' DEF','INED',' MAC','RO N'/
      DATA E( 173),E( 174),E( 175),E( 176)/'OR I','T IS',' A S','YSTE'/
      DATA E( 177),E( 178),E( 179),E( 180)/'M MA','CRO ','UNKN','OWN '/
      DATA E( 181),E( 182),E( 183),E( 184)/'FORM','AT U','SED ','IN O'/
      DATA E( 185),E( 186),E( 187),E( 188)/'BTAI','N ST','ATEM','ENT '/
      DATA E( 189),E( 190),E( 191),E( 192)/'TOO ','MANY',' ARG','UMEN'/
      DATA E( 193),E( 194),E( 195),E( 196)/'TS I','N CA','NON ','OR O'/
      DATA E( 197),E( 198),E( 199),E( 200)/'BTAI','N ST','ATEM','ENT;'/
      DATA E( 201),E( 202),E( 203),E( 204)/'CANS','TK A','RRAY',' EXC'/
      DATA E( 205),E( 206),E( 207),E( 208)/'EEDE','D   ','LINU','SD T'/
      DATA E( 209),E( 210),E( 211),E( 212)/'ABLE',' USE','D IN',' MAC'/
      DATA E( 213),E( 214),E( 215),E( 216)/'RO P','ROCE','SSIN','G IS'/
      DATA E( 217),E( 218),E( 219),E( 220)/' FIL','LED.',' SEE',' APT'/
      DATA E( 221),E( 222),E( 223),E( 224)/' SYS','TEM ','PROG','RAMM'/
      DATA E( 225),E( 226),E( 227),E( 228)/'ER  ','TOO ','MANY',' MAC'/
      DATA E( 229),E( 230),E( 231),E( 232)/'RO V','ARIA','BLES',' IN '/
      DATA E( 233),E( 234),E( 235),E( 236)/'PART',' PRO','GRAM','. MA'/
      DATA E( 237),E( 238),E( 239),E( 240)/'CDF1',' AND',' MAC','DF2 '/
      DATA E( 241),E( 242),E( 243),E( 244)/'TABL','ES E','XCEE','DED '/
      DATA E( 245),E( 246),E( 247),E( 248)/'TOO ','MANY',' VAL','UES '/
      DATA E( 249),E( 250),E( 251),E( 252)/'ASSI','GNED',' TO ','THE '/
      DATA E( 253),E( 254),E( 255),E( 256)/'MACR','O VA','RIAB','LES '/
      DATA E( 257),E( 258),E( 259),E( 260)/'IN P','ART ','PROG','RAM.'/
      DATA E( 261),E( 262),E( 263),E( 264)/' MAC','HST ','TABL','E EX'/
      DATA E( 265),E( 266),E( 267),E( 268)/'CEED','ED  ','MACR','O NE'/
      DATA E( 269),E( 270),E( 271),E( 272)/'ST L','EVEL',' MAX','IMUM'/
      DATA E( 273),E( 274),E( 275),E( 276)/' EXC','EEDE','D. M','ACSV'/
      DATA E( 277),E( 278),E( 279),E( 280)/'1,MA','CSV2',',MAC','SV3 '/
      DATA E( 281),E( 282),E( 283),E( 284)/'TABL','ES E','XCEE','DED '/
      DATA E( 285),E( 286),E( 287),E( 288)/'MAS ','TABL','E US','ED I'/
      DATA E( 289),E( 290),E( 291),E( 292)/'N MA','CRO ','PROC','ESSI'/
      DATA E( 293),E( 294),E( 295),E( 296)/'NG I','S FI','LLED','. SE'/
      DATA E( 297),E( 298),E( 299),E( 300)/'E AP','T SY','STEM',' PRO'/
      DATA E( 301),E( 302),E( 303),E( 304)/'GRAM','MER ','MORE',' THA'/
      DATA E( 305),E( 306),E( 307),E( 308)/'N 50',' MAC','ROS ','IN P'/
      DATA E( 309),E( 310),E( 311),E( 312)/'ART ','PROG','RAM.',' MAC'/
      DATA E( 313),E( 314),E( 315),E( 316)/'SEQ ','TABL','E EX','CEED'/
      DATA E( 317),E( 318),E( 319),E( 320)/'ED  ','TOO ','MANY',' MAC'/
      DATA E( 321),E( 322),E( 323),E( 324)/'RO V','ARIA','BLES',' HAV'/
      DATA E( 325),E( 326),E( 327),E( 328)/'E BE','EN A','SSIG','NED '/
      DATA E( 329),E( 330),E( 331),E( 332)/'MACR','O NA','MES.',' MNM'/
      DATA E( 333),E( 334),E( 335),E( 336)/'VB A','ND M','NMVC',' TAB'/
      DATA E( 337),E( 338),E( 339),E( 340)/'LES ','EXCE','EDED','    '/
      DATA E( 341),E( 342),E( 343),E( 344)/'VBLS','AV T','ABLE',' OVE'/
      DATA E( 345),E( 346),E( 347),E( 348)/'RFLO','W.RE','DUCE',' NUM'/
      DATA E( 349),E( 350),E( 351),E( 352)/'BER ','OF M','ACRO',' CAL'/
      DATA E( 353),E( 354),E( 355),E( 356)/'LS A','ND/O','R NU','MBER'/
      DATA E( 357),E( 358),E( 359),E( 360)/' OF ','MACR','O VA','RIAB'/
      DATA E( 361),E( 362),E( 363),E( 364)/'LES ','MACS','PD T','ABLE'/
      DATA E( 365),E( 366),E( 367),E( 368)/' USE','D IN',' MAC','RO P'/
      DATA E( 369),E( 370),E( 371),E( 372)/'ROCE','SSIN','G IS',' FIL'/
      DATA E( 373),E( 374),E( 375),E( 376)/'LED.','SEE ','APT ','SYST'/
      DATA E( 377),E( 378),E( 379),E( 380)/'EM P','ROGR','AMME','R   '/
      DATA E( 381),E( 382),E( 383),E( 384)/'TOO ','MANY',' MAC','RO V'/
      DATA E( 385),E( 386),E( 387),E( 388)/'ARIA','BLES',' IN ','A SI'/
      DATA E( 389),E( 390),E( 391),E( 392)/'NGLE',' EXP','RESS','ION.'/
      DATA E( 393),E( 394),E( 395),E( 396)/' MRG','STK ','OR M','ACVA'/
      DATA E( 397),E( 398),E( 399),E( 400)/'R TA','BLE ','OVER','FLOW'/
      DATA E( 401),E( 402),E( 403),E( 404)/'    ','KSC ','TABL','E FI'/
      DATA E( 405),E( 406),E( 407),E( 408)/'LLED','. TO','O MA','NY S'/
      DATA E( 409),E( 410),E( 411),E( 412)/'CULP','TURE','D SU','RFAC'/
      DATA E( 413),E( 414),E( 415),E( 416)/'E DE','FINI','TION','S   '/
      DATA E( 417),E( 418),E( 419),E( 420)/'TOO ','MUCH',' MAC','RO T'/
      DATA E( 421),E( 422),E( 423),E( 424)/'EXT ','NUME','RIC ','NAME'/
      DATA E( 425),E( 426),E( 427),E( 428)/' TAB','LE O','VERF','LOW '/
      DATA E( 429),E( 430),E( 431),E( 432)/'INVA','LID ','USE ','OF W'/
      DATA E( 433),E( 434),E( 435),E( 436)/'ORD ','TERM','AC  ','SUPP'/
      DATA E( 437),E( 438),E( 439),E( 440)/'OSED',' PRO','CEDU','RE D'/
      DATA E( 441),E( 442),E( 443),E( 444)/'OES ','NOT ','HAVE',' CLA'/
      DATA E( 445),E( 446),E( 447),E( 448)/'SS P','ROCE','DURE',' OR '/
      DATA E( 449),E( 450),E( 451),E( 452)/'FUNC','TION','. SE','E AP'/
      DATA E( 453),E( 454),E( 455),E( 456)/'T SY','STEM',' PRO','GRAM'/
      DATA E( 457),E( 458),E( 459),E( 460)/'MER ','LABA','RY T','ABLE'/
      DATA E( 461),E( 462),E( 463),E( 464)/' FIL','LED.',' NO ','FURT'/
      DATA E( 465),E( 466),E( 467),E( 468)/'HER ','SEAR','CH F','OR M'/
      DATA E( 469),E( 470),E( 471),E( 472)/'ISSI','NG L','ABEL','S   '/
      DATA E( 473),E( 474),E( 475),E( 476)/'GEOM','ETRI','C VA','RIAB'/
      DATA E( 477),E( 478),E( 479),E( 480)/'LE B','EING',' USE','D HA'/
      DATA E( 481),E( 482),E( 483),E( 484)/'S BE','EN P','REVI','OUSL'/
      DATA E( 485),E( 486),E( 487),E( 488)/'Y DE','FINE','D WI','TH T'/
      DATA E( 489),E( 490),E( 491),E( 492)/'HE S','AME ','MODE','. FI'/
      DATA E( 493),E( 494),E( 495),E( 496)/'RST ','DEFI','NITI','ON O'/
      DATA E( 497),E( 498),E( 499),E( 500)/'VERR','IDDE','N   ','SCUL'/
      DATA E( 501),E( 502),E( 503),E( 504)/'PTUR','ED S','URFA','CE V'/
      DATA E( 505),E( 506),E( 507),E( 508)/'ARIA','BLE ','BEIN','G US'/
      DATA E( 509),E( 510),E( 511),E( 512)/'ED H','AS B','EEN ','PREV'/
      DATA E( 513),E( 514),E( 515),E( 516)/'IOUS','LY D','EFIN','ED. '/
      DATA E( 517),E( 518),E( 519),E( 520)/'FIRS','T DE','F. O','VERR'/
      DATA E( 521),E( 522),E( 523),E( 524)/'IDDE','N   ','TOO ','MANY'/
      DATA E( 525),E( 526),E( 527),E( 528)/' LAR','GE D','ATA ','ARRA'/
      DATA E( 529),E( 530),E( 531),E( 532)/'Y DE','FINI','TION','S. C'/
      DATA E( 533),E( 534),E( 535),E( 536)/'ANSI','Z TA','BLE ','FILL'/
      DATA E( 537),E( 538),E( 539),E( 540)/'ED  ','MISS','ING ','FINI'/
      DATA E( 541),E( 542),E( 543),E( 544)/'. FI','NI I','NSER','TED '/
      DATA E( 545),E( 546),E( 547),E( 548)/'AND ','PROC','ESSI','NG C'/
      DATA E( 549),E( 550),E( 551),E( 552)/'ONTI','NUES','    ','MISS'/
      DATA E( 553),E( 554),E( 555),E( 556)/'ING ','TERM','AC. ','FINI'/
      DATA E( 557),E( 558),E( 559),E( 560)/' INS','ERTE','D AN','D PR'/
      DATA E( 561),E( 562),E( 563),E( 564)/'OCES','SING',' CON','TINU'/
      DATA E( 565),E( 566),E( 567),E( 568)/'ES  ','SEGM','ENT ','READ'/
      DATA E( 569),E( 570),E( 571),E( 572)/' OR ','FIRS','T CA','LL T'/
      DATA E( 573),E( 574),E( 575),E( 576)/'O SY','STEM',' MAC','RO C'/
      DATA E( 577),E( 578),E( 579),E( 580)/'ANNO','T BE',' CON','TAIN'/
      DATA E( 581),E( 582),E( 583),E( 584)/'ED I','N A ','SEGM','ENT '/
      DATA E( 585),E( 586),E( 587),E( 588)/'READ',' OR ','A SY','STEM'/
      DATA E( 589),E( 590),E( 591),E( 592)/' MAC','RO  ','UNAB','LE T'/
      DATA E( 593),E( 594),E( 595),E( 596)/'O OP','EN L','IBRA','RY A'/
      DATA E( 597),E( 598),E( 599),E( 600)/'PTLI','B. C','OULD',' RES'/
      DATA E( 601),E( 602),E( 603),E( 604)/'ULT ','FROM',' CAL','L TO'/
      DATA E( 605),E( 606),E( 607),E( 608)/' UND','EFIN','ED M','ACRO'/
      DATA E( 609),E( 610),E( 611),E( 612)/'    ','SEGM','ENT ','NAME'/
      DATA E( 613),E( 614),E( 615),E( 616)/'D IN',' REA','D/ S','TATE'/
      DATA E( 617),E( 618),E( 619),E( 620)/'MENT',' IS ','NOT ','IN A'/
      DATA E( 621),E( 622),E( 623),E( 624)/'PTLI','B   ','UNAB','LE T'/
      DATA E( 625),E( 626),E( 627),E( 628)/'O RE','AD A',' REC','ORD '/
      DATA E( 629),E( 630),E( 631),E( 632)/'FROM',' APT','LIB;',' I/O'/
      DATA E( 633),E( 634),E( 635),E( 636)/' ERR','OR O','R IL','LEGA'/
      DATA E( 637),E( 638),E( 639),E( 640)/'L BL','OCKS','IZE ','OR R'/
      DATA E( 641),E( 642),E( 643),E( 644)/'ECOR','D SI','ZE  ','GEOM'/
      DATA E( 645),E( 646),E( 647),E( 648)/'ETRI','C VA','RIAB','LE B'/
      DATA E( 649),E( 650),E( 651),E( 652)/'EING',' USE','D HA','S BE'/
      DATA E( 653),E( 654),E( 655),E( 656)/'EN P','REVI','OUSL','Y DE'/
      DATA E( 657),E( 658),E( 659),E( 660)/'FINE','D WI','TH A',' DIF'/
      DATA E( 661),E( 662),E( 663),E( 664)/'FERE','NT M','ODE.',' FIR'/
      DATA E( 665),E( 666),E( 667),E( 668)/'ST D','EFIN','ITIO','N RE'/
      DATA E( 669),E( 670),E( 671),E( 672)/'TAIN','ED  ','MISS','ING '/
      DATA E( 673),E( 674),E( 675),E( 676)/'LABE','L ST','ATEM','ENT '/
      DATA E( 677),E( 678),E( 679),E( 680)/'ADDR','ESSE','D BY',' JUM'/
      DATA E( 681),E( 682),E( 683),E( 684)/'PTO ','OR I','F   ','DUPL'/
      DATA E( 685),E( 686),E( 687),E( 688)/'ICAT','E LA','BEL ','MIXE'/
      DATA E( 689),E( 690),E( 691),E( 692)/'D MO','DE  ','INVA','LID '/
      DATA E( 693),E( 694),E( 695),E( 696)/'USE ','OF M','INUS',' SIG'/
      DATA E( 697),E( 698),E( 699),E( 700)/'N   ','INVA','LID ','STAT'/
      DATA E( 701),E( 702),E( 703),E( 704)/'EMEN','T IG','NORE','D   '/
      DATA E( 705),E( 706),E( 707),E( 708)/'IMPR','OPER',' ARG','UMEN'/
      DATA E( 709),E( 710),E( 711),E( 712)/'T   ','MISS','ING ','LABE'/
      DATA E( 713),E( 714),E( 715),E( 716)/'L. S','TATE','MENT',' NOT'/
      DATA E( 717),E( 718),E( 719),E( 720)/' REA','CHAB','LE  ','MATR'/
      DATA E( 721),E( 722),E( 723),E( 724)/'IX M','UST ','FOLL','OW  '/
      DATA E( 725),E( 726),E( 727),E( 728)/'NOMO','RE M','UST ','FOLL'/
      DATA E( 729),E( 730),E( 731),E( 732)/'OW  ','MIXE','D MO','DE  '/
      DATA E( 733),E( 734),E( 735),E( 736)/'VARI','ABLE',' IS ','UNRE'/
      DATA E( 737),E( 738),E( 739),E( 740)/'SERV','ED  ','NO T','YPE '/
      DATA E( 741),E( 742),E( 743),E( 744)/'FOR ','VARI','ABLE','    '/
      DATA E( 745),E( 746),E( 747),E( 748)/'SURF','ACE ','TYPE',' CHA'/
      DATA E( 749),E( 750),E( 751),E( 752)/'NGED',' IN ','NEST','ED G'/
      DATA E( 753),E( 754),E( 755),E( 756)/'EOME','TRIC',' DEF','INIT'/
      DATA E( 757),E( 758),E( 759),E( 760)/'ION ','MACR','O DE','FINI'/
      DATA E( 761),E( 762),E( 763),E( 764)/'TION',' NES','TED ','MACR'/
      DATA E( 765),E( 766),E( 767),E( 768)/'O NA','ME N','OT P','RECE'/
      DATA E( 769),E( 770),E( 771),E( 772)/'EDED',' BY ','CALL','    '/
      DATA E( 773),E( 774),E( 775),E( 776)/'DUMM','Y VA','RIAB','LE E'/
      DATA E( 777),E( 778),E( 779),E( 780)/'XPEC','TS M','ACRO',' NAM'/
      DATA E( 781),E( 782),E( 783),E( 784)/'E   ','DUMM','Y VA','RIAB'/
      DATA E( 785),E( 786),E( 787),E( 788)/'LE R','EJEC','TS M','ACRO'/
      DATA E( 789),E( 790),E( 791),E( 792)/' NAM','E   ','UNKN','OWN '/
      DATA E( 793),E( 794),E( 795),E( 796)/'MACR','O VA','RIAB','LE  '/
      DATA E( 797),E( 798),E( 799),E( 800)/'ERRO','R IN',' FIN','AL M'/
      DATA E( 801),E( 802),E( 803),E( 804)/'ACRO',' PRO','CESS','ING '/
      DATA E( 805),E( 806),E( 807),E( 808)/'RECU','RSIV','E US','E OF'/
      DATA E( 809),E( 810),E( 811),E( 812)/' MAC','ROS ','ILLE','GAL '/
      DATA E( 813),E( 814),E( 815),E( 816)/'MODE',' FOR',' TEM','PORA'/
      DATA E( 817),E( 818),E( 819),E( 820)/'RY I','N CA','LL T','O MA'/
      DATA E( 821),E( 822),E( 823),E( 824)/'CRO ','VARI','ABLE',' NAM'/
      DATA E( 825),E( 826),E( 827),E( 828)/'E IN',' CAN','ON D','EFIN'/
      DATA E( 829),E( 830),E( 831),E( 832)/'ITIO','N IS',' OF ','INCO'/
      DATA E( 833),E( 834),E( 835),E( 836)/'RREC','T MO','DE  ','INVA'/
      DATA E( 837),E( 838),E( 839),E( 840)/'LID ','TABC','YL D','EFIN'/
      DATA E( 841),E( 842),E( 843),E( 844)/'ITIO','N   ','INVA','LID '/
      DATA E( 845),E( 846),E( 847),E( 848)/'TABC','YL U','SED ','IN R'/
      DATA E( 849),E( 850),E( 851),E( 852)/'LDSR','F DE','FINI','TION'/
      DATA E( 853),E( 854),E( 855),E( 856)/'    ','INPU','T ST','ATEM'/
      DATA E( 857),E( 858),E( 859),E( 860)/'ENT ','IS T','OO L','ONG.'/
      DATA E( 861),E( 862),E( 863),E( 864)/' STA','CK O','VERF','LOW '/
      DATA E( 865),E( 866),E( 867),E( 868)/'BOUN','DED ','GEOM','ETRY'/
      DATA E( 869),E( 870),E( 871),E( 872)/' MUS','T NO','T BE',' SUB'/
      DATA E( 873),E( 874),E( 875),E( 876)/'SCRI','PTED','. ST','ATEM'/
      DATA E( 877),E( 878),E( 879),E( 880)/'ENT ','IGNO','RED ','INVA'/
      DATA E( 881),E( 882),E( 883),E( 884)/'LID ','ARGU','MENT',' IN '/
      DATA E( 885),E( 886),E( 887),E( 888)/'A LA','RGE ','DATA',' CAN'/
      DATA E( 889),E( 890),E( 891),E( 892)/'ON S','TATE','MENT','    '/
      DATA E( 893),E( 894),E( 895),E( 896)/'OBTA','IN S','TATE','MENT'/
      DATA E( 897),E( 898),E( 899),E( 900)/' SPE','CIFI','ES M','ORE '/
      DATA E( 901),E( 902),E( 903),E( 904)/'VARI','ABLE','S TH','AN T'/
      DATA E( 905),E( 906),E( 907),E( 908)/'HERE',' ARE',' ELE','MENT'/
      DATA E( 909),E( 910),E( 911),E( 912)/'S IN',' IND','ICAT','ED S'/
      DATA E( 913),E( 914),E( 915),E( 916)/'URFA','CE C','ANON','ICAL'/
      DATA E( 917),E( 918),E( 919),E( 920)/' FOR','M   ','TOO ','MANY'/
      DATA E( 921),E( 922),E( 923),E( 924)/' DO-','ARGU','MENT','S OR'/
      DATA E( 925),E( 926),E( 927),E( 928)/' ARG','UMEN','T WI','THOU'/
      DATA E( 929),E( 930),E( 931),E( 932)/'T VA','LUE ','DO-L','OOP '/
      DATA E( 933),E( 934),E( 935),E( 936)/'NOT ','CLOS','ED A','T FI'/
      DATA E( 937),E( 938),E( 939),E( 940)/'NI O','R TE','RMAC','    '/
      DATA E( 941),E( 942),E( 943),E( 944)/'MORE',' THA','N 10',' DO '/
      DATA E( 945),E( 946),E( 947),E( 948)/'NEST','ED  ','BAD ','NEST'/
      DATA E( 949),E( 950),E( 951),E( 952)/'ED D','O   ','IDEN','TICA'/
      DATA E( 953),E( 954),E( 955),E( 956)/'L NA','MES ','OF V','ARIA'/
      DATA E( 957),E( 958),E( 959),E( 960)/'BLES',' IN ','NEST','ED D'/
      DATA E( 961),E( 962),E( 963),E( 964)/'O   ','ILLE','GAL ','PATE'/
      DATA E( 965),E( 966),E( 967),E( 968)/'RN D','EFIN','ITIO','N FO'/
      DATA E( 969),E( 970),E( 971),E( 972)/'RMAT','    ','WRON','G SU'/
      DATA E( 973),E( 974),E( 975),E( 976)/'RFAC','E AS','SOCI','ATED'/
      DATA E( 977),E( 978),E( 979),E( 980)/' WIT','H VA','RIAB','LE I'/
      DATA E( 981),E( 982),E( 983),E( 984)/'N OB','TAIN',' STA','TEME'/
      DATA E( 985),E( 986),E( 987),E( 988)/'NT  ','ILLE','GAL ','SUBS'/
      DATA E( 989),E( 990),E( 991),E( 992)/'CRIP','TED ','VARI','ABLE'/
      DATA E( 993),E( 994),E( 995),E( 996)/'. CH','ECK ','FOR ','MISS'/
      DATA E( 997),E( 998),E( 999),E(1000)/'ING ','RESE','RV  ','MORE'/
      DATA E(1001),E(1002),E(1003),E(1004)/' THA','N 30',' RES','P. 5'/
      DATA E(1005),E(1006),E(1007),E(1008)/' POI','NT D','EFIN','ITIO'/
      DATA E(1009),E(1010),E(1011),E(1012)/'NS  ','MORE',' THA','N 30'/
      DATA E(1013),E(1014),E(1015),E(1016)/' RES','P. 5',' SPL','INE '/
      DATA E(1017),E(1018),E(1019),E(1020)/'DEFI','NITI','ONS ','SURF'/
      DATA E(1021),E(1022),E(1023),E(1024)/'ACE ','DEFI','NITI','ON I'/
      DATA E(1025),E(1026),E(1027),E(1028)/'S NO','T CO','MPLE','TE  '/
      DATA E(1029),E(1030),E(1031),E(1032)/'TOO ','MANY',' SEG','MENT'/
      DATA E(1033),E(1034),E(1035),E(1036)/'S IN',' THE',' FLO','W SE'/
      DATA E(1037),E(1038),E(1039),E(1040)/'CTIO','N   ','INCO','RREC'/
      DATA E(1041),E(1042),E(1043),E(1044)/'T DE','FINI','TION',' OF '/
      DATA E(1045),E(1046),E(1047),E(1048)/'THE ','FLOW',' SEG','MENT'/
      DATA E(1049),E(1050),E(1051),E(1052)/'    ','TOO ','MANY',' OR '/
      DATA E(1053),E(1054),E(1055),E(1056)/'INCO','RREC','T IT','EMS '/
      DATA E(1057),E(1058),E(1059),E(1060)/'IN T','HE F','LOW ','SECT'/
      DATA E(1061),E(1062),E(1063),E(1064)/'ION ','TOO ','MANY',' SEG'/
      DATA E(1065),E(1066),E(1067),E(1068)/' DEF','INIT','IONS','    '/
      DATA E(1069),E(1070),E(1071),E(1072)/'MULT','IPLE',' DEF','INED'/
      DATA E(1073),E(1074),E(1075),E(1076)/' LIM','IT O','R WE','IGHT'/
      DATA E(1077),E(1078),E(1079),E(1080)/'    ','TANS','PL,C','RSSP'/
      DATA E(1081),E(1082),E(1083),E(1084)/'L OR',' NOR','MAL ','MULT'/
      DATA E(1085),E(1086),E(1087),E(1088)/'IPLE',' DEF','INED','    '/
      DATA E(1089),E(1090),E(1091),E(1092)/'USE ','OF C','RSSP','L ON'/
      DATA E(1093),E(1094),E(1095),E(1096)/'LY C','ORRE','CT A','T ST'/
      DATA E(1097),E(1098),E(1099),E(1100)/'ART ','AND ','END ','POIN'/
      DATA E(1101),E(1102),E(1103),E(1104)/'T   ','MODI','FICA','TOR '/
      DATA E(1105),E(1106),E(1107),E(1108)/'OR D','EFIN','ITIO','N RE'/
      DATA E(1109),E(1110),E(1111),E(1112)/'PEAT','ING ','MORE',' THA'/
      DATA E(1113),E(1114),E(1115),E(1116)/'N 30',' SUR','FACE','S DE'/
      DATA E(1117),E(1118),E(1119),E(1120)/'FINE',' A C','OMBI','N   '/
      DATA E(1121),E(1122),E(1123),E(1124)/'MORE',' THA','N ON','E PA'/
      DATA E(1125),E(1126),E(1127),E(1128)/'TCH ','DEFI','NE A',' PAT'/
      DATA E(1129),E(1130),E(1131),E(1132)/'CH/P','NTSO','N   ','TRFO'/
      DATA E(1133),E(1134),E(1135),E(1136)/'RM,M','ATRI','X NO','T AL'/
      DATA E(1137),E(1138),E(1139),E(1140)/'LOWE','D IN',' THI','S DE'/
      DATA E(1141),E(1142),E(1143),E(1144)/'FINI','TION','    ','TRFO'/
      DATA E(1145),E(1146),E(1147),E(1148)/'RM,M','ATRI','X SH','OULD'/
      DATA E(1149),E(1150),E(1151),E(1152)/' BE ','DEFI','NED ','AT T'/
      DATA E(1153),E(1154),E(1155),E(1156)/'HE E','ND O','F TH','E DE'/
      DATA E(1157),E(1158),E(1159),E(1160)/'FINI','TION','    ','MATR'/
      DATA E(1161),E(1162),E(1163),E(1164)/'IX D','EFIN','ITIO','N EX'/
      DATA E(1165),E(1166),E(1167),E(1168)/'PECT','ED  ','POIN','T DE'/
      DATA E(1169),E(1170),E(1171),E(1172)/'FINI','TION',' EXP','ECTE'/
      DATA E(1173),E(1174),E(1175),E(1176)/'D   ','VECT','OR D','EFIN'/
      DATA E(1177),E(1178),E(1179),E(1180)/'ITIO','N EX','PECT','ED  '/
      DATA E(1181),E(1182),E(1183),E(1184)/'SCAL','AR E','XPEC','TED '/
      DATA E(1185),E(1186),E(1187),E(1188)/'POIN','T DE','FINI','TION'/
      DATA E(1189),E(1190),E(1191),E(1192)/' NOT',' PER','MITT','ED I'/
      DATA E(1193),E(1194),E(1195),E(1196)/'N TH','IS P','OSIT','ION '/
      DATA E(1197),E(1198),E(1199),E(1200)/'VECT','OR D','EFIN','ITIO'/
      DATA E(1201),E(1202),E(1203),E(1204)/'N NO','T PE','RMIT','TED '/
      DATA E(1205),E(1206),E(1207),E(1208)/'IN T','HIS ','POSI','TION'/
      DATA E(1209),E(1210),E(1211),E(1212)/'    ','SCAL','AR N','OT P'/
      DATA E(1213),E(1214),E(1215),E(1216)/'ERMI','TTED',' IN ','THIS'/
      DATA E(1217),E(1218),E(1219),E(1220)/' POS','ITIO','N   ','VARI'/
      DATA E(1221),E(1222),E(1223),E(1224)/'OUS ','NUMB','ERS ','OF P'/
      DATA E(1225),E(1226),E(1227),E(1228)/'OINT','S OR',' LES','S TH'/
      DATA E(1229),E(1230),E(1231),E(1232)/'AN T','WO P','OINT','S IN'/
      DATA E(1233),E(1234),E(1235),E(1236)/' THE',' SPL','INES','STK '/
      DATA E(1237),E(1238),E(1239),E(1240)/'TABL','E FI','LLED','. SU'/
      DATA E(1241),E(1242),E(1243),E(1244)/'RFAC','E UN','DEFI','NED '/
      DATA E(1245),E(1246),E(1247),E(1248)/'TRIP','LE N','ESTE','D SU'/
      DATA E(1249),E(1250),E(1251),E(1252)/'RFAC','E DE','FINI','TION'/
      DATA E(1253),E(1254),E(1255),E(1256)/'    ','SSUR','F DE','FINI'/
      DATA E(1257),E(1258),E(1259),E(1260)/'TION',' EXP','ECTE','D   '/
      DATA E(1261),E(1262),E(1263),E(1264)/'SCUR','V DE','FINI','TION'/
      DATA E(1265),E(1266),E(1267),E(1268)/' EXP','ECTE','D   ','SSUR'/
      DATA E(1269),E(1270),E(1271),E(1272)/'F DE','FINI','TION',' NOT'/
      DATA E(1273),E(1274),E(1275),E(1276)/' PER','MITT','ED I','N TH'/
      DATA E(1277),E(1278),E(1279),E(1280)/'IS P','OSIT','ION ','SCUR'/
      DATA E(1281),E(1282),E(1283),E(1284)/'V DE','FINI','TION',' NOT'/
      DATA E(1285),E(1286),E(1287),E(1288)/' PER','MITT','ED I','N TH'/
      DATA E(1289),E(1290),E(1291),E(1292)/'IS P','OSIT','ION ','SURF'/
      DATA E(1293),E(1294),E(1295),E(1296)/'ACE ','DEFI','NITI','ON A'/
      DATA E(1297),E(1298),E(1299),E(1300)/'ND I','TS S','IZE ','IS N'/
      DATA E(1301),E(1302),E(1303),E(1304)/'OT T','O BE',' FOU','ND  '/
      DATA E(1305),E(1306),E(1307),E(1308)/'FORM','AT U','NKNO','WN O'/
      DATA E(1309),E(1310),E(1311),E(1312)/'R SO','ME P','ARAM','ETER'/
      DATA E(1313),E(1314),E(1315),E(1316)/'S AR','E UN','DEFI','NED '/
      DATA E(1317),E(1318),E(1319),E(1320)/'ILLE','GAL ','ARGU','MENT'/
      DATA E(1321),E(1322),E(1323),E(1324)/' IN ','POST','PROC','ESSO'/
      DATA E(1325),E(1326),E(1327),E(1328)/'R ST','ATEM','ENT ','ILLE'/
      DATA E(1329),E(1330),E(1331),E(1332)/'GAL ','GODL','TA S','TATE'/
      DATA E(1333),E(1334),E(1335),E(1336)/'MENT','    ','NO D','RIVE'/
      DATA E(1337),E(1338),E(1339),E(1340)/' SUR','FACE',' NAM','ED A'/
      DATA E(1341),E(1342),E(1343),E(1344)/'FTER',' GO/',', EN','TERI'/
      DATA E(1345),E(1346),E(1347),E(1348)/'NG R','ESTA','RT  ','ITEM'/
      DATA E(1349),E(1350),E(1351),E(1352)/' NOT',' FED','RAT,',' TO,'/
      DATA E(1353),E(1354),E(1355),E(1356)/' ON,',' PAS','T OR',' SUR'/
      DATA E(1357),E(1358),E(1359),E(1360)/'FACE',' FOU','ND A','FTER'/
      DATA E(1361),E(1362),E(1363),E(1364)/' GO/','. EN','TERI','NG R'/
      DATA E(1365),E(1366),E(1367),E(1368)/'ESTA','RT  ','ILLE','GAL '/
      DATA E(1369),E(1370),E(1371),E(1372)/'PERM','ANEN','T ID','ENTI'/
      DATA E(1373),E(1374),E(1375),E(1376)/'FIER',' FOL','LOWS',' GO/'/
      DATA E(1377),E(1378),E(1379),E(1380)/'. EN','TERI','NG R','ESTA'/
      DATA E(1381),E(1382),E(1383),E(1384)/'RT  ','A LO','GICA','LLY '/
      DATA E(1385),E(1386),E(1387),E(1388)/'COMP','LETE',' GO/',' COM'/
      DATA E(1389),E(1390),E(1391),E(1392)/'MAND',' WAS',' FOL','LOWE'/
      DATA E(1393),E(1394),E(1395),E(1396)/'D BY',' OTH','ER D','ATA.'/
      DATA E(1397),E(1398),E(1399),E(1400)/' SUR','PLUS',' CHE','CK S'/
      DATA E(1401),E(1402),E(1403),E(1404)/'URFA','CES ','IGNO','RED '/
      DATA E(1405),E(1406),E(1407),E(1408)/'MORE',' THA','N ON','E CH'/
      DATA E(1409),E(1410),E(1411),E(1412)/'ECK ','SURF','ACE ','FOUN'/
      DATA E(1413),E(1414),E(1415),E(1416)/'D AF','TER ','A GO',' COM'/
      DATA E(1417),E(1418),E(1419),E(1420)/'MAND','. SU','RPLU','S CH'/
      DATA E(1421),E(1422),E(1423),E(1424)/'ECK ','SURF','ACES',' IGN'/
      DATA E(1425),E(1426),E(1427),E(1428)/'ORED','    ','ILLE','GAL '/
      DATA E(1429),E(1430),E(1431),E(1432)/'LANG','UAGE',' USA','GE E'/
      DATA E(1433),E(1434),E(1435),E(1436)/'NCOU','NTER','ED B','EFOR'/
      DATA E(1437),E(1438),E(1439),E(1440)/'E DR','IVE ','SURF','ACE.'/
      DATA E(1441),E(1442),E(1443),E(1444)/'ENTE','RING',' RES','TART'/
      DATA E(1445),E(1446),E(1447),E(1448)/'    ','FIRS','T NO','T DR'/
      DATA E(1449),E(1450),E(1451),E(1452)/'IVE ','SURF','ACE.',' DS '/
      DATA E(1453),E(1454),E(1455),E(1456)/'IS A','SSUM','ED  ','STAT'/
      DATA E(1457),E(1458),E(1459),E(1460)/'EMEN','T WI','TH W','RONG'/
      DATA E(1461),E(1462),E(1463),E(1464)/' ARG','UMEN','TS: ','TOO '/
      DATA E(1465),E(1466),E(1467),E(1468)/'LONG',' OR ','ILLE','GAL '/
      DATA E(1469),E(1470),E(1471),E(1472)/'GEOM','ETRY','    ','PARA'/
      DATA E(1473),E(1474),E(1475),E(1476)/'METE','R LI','ST T','OO L'/
      DATA E(1477),E(1478),E(1479),E(1480)/'ONG ','ILLE','GAL ','ARGU'/
      DATA E(1481),E(1482),E(1483),E(1484)/'MENT','    ','APPR','OPRI'/
      DATA E(1485),E(1486),E(1487),E(1488)/'ATE ','SURF','ACE ','IS N'/
      DATA E(1489),E(1490),E(1491),E(1492)/'OT N','AMED',' AFT','ER P'/
      DATA E(1493),E(1494),E(1495),E(1496)/'SIS.','COMM','AND ','IGNO'/
      DATA E(1497),E(1498),E(1499),E(1500)/'RED.','CONT','INUI','NG  '/
      DATA E(1501),E(1502),E(1503),E(1504)/'INPR','OPER',' FOR','MAT '/
      DATA E(1505),E(1506),E(1507),E(1508)/'FOR ','JUMP','TO. ','STAT'/
      DATA E(1509),E(1510),E(1511),E(1512)/'EMEN','T IG','NORE','D   '/
      DATA E(1513),E(1514),E(1515),E(1516)/'SYN ','OR R','ESER','V ST'/
      DATA E(1517),E(1518),E(1519),E(1520)/'ATEM','ENT ','HAS ','NO A'/
      DATA E(1521),E(1522),E(1523),E(1524)/'RGUM','ENTS',' OR ','AN O'/
      DATA E(1525),E(1526),E(1527),E(1528)/'DD N','UMBE','R OF',' ARG'/
      DATA E(1529),E(1530),E(1531),E(1532)/'UMEN','TS  ','SYN ','STAT'/
      DATA E(1533),E(1534),E(1535),E(1536)/'EMEN','T HA','S A ','VALU'/
      DATA E(1537),E(1538),E(1539),E(1540)/'E OR',' AN ','ILLE','GAL '/
      DATA E(1541),E(1542),E(1543),E(1544)/'WORD','    ','NO D','RIVE'/
      DATA E(1545),E(1546),E(1547),E(1548)/' SUR','FACE',' FOU','ND P'/
      DATA E(1549),E(1550),E(1551),E(1552)/'RECE','DING',' OTH','ERWI'/
      DATA E(1553),E(1554),E(1555),E(1556)/'SE A','CCEP','TABL','E FO'/
      DATA E(1557),E(1558),E(1559),E(1560)/'RMAT','S. E','NTER','ING '/
      DATA E(1561),E(1562),E(1563),E(1564)/'REST','ART ','ARGU','MENT'/
      DATA E(1565),E(1566),E(1567),E(1568)/' MOD','E IS',' WRO','NG  '/
      DATA E(1569),E(1570),E(1571),E(1572)/'AN A','CCEP','TABL','E CH'/
      DATA E(1573),E(1574),E(1575),E(1576)/'ECK ','SURF','ACE ','IS N'/
      DATA E(1577),E(1578),E(1579),E(1580)/'OT N','AMED','    ','IDEN'/
      DATA E(1581),E(1582),E(1583),E(1584)/'TIFI','ER N','OT P','RECE'/
      DATA E(1585),E(1586),E(1587),E(1588)/'DED ','BY A','CCEP','TABL'/
      DATA E(1589),E(1590),E(1591),E(1592)/'E SU','RFAC','E. E','NTER'/
      DATA E(1593),E(1594),E(1595),E(1596)/'ING ','REST','ART ','THE '/
      DATA E(1597),E(1598),E(1599),E(1600)/'WORD',' INT','OF W','AS N'/
      DATA E(1601),E(1602),E(1603),E(1604)/'OT P','RECE','DED ','BY A'/
      DATA E(1605),E(1606),E(1607),E(1608)/' NUM','BER.','FIRS','T IN'/
      DATA E(1609),E(1610),E(1611),E(1612)/'TERS','ECTI','ON A','SSUM'/
      DATA E(1613),E(1614),E(1615),E(1616)/'ED  ','MACR','O VA','RIAB'/
      DATA E(1617),E(1618),E(1619),E(1620)/'LE N','OT F','UNCT','ION '/
      DATA E(1621),E(1622),E(1623),E(1624)/'TOO ','MANY',' DIM','ENSI'/
      DATA E(1625),E(1626),E(1627),E(1628)/'ONED',' VAR','IABL','ES I'/
      DATA E(1629),E(1630),E(1631),E(1632)/'N PA','RT P','ROGR','AM. '/
      DATA E(1633),E(1634),E(1635),E(1636)/'RANG','E TA','BLE ','FILL'/
      DATA E(1637),E(1638),E(1639),E(1640)/'ED  ','INCO','RREC','T FO'/
      DATA E(1641),E(1642),E(1643),E(1644)/'RMAT',' FOR',' RES','ERV '/
      DATA E(1645),E(1646),E(1647),E(1648)/'STAT','EMEN','T. M','UST '/
      DATA E(1649),E(1650),E(1651),E(1652)/'BE S','YMBO','L,NU','MBER'/
      DATA E(1653),E(1654),E(1655),E(1656)/'    ','NO A','RGUM','ENTS'/
      DATA E(1657),E(1658),E(1659),E(1660)/' DES','IRED','. AR','GUME'/
      DATA E(1661),E(1662),E(1663),E(1664)/'NTS ','IGNO','RED ','ARGU'/
      DATA E(1665),E(1666),E(1667),E(1668)/'MENT',' FOL','LOWI','NG Z'/
      DATA E(1669),E(1670),E(1671),E(1672)/'SURF','/ IS',' NOT',' A P'/
      DATA E(1673),E(1674),E(1675),E(1676)/'LANE','    ','NO A','RGUM'/
      DATA E(1677),E(1678),E(1679),E(1680)/'ENTS',' FOL','LOW ','PRIN'/
      DATA E(1681),E(1682),E(1683),E(1684)/'T/,P','UNCH','/,CF','SAVE'/
      DATA E(1685),E(1686),E(1687),E(1688)/'/,CO','NTRL','/ OR',' PPO'/
      DATA E(1689),E(1690),E(1691),E(1692)/'PTN/','. ST','ATEM','ENT '/
      DATA E(1693),E(1694),E(1695),E(1696)/'IGNO','RED ','INVA','LID '/
      DATA E(1697),E(1698),E(1699),E(1700)/'ARGU','MENT',' FOL','LOWS'/
      DATA E(1701),E(1702),E(1703),E(1704)/' PRI','NT/,',' PUN','CH/ '/
      DATA E(1705),E(1706),E(1707),E(1708)/'OR C','FSAV','E/.A','RGUM'/
      DATA E(1709),E(1710),E(1711),E(1712)/'ENT ','IGNO','RED ','INVA'/
      DATA E(1713),E(1714),E(1715),E(1716)/'LID ','NUMB','ER O','F AR'/
      DATA E(1717),E(1718),E(1719),E(1720)/'GUME','NTS ','IN C','ANON'/
      DATA E(1721),E(1722),E(1723),E(1724)/' DEF','INIT','ION ','INVA'/
      DATA E(1725),E(1726),E(1727),E(1728)/'LID ','ARGU','MENT',' IN '/
      DATA E(1729),E(1730),E(1731),E(1732)/'CANO','N DE','FINI','TION'/
      DATA E(1733),E(1734),E(1735),E(1736)/'    ','INVA','LID ','POCK'/
      DATA E(1737),E(1738),E(1739),E(1740)/'ET F','ORMA','T   ','A SY'/
      DATA E(1741),E(1742),E(1743),E(1744)/'NONY','M AR','GUME','NT P'/
      DATA E(1745),E(1746),E(1747),E(1748)/'AIR ','CONT','AINS',' NO '/
      DATA E(1749),E(1750),E(1751),E(1752)/'VARI','ABLE',' OR ','TWO '/
      DATA E(1753),E(1754),E(1755),E(1756)/'VARI','ABLE','S   ','INPR'/
      DATA E(1757),E(1758),E(1759),E(1760)/'OPER',' ARG','UMEN','T IN'/
      DATA E(1761),E(1762),E(1763),E(1764)/' GOT','O/PA','TERN',' STA'/
      DATA E(1765),E(1766),E(1767),E(1768)/'TEME','NT  ','BOTH',' OMI'/
      DATA E(1769),E(1770),E(1771),E(1772)/'T AN','D RE','TAIN',' SPE'/
      DATA E(1773),E(1774),E(1775),E(1776)/'CIFI','ED I','N GO','TO/P'/
      DATA E(1777),E(1778),E(1779),E(1780)/'ATER','N ST','ATEM','ENT '/
      DATA E(1781),E(1782),E(1783),E(1784)/'TOO ','MANY',' ARG','UMEN'/
      DATA E(1785),E(1786),E(1787),E(1788)/'TS S','PECI','FIED',' IN '/
      DATA E(1789),E(1790),E(1791),E(1792)/'GOTO','/PAT','ERN ','STAT'/
      DATA E(1793),E(1794),E(1795),E(1796)/'EMEN','T. A','RGST','K TA'/
      DATA E(1797),E(1798),E(1799),E(1800)/'BLE ','OVER','FLOW','    '/
      DATA E(1801),E(1802),E(1803),E(1804)/'ILLE','GAL ','ARGU','MENT'/
      DATA E(1805),E(1806),E(1807),E(1808)/' OR ','UNEV','EN N','UMBE'/
      DATA E(1809),E(1810),E(1811),E(1812)/'R OF',' ARG','UMEN','TS I'/
      DATA E(1813),E(1814),E(1815),E(1816)/'N PP','OPTN',' STA','TEME'/
      DATA E(1817),E(1818),E(1819),E(1820)/'NT  ','TOO ','MANY',' ARG'/
      DATA E(1821),E(1822),E(1823),E(1824)/'UMEN','TS I','N IN','CR L'/
      DATA E(1825),E(1826),E(1827),E(1828)/'IST ','INVA','LID ','CONT'/
      DATA E(1829),E(1830),E(1831),E(1832)/'ROL ','STAT','EMEN','T. A'/
      DATA E(1833),E(1834),E(1835),E(1836)/'RGUM','ENT ','IGNO','RED '/
      DATA E(1837),E(1838),E(1839),E(1840)/'DUPL','ICAT','E NA','ME O'/
      DATA E(1841),E(1842),E(1843),E(1844)/'F DI','MENS','IONE','D VA'/
      DATA E(1845),E(1846),E(1847),E(1848)/'RIAB','LES ','RESE','RV I'/
      DATA E(1849),E(1850),E(1851),E(1852)/'NVAL','ID I','N MA','CRO '/
      DATA E(1853),E(1854),E(1855),E(1856)/'PROG','RAM ','CLDA','T SE'/
      DATA E(1857),E(1858),E(1859),E(1860)/'CTIO','N NE','STED',' OR '/
      DATA E(1861),E(1862),E(1863),E(1864)/'STAT','EMEN','T IN',' WRO'/
      DATA E(1865),E(1866),E(1867),E(1868)/'NG S','EQUE','NCE.','    '/
      DATA E(1869),E(1870),E(1871),E(1872)/'INVA','LID ','ARGU','MENT'/
      DATA E(1873),E(1874),E(1875),E(1876)/' IN ','OBTA','IN S','TATE'/
      DATA E(1877),E(1878),E(1879),E(1880)/'MENT','    ','INCO','RREC'/
      DATA E(1881),E(1882),E(1883),E(1884)/'T NU','MBER',' OF ','ARGU'/
      DATA E(1885),E(1886),E(1887),E(1888)/'MENT','S OR',' INV','ALID'/
      DATA E(1889),E(1890),E(1891),E(1892)/' ARG','UMEN','T   ','INVA'/
      DATA E(1893),E(1894),E(1895),E(1896)/'LID ','INCL','USIV',' SUB'/
      DATA E(1897),E(1898),E(1899),E(1900)/'SCRI','PT F','ORMA','T   '/
      DATA E(1901),E(1902),E(1903),E(1904)/'A,B ','AND ','C IN',' INC'/
      DATA E(1905),E(1906),E(1907),E(1908)/'LUSI','VE S','UBSC','RIPT'/
      DATA E(1909),E(1910),E(1911),E(1912)/' FOR','MAT ','MUST',' BE '/
      DATA E(1913),E(1914),E(1915),E(1916)/'EXPL','ICIT',' INT','EGER'/
      DATA E(1917),E(1918),E(1919),E(1920)/'S   ','UNEV','EN N','UMBE'/
      DATA E(1921),E(1922),E(1923),E(1924)/'R OF',' ARG','UMEN','TS  '/
      DATA E(1925),E(1926),E(1927),E(1928)/'INVA','LID ','ARGU','MENT'/
      DATA E(1929),E(1930),E(1931),E(1932)/' SHO','ULD ','BE O','N OR'/
      DATA E(1933),E(1934),E(1935),E(1936)/' OFF','INVA','LID ','ARGU'/
      DATA E(1937),E(1938),E(1939),E(1940)/'MENT',' SHO','ULD ','BE P'/
      DATA E(1941),E(1942),E(1943),E(1944)/'S OR',' A S','SURF',' NAM'/
      DATA E(1945),E(1946),E(1947),E(1948)/'E   ','THER','E IS',' NO '/
      DATA E(1949),E(1950),E(1951),E(1952)/'ASSI','GNME','NT T','O AR'/
      DATA E(1953),E(1954),E(1955),E(1956)/'GUME','NT: ','....','....'/
      DATA E(1957),E(1958),E(1959),E(1960)/' IN ','MACR','O : ','....'/
      DATA E(1961),E(1962),E(1963),E(1964)/'....','SYMB','OLIC',' NAM'/
      DATA E(1965),E(1966),E(1967),E(1968)/'E TA','BLE ','OVER','FLOW'/
      DATA E(1969),E(1970),E(1971),E(1972)/'. SY','MBOL',' IGN','ORED'/
      DATA E(1973),E(1974),E(1975),E(1976)/'    ','TABL','E OV','ERFL'/
      DATA E(1977),E(1978),E(1979),E(1980)/'OW F','OR N','UMER','ICAL'/
      DATA E(1981),E(1982),E(1983),E(1984)/' MAC','RO A','SSIG','NMEN'/
      DATA E(1985)/'TS. '/
      END
**** SOURCE FILE : M0006690.W06   ***
*
C
C              FORTRAN SUBROUTINE TSSMIL
C
C LINKAGE      SUBROUTINE TSSMIL
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    PRO026
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    BINBCD
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    CONCAT
C          INTEGER FCT.  NUMB
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  SEARCH
C          SUBROUTINE    TWOARG
C
      SUBROUTINE TSSMIL
C
      IMPLICIT INTEGER (A-Z)
C
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF THE PART PROGRAM NAME SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),NUMBER(2),TEMP(2),PERMID(2),VBL(2),IDENT(2),
     *          CANON(2)
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C CANON:       (1)=CODE CLASS 42000,(2)=NAMTBL INDEX OF 'CANON '
      EQUIVALENCE (CANON(1),CODE(83))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C        8.    NAME TABLE POINTERS TO BCD LITERALS
C
      COMMON/BCDPTR/BCDPTR
      DIMENSION BCDPTR(7)
C DOTTAB:      NAMTBL POINTER TO ALPHAMERIC LITERAL '$$TAB'
      EQUIVALENCE (DOTTAB,BCDPTR(7))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12)
C ZEROPT:      NAMTBL POINTER TO '0.    '
      EQUIVALENCE (ZEROPT,NUMPTR(2))
C ONEPT:       NAMTBL POINTER TO '1.    '
      EQUIVALENCE (ONEPT,NUMPTR(4))
C
C       10.    TABLE STORAGE FOR GEOMETRIC FUNCTION PROCESSOR
C
      INCLUDE (GMTY)    
C GEOLOC:      GEOMETRIC ,PRODUCTION STARTING INDEX IN GEOMTB
C PMIDTB:      INTERNAL BIT REPRESENTATIONS FOR EACH ELEMENT OF GEOMTB
C GEOMTB:      GEOMETRIC FORMAT PRODUCTIONS ARRANGED BY SURFACE TYPE
C
C       12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE
      DIMENSION CFSIZE(205),MAXSIZ(2)
C MAXSIZ:      SIZE OF THE LAST LARGEST LARGE DATA ARRAY
      EQUIVALENCE (MAXSIZ(1),CFSIZE(4))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C REPL:        CONTAINS COMMAND CODE (17) FOR REPL COMMAND
      EQUIVALENCE (REPL,IL(17))
C MOVE:        CONTAINS COMMAND CODE (19) FOR MOVE COMMAND
      EQUIVALENCE (MOVE,IL(19))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C LINE:        MODE CODE ( 1) FOR LINE
      EQUIVALENCE (LINE,MODX(1))
C PLANE:       MODE CODE ( 2) FOR PLANE
      EQUIVALENCE (PLANE,MODX(2))
C POINT:       MODE CODE (19) FOR POINT
      EQUIVALENCE (POINT,MODX(19))
C REAL:        MODE CODE (21) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C SSURF:       MODE CODE (29) FOR SCULPTURED SURFACE
      EQUIVALENCE (SSURF,MODX(29))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C DLR:         CONTAINS OPERAND TYPE CODE 1
      EQUIVALENCE (DLR,OPMOD(2))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(135),APTXXX(120)
C APTXXX:      NAMTBL POINTERS FOR XECUTION SUBROUTINE NAMES
      EQUIVALENCE (APTXXX(1),SUBLST(1))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C*
      CHARACTER*6 DPS(2),SMIL(6)
      CHARACTER IBUFF*15,BLANK*4
      DIMENSION LOC(4),ARG(5)
      DATA DPS,BLANK,OFFSET /'DS  ','PS  ','    ',25/
      DATA SMIL /'SCON  ','SMIL  ','GOMILL','GCLEAR','INTSEC','AVCTRL'/
C**
C     PREPARE MODES AND PERMANENT IDENTIFIERS OF THE ARGSTK ARGUMENTS
C          AND MOVE THEM TO STACK(2,TOP+1) AND HIGHER ADDR.
C
      IF(ARGTOP.LT.1)GOTO 4000
      TP=TOP+1
      STACK(2,TP)=-1
      DO 40 ERRPT=1,ARGTOP
      NN=0
      J=ARGSTK(ERRPT)
      IF(J.GT.NAMMAX)GOTO 20
      CLASS=NAMTBL(J)/MODULO*MODULO
      MM=NAMTBL(J)-CLASS
      IF(MM.GT.MODHLF)MM=MM-MODHLF
      IF(CLASS.NE.PERMID(1).AND.CLASS.NE.CANON(1))GOTO 10
      NN=50
      MM=MM+NN
      GOTO 30
   10 IF(CLASS.EQ.VBL(1).OR.CLASS.EQ.TEMP(1).OR.MM.EQ.OFFSET)GOTO 30
      IF(CLASS.NE.NUMBER(1))GOTO 4030
   20 MM=REAL
   30 TP=TP+1
      STACK(1,TP)=MM-NN
   40 STACK(2,TP)=PMIDTB(MM)
C
C
C     BRANCH IF INTSEC STATEMENT OR DEFINE START OF SEARCHING
C
      SNAME=STACK(1,TOP-1)
      DO 50 TYP=1,6
        IF(CNAMTB(STACK(1,TOP-1)).NE.SMIL(TYP))GOTO 50
        GOTO(  60,  60,  70,  65,2000,  72),TYP
   50 CONTINUE
      ERRPT=1-TOP
      GOTO 4060
C
C                   START OF SCON/, SMIL/ PRODUCTIONS
   60 GL=GEOLOC(50)
      GOTO 75
C                   START OF GCLEAR/ PRODUCTIONS
   65 GL=GEOLOC(46)
      LPROD=1
      DO 66 I=1,4
      ARG(I)=1
   66 LOC(I)=0
      ARG(5)=1
      GOTO 76
C                  START OF GOMILL/ PRODUCTIONS
   70 GL=GEOLOC(47)
      GOTO 75
C                  START OF AVCTRL/ PRODUCTIONS
   72 GL=GEOLOC(45)
C
C     SEARCH FOR THE PRODUCTION NUMBER AND BRANCH
C
   75 LPROD=0
   76 KK=ARGTOP
      IEND=0
   80 ERRPT=KK
      TPT2=TP*2
      PROD=SEARCH(STACK,TPT2,GEOMTB(GL),ERRPT)
      IF(PROD.EQ.200)GOTO 4050
      IF(LPROD.GT.0)GOTO 90
      J=PROD/5+1
      IF(CNAMTB(STACK(1,TOP-1)).NE.SMIL(J))GOTO 4020
C                   PRODUCTION NUMBERS
C             1    2    3    4    5    6    7    8    9   10
   90 GOTO( 100, 200, 300,3000, 500, 600, 600,4050,4050,1000,
C            11   12   13   14   15   16   17   18   19   20
     *     1000,1200,1300,1400,1600,1600,1600,1600,1600,1700,
C            21   22   23   24   25   26   27   28   29   30
     *     1700,1700,1700,1650,1800,3000,2700,2800,2900,2950),PROD
      GOTO 4050
C
C     CONTROL OF SCON/INIT,DS,PS,FEED,....
C     NO CONTROL OF MULTIPLE DEFINITIONS
C
  100 IF(KK.EQ.2)GOTO 3000
      TP=TP-1
      KK=KK-1
      STACK(2,TP)=STACK(2,TP+1)
      GOTO 80
C
C     CONTROL OF OPTIONAL 'OFFSET' IN SCON/DS,......
C
  200 MM=ARGTOP
      NN=1
      IF(ERRPT.LE.0)GOTO 610
      IF(STACK(1,TOP+1+ERRPT).NE.OFFSET)GOTO 4030
      ERRPT=ERRPT-1
      GOTO 610
C
C     CONTROL SCON/PS,....
C
  300 MM=ARGTOP
      NN=2
      IF(ERRPT.LE.0)GOTO 610
      GOTO 510
C
C     CONTROL SMIL/PATH,..  SMIL/ZIGZAG,... SMIL/PICKFD,....
C
  500 MM=ARGTOP-1
      NN=1
      IF(ERRPT.LE.0)GOTO 610
C
C     CONTROL OF OPTIONAL 'REAL'
C
  510 IF(STACK(1,TOP+1+ERRPT).NE.REAL)GOTO 4030
      ERRPT=ERRPT-1
      GOTO 610
C
C     CONTROL SMIL/POSN,..
C
  600 MM=ARGTOP-1
      NN=1
C
C     CONTROL OF 'PS' RSP. 'DS' ,BECAUSE BOTH ARE OF SAME MODE AND CLASS
C
  610 IF(CNAMTB(ARGSTK(MM)).NE.DPS(NN))GOTO 4040
      GOTO 3000
C
C     A P T  COMPATIBLE REGIONAL MILLING
C
C     FIRST (STANDARD) PART OF MULTI-CUT SEQUENCE COMMAND
C           PRODUCTION 13 MAY, 14 MUST FOLLOW
C                        - OR -
C     START UP RESP. SINGLE CUT SEQUENCE COMMAND
C           PRODUCTION 12 SHOULD , 13 MAY FOLLOW
 1000 IF(LPROD.NE.0)GOTO 4070
      IF(ERRPT.EQ.0)GOTO 3000
 1010 TP=ERRPT+4
      KK=ERRPT
      LPROD=PROD
      GOTO 80
C
C     START UP COMMAND COMPLETE
 1200 IF(LPROD.NE.11)GOTO 4070
 1210 IF(MOD(ARGTOP,2).EQ.0)GOTO 4050
      GOTO 3000
C
C     PARAMETERS FOR FOR SINGLE OR MULTI CUT SEQUENCE MILLING
 1300 IF(LPROD.EQ.11)GOTO 3000
      IF(LPROD.NE.10)GOTO 4070
      GOTO 1010
C
C     MULTI CUT SEQUENCE COMMAND COMPLETE
 1400 IF(LPROD.EQ.0)GOTO 3000
      IF(LPROD.NE.10.AND.LPROD.NE.13)GOTO 4070
      GOTO 3000
C
C     REGIONAL MILLING GCLEAR COMMAND
C
 1600 IEND=KK
      IF(KK.NE.ARGTOP)GOTO 3010
 1610 IEND=0
      DO 1620 I=1,5
 1620 ARG(I)=0
      ARG(PROD-14)=1
      J=3
      GOTO 1850
C
 1650 SNAME=ARGSTK(KK-1)
 1700 NN=PROD-19
      IF(ARG(NN).NE.0)GOTO 4070
      ARG(NN)=1
      J=2
      GOTO 1860
C
 1800 IEND=KK
      IF(KK.NE.ARGTOP)GOTO 3010
 1810 IEND=0
      DO 1820 I=1,5
 1820 ARG(I)=1
      J=2
C   K FOR START=3 , FOR THRU=6 , FOR AWAY=11 , FOR BACK=12
 1850 K=MOD(STACK(1,TP),10)+3
      K=K/3
      IF(LOC(K).NE.0)GOTO 4070
      LOC(K)=1
 1860 IF(ERRPT.EQ.0)GOTO 3010
      TP=TP-J
      KK=KK-J
      GOTO 80
C
C     INTERSECTION OF PLANE AND SCULPTURED SURFACE
C
 2000 K=1
      J=ARGSTK(K)
      IF(NAMTBL(J).EQ.CANON(1).OR.STACK(1,TOP+2).EQ.72)K=2
      ERRPT=1
      IF(STACK(1,TP).EQ.LINE.OR.STACK(1,TP).EQ.PLANE)GOTO 2500
      IF(ARGTOP.LE.K)GOTO 4060
      J=TOP+K+1
      L=J+20
      ERRPT=K-1
      DO 2010 I=J,L
      ERRPT=ERRPT+1
      IF(STACK(1,I).NE.SSURF)GOTO 2020
 2010 CONTINUE
      GOTO 4010
 2020 IF(STACK(1,I).NE.73)GOTO 4030
      J=I+1
      L=TP
      IF(L.LT.J)GOTO 4060
      GOTO 2520
C
 2500 IF(STACK(1,TP-1).NE.73)GOTO 2510
      ARGSTK(ARGTOP-1)=ARGSTK(ARGTOP)
      ARGTOP=ARGTOP-1
      STACK(1,TP-1)=STACK(1,TP)
      TP=TP-1
 2510 IF(ARGTOP.LE.K)GOTO 4060
      ERRPT=ARGTOP-41
      IF(ARGTOP.GT.(K+40))GOTO 4010
      J=TOP+K+1
      ERRPT=K-1
      L=TP-1
 2520 DO 2530 I=J,L
      ERRPT=ERRPT+1
      IF(STACK(1,I).NE.SSURF)GOTO 4030
 2530 CONTINUE
      ERRPT=0
      GOTO 3010
C
C.... AVOIDANCE CONTROL LANGUAGE
C
C.... AVCTRL/ON
C            OFF
 2700 SUB=STACK(1,TOP-1)
      ERRPT=1-ARGTOP
      IF (ARGTOP.GT.1) GOTO 4060
      CALL CALLZZ(SUB)
      CALL ARGCVT(ARGSTK(ARGTOP))
      JNULL=NAME('NULL  ')
      CALL ARGCVT(JNULL)
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(JNULL)
      CALL ARGCVT(ZEROPT)
      GOTO 3200
C
C.... AVCTRL/CUTANG,CONST,GAMMA,RANGE,BLOW,BHIGH
C
 2800 IF (LPROD.NE.0) GOTO 4070
      SUB=STACK(1,TOP-1)
      JNULL=NAME('NULL  ')
      CALL CALLZZ(SUB)
      J=NAME('ON    ')
      CALL ARGCVT(J)
      CALL ARGCVT(ARGSTK(ARGTOP))
      CALL ARGCVT(ARGSTK(ARGTOP-2))
      CALL ARGCVT(ARGSTK(ARGTOP-4))
      CALL ARGCVT(ARGSTK(ARGTOP-5))
      IF (ERRPT.EQ.0) THEN
        CALL ARGCVT(JNULL)
        CALL ARGCVT(ZEROPT)
        GOTO 3200
      ELSE
        TP=ERRPT+4
        KK=ERRPT
        LPROD=PROD
        GOTO 80
      ENDIF
C
C.... AVCTRL/[CUTANG,....,] NORMPS
C                           AXIS
 2900 IF (LPROD.EQ.0) THEN
        SUB=STACK(1,TOP-1)
        JNULL=NAME('NULL  ')
        CALL CALLZZ(SUB)
        J=NAME('ON    ')
        CALL ARGCVT(J)
        CALL ARGCVT(JNULL)
        CALL ARGCVT(ZEROPT)
        CALL ARGCVT(ZEROPT)
        CALL ARGCVT(ZEROPT)
        CALL ARGCVT(ARGSTK(ARGTOP))
      ELSE IF (LPROD.EQ.28) THEN
        CALL ARGCVT(ARGSTK(KK))
      ELSE
        GOTO 4070
      ENDIF
      IF (ERRPT.EQ.0) THEN
        CALL ARGCVT(ZEROPT)
        GOTO 3200
      ELSE
        TP=ERRPT+4
        KK=ERRPT
        LPROD=PROD
        GOTO 80
      ENDIF
C
C.... AVCTRL/[CUTANG,...,] NORMPS,LIMIT,DMAX
C                          AXIS
 2950 IF (LPROD.NE.29) GOTO 4070
      IF (ERRPT.GT.0) GOTO 4010
      CALL ARGCVT(ARGSTK(1))
      GOTO 3200
C
C     GENERATE I.L. OUTPUT
C
 3000 IF(ERRPT.GT.0)GOTO 4010
 3010 TP=ARGTOP+TOP+1
      INDEX=-3
 3020 MM=STACK(1,TP)
      NN=ARGSTK(ARGTOP)
      I=1
      IBUFF(8:15)=BLANK
      CALL BINBCD(MM,IBUFF(4:),NCH)
      WRITE (IBUFF(1:3),'(I3)') NCH
      CALL CONCAT(IBUFF,'.')
      J=NUMB(IBUFF(4:15))+NAMMAX
      CALL OPCODE(MOVE)
      CALL TWOARG(INDEX,DOTTAB)
      CALL TWOARG(DLR,J)
      CALL RLSLIN
      INDEX=INDEX-1
      IF (NN.GT.NAMMAX) THEN
        I=TXXXX(1,MM)
      ELSE
        CLASS=NAMTBL(NN)/MODULO*MODULO
        IF(CLASS.NE.PERMID(1).AND.CLASS.NE.CANON(1))I=TXXXX(1,MM)
      ENDIF
      IF(I.EQ.12)I=1
      IF(I.GT.1)GOTO 3030
      I=1
      CALL OPCODE(MOVE)
      GOTO 3040
 3030 CALL OPCODE(REPL)
      CALL ONEARG(I)
 3040 CALL TWOARG(INDEX,DOTTAB)
      CALL ARGCVT(NN)
      CALL RLSLIN
      INDEX=INDEX-I
      ARGTOP=ARGTOP-1
      TP=TP-1
      IF(ARGTOP.GT.IEND) GOTO 3020
      IBUFF(8:15)=BLANK
      CALL BINBCD(-INDEX,IBUFF(4:),NCH)
      WRITE(IBUFF(1:3),'(I3)') NCH
      CALL CONCAT(IBUFF,'.')
      J=NUMB(IBUFF(4:15))+NAMMAX
      CALL OPCODE(MOVE)
      CALL TWOARG(-2,DOTTAB)
      CALL TWOARG(DLR,J)
      CALL RLSLIN
      CALL CALLZZ(APTXXX(92))
      CALL ARGCVT(STACK(1,TOP-1))
      CALL ARGCVT(SNAME)
C
      NOWRDS=40+INDEX
      IF(NOWRDS .LE.MAXSIZ(2)) GOTO 3100
      IF(NOWRDS .GE.MAXSIZ(1)) GO TO 3090
C
C     REPLACE MAXSIZ(2)
C
      MAXSIZ(2)=NOWRDS
      GOTO 3100
C
C     ADJUST BOTH MAXSIZ(1) AND (2)
C
 3090 MAXSIZ(2)=MAXSIZ(1)
      MAXSIZ(1)=NOWRDS
C
 3100 IF(IEND.EQ.0) GOTO 3200
      CALL RLSLIN
      ARGTOP=KK
      TP=ARGTOP+TOP+1
      IF (PROD.EQ.25) GOTO 1810
      GOTO 1610
 3200 RETURN
C
 4000 ERRPT=1-TOP
 4010 CALL ALARM(2052,-ERRPT,8,'TSSMIL  ')
      GOTO 3100
 4020 ERRPT=1-TOP
 4030 CALL ALARM(2021,-ERRPT,8,'TSSMIL  ')
      GOTO 3100
 4040 ERRPT=MM
      GOTO 4060
 4050 IF(ERRPT.LE.0)ERRPT=1
 4060 CALL ALARM(2001,-ERRPT,8,'TSSMIL  ')
      GOTO 3100
 4070 ERRPT=KK
      GOTO 4060
C
      END
**** SOURCE FILE : M0006691.W03   ***
*
C
C              FORTRAN SUBROUTINE TWOARG
C
C LINKAGE      SUBROUTINE TWOARG(I,J)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    ARGCVT
C                                        SUBROUTINE    ASNJPZ
C                                        SUBROUTINE    BOOLIF
C                                        SUBROUTINE    CALMCX
C                                        SUBROUTINE    GOLO
C                                        SUBROUTINE    GOPAT
C                                        SUBROUTINE    INPAT
C                                        SUBROUTINE    LARGES
C                                        SUBROUTINE    LCANON
C                                        SUBROUTINE    MOTION
C                                        SUBROUTINE    PRO020
C                                        SUBROUTINE    PRO021
C                                        SUBROUTINE    PRO026
C                                        SUBROUTINE    PRO027
C                                        SUBROUTINE    RECOG
C                                        SUBROUTINE    RECOGN
C                                        SUBROUTINE    RESRVZ
C                                        SUBROUTINE    SSDEF
C                                        SUBROUTINE    TSSMIL
C
      SUBROUTINE TWOARG(I,J)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)    
C CNUMTB:      NUMBER TABLE
C
C
C       19.    INTERMEDIATE LANGUAGE TEXT
C
      COMMON/ILTEXT/ILTEXT
      LOGICAL COMFIN
      DIMENSION ILTEXT(94),TEXTIN(90)
C COMFIN:      TRUE IF I.L. OPERATION CODE GIVEN
      EQUIVALENCE (COMFIN,ILTEXT(1))
C TPNTRX:      POINTER TO LAST TEXTIN ENTRY
      EQUIVALENCE (TPNTRX,ILTEXT(3))
C TEXTIN:      STORAGE FOR CURRENTLY GENERATED I.L. COMMAND ARGUM.LIST
      EQUIVALENCE (TEXTIN(1),ILTEXT(5))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(8)
C HEXDLR:      CONTAINS OPERAND TYPE CODE 6
      EQUIVALENCE (HEXDLR,OPMOD(7))
C SPTDLR:      CONTAINS OPERAND TYPE CODE 7
      EQUIVALENCE (SPTDLR,OPMOD(8))
C
C       45.    NUMBER TABLE INDICES
C
      INCLUDE (NUMBLK)    
C MNMBND:      LAST NAME TABLE ENTRY TO MACRO ASSIGNED NUMBER SECTION
C NMBRS:       QUANTITY OF NUMBERS IN THE CURRENT STATEMENT
C*
C ARGUMENTS    I         NORMALLY TYPE DESIGNATION OF
C                        ARGUMENT J.  COULD BE A NAME
C                        TABLE (NAMTBL) INDEX OF NUMBER.
C              J         NAME TABLE (NAMTBL) INDEX OF
C**                      ARGUMENT.
      IF (COMFIN) GOTO 10
      IERROR=3
      GO TO 90
   10 IF (TPNTRX.LT.89) GOTO 20
      IERROR=2
   90 CALL ALARM(IERROR,0,8,'TWOARG  ')
      GO TO 100
   20 K=I
      IF(J.LE.(MNMBND+NAMMAX))GOTO 30
C     HEXDLR: INDICATES NON FRACTIONAL REAL LITERAL
C     SPTDLR: INDICATES FRACTIONAL REAL LITERAL
      K=HEXDLR
      IDP=INDEX(CNUMTB(J-NAMMAX),'.')
      IF (CNUMTB(J-NAMMAX)(IDP+1:).EQ.' ') GOTO 30
      K=SPTDLR
      NMBRS=NMBRS+1
   30 TEXTIN(TPNTRX+1) = K
      TEXTIN(TPNTRX+2) = J
      TPNTRX = TPNTRX+2
  100 RETURN
       END
**** SOURCE FILE : M0006692.V01   ***
*
C
C              FORTRAN SUBROUTINE VCTPRD
C
C LINKAGE      SUBROUTINE  VCTPRD(JMP)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          INTEGER FCT.  NAME            SUBROUTINE    RECOG
C          SUBROUTINE    SETCHR
C
      SUBROUTINE  VCTPRD(JMP)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      COMMON/NAMETB/NAMETB
      DIMENSION NAMETB(3007),NAMTBL(3,999)
C NAMTBL:      NAME TABLE OR DICTIONARY
      EQUIVALENCE (NAMTBL(1,1),NAMETB(11))
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),SLASH(2),LPAREN(2),RPAREN(2),DOT(2),PERMID(2)
C LPAREN:      (1)=CODE CLASS  2000,(2)=NAMTBL INDEX OF '(     '
      EQUIVALENCE (LPAREN(1),CODE(3))
C RPAREN:      (1)=CODE CLASS  3000,(2)=NAMTBL INDEX OF ')     '
      EQUIVALENCE (RPAREN(1),CODE(5))
C SLASH:       (1)=CODE CLASS  5000,(2)=NAMTBL INDEX OF '/     '
      EQUIVALENCE (SLASH(1),CODE(9))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C DOT:         (1)=CODE CLASS 25000,(2)=NAMTBL INDEX OF 'DOT   '
      EQUIVALENCE (DOT(1),CODE(49))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(501),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C        5.    PROGRAM CONTROL FLAGS
C
      COMMON/FLAGS/FLAGS
      LOGICAL ENDFLG
      DIMENSION FLAGS(4)
C ENDFLG:      TRUE WHEN SOURCE STATEMENT TOTALLY IN STACK
      EQUIVALENCE (ENDFLG,FLAGS(1))
C
C        7.    STRING STORAGE AREA
C              POINTER TO THE LAST PROCESSED CHARACTER OF A STATEMENT
      COMMON/INPTR/CNT
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL MACRED
      DIMENSION MACXX1(71)
C MACRED:      SET TRUE TO INDICATE INPUT FROM MCBUFF TABLE
      EQUIVALENCE (MACRED,MACXX1(18))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C**
      DATA NMTB/0/
C
      IF(JMP.LT.0)GOTO 10
      JMP=1
      IF(NMTB.EQ.0)GOTO 50
      JMP=2
      TOP=TOP+1
      STACK(1,TOP)=NMTB
      STACK(2,TOP)=META(NAMTBL(1,NMTB)/MODULO)
      GOTO 40
C
C     VECTOR AND SCALAR PRODUCT
C
   10 IF(NAMTBL(1,STACK(1,TOP-2)).EQ.DOT(1))GOTO 30
C
      ARGTOP=2
      ARGSTK(1)=STACK(1,TOP-1)
      I=NAME('$CROSS   ')
      IF(MODULO*(NAMTBL(1,I)/MODULO).EQ.PERMID(1))GOTO 20
      NAMTBL(1,I)=PERMID(1)+40
   20 ARGSTK(2)=I
      STACK (1,TOP-1)=STACK(1,TOP-3)
      STACK (2,TOP-1)=STACK(2,TOP-3)
      CALL SETCHR(TOP-2,SLASH)
      STACK(1,TOP-3)=NAME('VECTOR  ')
      STACK(2,TOP-3)=META(NAMTBL(1,STACK(1,TOP-3))/MODULO)
C
      GOTO 40
C
   30 ARGTOP=1
      NMTB=STACK(1,TOP)
      ARGSTK(1)=STACK(1,TOP-1)
      CALL SETCHR(TOP,RPAREN)
      STACK (1,TOP-1)=STACK(1,TOP-3)
      STACK (2,TOP-1)=STACK(2,TOP-3)
      CALL SETCHR(TOP-2,LPAREN)
      STACK(1,TOP-3)=NAME('DOTF    ')
      STACK(2,TOP-3)=META(NAMTBL(1,STACK(1,TOP-3))/MODULO)
      IF(MACRED)GOTO 50
      ENDFLG=.FALSE.
      CNT=CNT-1
C
   40 NMTB=0
   50 RETURN
C
      END
