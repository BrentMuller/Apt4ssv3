**** SOURCE FILE : M0012333.V01   ***
*
      BLOCK DATA BDCCLR
C
C COMMON FOR REGIONAL STARTUP AND RETRACT VALUES
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      COMMON/CCLEAR/ DIRMOT(3,4)
     *              ,GOFEED(4)
     *              ,GLFEED
     *              ,REGLDA(2)
     *              ,IRETRO(4)
     *              ,IDIRMO(4)
     *              ,ICANIN(4)
     *              ,IFEEDF
C
C              (1) : START
C              (2) : AWAY
C              (3) : BACK
C              (4) : THRU
C DIRMOT(3,4): ARRAY FOR MOTDIR, NORMAL OR VECTOR VALUES
C              (1,I) : VALUES OF MOTDIR AND/OR NORMAL
C              (2,I)
C           OR (1,I) : VALUES OF VECTOR
C              (2,I)
C              (3,I)
C
      DATA DIRMOT /12*0.D0/
C
C GOFEED(4)  : ARRAY FOR MOTION FEEDRAT
C              (1)   : FEDRAT OF START-MOTION (START AT FIRST POINT)
C              (2)   : FEDRAT OF AWAY-MOTION
C              (3)   : FEDRAT OF BACK-MOTION
C              (4)   : FEDRAT OF THRU-MOTION (RETRACT AT LAST POINT)
C
      DATA GOFEED /4*0.D0/
C
C GLFEED     : VARIABLE FOR NORMAL FEDRAT BEFORE GOMILL OR GOLOFT
      DATA GLFEED /0.D0/
C
C REGLDA     : ARRAY FOR CANONICAL FORM OF REGION DATA
      DATA REGLDA /2*0.D0/
C
C IRETRO(4)  : ARRAY FOR START, AWAY, BACK, THRU
C              (1) : START
C              (2) : AWAY
C              (3) : BACK
C              (4) : THRU
C                    0 : NOT USED
C                    1 : CONDITION SET
      DATA IRETRO /4*0/
C
C IDIRMO(4)  : ARRAY FOR START ON AND END CONDITION
C                    0 : NOT SET
C                    1 : MOTDIR AND/OR NORMAL
C                    2 : VECTOR
      DATA IDIRMO /4*0/
C
C ICANIN(4)  : ARRAY FOR THE CANONICAL FORM INDEX OF THE SURFACE
C                    0 : NOT SET
C                    IC: INDEX
      DATA ICANIN /4*0/
C
C IFEEDF     : FLAG (=1) FOR >GOP< TO OUTPUT GLOBAL FEEDRATE
      DATA IFEEDF /0/
C
      END
**** SOURCE FILE : BDGLFL.ORG   ***
*
      BLOCK DATA BDGLFL
C
C.... INITIALIZE COMMON/GLFLGS/
C
      INCLUDE 'GLFLGS.INC'
C
      DATA REGFLG/0/
      DATA RINGFG/.FALSE./
      DATA MOTDIR/0/
      DATA IAUTOG/0/
C
      END
**** SOURCE FILE : M0012242.V01   ***
*
      BLOCK DATA BDPLGL
C
C  INITIALISE COMMON FOR  >GOLOFT/PLOTFT<
C
C
C  VALUES FOR  >GOLOFT/PLOTFT<
      INTEGER IPLGO(26)
C
C  USED CUTTER SEGMENT
      INTEGER JCSEG
C
C  NUMBER OF VALID CUTTER SEGMENTS
      INTEGER NCSEG
C
C  CUTTER SEGMENT IN TLLDAT ARRAYS
      INTEGER ICSEG(10)
C
C  NATURE OF SEGMENT
      INTEGER NLIOCI(10)
C
C  COMPONENTS OF SEGMENT AND UNIT NORMAL POINTING INTO THE CUTTER
      DOUBLE PRECISION COSAL(10)
      DOUBLE PRECISION SINAL(10)
C
C  DISTANCE PARALLEL TO THE CUTTER AXIS
      DOUBLE PRECISION CUTY(10)
C
C  DISTANCE TO THE CUTTER AXIS
      DOUBLE PRECISION CUTX(10)
C
C  ELEMENT LENGTH
      DOUBLE PRECISION CUTL(10)
C
C  VECTOR-COMPONENTS OF THE TOOL-AXIS-VECTOR
      DOUBLE PRECISION VTA(3)
C
      COMMON/PLGOL/IPLGO,JCSEG,NCSEG,ICSEG,NLIOCI,
     *             COSAL,SINAL,
     *             CUTY,CUTX,CUTL,
     *             VTA
C
      DATA IPLGO  /26*0/
      DATA JCSEG  /0/
      DATA NCSEG  /0/
      DATA ICSEG  /10*0/
      DATA NLIOCI /10*0/
      DATA SINAL  /10*0.D0/
      DATA COSAL  /10*0.D0/
      DATA CUTY   /10*0.D0/
      DATA CUTX   /10*0.D0/
      DATA CUTL   /10*0.D0/
      DATA VTA    /3*0.D0/
C
      END
**** SOURCE FILE : M0012230.V01   ***
*
      SUBROUTINE CPLDST(SPV,PLANE,TH,IWAS,DIST,IRET)
C
C   ROUTINE TO CALCULATE THE DISTANCE OF A CUTTER TO/ON/PAST POINT
C    TO A PLANE
C
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C  CONTROL OF TEST-OUTPUT
      COMMON/SSPRT/SSPRT,SSTEST
      LOGICAL SSPRT,SSTEST
C
C  INPUT EVALUATION VALUES OF CUTTER POSITION
      DOUBLE PRECISION SPV(52)
C
C  INPUT PLANE
      DOUBLE PRECISION PLANE(4)
C
C  INPUT THICKNES
      DOUBLE PRECISION TH
C
C  INPUT TO/ON/PAST TYPE (2/3/4)
      INTEGER IWAS
C
C  OUTPUT DISTANCE
      DOUBLE PRECISION DIST
C
C  OUTPUT RETURN CODE (=0 IF OK)
      INTEGER IRET
C
C  TOOL POINT,HELP VECTORS
      DOUBLE PRECISION TP(3),VT(3),VT2(3)
C
C  GOLOFT/PLOTFT COMMON
C
C  USED CUTTER SEGMENT
      INTEGER JCSEG
C
C  NUMBER OF VALID CUTTER SEGMENTS
      INTEGER NCSEG
C
C  CUTTER SEGMENT IN TLLDAT ARRAYS
      INTEGER ICSEG(10)
C
C  NATURE OF SEGMENT
      INTEGER NLIOCI(10)
C
C  COMPONENTS OF SEGMENT AND UNIT NORMAL POINTING INTO THE CUTTER
      DOUBLE PRECISION COSAL(10)
      DOUBLE PRECISION SINAL(10)
C
C  DISTANCE PARALLEL TO THE CUTTER AXIS
      DOUBLE PRECISION CUTY(10)
C
C  DISTANCE TO THE CUTTER AXIS
      DOUBLE PRECISION CUTX(10)
C
C  ELEMENT LENGTH
      DOUBLE PRECISION CUTL(10)
C
      COMMON/PLGOL/ID(24),OBNAM1,JCSEG,NCSEG,ICSEG,NLIOCI,
     *             COSAL,SINAL,
     *             CUTY,CUTX,CUTL
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C CHECK TOOL POSITION INFORMATION
      IF(IWAS.GE.2.AND.IWAS.LE.4) GOTO 5
      IRET=MAX0(IRET,1)
      IF(.NOT.SSTEST)RETURN
C
C  WRONG TOOL AXIS INFORMATION.
      CALL AERR(22223,'CPLDST  ')
      CALL BAD(1,0,'IWAS',IWAS)
      RETURN
C
C  MOVE TOOL TIP
    5 DO 10 I=1,3
   10 TP(I)=SPV(32+I)
C
C  ON-CONDITION ?
      IF(IWAS.EQ.3) GOTO 90
C
C  COMPUTE COSIN OF ANGLE BETWEEN TOOL AXIS AND PLANE
      COSANG=SPV(37)*PLANE(1)
     *      +SPV(38)*PLANE(2)
     *      +SPV(39)*PLANE(3)
      IF(IWAS.EQ.4) COSANG=-COSANG
C
C  FIND TOOL SEGMENT
      DO 20 I=1,NCSEG
      IF(NLIOCI(I).EQ.1) GOTO 20
      JCSEG=I
      IF(COSAL(I).LE.COSANG) GOTO 25
   20 CONTINUE
C
C  COMPUTE VECTOR PERPTO AXIS AND PERPTO PLANE NORMAL
   25 CALL CROSS(PLANE,SPV(37),VT)
C
C  COMPUTE LENGTH OF THIS VECTOR
      VLL=VT(1)*VT(1)+VT(2)*VT(2)+VT(3)*VT(3)
C
C  TAKE ONLY TOOL TIP, IF VLL TOO SMALL
      IF(VLL.LE.1.D-10) GOTO 90
      VLL=DSQRT(VLL)
C
C  COMPUTE VECTOR PERPENTICULAR TO TOOL AXIS AND POINTING TO PLANE
      CALL CROSS(VT,SPV(37),VT2)
C
C  INVERT VLL FOR PAST CONDITION
      IF(IWAS.EQ.4) VLL=-VLL
C
C  COMPUTE FACTOR FOR TO AND PAST CONDITION
      FACT=1.D0
      IF(IWAS.EQ.4) FACT=-1.D0
C
C  COMPUTE CUTTER POINT
      DO 40 I=1,3
   40 TP(I)=TP(I)
     *           +SPV(36+I)*CUTY(JCSEG)
     *           +VT2(   I)*CUTX(JCSEG)/VLL
     *           -PLANE( I)*(CUTL(JCSEG)+TH)*FACT
C
C  COMPUTE DISTANCE
   90 DIST=TP(1)*PLANE(1)
     *    +TP(2)*PLANE(2)
     *    +TP(3)*PLANE(3)
     *    -PLANE(4)
C
      RETURN
      END
**** SOURCE FILE : M0011488.V01   ***
*
      SUBROUTINE GCLEAR(CNAME)
C
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C
C PROCESSES THE GCLEAR STATEMENT
C
      COMMON/CCLEAR/ DIRMOT(3,4)
     *              ,GOFEED(4)
     *              ,GLFEED
     *              ,REGLDA(2)
     *              ,IRETRO(4)
     *              ,IDIRMO(4)
     *              ,ICANIN(4)
      INCLUDE 'BLANKCOM.INC'
C
      LOGICAL CKDEF
      CHARACTER*6 HPOS,HARG,TEST
      DIMENSION HPOS(6),HARG(5),LCNN(7),CNAME(1)
      INTEGER ADDRSS
C
      DATA HPOS /'START ','AWAY  ','BACK  ','THRU  ','ON    ','OFF   '/
      DATA HARG /'MOTDIR','NORMAL','PARLEL','FEED  ','CLEARS'/
      DATA LCNN /7,7,10,10,7,4,10/
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C SET DEFAULT GLFEED
      IF(GLFEED.EQ.0.D0) GLFEED=50.D0
C
      IS=4
      IE=SSCAN(2)-1
C
C             DEFINE COLUMN, I.E. POSITION OF TOOL MOTION
      K=0
      DO 10 MP=1,6
      CALL HOLFRM(SSCAN(IS),TEST,1,6,NWD)
      IF(TEST.NE.HPOS(MP)) GOTO 10
      IF(MP-5)20,4,6
    4 K=1
    6 DO 8 I=1,4
    8 IRETRO(I)=K
      GOTO 15
   10 CONTINUE
C
C             NO CONDITIONS CHANGED
   15 GOTO 999
C
C             ZERO LOCATIONS MP IN THE /CCLEAR/ ARRAYS
   20 IS=IS+2
      IRETRO(  MP)=0
      CALL HOLFRM(SSCAN(IS),TEST,1,6,NWD)
      IF(TEST.EQ.HPOS(6)) GOTO 15
      IRETRO(  MP)=1
      IF(TEST.EQ.HPOS(5)) GOTO 15
C
C FEED PARAMETER
      IF(TEST.NE.HARG(4)) GOTO 25
      GOFEED(MP)=SSCAN(IS+2)
      IS=IS+4
      IF(IS.LT.IE) GOTO 25
      GOTO 115
C
   25 DO 30 I=1,3
   30 DIRMOT(I,MP)=0.D0
      IDIRMO(  MP)=0
      ICANIN(  MP)=0
C
C             SET FLAGS AND VALUES FOR MOTION CONDITIONS
   40 CALL HOLFRM(SSCAN(IS),TEST,1,6,NWD)
      DO 50 I=1,5
      IF(TEST.NE.HARG(I)) GOTO 50
      GOTO( 60, 60, 70, 80, 90),I
   50 CONTINUE
C
C             NO FURTHER CONDITION CHANGE
      GOTO 999
C
C             MOTION DIRECTION OR NORMAL DIRECTION (FLAG AND VALUE)
   60 IDIRMO(MP)=1
      DIRMOT(I,MP)=SSCAN(IS+2)
      GOTO 100
C
C             MOTION DIRECTION OR NORMAL DIRECTION (FLAG AND VALUE)
   70 IS=IS+2
      IF(CKDEF(SSCAN(IS)))GOTO 130
      K=IS-1
      DO 75 I=1,3
   75 DIRMOT(I,MP)=SSCAN(K+I)
      IDIRMO(MP)=2
      GOTO 100
C
C             SPECIAL FEEDRATES
   80 GOFEED(MP)=SSCAN(IS+2)
      GOTO 100
C
C             CLEARANCE SURFACES
   90 IF(CKDEF(SSCAN(IS+2)))GOTO 130
      ICANIN(MP)=(ADDRSS(CNAME(1))-ADDRSS(COM(1)))/8+1
      I=SSCAN(IS+1)
      K=5
      IF(I.LT.8)K=LCNN(I)
      IS=IS+K
      GOTO 110
C
  100 IS=IS+4
  110 IF(IS.LT.IE)GOTO 40
C
C IF NO MOTION, SET MOTION-DIRECTION ZERO
  115 IF(DIRMOT(1,MP).EQ.0.D0.AND.
     *   DIRMOT(2,MP).EQ.0.D0.AND.
     *   DIRMOT(3,MP).EQ.0.D0) IDIRMO(MP)=0
C
C SET DEFAULT FOR FEED, IF ZERO-FEDRAT GIVEN
      IF(GOFEED(MP).EQ.0.D0) GOFEED(MP)=50.D0
C
  120 GOTO 999
C
  130 CALL ERROR(5157,'GCLEAR  ')
      GOTO 120
C
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0012335.V02   ***
*
      SUBROUTINE SETVER(W)
C
C ROUTINE SETVER SETS THE STARTING VALUES FOR INTERSECTION
C
C STORES ARRAY W IN ARRAY W1 IN COMMON/VERCOM FOR USE BY GETVER
C
C       W1     : I: DEFINITION OF 1ST LINE: START POINT (U1,V1)
C                                           END   POINT (U2,V2)
C                    W1(1) = U1
C                    W1(2) = V1
C                    W1(3) = U2-U1
C                    W1(4) = V2-V1
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      DIMENSION W1(4),W(4)
C
      COMMON/VERCOM/UMIN1,UMAX1,VMIN1,VMAX1,W1
C
      DO 10 I=1,4
        W1(I)=W(I)
   10 CONTINUE
C
      UMIN1=DMIN1(W1(1),W1(1)+W1(3))
      UMAX1=DMAX1(W1(1),W1(1)+W1(3))
      VMIN1=DMIN1(W1(2),W1(2)+W1(4))
      VMAX1=DMAX1(W1(2),W1(2)+W1(4))
      END
C
      SUBROUTINE GETVER(W2,RESULT,IRES)
C
C ROUTINE   GETVER COMPUTES THE INTERSECTION
C       W2     : I: DEFINITION OF 2ND LINE: START POINT (U3,V3)
C                                           END   POINT (U4,V4)
C                    W2(1) = U3
C                    W2(2) = V3
C                    W2(3) = U4-U3
C                    W2(4) = V4-V3
C       RESULT : O: RESULTING VALUES, POINT OF INTERSECTION
C       IRES   : O: =0: NO INTERSECTION
C                   =1: INTERSECTION, RESULT IN RESULT
C                   =2: INTERSECTION, PARALLEL LINES,
C                        UPON EACH OTHER
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      DIMENSION W1(4), W2(4), RESULT(2)
C
      COMMON/VERCOM/UMIN1,UMAX1,VMIN1,VMAX1,W1
C
      IRES=0
C
      IF(UMIN1.GT.DMAX1(W2(1),W2(1)+W2(3))) RETURN
      IF(UMAX1.LT.DMIN1(W2(1),W2(1)+W2(3))) RETURN
      IF(VMIN1.GT.DMAX1(W2(2),W2(2)+W2(4))) RETURN
      IF(VMAX1.LT.DMIN1(W2(2),W2(2)+W2(4))) RETURN
C
      IF(((W2(1)-W1(1))*W1(4)  -
     *    (W2(2)-W1(2))*W1(3)) *
     *   ((W2(1)+W2(3) -W1(1)) *W1(4) -
     *    (W2(2)+W2(4) -W1(2)) *W1(3))
     *                            .GT.0.D0) RETURN
C
      IF(((W1(1)-W2(1))*W2(4)  -
     *    (W1(2)-W2(2))*W2(3)) *
     *   ((W1(1)+W1(3) -W2(1)) *W2(4) -
     *    (W1(2)+W1(4) -W2(2)) *W2(3))
     *                            .GT.0.D0) RETURN
C
C INTERSECT THE 1ST AND 2ND LINE
      A1= W1(4)
      A2=-W1(3)
      A3= W1(4)*W1(1)-W1(3)*W1(2)
      B1= W2(4)
      B2=-W2(3)
      B3= W2(4)*W2(1)-W2(3)*W2(2)
C
C  CHECK FOR PARALLEL
      D=A2*B1-A1*B2
      IF(DABS(D).LT.1D-10)GOTO 50
      RESULT(1)=-(A3*B2-A2*B3)/D
      RESULT(2)=(A3*B1-A1*B3)/D
      IRES=1
      GOTO 60
   50 IRES=2
   60 CONTINUE
CCCCC WRITE(6,100)IRES,W1,W2,RESULT
CC100 FORMAT(' IRES,W1,W2,RESULT:'/I3/1X,4F20.5/1X,4F20.5/1X,2F20.5)
C
      RETURN
      END
**** SOURCE FILE : M0012232.V01   ***
*
      SUBROUTINE GOCHOR(MODC,U1,U2,J11,IRET)
C
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      COMMON/PLGOL/ID(24)
      DOUBLE PRECISION UVCONS,TOL,VL
      EQUIVALENCE (ID(1),UVCONS)
      EQUIVALENCE (ID(7),TOL)
      EQUIVALENCE (ID(9),VL)
C
C  POINT STORAGE AND CURVATURE
      DOUBLE PRECISION SPV(52,3),K1
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
      TOL2=TOL*TOL
      UI=U1
      UJ=U1
C
C  TANGENT IN SPV (-1)
      IT=4
      IF(MODC.EQ.2.OR.MODC.EQ.3) IT=8
C
C  DIFFERENT KINDS OF CALCULATION
    1 GOTO( 10, 20, 30, 40, 50),MODC
C
C  CURVE
   10 CALL GOP(3,UI,UDUMMY,SPV(1,1),J11,IRET)
C
C  CURVATURE OF A CURVE
      SPSP=0.D0
      SPPSPP=0.D0
      SPSPP=0.D0
      DO 11 I=1,3
      SPI=SPV(4+I,1)
      SPPI=SPV(8+I,1)
      SPSP=SPI*SPI+SPSP
      SPPSPP=SPPI*SPPI+SPPSPP
   11 SPSPP=SPI*SPPI+SPSPP
C
C  OFFSET OF RADIUS
      ZR=0.D0
      IF(DABS(SPSP).LT.1.D-12) GOTO 12
C
C  LENGTH OF THE TANGENT
      TL=DSQRT(SPSP)
      K1=DSQRT((DABS(SPSP*SPPSPP-SPSPP*SPSPP)/SPSP/SPSP/SPSP))
      GOTO 60
   12 K1=1.D18
      GOTO 60
C
C  CURVATURE AT VARIABLE V
   20 CONTINUE
   30 CALL GOP(3,UVCONS,UI,SPV(1,1),J11,IRET)
C
C  K=N/G
      K1=SPV(51,1)/SPV(47,1)
C
C  LENGTH OF TANGENT
      TL=DSQRT(SPV(47,1))
C
C  OFFSET OF RADIUS
      ZR=SPV(52,1)
      GOTO 60
C
C  CURVATURE AT VARIABLE  U
   40 CONTINUE
   50 CALL GOP(3,UI,UVCONS,SPV(1,1),J11,IRET)
C
C  K=L/E
      K1=SPV(49,1)/SPV(45,1)
C
C  LENGTH OF THE TANGENT
      TL=DSQRT(SPV(45,1))
C
C  OFFSET OF RADIUS
      ZR=SPV(52,1)
      GOTO 60
C
C  CACULATION OF THE STEP OUT U-DISTANCE
   60 IF(K1.LT.0.D0)ZR=-ZR
      K1=DABS(K1)
      R1=1.D0/(K1+1.D-12)
      IF(R1.LT.TOL) GOTO 61
      IF(ZR.EQ.0.D0) GOTO 63
      R1=R1+ZR
      IF(R1.LE.0.D0)GOTO 61
      TL=TL/(R1-ZR)*R1
   63 DU=2.D0*DSQRT(TOL*(R1+R1-TOL))/TL
      GOTO 62
   61 DU=TOL
C  R1 LESS THAN THE TOLERANCE
      CALL AERR(-22221,'GOCHOR  ')
   62 CONTINUE
C
C  LENGTH COMPUTING OF THE CUT
      IF(DU*TL.LT.VL) GOTO 64
      DU=DU*VL*.99D0/TL
   64 CONTINUE
      GOTO(110,120,130,140,150),MODC
C
C  U2 IS BIGGER THAN   U1
  110 CONTINUE
  120 CONTINUE
  140 IANZ=(U2-UI)/DU
      ANZ=IANZ+1
      DU=(U2-UI)/ANZ
      UJ=UI+DU+.0000001D0
      IF(UJ.GT.U2) UJ=U2
      GOTO 160
C
C  U1 IS BIGGER THAN  U2
  130 CONTINUE
  150 IANZ=(UI-U2)/DU
      ANZ=IANZ+1
      DU=(UI-U2)/ANZ
      UJ=UI-DU-.0000001D0
      IF(UJ.LT.U2) UJ=U2
      GOTO 160
C
C  COMPUTATION OF THE NEW ENDPOINT AND CONTROL OF THE CHORD
  160 GOTO(210,220,230,240,250),MODC
  210 CONTINUE
  240 CONTINUE
  250 CALL GOP(1,UJ          ,UVCONS,SPV(1,2),J11,IRET)
      CALL GOP(1,(UJ+UI)/2.D0,UVCONS,SPV(1,3),J11,IRET)
      GOTO 260
  220 CONTINUE
  230 CALL GOP(1,UVCONS,          UJ,SPV(1,2),J11,IRET)
      CALL GOP(1,UVCONS,(UJ+UI)/2.D0,SPV(1,3),J11,IRET)
      GOTO 260
C
C  DISTANCE VALUES :
  260 AB=QABPST(SPV(1,1),SPV(1,2),SPV(1,3))
      IF(AB.LE.TOL2) GOTO 270
      UJ=(UI+UJ)/2.D0
      GOTO 160
C
C  CONTROL OF THE LENGTH OF A CUT
  270 VL1=DSQRT((SPV(1,2)-SPV(1,1))**2
     *         +(SPV(2,2)-SPV(2,1))**2
     *         +(SPV(3,2)-SPV(3,1))**2)
C
      IF(VL1.LE.VL) GOTO 280
      DU=DU*VL*.9D0/VL1
      GOTO 64
C
C  CONTROL OF THE TURNING POINT
  280 IF((SPV(IT+2,1)*SPV(IT+3,3)-SPV(IT+3,1)*SPV(IT+2,3))
     *  *(SPV(IT+2,3)*SPV(IT+3,2)-SPV(IT+3,3)*SPV(IT+2,2))
     *  +(SPV(IT+3,1)*SPV(IT+1,3)-SPV(IT+1,1)*SPV(IT+3,3))
     *  *(SPV(IT+3,3)*SPV(IT+1,2)-SPV(IT+1,3)*SPV(IT+3,2))
     *  +(SPV(IT+1,1)*SPV(IT+2,3)-SPV(IT+2,1)*SPV(IT+1,3))
     *  *(SPV(IT+1,3)*SPV(IT+2,2)-SPV(IT+2,3)*SPV(IT+1,2)))
     * 285,290,290
  285 UJ=(UI+UJ)/2.D0
      GOTO 160
  290 UI=UJ
C
C  FINISHED ?
      IF(UJ.NE.U2) GOTO 1
C
C  THE LAST POINT WILL BE OUTPUT IN THE CALLING PROGRAM
      RETURN
      END
**** SOURCE FILE : M0012234.V04   ***
*
      SUBROUTINE GOL(ADRESS)
C
C  MAIN DISPATCHING ROUTINE FOR GOLOFT/PLOTFT
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C  CANONICAL FORM OF SS GEOMETRY
      DIMENSION ADRESS(3)
C
C  HELP ARRAY FOR VECTOR TRANSFORMATION
      DOUBLE PRECISION VTAX(3),VT1(4)
      EQUIVALENCE(VT1(2),VTAX(1))
      INCLUDE 'DARRAY.INC'
C
C   STORAGE FOR REGION SEGMENTS
      DOUBLE PRECISION UV(4,25)
C
C  GOLOFT COMMON
      INTEGER JCSEG,NCSEG
      INTEGER ICSEG(10),NLIOCI(10)
      DOUBLE PRECISION COSAL(10),SINAL(10),CUTY(10),CUTX(10),CUTL(10)
C
C  VECTOR-COMPONENTS OF THE TOOL-AXIS-VECTOR
      DOUBLE PRECISION VTA(3)
                             
      COMMON/PLGOL/ID(24),OBNAM1,JCSEG,NCSEG,ICSEG,NLIOCI,
     *             COSAL,SINAL,CUTY,CUTX,CUTL,VTA
C
      DOUBLE PRECISION UVCONS,UVA,UVE,TOL,VL
C
C UVCONS:    U-, V- CONSTANTS, GIVEN BY "UCONST,U" OR "VCONST,V"
      EQUIVALENCE (ID( 1),UVCONS)
C
C UVA:       STARTPARAMETER GIVEN BY "START,S"
      EQUIVALENCE (ID( 3),UVA   )
C
C UVE:       ENDPARAMETER GIVEN BY "THRU,T"
      EQUIVALENCE (ID( 5),UVE   )
C
C TOL:       INCREMENTS BY "INCR,I", ERROR OF CHORD BY "CHORD,C"
      EQUIVALENCE (ID( 7),TOL   )
C
C VL:        LENGTH-PARAMETER GIVEN BY "LENGTH,L"
      EQUIVALENCE (ID( 9),VL    )
C
C NU:        AMOUNT OF INTERMEDIATE LINES IN DIRECTION    UCONST
      EQUIVALENCE (ID(11),NU    )
C
C NV:        AMOUNT OF INTERMEDIATE LINES IN DIRECTION    VCONST
      EQUIVALENCE (ID(12),NV    )
C
C IART:      IART = 1   PLOTFT/SCURV,.........,PARAM,....
C            IART = 2   PLOTFT/SCURV,.........,FLOW ,....
C            IART = 3   PLOTFT/SSURF,UCONST,U,...........
C            IART = 4   PLOTFT/SSURF,VCONST,V,...........
C            IART = 5   PLOTFT/SSURF,GRID,...............
C            IART = 6   GOLOFT/SSURF,UCONST,U,...........
C            IART = 7   GOLOFT/SSURF,VCONST,V,...........
      EQUIVALENCE (ID(13),IART  )
C
C INVERS:    INVERSION OF THE POINT-SEQUENCE
      EQUIVALENCE (ID(14),INVERS)
C
C MIRROR:    INVERSION OF THE MANUFACTURED SIDE  (DIRECTION OF NORMAL)
      EQUIVALENCE (ID(15),MIRROR)
C
C NORMAL:   =1, IF  TLAXIS/NORMPS GIVEN; SURFACE-NORMAL = AXIS-DIRECTION
      EQUIVALENCE (ID(16),NORMAL)
C
C INCR:     =1 IF "INCR,I", =0 IF "CHORD,C" GIVEN
      EQUIVALENCE (ID(17),INCR  )
C
C IAT:       IAT   = 0 AT NOT PROGRAMMED
C            IAT   = 1 AT   "AT,A",        = 2 AT   "AT,TO,PL1"
C            IAT   = 3 AT   "AT,ON,PL1,    = 4 AT   "AT,PAST,PL1
      EQUIVALENCE (ID(18),IAT   )
C
C ISTRT:     ISTRT = 0 START NOT PROGRAMMED
C            ISTRT = 1 AT   "START,A",     = 2 AT   "START,TO,PL1"
C            ISTRT = 3 AT   "START,ON,PL1, = 4 AT   "START,PAST,PL1
      EQUIVALENCE (ID(19),ISTRT )
C
C ITHRU:     ITHRU = 0 THRU NOT PROGRAMMED
C            ITHRU = 1 AT   "THRU,A",      = 2 AT   "THRU,TO,PL1"
C            ITHRU = 3 AT   "THRU,ON,PL1,  = 4 AT   "THRU,PAST,PL1
      EQUIVALENCE (ID(20),ITHRU )
C
C   LOGIC-FUNCTION FOR CHECKING THE GEOMETRY
      LOGICAL CKDEF
C
C  BLANK-COMMON
      INCLUDE 'BLANKCOM.INC'
C
C  OUTPUT-ARRAY OF THE HEADER
      DOUBLE PRECISION OBNAME,MODF(7)
      CHARACTER*8 CMODF(7)
      DOUBLE PRECISION LEIT(9)
      INTEGER ILEIT(18),IMODF(2,7)
      EQUIVALENCE (LEIT(7),OBNAME),(LEIT(1),ILEIT(1))
      EQUIVALENCE (MODF(1),IMODF(1,1))
      DOUBLE PRECISION PENUP (5)
      EQUIVALENCE (PENUP (1),IPENU(1))
      INTEGER IPENU(10)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'GLFLGS.INC'
C
C  SYSTEM - INPUT/OUTPUT-NAMES
      INCLUDE 'SYMFIL.INC'
C
C  STORAGE OF POINTS
      DOUBLE PRECISION SPV(52)
C
C  CONTROL OF TEST-OUTPUT
      COMMON/SSPRT/SSPRT,SSTEST
      LOGICAL SSPRT,SSTEST
C
      INTEGER Z4E
      PARAMETER (Z4E=1308622848)
C
      INTEGER BCDF
      LOGICAL FIRST
      SAVE FIRST,LEIT,PENUP
C
      DATA CMODF/'PLOTKP  ','PLOTKF  ','PLOTFU  ','PLOTFV  ','PLOTGR  ',
     +          'GOFLU   ','GOFLV   '/
      DATA VT1/20030000.0D0,3*.0D0/
      DATA ILEIT/0,0,Z4E,0,Z4E,6,Z4E,1,0,0,Z4E,0,0,0,Z4E,0,Z4E,0/
      DATA IPENU/0,0,Z4E,0,Z4E,2,Z4E,2,0,0/
      DATA FIRST/.TRUE./
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C     INITIALISE CHARACTER ITEMS FOR OUTPUT TO EXFILE
C
      IF (FIRST) THEN
        DO 5 I=1,7
          IMODF(1,I)=BCDF(CMODF(I)(1:4))
          IMODF(2,I)=BCDF(CMODF(I)(5:8))
    5   CONTINUE
        ILEIT(1)=BCDF('CLDA')
        ILEIT(2)=BCDF('TA  ')
        IPENU(1)=BCDF('PENU')
        IPENU(2)=BCDF('P   ')
        IPENU(9)=BCDF('    ')
        IPENU(10)=IPENU(9)
        FIRST=.FALSE.
      ENDIF
      IF(.NOT.SSTEST) GOTO 22
      CALL CFORM('1 GOLOFT/PLOTFT-CALLED WITH IART=  ',DARRAY,1,34)
      CALL ICONV(IART,DARRAY,34,4)
      CALL CPRINT(DARRAY)
      CALL CFORM('  PART PROGRAM-SEQUENCE-N0. (ISN): ',DARRAY,1,34)
      CALL RECORD(I)
      CALL ICONV(I,DARRAY,34,4)
      CALL CPRINT(DARRAY)
      CALL CFORM('0  -U-, V- CONSTANTS         UVCONS=',DARRAY,1,36)
      CALL FCONV(UVCONS,DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -START PARAMETER             UVA=',DARRAY,1,36)
      CALL FCONV(UVA   ,DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -END PARAMETER               UVE=',DARRAY,1,36)
      CALL FCONV(UVE   ,DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -TOLERANCE                   TOL=',DARRAY,1,36)
      IF(INCR.EQ.1) CALL CFORM('   -INCREMENT ',DARRAY,1,14)
      CALL FCONV(TOL   ,DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -MAX.CUT-VECTOR               VL=',DARRAY,1,36)
      CALL FCONV(VL    ,DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -NO. INTERMEDIATE LINES-U     NU=',DARRAY,1,36)
      CALL ICONV(NU    ,DARRAY,36,5)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -NO. INTERMEDIATE LINES-V     NV=',DARRAY,1,36)
      CALL ICONV(NV    ,DARRAY,36,5)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -INTERPOLATION-MODE         IART=',DARRAY,1,36)
      CALL ICONV(IART  ,DARRAY,36,5)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -POINT SEQ. INVERSION     INVERS=',DARRAY,1,36)
      CALL ICONV(INVERS,DARRAY,36,5)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -SPIMANUF. SIDE INVERSION    MIRROR=',DARRAY,1,36)
      CALL ICONV(MIRROR,DARRAY,36,5)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -NORMALS REQUIRED         NORMAL=',DARRAY,1,36)
      CALL ICONV(NORMAL,DARRAY,36,5)
      CALL CPRINT(DARRAY)
      IC1=ICS
      IC2=ICS+LSV1
      CALL CFORM('   -AT    CONDITION              AT=',DARRAY,1,36)
      CALL ICONV(IAT,DARRAY,36,5)
      CALL CPRINT(DARRAY)
      IF(IAT.LT.2.OR.IAT.GT.4) GOTO 7
      CALL CFORM('   -THICK FOR CHECKSURFACE 1     TH=',DARRAY,1,36)
      CALL FCONV(TH(IC1),DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -OUTTOL                     TAU1=',DARRAY,1,36)
      CALL FCONV(TAU1(IC1),DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -INTOL                      TAU2=',DARRAY,1,36)
      CALL FCONV(TAU2(IC1),DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
    7 CALL CFORM('   -START CONDITION           START=',DARRAY,1,36)
      CALL ICONV(ISTRT,DARRAY,36,5)
      CALL CPRINT(DARRAY)
      IF(ISTRT.LT.2.OR.ISTRT.GT.4) GOTO 8
      CALL CFORM('   -THICK FOR CHECKSURFACE 1     TH=',DARRAY,1,36)
      CALL FCONV(TH(IC1),DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -OUTTOL                     TAU1=',DARRAY,1,36)
      CALL FCONV(TAU1(IC1),DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -INTOL                      TAU2=',DARRAY,1,36)
      CALL FCONV(TAU2(IC1),DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
    8 CALL CFORM('   -THRU  CONDITION            THRU=',DARRAY,1,36)
      CALL ICONV(ITHRU,DARRAY,36,5)
      CALL CPRINT(DARRAY)
      IF(ITHRU.LT.2.OR.ITHRU.GT.4) GOTO 9
      CALL CFORM('   -THICK FOR CHECKSURFACE 2     TH=',DARRAY,1,36)
      CALL FCONV(TH(IC2),DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -OUTTOL                     TAU1=',DARRAY,1,36)
      CALL FCONV(TAU1(IC2),DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
      CALL CFORM('   -INTOL                      TAU2=',DARRAY,1,36)
      CALL FCONV(TAU2(IC2),DARRAY,36,15,6)
      CALL CPRINT(DARRAY)
    9 CALL CFORM('   -SURFACE NAME                   :',DARRAY,1,36)
      CALL UNPACK(ADRESS,MODE,ISIZE,ISBSCT)
      CALL HOLFRM(ADRESS(3),DARRAY,36,8,N)
      IF(ISBSCT.LT.1) GOTO 10
      CALL HOLFRM(ADRESS(ISBSCT*3),DARRAY,36,8,N)
      CALL CFORM(' (....) ',DARRAY,44,8)
      CALL ICONV(ISBSCT,DARRAY,46,4)
   10 CALL CPRINT(DARRAY)
C
C  COMMON START OF ROUTINE
C
C  NAME OF THE SURFACE
   22 CALL UNPACK(ADRESS,MODE,ISIZE,ISBSCT)
      OBNAME=ADRESS(ISIZE+1)
      IF(ISBSCT.GT.1)OBNAME=ADRESS(ISBSCT*ISIZE+ISBSCT)
      OBNAM1=OBNAME
C
C   SAVE REGION FLAG ANS SWITCH OFF GLOBAL REGION FLAG TO PREVENT
C                        REGION PROCESSING IF PROGRAMMED IN ATAPE
      REGFLS=REGFLG
      REGFLG=0
C
C  FETCHING THE SURFACE
      LDAFLG=3
      CALL APT094(LDAFLG,ADRESS,J11)
      J11=J11-41
C
C  TAKE OLD TLAXIS FOR 5-AXIS DIRECTION DECISION
      IF(MANTAX.NE.2.OR.NORMAL.EQ.1) GOTO 200
      DO 210 I=1,3
  210 VTAX(I)=TA(I)
      CALL TRANSM(VTA,VTAX,3,3,-1)
  200 CONTINUE
C
C PREPARATION FOR PLANE LIMITS
      IRET=0
      INCR1=INCR
      INCR=1
      CALL GOLPLN(J11,IRET)
      INCR=INCR1
C
C  WRONG TOOL AXIS INFORMATION.
      IF(IRET.EQ.1) CALL AERR(22223,'GOL     ')
C
C  TOOL-AXIS CAN NOT BE COMPUTED.
      IF(IRET.EQ.2) CALL AERR(22222,'GOL     ')
C
C  POINT IS OUTSIDE OF THE U/V PARAMETERS OF THE PATCH.
      IF(IRET.EQ.3) CALL AERR(22220,'GOL     ')
      IF(IRET.NE.0) GOTO 998
C
C  TAKE OLD TLAXIS FOR 5-AXIS DIRECTION DECISION
      IF(MANTAX.NE.2.OR.NORMAL.EQ.1) GOTO 300
      DO 310 I=1,3
  310 VTAX(I)=TA(I)
      CALL TRANSM(VTA,VTAX,3,3,-1)
  300 CONTINUE
C
C  OUTPUT OF    PENUP, IF  PLOTFT/GRID WANTED
      IF(IART.NE.5) GOTO 30
      NR=0
      J=10
      CALL RECORD(ISEQNO)
      IPENU(4)=ISEQNO
      CALL EWRITE(EXFILE,NR,PENUP,J,IR)
C
C  OUTPUT OF THE HEADER ONLY FOR >PLOTFT/SCURV,...<
   30 IF(IART.GT.2)GOTO 35
      NR=0
      J=18
      CALL RECORD(ILEIT(4))
      ISEQNO=ILEIT(4)
      LEIT(5)=MODF(IART)
      CALL EWRITE(EXFILE,NR,LEIT,J,IR)
      ICL=2
      IF(UVA.EQ.UVE)ICL=3
C
C  DISPATCHING OF IART
   35 IF(UVA.EQ.-1.D30) UVA=0.D0
      GOTO(1200,1100,1300,1400,1500,1600,1700),IART
      STOP
C
C  PLOTFT/CURVE,FLOW,...
 1100 UMX=SSCAN(J11+8)
C
C  IF NEEDED OUTPUT WITH 'PARAM'
      IF(UMX.EQ.0.D0) UMX=SSCAN(J11+4)
C
C  KEEP THE 'FLOW'-SEGMENT-ACCOUNT
      UHILFS=SSCAN(J11+8)
      GOTO 1210
C
C  PLOTFT/CURVE,PARAM,...
 1200 UMX=SSCAN(J11+4)
C
C  KEEP THE 'FLOW'-SEGMENT-ACCOUNT
      UHILFS=SSCAN(J11+8)
C
C  'FLOW'-SEGMENT-ACCOUNT =0 FOR A SHORT TIME
      SSCAN(J11+8)=0.D0
 1210 UA=DMAX1(.0D0,UVA)
      IF(UVE.EQ.1.D30) UVE=UMX
      UE=DMIN1(UVE,UMX)
      IANZ=(UE-UA)/TOL
      ANZ=IANZ
      IF(IANZ.EQ.0) ANZ=1.D0
      ANZ=ANZ-.0001
      TOLI=(UE-UA)/ANZ
      IF(UA.GE.UE) GOTO 1205
      IF(UVA.GE.0.D0) GOTO 1220
 1205 CALL GOP(2,UVA,UDUMMY,SPV,J11,IRET)
      IF(UA.GE.UE) GOTO 1240
 1220 IF(INCR.EQ.1) GOTO 1221
C
C  OUTPUT OF POINTS UNDER CHORD-CONTROL
      CALL GOCHOR (1,UA,UE,J11,IRET)
      GOTO 1222
C
C  MOVEMENT WITH 'INCR'
 1221 CALL GOP(2,UA,UDUMMY,SPV,J11,IRET)
      UA=UA+TOLI
      IF(UA.LT.UE) GOTO 1221
 1222 IF(UE.EQ.UVE)ICL=3
      CALL GOP(2,UE,UDUMMY,SPV,J11,IRET)
      IF(UE.EQ.UVE) GOTO 1260
 1240 IF(ICL.EQ.3) GOTO 1260
      ICL=3
      CALL GOP(2,UVE,UDUMMY,SPV,J11,IRET)
 1260 SSCAN(J11+8)=UHILFS
      GOTO 999
C
C  PLOTTING OF THE GRID
 1500 INVERS=0
      INVER1=1
      IF(NU.LT.0) GOTO 1510
      UVCONS=0.D0
      UVA=0.D0
      UVE=SSCAN(J11+9)-1.D0
      DELTUV=1.D0/(NU+1)
      UMX=SSCAN(J11+10)-1.D0
      GOTO 1300
 1510 IF(NV.LT.0) GOTO 999
      UVCONS=0.D0
      UVA=0.D0
      UVE=SSCAN(J11+10)-1.D0
      DELTUV=1.D0/(NV+1)
      VMAX=SSCAN(J11+9)-1.D0
      GOTO 1400
C
C  PLOTTING OR MANUFACTURING WITH    UCONST
 1300 CONTINUE
 1600 VMAX=SSCAN(J11+9)-1.D0
      IF(UVE.EQ.1.D30) UVE=VMAX
C
C  PRESET >NSEG< AND >LSEG< TO ZERO FOR REGION/OFF CASE
      NSEG=0
      LSEG=0
C  COMPUTE THE SEGMENTS
      IF(REGFLS.EQ.0)GOTO 1604
      CALL NUMVER(UVCONS,UVA,UVCONS,UVE,ADRESS,UV,NSEG)
      LDAFLG=3
      CALL APT094(LDAFLG,ADRESS,J11)
      J11=J11-41
      IF(NSEG.EQ.0)GOTO 1552
      IF(INVERS.EQ.1)GOTO 1602
C
C  PREPARATION OF REGION SEGMENT CUTS
      ISEG=1
 1601 UVCONS=UV(1,ISEG)
      UVA   =UV(2,ISEG)
      UVE   =UV(4,ISEG)
      LSEG=3
      IF(ISEG.EQ.1)LSEG=1
      ISEG=ISEG+1
      NSEG=NSEG-1
      GOTO 1604
C
C  PREPARATION OF INVERS REGION SEGMENT CUTS
 1602 ISEG=NSEG
      NNSEG=NSEG
 1603 UVCONS=UV(1,ISEG)
      UVA   =UV(2,ISEG)
      UVE   =UV(4,ISEG)
      LSEG=2
      IF(ISEG.EQ.NNSEG)LSEG=4
      ISEG=ISEG-1
      NSEG=NSEG-1
 1604 CONTINUE
      VA=DMAX1(.0D0,UVA)
      VE=DMIN1(UVE,VMAX)
C
C  COMPUTING OF A CUT-NUMBER WITHOUT REST
      IANZ=(VE-VA)/TOL
      ANZ=IANZ
      IF(IANZ.EQ.0) ANZ=1.D0
      ANZ=ANZ-.0001
      TOLI=(VE-VA)/ANZ
C
C  INVERS ?
      IF(INVERS.EQ.1) GOTO 1650
C
C  CUTTER PATH INTRODUCTION
      IF(LSEG.EQ.0)LSEG=1
      ICL=2
      IF(UVA.EQ.UVE)ICL=3
      CALL GORETR(LSEG,UVCONS,UVA,SPV,J11,IRET)
C
C  NOT   INVERS
      IF(VA.GE.VE) GOTO 1605
      IF(UVA.GE.0.D0) GOTO 1620
 1605 CALL GOP(2,UVCONS,UVA,SPV,J11,IRET)
      IF(VA.GE.VE) GOTO 1640
 1620 IF(INCR.EQ.1) GOTO 1621
C
C  OUTPUT OF POINTS UNDER CONTROL OF CHORD
      CALL GOCHOR (2,VA,VE,J11,IRET)
      GO TO 1622
C
C  MOVEMENTS WITH 'INCR'
 1621 CALL GOP(2,UVCONS,VA,SPV,J11,IRET)
      VA=VA+TOLI
      IF(VA.LT.VE) GOTO 1621
 1622 IF(VE.EQ.UVE) ICL=3
      CALL GOP(2,UVCONS,VE,SPV,J11,IRET)
      IF(VE.EQ.UVE) GOTO 1550
 1640 IF(ICL.EQ.3) GOTO 1550
      ICL=3
      CALL GOP(2,UVCONS,UVE,SPV,J11,IRET)
      GOTO 1550
C
C  INVERS
C
C  CUTTER PATH INTRODUCTION
 1650 IF(LSEG.EQ.0)LSEG=4
      ICL=2
      IF(UVA.EQ.UVE)ICL=3
      CALL GORETR(LSEG,UVCONS,UVE,SPV,J11,IRET)
      IF(VA.GE.VE) GOTO 1655
      IF(UVE.LE.VMAX) GOTO 1670
 1655 CALL GOP(2,UVCONS,UVE,SPV,J11,IRET)
      IF(VA.GE.VE) GOTO 1690
 1670 IF(INCR.EQ.1) GOTO 1671
C
C  OUTPUT OF POINTS UNDER CONTROL OF CHORD
      CALL GOCHOR (3,VE,VA,J11,IRET)
      GO TO 1672
C
C  MOVEMENT WITH 'INCR'
 1671 CALL GOP(2,UVCONS,VE,SPV,J11,IRET)
      VE=VE-TOLI
      IF(VA.LT.VE) GOTO 1671
 1672 IF(VA.EQ.UVA) ICL=3
      CALL GOP(2,UVCONS,VA,SPV,J11,IRET)
      IF(VA.EQ.UVA) GOTO 1550
 1690 IF(ICL.EQ.3) GOTO 1550
      ICL=3
      CALL GOP(2,UVCONS,UVA,SPV,J11,IRET)
C
C  RETRACT AT END OF SEGMENT
 1550 IF(INVERS.EQ.1)GOTO 1551
      LSEG=2
      IF(NSEG.EQ.0)LSEG=4
      CALL GORETR(LSEG,UVCONS,UVE,SPV,J11,IRET)
      IF(NSEG.NE.0)GOTO 1601
      GOTO 1552
 1551 LSEG=3
      IF(NSEG.EQ.0)LSEG=1
      CALL GORETR(LSEG,UVCONS,UVA,SPV,J11,IRET)
      IF(NSEG.NE.0)GOTO 1603
 1552 IF(IART.NE.5) GOTO 999
      INVERS=INVERS+INVER1
      INVER1=-INVER1
      UVCONS=UVCONS+DELTUV
      IF(UVCONS.LE.UMX) GOTO 1300
      NU=-1
      GOTO 1500
C
C  PLOTTING OR MANUFACTURING WITH VCONST
 1400 CONTINUE
 1700 UMX=SSCAN(J11+10)-1.D0
      IF(UVE.EQ.1.D30) UVE=UMX
C
C  PRESET >NSEG< AND >LSEG< TO ZERO FOR REGION/OFF CASE
      NSEG=0
      LSEG=0
C  COMPUTE THE SEGMENTS
      IF(REGFLS.EQ.0)GOTO 1704
      CALL NUMVER(UVA,UVCONS,UVE,UVCONS,ADRESS,UV,NSEG)
      LDAFLG=3
      CALL APT094(LDAFLG,ADRESS,J11)
      J11=J11-41
      IF(NSEG.EQ.0)GOTO 1562
      IF(INVERS.EQ.1)GOTO 1702
C
C  PREPARATION OF REGION SEGMENT CUTS
      ISEG=1
 1701 UVCONS=UV(2,ISEG)
      UVA   =UV(1,ISEG)
      UVE   =UV(3,ISEG)
      LSEG=3
      IF(ISEG.EQ.1)LSEG=1
      ISEG=ISEG+1
      NSEG=NSEG-1
      GOTO 1704
C
C  PREPARATION OF INVERS REGION SEGMENT CUTS
 1702 ISEG=NSEG
      NNSEG=NSEG
 1703 UVCONS=UV(2,ISEG)
      UVA   =UV(1,ISEG)
      UVE   =UV(3,ISEG)
      LSEG=2
      IF(ISEG.EQ.NNSEG)LSEG=4
      ISEG=ISEG-1
      NSEG=NSEG-1
 1704 CONTINUE
      UA=DMAX1(.0D0,UVA)
      UE=DMIN1(UVE,UMX)
C
C  COMPUTATION OF THE CUT-NUMBER WITHOUT REST
      IANZ=(UE-UA)/TOL
      ANZ=IANZ
      IF(IANZ.EQ.0) ANZ=1.D0
      ANZ=ANZ-.0001
      TOLI=(UE-UA)/ANZ
C
C  INVERS ?
      IF(INVERS.EQ.1) GOTO 1750
C
C  CUTTER PATH INTRODUCTION
      IF(LSEG.EQ.0)LSEG=1
      ICL=2
      IF(UVA.EQ.UVE)ICL=3
      CALL GORETR(LSEG,UVA,UVCONS,SPV,J11,IRET)
C
C  NOT  INVERS
      IF(UA.GE.UE) GOTO 1705
      IF(UVA.GE.0.D0) GOTO 1720
 1705 CALL GOP(2,UVA,UVCONS,SPV,J11,IRET)
      IF(UA.GE.UE) GOTO 1740
 1720 IF(INCR.EQ.1) GOTO 1721
C
C  OUTPUT OF POINTS UNDER CONTROL OF CHORD
      CALL GOCHOR (4,UA,UE,J11,IRET)
      GO TO 1722
C
C  MOVEMENT WITH 'INCR'
 1721 CALL GOP(2,UA,UVCONS,SPV,J11,IRET)
      UA=UA+TOLI
      IF(UA.LT.UE) GOTO 1721
 1722 IF(UE.EQ.UVE)ICL=3
      CALL GOP(2,UE,UVCONS,SPV,J11,IRET)
      IF(UE.EQ.UVE) GOTO 1560
 1740 IF(ICL.EQ.3) GOTO 1560
      ICL=3
      CALL GOP(2,UVE,UVCONS,SPV,J11,IRET)
      GOTO 1560
C
C  INVERS
C
C  CUTTER PATH INTRODUCTION
 1750 IF(LSEG.EQ.0)LSEG=4
      ICL=2
      IF(UVA.EQ.UVE)ICL=3
      CALL GORETR(LSEG,UVE,UVCONS,SPV,J11,IRET)
      IF(UA.GE.UE) GOTO 1755
      IF(UVE.LE.UMX) GOTO 1770
 1755 CALL GOP(2,UVE,UVCONS,SPV,J11,IRET)
      IF(UA.GE.UE) GOTO 1790
 1770 IF(INCR.EQ.1) GOTO 1771
C
C  OUTPUT OF POINTS UNDER CONTROL OF CHORD
      CALL GOCHOR (5,UE,UA,J11,IRET)
      GO TO 1772
C
C  MOVEMENT WITH 'INCR'
 1771 CALL GOP(2,UE,UVCONS,SPV,J11,IRET)
      UE=UE-TOLI
      IF(UA.LT.UE) GOTO 1771
 1772 IF(UA.EQ.UVA) ICL=3
      CALL GOP(2,UA,UVCONS,SPV,J11,IRET)
      IF(UA.EQ.UVA) GOTO 1560
 1790 IF(ICL.EQ.3) GOTO 1560
      ICL=3
      CALL GOP(2,UVA,UVCONS,SPV,J11,IRET)
C
C  RETRACT AT END OF SEGMENT
 1560 IF(INVERS.EQ.1)GOTO 1561
      LSEG=2
      IF(NSEG.EQ.0)LSEG=4
      CALL GORETR(LSEG,UVE,UVCONS,SPV,J11,IRET)
      IF(NSEG.NE.0)GOTO 1701
      GOTO 1562
 1561 LSEG=3
      IF(NSEG.EQ.0)LSEG=1
      CALL GORETR(LSEG,UVA,UVCONS,SPV,J11,IRET)
      IF(NSEG.NE.0)GOTO 1703
 1562 IF(IART.NE.5) GOTO 999
      INVERS=INVERS+INVER1
      INVER1=-INVER1
      UVCONS=UVCONS+DELTUV
      IF(UVCONS.LE.VMAX) GOTO 1400
      NV=-1
      GOTO 999
C
C  DIRECTION OF MOVEMENT
  999 DO 2000 I=1,3
 2000 TEMP(I)=TE(I)-TEK(I)
      CALL VNORM(TEMP,TI)
      IGOTO=0
      IF(IER.GT.0) GOTO 998
      IF(DABS(TI(1)*TA(1)+TI(2)*TA(2)+TI(3)*TA(3)).GT..997D0) GOTO 998
      DO 2010 I=1,3
 2010 PMOVE(I)=TI(I)
C
C
C  POINT IS OUTSIDE OF THE U/V PARAMETERS OF THE PATCH.
      IF(IRET.EQ.2) CALL AERR(22220,'GOL     ')
C
C   RESTURE GLOBAL REGION FLAG
  998 REGFLG=REGFLS
      RETURN
      END
**** SOURCE FILE : M0012104.V05   ***
*
C
C              FORTRAN SUBROUTINE GOLOFT
C
C LINKAGE      SUBROUTINE GOLOFT
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    PRO026
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    BINBCD
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    CONCAT
C          INTEGER FCT.  NUMB
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  SEARCH
C          SUBROUTINE    TWOARG
C
      SUBROUTINE GOLOFT
C
      IMPLICIT INTEGER (A-Z)
C
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE 'NAMETB.INC'
C NAMMAX:      NAMTBL INDEX OF THE PART PROGRAM NAME SECTION
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),NUMBER(2),TEMP(2),PERMID(2),VBL(2),IDENT(2)
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C        8.    NAME TABLE POINTERS TO BCD LITERALS
C
      COMMON/BCDPTR/BCDPTR
      DIMENSION BCDPTR(7)
C DOTTAB:      NAMTBL POINTER TO ALPHAMERIC LITERAL '$$TAB'
      EQUIVALENCE (DOTTAB,BCDPTR(7))
C
C       10.    TABLE STORAGE FOR GEOMETRIC FUNCTION PROCESSOR
C
      INCLUDE 'GMTY.INC'
C GEOLOC:      GEOMETRIC PRODUCTION STARTING INDEX IN GEOMTB
C PMIDTB:      INTERNAL BIT REPRESENTATIONS FOR EACH ELEMENT OF GEOMTB
C GEOMTB:      GEOMETRIC FORMAT PRODUCTIONS ARRANGED BY SURFACE TYPE
C
C       12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE
      DIMENSION CFSIZE(205),MAXSIZ(2)
C MAXSIZ:      SIZE OF THE LAST LARGEST LARGE DATA ARRAY
      EQUIVALENCE (MAXSIZ(1),CFSIZE(4))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C REPL:        CONTAINS COMMAND CODE (17) FOR REPL COMMAND
      EQUIVALENCE (REPL,IL(17))
C MOVE:        CONTAINS COMMAND CODE (19) FOR MOVE COMMAND
      EQUIVALENCE (MOVE,IL(19))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C REAL:        MODE CODE (21) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C SCURV:       MODE CODE (30) FOR SCULPTURED CURVE
      EQUIVALENCE (SCURV,MODX(30))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C DLR:         CONTAINS OPERAND TYPE CODE 1
      EQUIVALENCE (DLR,OPMOD(2))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(135),APTXXX(120)
C APTXXX:      NAMTBL POINTERS FOR XECUTION SUBROUTINE NAMES
      EQUIVALENCE (APTXXX(1),SUBLST(1))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C*
      DIMENSION LENGTH(42)
      CHARACTER IBUFF*15,BLANK*8
      CHARACTER*6 PLFT,UC,VC,FLW
      DATA PLFT,UC,VC,FLW/'PLOTFT','UCONST','VCONST','FLOW  '/
      DATA BLANK/'        '/
      DATA LENGTH/3,7,6,6,5,3,4,7,5,6,3,5,4,2,3,2,8,6,6,6,4,
     *            4,4,1,7,5,5,5,3,8,6,7,5,7,5,6,4,6,4,5,3,2/
C**
C     PREPARE MODES AND PERMANENT IDENTIFIERS OF THE ARGSTK ARGUMENTS
C          AND MOVE THEM TO STACK(2,TOP+1) AND HIGHER ADDR.
C
      IF(ARGTOP.LT.1)GOTO 4000
      TP=TOP+1
      STACK(2,TP)=-1
      DO 40 ERRPT=1,ARGTOP
      NN=0
      J=ARGSTK(ERRPT)
      IF(J.GT.NAMMAX)GOTO 20
      CLASS=NAMTBL(J)/MODULO*MODULO
      MM=NAMTBL(J)-CLASS
      IF(MM.GT.MODHLF)MM=MM-MODHLF
      IF(CLASS.NE.PERMID(1))GOTO 10
      NN=50
      MM=MM+NN
      GOTO 30
   10 IF(CLASS.EQ.VBL(1).OR.CLASS.EQ.TEMP(1))GOTO 30
      IF(CLASS.NE.NUMBER(1))GOTO 4030
   20 MM=REAL
   30 TP=TP+1
      STACK(1,TP)=MM-NN
   40 STACK(2,TP)=PMIDTB(MM)
C
C
C     SEARCH FOR THE PRODUCTION NUMBER AND BRANCH
C
      KK=ARGTOP
      LPROD=0
      FMT=1
      NN=GEOLOC(48)
   50 ERRPT=KK
      TP2=TP*2
      PROD=SEARCH(STACK,TP2,GEOMTB(NN),ERRPT)
C
      IF(PROD.EQ.200)GOTO 4050
      IF((KK-ERRPT).NE.LENGTH(PROD))GOTO 4090
C
C                   PRODUCTION NUMBERS
C             1    2    3    4    5    6    7    8    9   10   11   12
      GOTO( 100, 200, 200, 200, 200, 200, 200, 300, 300, 300, 300, 300,
C            13   14   15   16   17   18   19   20   21   22   23   24
     *      300, 300, 300, 400, 500, 400, 500, 500, 400, 400, 500, 600,
C            25   26   27   28   29   30   31   32   33   34   35   36
     *      600, 600, 600, 600, 600, 700, 700, 800, 800, 700, 700, 800,
C            37   38   39   40   41   42
     *      800, 900, 900, 900, 900, 900),PROD
C
C     GOLOFT/SSURF,UCONST,U,.............
C
  100 FMT=6
      IF(CNAMTB(STACK(1,TOP-1)).NE.PLFT)GOTO 110
      FMT=3
      STACK(2,TP)=PMIDTB(SCURV)
  110 IF(CNAMTB(ARGSTK(ARGTOP-1)).EQ.VC)FMT=FMT+1
      LPROD=1
      GOTO 2900
C
  200 IF(FMT.LT.6)GOTO 4100
      IF(LPROD.EQ.0.OR.LPROD.GE.PROD)GOTO 4070
      LPROD=7
      GOTO 2900
C
  300 IF(FMT.LT.6)GOTO 4100
      IF(LPROD.EQ.0.OR.LPROD.GE.PROD)GOTO 4070
      GOTO 3000
C                                  FLOW
C     PLOTFT/SCURV,START,S,.......,PARAM,.....
C
  400 JJ=1
      GOTO 510
C
  500 JJ=3
  510 IF(CNAMTB(STACK(1,TOP-1)).NE.PLFT)GOTO 4100
      IF(CNAMTB(ARGSTK(JJ)).EQ.FLW)FMT=2
      GOTO 3000
C
C     PLOTFT/SSURF,UCONST,U,START,S,.......
C     PLOTFT/SCURV,START,S,................
C
  600 GOTO 3000
C
C     PLOTFT/SSURF,GRID,...................
C
  700 JJ=4
      GOTO 810
  800 JJ=3
  810 KK=ARGTOP-2
      IF(CNAMTB(ARGSTK(KK)).NE.UC)GOTO 4080
      KK=ARGTOP-JJ
      IF(CNAMTB(ARGSTK(KK)).NE.VC)GOTO 4080
  900 FMT=5
      IF(CNAMTB(STACK(1,TOP-1)).NE.PLFT)GOTO 4100
      GOTO 3000
C
C     REDUCE STACK BY I
C
 2900 IF(ERRPT.EQ.0)GOTO 3010
      JJ=LENGTH(PROD)-1
      STACK(2,TP-JJ)=STACK(2,TP)
      TP=TP-JJ
      KK=KK-JJ
      GOTO 50
C
C     GENERATE I.L. OUTPUT
C
 3000 IF(ERRPT.GT.0)GOTO 4010
 3010 TP=ARGTOP+TOP+1
      INDEX=-3
      JJ=ARGSTK(ARGTOP)
 3020 MM=STACK(1,TP)
      NN=ARGSTK(ARGTOP)
      I=1
      IBUFF(8:15)=BLANK
      CALL BINBCD(MM,IBUFF(4:),NCH)
      WRITE (IBUFF(1:3),'(I3)') NCH
      CALL CONCAT(IBUFF,'.')
      J=NUMB(IBUFF(4:15))+NAMMAX
      CALL OPCODE(MOVE)
      CALL TWOARG(INDEX,DOTTAB)
      CALL TWOARG(DLR,J)
      CALL RLSLIN
      INDEX=INDEX-1
      IF (NN.GT.NAMMAX) THEN
        I=TXXXX(1,MM)
      ELSE
      IF(NAMTBL(NN)/MODULO*MODULO.NE.PERMID(1))I=TXXXX(1,MM)
      ENDIF
      IF(I.EQ.12)I=1
      IF(I.GT.1)GOTO 3030
      CALL OPCODE(MOVE)
      GOTO 3040
 3030 CALL OPCODE(REPL)
      CALL ONEARG(I)
 3040 CALL TWOARG(INDEX,DOTTAB)
      CALL ARGCVT(NN)
      CALL RLSLIN
      INDEX=INDEX-I
      ARGTOP=ARGTOP-1
      TP=TP-1
      IF(ARGTOP.GT.0) GOTO 3020
      DO 3050 KK=1,2
      IBUFF(8:15)=BLANK
      CALL BINBCD(FMT,IBUFF(4:),NCH)
      WRITE (IBUFF(1:3),'(I3)') NCH
      CALL CONCAT(IBUFF,'.')
      J=NUMB(IBUFF(4:15))+NAMMAX
      CALL OPCODE(MOVE)
      CALL TWOARG(-KK,DOTTAB)
      CALL TWOARG(DLR,J)
      CALL RLSLIN
 3050 FMT=-INDEX
      CALL CALLZZ(APTXXX(92))
      CALL ARGCVT(STACK(1,TOP-1))
      CALL ARGCVT(JJ)
C
      NOWRDS=40+INDEX
      IF(NOWRDS .LE.MAXSIZ(2)) GOTO 3100
      IF(NOWRDS .GE.MAXSIZ(1)) GO TO 3090
C
C     REPLACE MAXSIZ(2)
C
      MAXSIZ(2)=NOWRDS
      GOTO 3100
C
C     ADJUST BOTH MAXSIZ(1) AND (2)
C
 3090 MAXSIZ(2)=MAXSIZ(1)
      MAXSIZ(1)=NOWRDS
C
 3100 RETURN
C
 4000 ERRPT=1-TOP
 4010 CALL ALARM(2052,-ERRPT,8,'GOLOFT  ')
      GOTO 3100
 4030 CALL ALARM(2021,-ERRPT,8,'GOLOFT  ')
      GOTO 3100
 4050 IF(ERRPT.LE.0)ERRPT=1
 4060 CALL ALARM(2001,-ERRPT,8,'GOLOFT  ')
      GOTO 3100
 4070 ERRPT=KK-1
      GOTO 4060
 4080 ERRPT=KK
      GOTO 4060
 4090 ERRPT=ERRPT+1
      GOTO 4010
 4100 ERRPT=1-TOP
      GOTO 4060
C
      END
**** SOURCE FILE : M0012236.V02   ***
*
      SUBROUTINE GOLOVO(ADRESS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C...  1.MAIN CDE PACKAGE. INCLUDED IN EVERY PROGRAM IN THE SUBROUTINE
C...    LIBRARY.
C
      INCLUDE 'TOTAL.INC'
C
      INCLUDE 'ISV.INC'
C
      INCLUDE 'FXCOR.INC'
C
      INCLUDE 'IFXCOR.INC'
C
      INCLUDE 'BLANKCOM.INC'
C
      DOUBLE PRECISION HMOD,WORD
      INTEGER IWORD(2)
      EQUIVALENCE (WORD,IWORD(1))
C
      COMMON/PLGOL/ID(26)
C
C UVCONS: U-, V- CONSTANTS, GIVEN BY "UCONST,U" OR "VCONST,V"
      EQUIVALENCE (ID( 1),UVCONS)
C    UVA: START PARAMETER GIVEN BY "START,S"
      DIMENSION UVA(2)
      EQUIVALENCE (ID( 3),UVA(1))
C    UVE: END PARAMETER GIVEN BY "THRU,T"
      EQUIVALENCE (ID( 5),UVE   )
C    TOL: INCREMENTS BY "INCR,I", ERROR OF CHORD BY "CHORD,C"
      EQUIVALENCE (ID( 7),TOL   )
C     VL: LENGTH-PARAMETER GIVEN BY "LENGTH,L"
      EQUIVALENCE (ID( 9),VL    )
C     NU: AMOUNT OF INTERMEDIATE LINES IN DIRECTION    UCONST
      EQUIVALENCE (ID(11),NU    )
C     NV: AMOUNT OF INTERMEDIATE LINES IN DIRECTION    VCONST
      EQUIVALENCE (ID(12),NV    )
C IART:      IART = 1   PLOTFT/SCURV,.........,PARAM,....
C            IART = 2   PLOTFT/SCURV,.........,FLOW ,....
C            IART = 3   PLOTFT/SSURF,UCONST,U,...........
C            IART = 4   PLOTFT/SSURF,VCONST,V,...........
C            IART = 5   PLOTFT/SSURF,GRID,...............
C            IART = 6   GOLOFT/SSURF,UCONST,U,...........
C            IART = 7   GOLOFT/SSURF,VCONST,V,...........
      EQUIVALENCE (ID(13),IART  )
C INVERS: INVERT THE TRAVEL DIRECTION IF =1
      EQUIVALENCE (ID(14),INVERS)
C MIRROR: INVERT NORMAL DIRECTION IF =1
      EQUIVALENCE (ID(15),MIRROR)
C NORMAL: TAKE THE SURFACE NORMAL AS TOOL AXIS IF =1
      EQUIVALENCE (ID(16),NORMAL)
C   INCR: =1 IF "INCR,I", =0 IF "CHORD,C" GIVEN
C           CURVATURE CALCULATION NECESSARY IF NOT =1
      EQUIVALENCE (ID(17),INCR  )
C    IAT: IAT   = 0 AT NOT PROGRAMMED
C         IAT   = 1 AT   "AT,A",        = 2 AT   "AT,TO,PL1"
C         IAT   = 3 AT   "AT,ON,PL1,    = 4 AT   "AT,PAST,PL1
      EQUIVALENCE (ID(18),IAT   )
C  ISTRT: ISTRT = 0 START NOT PROGRAMMED
C         ISTRT = 1 AT   "START,A",     = 2 AT   "START,TO,PL1"
C         ISTRT = 3 AT   "START,ON,PL1, = 4 AT   "START,PAST,PL1
      EQUIVALENCE (ID(19),ISTRT )
C  ITHRU: ITHRU = 0 THRU NOT PROGRAMMED
C         ITHRU = 1 AT   "THRU,A",      = 2 AT   "THRU,TO,PL1"
C         ITHRU = 3 AT   "THRU,ON,PL1,  = 4 AT   "THRU,PAST,PL1
      EQUIVALENCE (ID(20),ITHRU )
C   IPL1: CF-BEGIN OF THE "AT" OR "START" PLANE IN THE ARRAY SSCAN
      EQUIVALENCE (ID(21),IPL1  )
C   IPL2: CF-BEGIN OF THE "THRU" PLANE IN THE ARRAY SSCAN
      EQUIVALENCE (ID(22),IPL2  )
C  ISCAN: FIRST FREE LOCATION IN SSCAN AFTER GOLOFT DATA
      EQUIVALENCE (ID(23),ISCAN )
C
      LOGICAL CKDEF
      DIMENSION JART(3),ADRESS(1)
      EQUIVALENCE(JART(1),IAT)
C
      CHARACTER*6 TEST,UCONST,VCONST,START,THRU,AT,TO,ON,PAST,PARAM,
     +            FLOW,RINCR,CHORD,RMIROR,RINVRS,RLENGT
      LOGICAL FIRST
      INTEGER BCDF
      SAVE FIRST,HMOD
C
      DATA UCONST/'UCONST'/,   VCONST/'VCONST'/,   START /'START '/
      DATA THRU  /'THRU  '/,   AT    /'AT    '/,   TO    /'TO    '/
      DATA ON    /'ON    '/,   PAST  /'PAST  '/,   PARAM /'PARAM '/
      DATA FLOW  /'FLOW  '/,   RINCR /'INCR  '/,   CHORD /'CHORD '/
      DATA RMIROR/'MIRROR'/,   RINVRS/'INVERS'/,   RLENGT/'LENGTH'/
      DATA RLW /21./
      DATA FIRST/.TRUE./
C
      IF (FIRST) THEN
        IWORD(1)=BCDF('TO  ')
        IWORD(2)=BCDF('    ')
        HMOD=WORD
        FIRST=.FALSE.
      ENDIF
C
      IF(CKDEF(ADRESS)) GOTO 170
C  INITIALIZE PART SURFACE
      IS=IPS
      CALL APT234(HMOD,ADRESS)
      UVA(1)=-1.D30
      UVE   = 1.D30
      TOL=.05
C  USE OF MAXDP/DPMAX,... AS DEFAULT
      VL=DPMAX
      NU=-1
      NV=-1
      DO 1 I=14,22
    1 ID(I)=0
      INCR=1
      IF(GAMMA.NE.0.D0.OR.NUMAX.NE.1)GOTO 5
      IF(DABS(ALP).EQ.0.D0)NORMAL=JTLFLG(IPS)
    5 IART=SSCAN(1)
      ISCAN=SSCAN(2)
      GOTO(45,45,20,20,30,10,10),IART
   10 CALL HOLFRM(SSCAN(ISCAN-3),TEST,1,6,NWD)
      IF (TEST.NE.RLENGT)GOTO 20
      VL=SSCAN(ISCAN-1)
      ISCAN=ISCAN-4
   20 UVCONS=SSCAN(9)
      ICUR=11
      GOTO 50
C
   30 ICUR=9
      CALL HOLFRM(SSCAN(ICUR),TEST,1,6,NWD)
      IF(TEST.NE.UCONST)GOTO 40
      ICUR=ICUR+2
      CALL HOLFRM(SSCAN(ICUR),TEST,1,6,NWD)
      NU=1
      IF(SSCAN(ICUR-1).NE.RLW)GOTO 40
      NU=DABS(SSCAN(ICUR))
      ICUR=ICUR+2
      CALL HOLFRM(SSCAN(ICUR),TEST,1,6,NWD)
   40 IF(TEST.NE.VCONST)GOTO 140
      ICUR=ICUR+2
      CALL HOLFRM(SSCAN(ICUR),TEST,1,6,NWD)
      NV=1
      IF(SSCAN(ICUR-1).NE.RLW)GOTO 140
      NV=DABS(SSCAN(ICUR))
      ICUR=ICUR+2
      CALL HOLFRM(SSCAN(ICUR),TEST,1,6,NWD)
      GOTO 140
C
   45 ICUR=7
   50 IF(ICUR.GE.ISCAN)GOTO 160
      CALL HOLFRM(SSCAN(ICUR),TEST,1,6,NWD)
      IF(TEST.NE.AT)GOTO 60
      K=1
      GOTO 80
   60 IF(TEST.NE.START)GOTO 70
      K=2
      GOTO 80
   70 IF(TEST.NE.THRU)GOTO 120
      K=3
C
   80 ICUR=ICUR+2
      CALL HOLFRM(SSCAN(ICUR),TEST,1,6,NWD)
      JART(K)=1
      IF(SSCAN(ICUR-1).NE.RLW)GOTO 90
      UVA(1+K/3)=SSCAN(ICUR)
      ICUR=ICUR+2
      CALL HOLFRM(SSCAN(ICUR),TEST,1,6,NWD)
      GOTO 110
   90 IF(TEST.EQ.TO  )JART(K)=2
      IF(TEST.EQ.ON  )JART(K)=3
      IF(TEST.EQ.PAST)JART(K)=4
      ICUR=ICUR+2
      IF(CKDEF(SSCAN(ICUR)))GOTO 170
      ID(21+K/3)=ICUR
      ICUR=ICUR+5
      CALL HOLFRM(SSCAN(ICUR),TEST,1,6,NWD)
  110 IF(K.EQ.2)GOTO 70
C
  120 IF(ICUR.GT.ISCAN)GOTO 160
      IF(TEST.EQ.PARAM.OR.TEST.EQ.FLOW) THEN
        ICUR=ICUR+2
        CALL HOLFRM(SSCAN(ICUR),TEST,1,6,NWD)
      ENDIF
      IF(TEST.NE.RINVRS)GOTO 130
      ICUR=ICUR+2
      CALL HOLFRM(SSCAN(ICUR),TEST,1,6,NWD)
      INVERS=1
  130 IF(TEST.NE.RMIROR)GOTO 140
      ICUR=ICUR+2
      CALL HOLFRM(SSCAN(ICUR),TEST,1,6,NWD)
      MIRROR=1
C
  140 IF(TEST.EQ.RINCR)GOTO 150
      IF(TEST.NE.CHORD)GOTO 160
      INCR=0
  150 TOL=SSCAN(ICUR+2)
C
  160 IF(IART.NE.5)GOTO 161
      IF(NU.NE.-1.OR.NV.NE.-1)GOTO 161
      NU=0
      NV=0
  161 CALL GOL(ADRESS)
      RETURN
  170 CALL AERR(5157,'GOLOVO  ')
      IAERR=1
      RETURN
      END
**** SOURCE FILE : M0012238.V01   ***
*
      SUBROUTINE GOLPLN(J11,IRET)
C
C   ROUTINE TO TEST, IF A PLANE IS INVOLVED AND TO CALCULATE A UV VALUE
C
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C  CONTROL OF TEST-OUTPUT
      COMMON/SSPRT/SSPRT,SSTEST
      LOGICAL SSPRT,SSTEST
C
      COMMON/PLGOL/ID(24),OBNAM1
C
C UVCONS:    U-, V- CONSTANT, GIVEN AT  "UCONST,U" OR "VCONST,V"
      EQUIVALENCE (ID( 1),UVCONS)
C
C UVA:       START-PRAMETER, GIVEN BY "START,S"
      EQUIVALENCE (ID( 3),UVA   )
C
C UVE:       END-PARAMETER, GIVEN BY "THRU,T"
      EQUIVALENCE (ID( 5),UVE   )
C
C IART:      IART = 1   PLOTFT/SCURV,.........,PARAM,....
C            IART = 2   PLOTFT/SCURV,.........,FLOW ,....
C            IART = 3   PLOTFT/SSURF,UCONST,U,...........
C            IART = 4   PLOTFT/SSURF,VCONST,V,...........
C            IART = 5   PLOTFT/SSURF,GRID,...............
C            IART = 6   GOLOFT/SSURF,UCONST,U,...........
C            IART = 7   GOLOFT/SSURF,VCONST,V,...........
      EQUIVALENCE (ID(13),IART  )
C
C IAT:       IAT   = 0 : AT NOT PROGRAMMED
C            IAT   = 1 : AT   "AT,A",        = 2 AT   "AT,TO,PL1"
C            IAT   = 3 : AT   "AT,ON,PL1,    = 4 AT   "AT,PAST,PL1
C
      EQUIVALENCE (ID(18),IAT   )
C ISTRT:     ISTRT = 0 : START NOT PROGRAMMED
C            ISTRT = 1 : AT   "START,A",     = 2 AT   "START,TO,PL1"
C            ISTRT = 3 : AT   "START,ON,PL1, = 4 AT   "START,PAST,PL1
      EQUIVALENCE (ID(19),ISTRT )
C
C ITHRU:     ITHRU = 0 : THRU NOT PROGRAMMED
C            ITHRU = 1 : AT   "THRU,A",      = 2 AT   "THRU,TO,PL1"
C            ITHRU = 3 : AT   "THRU,ON,PL1,  = 4 AT   "THRU,PAST,PL1
      EQUIVALENCE (ID(20),ITHRU )
C
C IPL1:      CF-BEGIN OF THE "AT" OR "START" PLANE IN THE ARRAY SSCAN
      EQUIVALENCE (ID(21),IPL1  )
C
C IPL2:      CF-BEGIN OF THE  "THRU" PLANE IN THE ARRAY SSCAN
      EQUIVALENCE (ID(22),IPL2  )
C
C  COMMON TOTAL
      INCLUDE 'TOTAL.INC'
      INCLUDE 'SV.INC'
C
      INCLUDE 'IFXCOR.INC'
C
C  BLANK COMMON
      INCLUDE 'BLANKCOM.INC'
C
C  EVALUATION RESULTS
      DOUBLE PRECISION SPV(52)
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C RETURN IF NOT >GOLOFT<
      IF(IART.NE.6.AND.IART.NE.7) RETURN
C
C LOOP OVER THE 3 POSSIBLE PLANE CONDITIONS: >AT<,>START<,>THRU<
      DO 90 I=1,3
C
C >AT< CONDITION
      IWAS=IAT
      IPL=IPL1
      IIC=ICS
      IF(I.EQ.1) GOTO 1
C
C >START< CONDITION
      IWAS=ISTRT
      IF(I.EQ.2) GOTO 1
C
C >THRU< CONDITION
      IWAS=ITHRU
      IPL=IPL2
      IIC=ICS+LSV1
C
C WITH AT CONDITION,  SET THRU PARAMETER EQUAL START PARAMETER
    1 IF(I.EQ.1.AND.IWAS.NE.0)UVE=UVA
C
C CHECK,  IF PLANE CONDITION
      IF(IWAS.LT.2.OR.IWAS.GT.4) GOTO 90
C
C PROLOG FOR >UCONST<
      IF(IART.NE.6) GOTO 10
      U=UVCONS
      DU=0.D0
      UE=U
      V=0.D0
      DV=.5D0
      VE=SSCAN(J11+9)-1.D0
      GOTO 20
C
C PROLOG FOR >VCONST<
   10 U=0.D0
      DU=.5D0
      UE=SSCAN(J11+10)-1.D0
      V=UVCONS
      DV=0.D0
      VE=V
C
C COMPUTE PLANE ORIENTATION AND SWITCH IF NECESSARY
C  FIRST TOOL TIP IS INVESTIGATED
   20 CALL GOP(1,U,V,SPV,J11,IRET)
C
C NORMALISATION OF INPUT PLANE
      VLL=DSQRT(SSCAN(IPL)**2+SSCAN(IPL+1)**2+SSCAN(IPL+2)**2)
      DO 21 J=1,4
   21 SSCAN(IPL+J-1)=SSCAN(IPL+J-1)/VLL
C
C DISTANCE OF FIRST POINT TO PLANE (DIST=AX+BY+CZ-D)
      DI  =SSCAN(IPL)*SPV(33)
     *    +SSCAN(IPL+1)*SPV(34)
     *    +SSCAN(IPL+2)*SPV(35)
     *    -SSCAN(IPL+3)
C
C INVERSION OF PLANE IF DISTANCE IS NEGETIVE
      IF(DI.GT.0.D0) GOTO 25
      DO 22 J=1,4
   22 SSCAN(IPL+J-1)=-SSCAN(IPL+J-1)
C
C PRESET OLD DISTANCE
   25 CONTINUE
      CALL CPLDST(SPV,SSCAN(IPL),TH(IIC),IWAS,ODIST,IRET)
      DIST=ODIST
      OU=U
      OV=V
      GOTO 35
C
C FIND INTERSECTION (OUTER LOOP)
C  OLD DISTANCE AND OLD PARAMETERS
   30 ODIST=DIST
      OU=U
      OV=V
C
C NEW PARAMETERS
      U=U+DU
      V=V+DV
      IF(U.GT.UE.OR.V.GT.VE) GOTO 80
      CALL GOP(1,U,V,SPV,J11,IRET)
      CALL CPLDST(SPV,SSCAN(IPL),TH(IIC),IWAS,DIST,IRET)
C
C  TOLERANCE INVESTIGATION (OUTTOL)
   35 IF(DIST.GT.TAU1(IIC)) GOTO 30
C
C  INTOL:
      IF(DIST.GE.TAU2(IIC)) GOTO 50
C
C FIND INTERSECTION (INNER LOOP): NESTED INTERVALS
   40 UM=(OU+U)/2.D0
      VM=(OV+V)/2.D0
      CALL GOP(1,UM,VM,SPV,J11,IRET)
      CALL CPLDST(SPV,SSCAN(IPL),TH(IIC),IWAS,DISTM,IRET)
C
C INSIDE OUTTOL TOLERANCE ?
      IF(DISTM.LE.TAU1(IIC)) GOTO 45
C NO
      OU=UM
      OV=VM
      ODIST=DISTM
C
C BREAK FOR UNLIMITED LOOP
      IF(ODIST-DIST.LT.1.D-5) GOTO 50
      GOTO 40
C
C INSIDE INTOL TOLERANCE ?
   45 IF(DIST.GE.TAU2(IIC)) GOTO 50
C NO
      U=UM
      V=VM
      DIST=DISTM
C
C BREAK FOR UNLIMITED LOOP
      IF(ODIST-DIST.LT.1.D-5) GOTO 50
      GOTO 40
C
C  ONE FINAL POINT FOUND
   50 IF(IART.EQ.6.AND.I.NE.3) UVA=V
      IF(IART.EQ.6.AND.I.EQ.3) UVE=V
      IF(IART.EQ.7.AND.I.NE.3) UVA=U
      IF(IART.EQ.7.AND.I.EQ.3) UVE=U
      IF(I.EQ.1) IAT=1
C
C WITH AT CONDITION,  SET THRU PARAMETER EQUAL START PARAMETER
      IF(I.EQ.1) UVE=UVA
      IF(I.EQ.2) ISTRT=1
      IF(I.EQ.3) ITHRU=1
      GOTO 90
C
C NO INTERSECTION BETWEEN GOLOFT CUTTER PATH AND PLANE FOUND
   80 CONTINUE
C
C  POINT OUTSIDE OF U/V PARAMETERS OF THE PATCH
C
C  POINT IS OUTSIDE OF THE U/V PARAMETERS OF THE PATCH.
      IF(SSTEST) CALL AERR(22220,'GOLPLN  ')
      IAERR=1
      IRET=MAX0(IRET,3)
      GOTO 90
C
   90 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0012240.V01   ***
*
      SUBROUTINE GOP(MOD,U,V,SPV,J11,IRET)
C
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'GLFLGS.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISV.INC'
C
C SS - ARELEM - COMMON
      COMMON/SSARLM/BB(64,4),UU(4),VV(4),
     *              IITOP(6,4,4),IIFLAG(4,4),IPNUM(4)
C
C
C  LENGTH OF PROJECTION OF NEW AXIS ON OLD AXIS
      DOUBLE PRECISION AL(2)
C
C  PAIRS OF SIN AND COSIN VALUES
      DOUBLE PRECISION SIND(2),COSD(2)
C
C  TWO POSSIBLE TOOL AXIS IN 4 OR 5 AXIS CASE
      DOUBLE PRECISION AX(3,2)
      DOUBLE PRECISION LEIT(9)
      INTEGER ILEIT(18)
      EQUIVALENCE (LEIT(1),ILEIT(1))
      DOUBLE PRECISION PENUP (5)
      INTEGER IPENU(10)
      EQUIVALENCE (PENUP (1),IPENU(1))
      DOUBLE PRECISION PENDWN(5)
      INTEGER IPEND(10)
      EQUIVALENCE (PENDWN(1),IPEND(1))
      DOUBLE PRECISION FEDRAT(5)
      INTEGER IFEDR(10)
      EQUIVALENCE (FEDRAT(1),IFEDR(1))
C
C  OUTPUT-ARRAY OF THE HEADER
      DOUBLE PRECISION MODF(7)
      INTEGER IMODF(2,7)
      EQUIVALENCE (MODF(1),IMODF(1,1))
      CHARACTER*8 CMODF(7)
C
      COMMON/CCLEAR/ DIRMOT(3,4)
     *              ,GOFEED(4)
     *              ,GLFEED
     *              ,REGLDA(2)
     *              ,IRETRO(4)
     *              ,IDIRMO(4)
     *              ,ICANIN(4)
     *              ,IFEEDF
C
C   GOLOFT/PLOTFT-COMMON
C
      DIMENSION ICSEG(10),NLIOCI(10)
      DIMENSION COSAL(10),SINAL(10)
      DIMENSION CUTY(10),CUTX(10),CUTL(10),VTA(3)
C
      COMMON/PLGOL/ID(24),OBNAM1,JCSEG,NCSEG,ICSEG,NLIOCI,
     *             COSAL,SINAL,
     *             CUTY,CUTX,CUTL,VTA
C     EQUIVALENCE (ID(1),UVCONS)
C     EQUIVALENCE (ID(3),UVA)
C     EQUIVALENCE (ID(5),UVE)
C     EQUIVALENCE (ID(7),TOL)
C     EQUIVALENCE (ID(9),VL)
C     EQUIVALENCE (ID(11),NU)
C     EQUIVALENCE (ID(12),NV)
C
C   IART: 1,2: PLOTING CURVES; 3,4: PLOTING SURFACE LINES
C           5: PLOT SURF GRID; 6,7: SURFACE CUTTING
      EQUIVALENCE (ID(13),IART)
C INVERS: INVERT THE TRAVEL DIRECTION IF =1
C     EQUIVALENCE (ID(14),INVERS)
C MIRROR: INVERT NORMAL DIRECTION IF =1
      EQUIVALENCE (ID(15),MIRROR)
C NORMAL: TAKE THE SURFACE NORMAL AS TOOL AXIS IF =1
      EQUIVALENCE (ID(16),NORMAL)
C   INCR: CURVATURE CALCULATION NECESSARY IF NOT =1
      EQUIVALENCE (ID(17),INCR)
C
C  JCSEG: USED CUTTER SEGMENT
C  NCSEG: NUMBER OF VALID CUTTER SEGMENTS
C  ICSEG: CUTTER SEGMENT IN TLLDAT ARRAYS
C NLIOCI: NATURE OF SEGMENT
C  COSAL: COMPONENTS OF SEGMENT AND UNIT NORMAL
C  SINAL: POINTING INTO THE CUTTER
C   CUTY: DISTANCE PARALLEL TO THE CUTTER AXIS
C   CUTX: DISTANCE TO THE CUTTER AXIS
C   CUTL: ELEMENT LENGTH
C    VTA: VECTOR-COMPONENTS OF THE TOOL-AXIS-VECTOR
C
C     BLANK-COMMON
      INCLUDE 'BLANKCOM.INC'
C
C SYSTEM - I/O NAMES
      INCLUDE 'SYMFIL.INC'
C
C   POINT STORAGE FOR TRANSFORMATION PURPOSE
      DOUBLE PRECISION PT(3),PT1(4)
      EQUIVALENCE(PT1(2),PT(1))
C   VECTOR STORAGE FOR TRANSFORMATION PURPOSE
      DOUBLE PRECISION VT0(3),VT1(4),VT2(3)
      EQUIVALENCE(VT1(2),VT0(1))
C   MOTION DIRECTION AND CROSS VECTOR
      DOUBLE PRECISION DM(3),Q(3)
C   EVALUATION FIELDS
      DOUBLE PRECISION SPV(52),PATCH(64)
      INTEGER IFLAG(4) , ITOP(6,4)
      INCLUDE 'DARRAY.INC'
C
      INTEGER ITEST5
C
C       SS PRINT CONTROL
      COMMON/SSPRT/SSPRT,SSTEST
      LOGICAL SSPRT,SSTEST
C
      INTEGER J11O
C
      INTEGER Z4E,BCDF
      PARAMETER (Z4E=1308622848)
C
      LOGICAL FIRST
      SAVE FIRST,LEIT,PENUP,PENDWN,FEDRAT,MODF
                                              
      DATA ILEIT/0,0,Z4E,0,Z4E,6,Z4E,1,0,0,Z4E,0,0,0,Z4E,0,Z4E,0/
      DATA IPENU/0,0,Z4E,0,Z4E,2,Z4E,2,0,0/
      DATA IPEND/0,0,Z4E,0,Z4E,2,Z4E,2,0,0/
      DATA IFEDR/0,0,Z4E,0,Z4E,2,Z4E,1,0,0/
      DATA CMODF/'PLOTKP  ','PLOTKF  ','PLOTFU  ',
     *   'PLOTFV  ','PLOTGR  ','GOFLU   ','GOFLV   '/
      DATA PT1/19030000.0D0,3*.0D0/
      DATA VT1/20030000.0D0,3*.0D0/
      DATA ITEST5/1/,J11O/-1/
      DATA FIRST/.TRUE./
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C     INITIALISE CHARACTER ITEMS FOR OUTPUT TO EXFILE
C
      IF (FIRST) THEN
        DO 5 I=1,7
          IMODF(1,I)=BCDF(CMODF(I)(1:4))
          IMODF(2,I)=BCDF(CMODF(I)(5:8))
    5   CONTINUE
        ILEIT(1)=BCDF('CLDA')
        ILEIT(2)=BCDF('TA  ')
        LEIT(5)=MODF(5)
        IPENU(1)=BCDF('PENU')
        IPENU(2)=BCDF('P   ')
        IPENU(9)=BCDF('    ')
        IPENU(10)=IPENU(9)
        IPEND(1)=BCDF('PEND')
        IPEND(2)=BCDF('WN  ')
        PENDWN(5)=PENUP(5)
        IFEDR(1)=BCDF('FEDR')
        IFEDR(2)=BCDF('AT  ')
        FIRST=.FALSE.
      ENDIF
C  PREPARATION OF THE EVALUATION RESULT STORAGE
      IF(INCR.EQ.1)GOTO 11
      DO 10 I=33,52
   10 SPV(I)=0.D0
C
C   CURVE OR SURFACE ?
   11 IF(IART.GE.3) GOTO 1000
      MM=0
      IF(MOD.NE.2)MM=2
      CALL CURFLO(U,SSCAN(J11+1),SPV,MM,0)
      DO 80 I=1,3
      PT(I)=SPV(I)
   80 SPV(32+I)=SPV(I)
      IF(MOD.EQ.1)RETURN
      DO 90 I=1,3
   90 TEK(I)=TE(I)
      CALL TRANSM(TE,PT,2,3,0)
      GOTO 7100
C
C    COMPUTATION OF PATCH NUMBER AND FETCHING OF THE PATCH
 1000 NSPL=SSCAN(J11+9)-1.0D0
      NPNT=SSCAN(J11+10)-1.0D0
      IU=U
      IV=V
      IF(IU.LT.NPNT) GOTO 2110
      IU=NPNT-1
 2130 UP=U-IU
 2140 IF(IV.LT.NSPL) GOTO 2120
      IV=NSPL-1
 2150 VP=V-IV
 2160 NPATCH=IV*NPNT+IU+1
      GOTO 2310
 2110 IF(IU.GE.0) GOTO 2130
      IU=0
      UP=U
      GOTO 2140
 2120 IF(IV.GE.0) GOTO 2150
      IV=0
      VP=V
      GOTO 2160
 2310 IF(J11.EQ.J11O.AND.
     *   NPATCH.EQ.NPATO.AND.
     *   SSCAN(J11+1).EQ.CANOLD) GOTO 2315
      CALL LODPCH(SSCAN(J11+1),PATCH,IFLAG,ITOP,NPATCH,1)
      J11O=J11
      NPATO=NPATCH
      CANOLD=SSCAN(J11+1)
 2315 MM=2
      CALL CNSURF(UP,VP,PATCH,SPV,IFLAG,MM)
C
C STORE VALUES FOR ATAPE
      UU(1)=UP
      VV(1)=VP
      IPNUM(1)=NPATCH
C
C STORE SURFACE POINT WITH NORMAL FOR ATAPE
      DO 2320 I=1,3
      PT(I)=SPV(I)
      VT0(I)=SPV(I+28)
 2320 CONTINUE
      CALL TRANSM(SP(1,IPS),PT,2,3,0)
      CALL TRANSM(SN(1,IPS),VT0,3,3,0)
C
C  CALCULATION OF MOTION DIRECTION
      IWO=8
      IF(IART.EQ.7)IWO=4
      DO 4080 I=1,3
 4080 DM(I)=SPV(IWO+I)
C
C  LENGTH OF MOTION DIRECTION
      VLL=DSQRT(DM(1)*DM(1)+DM(2)*DM(2)+DM(3)*DM(3))
C  INVERT LENGTH IF MOTION DIRECTION IS INVERS
      IF(INVERS.EQ.1)VLL=-VLL
C  NORMALIZE MOTION DIRECTION
      DO 4090 I=1,3
      DM(I)=DM(I)/VLL
 4090 VT0(I)=DM(I)
      CALL TRANSM(TI,VT0,3,3,0)
C
C   INVERSION OF NORMAL
      IF(MIRROR.NE.1)GOTO 4000
      DO 3090 I=29,31
 3090 SPV(I)=-SPV(I)
C
C   IS THE SURFACE NORMAL TO BE USED AS TOOL AXIS ?
 4000 IF(NORMAL.EQ.1)GOTO 4050
      IF(JTLFLG(IPS).NE.0) GOTO 4070
C
C  GIVEN TOOL-AXIS IS USED
      DO 4010 I=1,3
 4010 VT0(I)=TA(I)
      CALL TRANSM(SPV(37),VT0,3,3,-1)
      GOTO 5000
C
C SURFACE NORMAL AS TOOL-AXIS
 4050 DO 4060 I=1,3
 4060 SPV(36+I)=SPV(28+I)
      GOTO 5000
C
C ********** 4 AND 5 AXIS CALCULATION **************
C
C  ONLY GOLOFT ALLOWED
 4070 IF(IART.NE.6.AND.IART.NE.7)GOTO 5000
C
C TLAXIS PARLELL CASE
      IF(MANTAX.EQ.2.AND.NUMAX.EQ.2)GOTO 4300
C
C  CALCULATE CROSS VECTOR
      CALL CROSS(DM,SPV(29),Q)
C
C 5 AXIS CALCULATION
 4100 IF(MANTAX.NE.2.OR.NUMAX.NE.1)GOTO 4200
C  NEAR NORMAL SURFACE CONDITION
      IF(DABS(SAGL).LT.1.D-5)GOTO 4110
C  INTERSECTION CONDITION
      IF(DABS(DSIN(ALP)/SAGL).LE.1.D0)GOTO 4120
C  TOOL AXIS CAN NOT BE COMPUTED
 4110 IRET=MAX0(IRET,2)
      IF(.NOT.SSTEST) GOTO 4115
C
C  TOOL-AXIS CAN NOT BE COMPUTED.
      CALL AERR (22222,'GOP     ')
C
      CALL BAD(1,1,'SAGL',SAGL)
      CALL BAD(1,1,'CAGL',CAGL)
      CALL BAD(1,1,'VN  ',VN  )
      CALL BAD(1,1,'VM  ',VM  )
      CALL BAD(-1,1,'VQ  ',VQ  )
      CALL BAD(2,1,'SIND',SIND)
      CALL BAD(-2,1,'COSD',COSD)
      CALL BAD(1,1,'A   ',A   )
      CALL BAD(1,1,'B   ',B   )
      CALL BAD(-1,1,'W   ',W   )
C
 4115 SPV(37)=0.D0
      SPV(38)=0.D0
      SPV(39)=1.D0
      GOTO 5000
C
C  SIN OF DELTA
 4120 SIND(1)=-DSIN(ALP)/SAGL
      SIND(2)=SIND(1)
C
C  COSIN OF DELTA
      COSD(1)=DSQRT(1.D0-SIND(1)*SIND(1))
      COSD(2)=-COSD(1)
      GOTO 4280
C
C 4 AXIS CALCULATION
 4200 IF(MANTAX.NE.2.OR.NUMAX.NE.0)GOTO 5000
C  NEAR NORMAL SURFACE CONDITION
      IF(DABS(SAGL).LT.1.D-5)GOTO 4110
C  COMPUTE COMPONENTS OF 4 AXIS VECTOR IN NORMAL MOTION AND CROSS DIR
      VN=0.D0
      VM=0.D0
      VQ=0.D0
      DO 4210 I=1,3
      VN=VN+SPV(28+I)*AX4(I)
      VM=VM+DM(I)*AX4(I)
 4210 VQ=VQ+Q(I)*AX4(I)
C  COMPUTE SOLUTIONS FOR QUADRATIC EQUATION FOR COSIN(DELTA)
      B=CAGL/SAGL*VN*VQ
      A=VQ*VQ+VM*VM
C  4 AXIS VECTOR NEAR NORMAL SURFACE
      IF(A.LT.1.D-10)GOTO 4110
      W=A-(CAGL/SAGL*VN)**2
C  NO INTERSECTION
      IF(W.LT.0.D0)GOTO 4110
      W=VM*DSQRT(W)
      COSD(1)=(B+W)/A
      COSD(2)=(B-W)/A
      IF(DABS(COSD(1)).GT.1.D0)COSD(1)=COSD(2)
      IF(DABS(COSD(2)).GT.1.D0)COSD(2)=COSD(1)
      IF(DABS(COSD(2)).GT.1.D0)GOTO 4110
      SIND(1)=(CAGL/SAGL*VN-COSD(1)*VQ)/VM
      SIND(2)=(CAGL/SAGL*VN-COSD(2)*VQ)/VM
C  COMPUTE THE TWO POSSIBLE AXIS VECTORS AND THE SCALAR PRODUCT
C   WITH THE PREVIOUS AXIS VECTOR
 4280 DO 4285 J=1,2
      AL(J)=0.D0
      DO 4285 I=1,3
      AX(I,J)=SAGL*(Q(I)*COSD(J)+DM(I)*SIND(J))-CAGL*SPV(28+I)
      AL(J)=AL(J)+AX(I,J)*VTA(I)
 4285 CONTINUE
C  SELECTION OF THE NEW TOOL AXIS VECTOR WICH IS CLOSER TO THE OLD ONE
      J=1
      IF(AL(2).GT.AL(1))J=2
C  NEW AXIS DIRECTION
      DO 4290 I=1,3
      VTA(I)=AX(I,J)
 4290 SPV(36+I)=VTA(I)
      GOTO 5000
C PARALLEL AXIS CALCULATION (ALONG RULINGS)
C  SELECTION OF CROSS DIRECTION
 4300 IWO=4
      IF(IART.EQ.7)IWO=8
      DO 4310 I=1,3
 4310 Q(I)=SPV(IWO+I)
C  LENGTH OF CROSS DIRECTION
      VLL=DSQRT(Q(1)**2+Q(2)**2+Q(3)**2)
C  USE INVERTED LENGTH IF CROSS DIRECTION HAS TO BE INVERTED
C   NEW AXIS SHOULD HAVE THE SAME ORIENTATION AS THE OLD ONE
      IF(Q(1)*VTA(1)+Q(2)*VTA(2)+Q(3)*VTA(3).LT.0.D0)VLL=-VLL
C  NEW AXIS DIRECTION PLUS A SMALL AMOUNT IN ORDER TO AVOID JUMPING
      DO 4320 I=1,3
      VTA(I)=Q(I)/VLL+1.D-12*SPV(28+I)
 4320 SPV(36+I)=VTA(I)
C  STORING NEW POINT
 5000 DO 5090 I=1,3
C  PART SURFACE THICKNES IS USED
 5090 SPV(32+I)=SPV(I)+TH(IPS)*SPV(28+I)
C  END OF CALCULATION IF PLOTING
      IF (IART.LT.6) GOTO 7000
C  END OF CALCULATION IF NORMAL CONDITION
      IF(NORMAL.EQ.1)GOTO 7000
C  END OF CALCULATION IF ZERO CUTTER
      IF(CUTDAT(1).LT..001) GOTO 7000
C  CALCULATION OF VECTOR PERPENDICULAR TO SURFACE NORMAL AND TOOL AXIS
      CALL CROSS(SPV(29),SPV(37),VT0)
C  LENGTH OF CROSS VECTOR
      VLL=VT0(1)*VT0(1)+VT0(2)*VT0(2)+VT0(3)*VT0(3)
C  END OF CALCULATION IF SURFACE NORMAL AND TOOL AXIS ARE PARALLEL
      IF(VLL.LE.1.D-10) GOTO 7000
      VLL=DSQRT(VLL)
C  PROJECTION OF SURFACE NORMAL
      CALL CROSS(SPV(37),VT0,VT2)
C  NEW TOOL-TIP CALCULATION
C  IS RING CUTTER GIVEN ?
      IF(.NOT.RINGFG) GOTO 6070
C  STORE RING AS 10TH SEGMENT
      JCSEG=10
      CUTL(JCSEG)=0.D0
      CUTX(JCSEG)=RI(8)
      CUTY(JCSEG)=TLHITE(8)
      GOTO 6075
C   COMPUTATION OF THE COSIN OF THE ANGLE BETWEEN THE TOOL-AXIS
C   AND THE SURFACE NORMAL
 6070 CGAMMA=0.D0
      DO 6080 I=1,3
 6080 CGAMMA=SPV(36+I)*SPV(28+I)+CGAMMA
      DO 6081 I=1,NCSEG
      JCSEG=I
      IF(NLIOCI(I).EQ.1) GOTO 6081
      IF(COSAL(I).LE.CGAMMA) GOTO 6082
 6081 CONTINUE
 6082 CONTINUE
C
C NEW TOOL-TIP CALCULATION
 6075 DO 6090 I=1,3
 6090 SPV(32+I)=SPV(32+I)
     *                   +SPV(28+I)*CUTL(JCSEG)
     *                   +VT2(   I)*CUTX(JCSEG)/VLL
     *                   -SPV(36+I)*CUTY(JCSEG)
C  NO CURVATURE CALCULATION IF INCR=1
 7000 IF(INCR.EQ.1)GOTO 7005
C  COMPUTATION OF THE FUNDAMENTAL FORMS
      E=0.D0
      F=0.D0
      G=0.D0
      XL=0.D0
      XN=0.D0
      XM=0.D0
C  PROJECTION LENGTH
      PL=0.D0
      DO 7002 I=1,3
      SUPI=SPV(4+I)
      SVPI=SPV(8+I)
      E=SUPI*SUPI+E
      F=SUPI*SVPI+F
      G=SVPI*SVPI+G
      XNORM=SPV(28+I)
      XL=SPV(12+I)*XNORM+XL
      XM=SPV(16+I)*XNORM+XM
      XN=SPV(20+I)*XNORM+XN
C  PROJECTION LENGTH
 7002 PL=(SPV(32+I)-SPV(I))*SPV(28+I)+PL
      SPV(45)=E
      SPV(46)=F
      SPV(47)=G
      SPV(49)=XL
      SPV(50)=XM
      SPV(51)=XN
C  PROJECTION LENGTH
      SPV(52)=PL
C  READY IF ONLY PLOTING
      IF(IART.LE.5)GOTO 7005
C   LENGTH OF NORMAL
      XNL=DSQRT(E*G-F*F)+1.D-12
C   COMPUTATION OF THE MAIN CURVATURE DIRECTION
C   A=G*M-F*N
      A=G*SPV(50)-F*SPV(51)
C   B=G*L-E*N
      B=G*SPV(49)-E*SPV(51)
C   C=F*L-E*M
      C=F*SPV(49)-E*SPV(50)
      T1=B*B-4.D0*A*C
      T2=DSQRT(T1)
      T3=E*B-2.D0*F*C
      IF(T3.LT.0.D0)T2=-T2
      T4=DSQRT(2.D0*E*E*T1+2.D0*E*T3*T2)
      IF(DABS(T4).GT.0.D-20)GO TO 7060
C   NO MAIN CURVATURE DIRECTION FOUND
      SINALF=0.D0
      COSALF=1.D0
      GOTO 7070
 7060 SINALF=(T3+E*T2)/T4
      COSALF=(2.D0*C*XNL)/T4
 7070 WE=DSQRT(E)
      DO 7300 I=1,3
C  U-TANGENT
 7300 VT0(I)=SPV(4+I)/WE
C  VECTOR PERPENTICULAR TO U-TANGENT
      IF(MIRROR.NE.1)CALL CROSS(SPV(29),VT0,VT2)
      IF(MIRROR.EQ.1)CALL CROSS(VT0,SPV(29),VT2)
C  DIRECTION OF 1. MAIN CURVATURE
      DO 7310 I=1,3
 7310 SPV(40+I)=COSALF*VT0(I)+SINALF*VT2(I)
C  COMPUTATION OF 1. MAIN CURVATURE
      DV=E*SINALF
      DU= XNL*COSALF-F*SINALF
      SPV(40)=(SPV(49)*DU*DU+2.D0*SPV(50)*DU*DV+SPV(51)*DV*DV)/
     *        (E*DU*DU+2.D0*F*DU*DV+G*DV*DV)
C  COMPUTATION OF 2. MAIN CURVATURE
      DV=E*COSALF
      DU=-XNL*SINALF-F*COSALF
      SPV(44)=(SPV(49)*DU*DU+2.D0*SPV(50)*DU*DV+SPV(51)*DV*DV)/
     *        (E*DU*DU+2.D0*F*DU*DV+G*DV*DV)
C  RETURN ,IF COMPUTATION OF POSITIONS ONLY
 7005 IF(MOD.EQ.1)RETURN
C  IS THE TOOL AXIS TO BE CHANGED
      IF(NORMAL.NE.1.AND.MANTAX.NE.2)GOTO 7020
C  STORING TOOL AXIS
      DO 7010 I=1,3
      TAK(I)=TA(I)
 7010 VT0(I)=SPV(36+I)
      CALL TRANSM(TA,VT0,3,3,0)
C  STORING TOOL TIP
 7020 DO 7030 I=1,3
      TEK(I)=TE(I)
 7030 PT(I)=SPV(32+I)
      CALL TRANSM(TE,PT,2,3,0)
C   CL FILE OUTPUT
      IF(IART.NE.5)GOTO 7100
      IF(ITEST5.EQ.0.AND.ICL.EQ.2)GOTO 7100
      IF(ITEST5.EQ.0)GOTO 7050
C   1. POINT OD A 'GRID' CURVE
      ICL=3
      CALL ATAPE
      ICL=2
      NR=0
      J=10
      CALL RECORD(ISEQNO)
      IPEND(4)=ISEQNO
      CALL EWRITE(EXFILE,NR,PENDWN,J,IR)
      NR=0
      J=18
      CALL RECORD(ISEQNO)
      ILEIT(4)=ISEQNO
      LEIT(5)=MODF(IART)
      LEIT(7)=OBNAM1
      CALL EWRITE(EXFILE,NR,LEIT,J,IR)
      ITEST5=0
      GOTO 7200
C   LAST POINT
 7050 CALL ATAPE
      ITEST5=1
      NR=0
      J=10
      CALL RECORD(ISEQNO)
      IPENU(4)=ISEQNO
      CALL EWRITE(EXFILE,NR,PENUP,J,IR)
      GOTO 7200
C
C  IS THE GLOBAL FEEDRAT TO BE WRITTEN
 7100 IF(IFEEDF.NE.1.OR.IART.LT.6)GOTO 7150
C
C  OUTPUT POINT
      ICL=3
      CALL ATAPE
      ICL=2
C
C  FEDRAT AFTER FIRST GOLOFT POINT
      NR=0
      J=10
      CALL RECORD(ISEQNO)
      IFEDR(4)=ISEQNO
      FEDRAT(5)=GLFEED
      CALL EWRITE(EXFILE,NR,FEDRAT,J,IR)
      NR=0
      J=18
      CALL RECORD(ISEQNO)
      ILEIT(4)=ISEQNO
      LEIT(5)=MODF(IART)
      LEIT(7)=OBNAM1
      CALL EWRITE(EXFILE,NR,LEIT,J,IR)
      IFEEDF=0
      GOTO 7200
 7150 CALL ATAPE
 7200 IF(.NOT.SSTEST)RETURN
      CALL CFORM('0PKT.,NORM.:',DARRAY,1,12)
      CALL FCONV(SPV(1),DARRAY, 13,14,4)
      CALL FCONV(SPV(2),DARRAY, 28,14,4)
      CALL FCONV(SPV(3),DARRAY, 43,14,4)
      CALL FCONV(SPV(29),DARRAY,61,14,6)
      CALL FCONV(SPV(30),DARRAY,76,14,6)
      CALL FCONV(SPV(31),DARRAY,91,14,6)
      CALL CPRINT(DARRAY)
      CALL CFORM(' TE,TA     :   ',DARRAY,1,15)
      CALL FCONV(TE(1),DARRAY, 15,14,4)
      CALL FCONV(TE(2),DARRAY, 30,14,4)
      CALL FCONV(TE(3),DARRAY, 45,14,4)
      CALL FCONV(TA(1),DARRAY,63,14,6)
      CALL FCONV(TA(2),DARRAY,78,14,6)
      CALL FCONV(TA(3),DARRAY,93,14,6)
      CALL CPRINT(DARRAY)
      IF(INCR.EQ.1)RETURN
      CALL CFORM(' E,F,G,L,M,N:  ',DARRAY,1,15)
      CALL FCONV(E,DARRAY, 15,14,6)
      CALL FCONV(F,DARRAY, 30,14,6)
      CALL FCONV(G,DARRAY, 45,14,6)
      CALL FCONV(SPV(49),DARRAY,63,14,6)
      CALL FCONV(SPV(50),DARRAY,78,14,6)
      CALL FCONV(SPV(51),DARRAY,93,14,6)
      CALL CPRINT(DARRAY)
      IF(IART.LE.5)RETURN
      CALL CFORM(' SIN,COS,K,K:  ',DARRAY,1,15)
      CALL FCONV(SINALF,DARRAY, 15,14,6)
      CALL FCONV(COSALF,DARRAY, 30,14,6)
      CALL FCONV(SPV(40),DARRAY,45,14,6)
      CALL FCONV(SPV(44),DARRAY,63,14,6)
      CALL CPRINT(DARRAY)
      CALL CFORM(' TANGENT    :  ',DARRAY,1,15)
      CALL FCONV(SPV(41),DARRAY,15,14,6)
      CALL FCONV(SPV(42),DARRAY,30,14,6)
      CALL FCONV(SPV(43),DARRAY,45,14,6)
      CALL CPRINT(DARRAY)
      RETURN
      END
**** SOURCE FILE : M0011489.V01   ***
*
      SUBROUTINE GORETR (LSEG,U,V,SPV,J11,IRET)
C
C  RETRACT AND MOVEIN ROUTINE FOR >GOL<
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C  GOLOFT COMMON
      COMMON/PLGOL/ID(24),OBNAM1
C
C IART:      IART = 1   PLOTFT/SCURV,.........,PARAM,....
C            IART = 2   PLOTFT/SCURV,.........,FLOW ,....
C            IART = 3   PLOTFT/SSURF,UCONST,U,...........
C            IART = 4   PLOTFT/SSURF,VCONST,V,...........
C            IART = 5   PLOTFT/SSURF,GRID,...............
C            IART = 6   GOLOFT/SSURF,UCONST,U,...........
C            IART = 7   GOLOFT/SSURF,VCONST,V,...........
      EQUIVALENCE (ID(13),IART  )
C
C INVERS:    INVERSION OF THE POINT-SEQUENCE
      EQUIVALENCE (ID(14),INVERS)
C
C  BLANK-COMMON
      INCLUDE 'BLANKCOM.INC'
C
C   POINT STORAGE FOR TRANSFORMATION PURPOSE
      DOUBLE PRECISION PT(3),PT1(4)
      EQUIVALENCE(PT1(2),PT(1))
C
C   VECTOR STORAGE FOR TRANSFORMATION PURPOSE
      DOUBLE PRECISION VT(3),VT1(4),VT2(3)
      EQUIVALENCE(VT1(2),VT(1))
C
C  OUTPUT-ARRAY OF THE HEADER
      CHARACTER*8 CMODF(9)
      DOUBLE PRECISION OBNAME,MODF(9)
      DOUBLE PRECISION LEIT(9)
      INTEGER ILEIT(18),IMODF(2,9)
      EQUIVALENCE (LEIT(7),OBNAME),(LEIT(1),ILEIT(1))
      EQUIVALENCE (MODF(1),IMODF(1,1))
      DOUBLE PRECISION RAPID (5)
      INTEGER IRAPI(10)
      EQUIVALENCE (RAPID (1),IRAPI(1))
      DOUBLE PRECISION FEDRAT(5)
      INTEGER IFEDR(10)
      EQUIVALENCE (FEDRAT(1),IFEDR(1))
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'IFXCOR.INC'
C
C  SYSTEM - INPUT/OUTPUT-NAMES
      INCLUDE 'SYMFIL.INC'
C
C  STORAGE OF POINTS
      DOUBLE PRECISION SPV(52)
C
C  MOTION DIRECTIONS (LATER RETRACT POINT), CLEAR POINT
      DOUBLE PRECISION DM(3) , CP(3)
C
      COMMON/CCLEAR/ DIRMOT(3,4)
     *              ,GOFEED(4)
     *              ,GLFEED
     *              ,REGLDA(2)
     *              ,IRETRO(4)
     *              ,IDIRMO(4)
     *              ,ICANIN(4)
     *              ,IFEEDF
C
      INTEGER Z4E,BCDF
      PARAMETER (Z4E=1308622848)
      LOGICAL FIRST
      SAVE FIRST,ILEIT,IRAPI,IFEDR,MODF
C
      DATA PT1/19030000.0D0,3*.0D0/
      DATA VT1/20030000.0D0,3*.0D0/
      DATA CMODF/'PLOTKP  ','PLOTKF  ','PLOTFU  ',
     *   'PLOTFV  ','PLOTGR  ','GOFLU   ','GOFLV   ',
     *   'CLEARS  ','CLEARP  '/
      DATA ILEIT/0,0,Z4E,0,Z4E,6,Z4E,1,0,0,Z4E,0,0,0,Z4E,0,Z4E,0/
      DATA IRAPI/0,0,Z4E,0,Z4E,2,Z4E,2,0,0/
      DATA IFEDR/0,0,Z4E,0,Z4E,2,Z4E,1,0,0/
      DATA FIRST/.TRUE./
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C.... INITIALIZE CHARACTER ITEMS FOR EXFILE RECORD
C
      IF (FIRST) THEN
        DO 5 I=1,9
          IMODF(1,I)=BCDF(CMODF(I)(1:4))
          IMODF(2,I)=BCDF(CMODF(I)(5:8))
   5    CONTINUE
        ILEIT(1)=BCDF('CLDA')
        ILEIT(2)=BCDF('TA  ')
        IRAPI(1)=BCDF('RAPI')
        IRAPI(2)=BCDF('D   ')
        IFEDR(1)=BCDF('FEDR')
        IFEDR(2)=BCDF('AT  ')
        IBLNK   =BCDF('    ')
        IRAPI(9)=IBLNK
        IRAPI(10)=IBLNK
        FIRST=.FALSE.
      ENDIF
C
C  SET FLAG FOR GLOBAL FEED
      IFEEDF=0
C
C  SAVE CL-FLAG
      ICLS=ICL
C
C  RETRACT AND FEEDRAT ONLY FOR GOLOFT
      IF(IART.LE.5)GOTO 90
C
C  EXTRA MOTION IF FLAG IS ONE
      IF(IRETRO(LSEG).EQ.0)GOTO 90
C
C  COMPUTE THE POINT IF PLUNGE IN MOTION
      IF((INVERS.EQ.0.AND.(LSEG.EQ.1.OR.LSEG.EQ.3)).OR.
     *   (INVERS.EQ.1.AND.(LSEG.EQ.2.OR.LSEG.EQ.4)))
     *  CALL GOP (1,U,V,SPV,J11,IRET)
C
C  CALCULATION OF MOTION DIRECTION
      DO 9 I=1,3
    9 DM(I)=0.D0
      IF(IDIRMO(LSEG).NE.1)GOTO 20
      IWO=8
      IF(IART.EQ.7)IWO=4
      DO 10 I=1,3
   10 DM(I)=SPV(IWO+I)
C
C  LENGTH OF MOTION DIRECTION
      VLL=DSQRT(DM(1)*DM(1)+DM(2)*DM(2)+DM(3)*DM(3))
C  INVERT LENGTH IF MOTION DIRECTION IS INVERS
      IF(INVERS.EQ.1)VLL=-VLL
C  NORMALIZE MOTION DIRECTION
      DO 11 I=1,3
      DM(I)=DM(I)/VLL
   11 VT(I)=DM(I)
C
C  CALCULATE EXTRA MOTION
      DO 12 I=1,3
   12 DM(I)=DM(I)*DIRMOT(1,LSEG)+SPV(28+I)*DIRMOT(2,LSEG)
      GOTO 30
C
C  VECTOR MOTION
   20 IF(IDIRMO(LSEG).NE.2) GOTO 30
      DO 22 I=1,3
   22 DM(I)=DIRMOT(I,LSEG)
C
C  COMPUTE STEP IN OR RETRACT POINT
   30 VLL=1.D0
      IF(INVERS.EQ.1)VLL=-1.D0
      IF((INVERS.EQ.0.AND.(LSEG.EQ.1.OR.LSEG.EQ.3)).OR.
     *   (INVERS.EQ.1.AND.(LSEG.EQ.2.OR.LSEG.EQ.4)))VLL=-VLL
      DO 32 I=1,3
   32 DM(I)=SPV(32+I)+DM(I)*VLL
C
C  COMPUTE CLEARENCE POSITION
      IF(ICANIN(LSEG).EQ.0)GOTO 45
C
C  COMPUTE POINT DISTANCE
      VLL=COM(ICANIN(LSEG))*DM(1)+COM(ICANIN(LSEG)+1)*DM(2)
     *   +COM(ICANIN(LSEG)+2)*DM(3)-COM(ICANIN(LSEG)+3)
C
C  COMPUTE CLEAR POINT ON CLEAR PLANE
      DO 40 I=1,3
   40 CP(I)=DM(I)-COM(ICANIN(LSEG)+I-1)*VLL
   45 CONTINUE
C
C  DECISION IF STEP IN OR STEP OUT
      IF((INVERS.EQ.0.AND.(LSEG.EQ.2.OR.LSEG.EQ.4)).OR.
     *   (INVERS.EQ.1.AND.(LSEG.EQ.1.OR.LSEG.EQ.3)))GOTO 70
C
C  STEP IN ******************************
      IF(ICANIN(LSEG).EQ.0)GOTO 55
C
C   RAPID
      NR=0
      J=10
      CALL RECORD(ISEQNO)
      IRAPI(4)=ISEQNO
      CALL EWRITE(EXFILE,NR,RAPID,J,IR)
C
C   CLEAR POINT
      NR=0
      J=18
      CALL RECORD(ILEIT(4))
      ISEQNO=ILEIT(4)
      LEIT(5)=MODF(8)
      LEIT(7)=OBNAM1
      CALL EWRITE(EXFILE,NR,LEIT,J,IR)
      ICL=3
C
C  STORING TOOL AXIS
      DO 50 I=1,3
      TAK(I)=TA(I)
   50 VT(I)=SPV(36+I)
      CALL TRANSM(TA,VT,3,3,0)
C
C  STORING TOOL TIP
      DO 51 I=1,3
      TEK(I)=TE(I)
   51 PT(I)=CP(I)
      CALL TRANSM(TE,PT,2,3,0)
      CALL ATAPE
C
C NEAR POINT ?
   55 IF(IDIRMO(LSEG).EQ.0) GOTO 90
C
C   RAPID
      NR=0
      J=10
      CALL RECORD(ISEQNO)
      IRAPI(4)=ISEQNO
      CALL EWRITE(EXFILE,NR,RAPID,J,IR)
C
C  NEAR POINT
      NR=0
      J=18
      CALL RECORD(ILEIT(4))
      ISEQNO=ILEIT(4)
      LEIT(5)=MODF(9)
      LEIT(7)=OBNAM1
      CALL EWRITE(EXFILE,NR,LEIT,J,IR)
      ICL=3
C
C  STORING TOOL AXIS
      DO 61 I=1,3
      TAK(I)=TA(I)
   61 VT(I)=SPV(36+I)
      CALL TRANSM(TA,VT,3,3,0)
C
C  STORING TOOL TIP
      DO 62 I=1,3
      TEK(I)=TE(I)
   62 PT(I)=DM(I)
      CALL TRANSM(TE,PT,2,3,0)
      CALL ATAPE
C
C FEDRATE FOR NEAR POINT
      IF(GOFEED(LSEG).EQ.0.D0)GOTO 90
      NR=0
      J=10
      CALL RECORD(ISEQNO)
      IFEDR(4)=ISEQNO
      FEDRAT(5)=GOFEED(LSEG)
      CALL EWRITE(EXFILE,NR,FEDRAT,J,IR)
C
C  SET FLAG FOR GLOBAL FEEDRAT OUTPUT IN >GOP<
      IF(ICLS.EQ.2)IFEEDF=1
C
C  CONTINUE WITH NORMAL PATH
      GOTO 90
C
C  STEP OUT ********************************
C
C  NEAR POINT ?
   70 IF(IDIRMO(LSEG).EQ.0) GOTO 80
C
C FEDRATE FOR NEAR POINT
      IF(GOFEED(LSEG).EQ.0.D0) GOTO 75
      NR=0
      J=10
      CALL RECORD(ISEQNO)
      IFEDR(4)=ISEQNO
      FEDRAT(5)=GOFEED(LSEG)
      CALL EWRITE(EXFILE,NR,FEDRAT,J,IR)
C
C  NEAR POINT
   75 NR=0
      J=18
      CALL RECORD(ILEIT(4))
      ISEQNO=ILEIT(4)
      LEIT(5)=MODF(9)
      LEIT(7)=OBNAM1
      CALL EWRITE(EXFILE,NR,LEIT,J,IR)
      ICL=3
C
C  STORING TOOL AXIS
      DO 76 I=1,3
      TAK(I)=TA(I)
   76 VT(I)=SPV(36+I)
      CALL TRANSM(TA,VT,3,3,0)
C
C  STORING TOOL TIP
      DO 77 I=1,3
      TEK(I)=TE(I)
   77 PT(I)=DM(I)
      CALL TRANSM(TE,PT,2,3,0)
      CALL ATAPE
C
C  FEDRAT FOR NORMAL GOLOFT
      IF(GOFEED(LSEG).EQ.0.D0.OR.LSEG.EQ.2.OR.LSEG.EQ.3)GOTO 80
      NR=0
      J=10
      CALL RECORD(ISEQNO)
      IFEDR(4)=ISEQNO
      FEDRAT(5)=GLFEED
      CALL EWRITE(EXFILE,NR,FEDRAT,J,IR)
C
C  CLEAR POINT
   80 IF(ICANIN(LSEG).EQ.0)GOTO 99
C
C   RAPID
      NR=0
      J=10
      CALL RECORD(ISEQNO)
      IRAPI(4)=ISEQNO
      CALL EWRITE(EXFILE,NR,RAPID,J,IR)
C
C   CLEAR POINT
      NR=0
      J=18
      CALL RECORD(ILEIT(4))
      ISEQNO=ILEIT(4)
      LEIT(5)=MODF(8)
      LEIT(7)=OBNAM1
      CALL EWRITE(EXFILE,NR,LEIT,J,IR)
      ICL=3
C
C  STORING TOOL AXIS
      DO 81 I=1,3
      TAK(I)=TA(I)
   81 VT(I)=SPV(36+I)
      CALL TRANSM(TA,VT,3,3,0)
C
C  STORING TOOL TIP
      DO 82 I=1,3
      TEK(I)=TE(I)
   82 PT(I)=CP(I)
      CALL TRANSM(TE,PT,2,3,0)
      CALL ATAPE
      GOTO 99
C
C  OUTPUT OF THE HEADER
   90 IF((INVERS.EQ.0.AND.(LSEG.EQ.2.OR.LSEG.EQ.4)).OR.
     *   (INVERS.EQ.1.AND.(LSEG.EQ.1.OR.LSEG.EQ.3)))GOTO 99
      NR=0
      J=18
      CALL RECORD(ILEIT(4))
      ISEQNO=ILEIT(4)
      LEIT(5)=MODF(IART)
      LEIT(7)=OBNAM1
      CALL EWRITE(EXFILE,NR,LEIT,J,IR)
      ICL=ICLS
C
   99 RETURN
      END
**** SOURCE FILE : M0012365.V01   ***
*
      SUBROUTINE INTBND(NS,IRC)
C
C     CALCULATES A SURFACE BOUNDARY PT ON THE INTERSECTION OF
C     TWO SURFACES.
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C SS - ARELEM - COMMON
      COMMON/SSARLM/BB(64,4),UU(4),VV(4),
     *              IITOP(6,4,4),IIFLAG(4,4),IPNUM(4)
C
C   COMMON FOR 2 SURFACE INTERSECTION
      COMMON/INTCOM/IKEEP(255)
C   EVALUATION VECTOR FOR PS AND DS
      DOUBLE PRECISION SPV(4,8,2)
      EQUIVALENCE (IKEEP(  1),SPV(1,1,1))
C   LAST THREE U,V PAIRS OF PS AND DS
      DOUBLE PRECISION UV(2,3,2)
      EQUIVALENCE (IKEEP(129),UV(1,1,1))
C   HISTORY OF UNIT NORMALS AT INTERSECTION POINTS ON PS AND DS
      DOUBLE PRECISION UN(3,3,2)
      EQUIVALENCE (IKEEP(165),UN(1,1,1))
C   THICKNESS ON PS AND DS
      DOUBLE PRECISION THICK(2)
      EQUIVALENCE (IKEEP(201),THICK(1))
C   POINT OF INTERSECTION
      DOUBLE PRECISION PXYZ(3)
      EQUIVALENCE (IKEEP(205),PXYZ(1))
C   OLD POINT OF INTERSECTION
      DOUBLE PRECISION OXYZ(3)
      EQUIVALENCE (IKEEP(211),OXYZ(1))
C   DS TANGENT PLANE
      DOUBLE PRECISION DTP(4)
      EQUIVALENCE (IKEEP(217),DTP(1))
C   PS TANGENT PLANE
      DOUBLE PRECISION PTP(4)
      EQUIVALENCE (IKEEP(225),PTP(1))
C   PLANE PERPENTICULAR TO INTERSECTION DIRECTION
      DOUBLE PRECISION CTP(4)
      EQUIVALENCE (IKEEP(233),CTP(1))
C  TRACE
CCCCC EQUIVALENCE (IKEEP(249),ITRACE)
C
      DIMENSION CTPI(4),PL(4,3)
      DIMENSION DXYZ(3,2),P1(3),P2(3)
      LOGICAL UXBND,VXBND
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
CCCCC IF(ITRACE.EQ.1)
CCCCC*WRITE(6,1000)KS
C1000 FORMAT(' ***TRACE***INTBND-KS=',I5)
      UXBND = .FALSE.
      VXBND = .FALSE.
      U  =UV(1,1,NS)
      V  =UV(2,1,NS)
C
C DETERMINE PARAMETRIC VALUE OF BOUNDARY (UBND OR VBND)
C -----------------------------------------------------
C  TEST FIRST FOR U OR V OR U&V OUT OF BOUNDS
      UUU=DABS(U-.5D0) + 1.D-12
      VVV=DABS(V-.5D0) + 1.D-12
      NT = 0
      UBND = 0.D0
C IS U OUT OF BOUNDS?
      IF (UUU.LT..5D0) GOTO 30
C U OUT OF BOUNDS; LIMIT: 0 <= UBND <= 1.
      IF(U.GT..5D0)UBND = 1.D0
      NT = NT + 1
      UXBND = .TRUE.
   30 CONTINUE
      VBND = 0.D0
C IS V OUT OF BOUNDS?
      IF (VVV.LT..5D0) GOTO 50
C V OUT OF BOUNDS; LIMIT: 0 <= VBND <= 1.
      IF(V.GT..5D0)VBND = 1.D0
      NT = NT + 1
      VXBND = .TRUE.
   50 CONTINUE
C RESET U,V HISTORY TABLE:
      UV(1,1,NS)=U
      UV(1,2,NS)=U
      UV(1,3,NS)=U
      UV(2,1,NS)=V
      UV(2,2,NS)=V
      UV(2,3,NS)=V
      IF (.NOT. UXBND) GOTO 60
C SET UUU AT APPROPRIATE BOUNDARY:
      UUU = UBND
      J=2
      JJ=3
      GOTO 80
   60 CONTINUE
      IF (.NOT. VXBND) GOTO 70
C SET VVV AT APPROPRIATE BOUNDARY:
      VVV = VBND
      J=3
      JJ=2
      GOTO 80
   70 CONTINUE
      GO TO 999
   80 CONTINUE
C
C EXECUTE THIS CODE FOR U BOUNDARY OR V BOUNDARY (OR BOTH):
      DO 200 IS = 1,NT
C
C ITERATE (MAX. 15 TIMES) TO FIND INTERSECTION PT PXYZ ON BOUNDARY
C ----------------------------------------------------------------
      DO 220 K=1,15
      KK=K
      HTX=PXYZ(1)
      HTY=PXYZ(2)
      HTZ=PXYZ(3)
C
C USE PXYZ FROM PREVIOUS LOOP:
      DO 240 L=1,3
      P1(L)=PXYZ(L)
      P2(L)=PXYZ(L)
  240 CONTINUE
C
C EVALUATE POINT, NORMAL & PARTIALS ALONG BOUNDARY:
      DUV=-.0001D0
      DO 190 L=1,3
      IF(L.EQ.3) DUV=0.D0
C ON V BOUNDARY, SET UUU = U-DUV, U+DUV, U.
      IF(J.EQ.3) UUU=UV(1,1,NS) + DUV
C ON U BOUNDARY, SET VVV = V-DUV, V+DUV, V.
      IF(J.EQ.2) VVV=UV(2,1,NS) + DUV
C COMPUTE POINT, NORMAL & PARTIALS AT UUU,VVV ON SURFACE I:
      CALL CNSURF(UUU,VVV,BB(1,NS),SPV(1,1,NS),IIFLAG(1,NS),0)
      IF (L.GT.2) GOTO 250
C ON U BOUNDARY, SAVE V-PARTIALS; ON V BOUNDARY, SAVE U-PARTIALS:
      DXYZ(1,L)=SPV(1,JJ,NS)
      DXYZ(2,L)=SPV(2,JJ,NS)
      DXYZ(3,L)=SPV(3,JJ,NS)
  250 CONTINUE
      DUV=-DUV
  190 CONTINUE
C
C COMPUTE YPL = NORMAL TO PLANE OF BOUNDARY:
C ------------------------------------------
C
C TRY YPL = CROSS PRODUCT OF V-PARTIAL & NORMAL VECTOR:
      CTPI(1)=SPV(2,JJ,NS)*SPV(3,8,NS) - SPV(3,JJ,NS)*SPV(2,8,NS)
      CTPI(2)=SPV(3,JJ,NS)*SPV(1,8,NS) - SPV(1,JJ,NS)*SPV(3,8,NS)
      CTPI(3)=SPV(1,JJ,NS)*SPV(2,8,NS) - SPV(2,JJ,NS)*SPV(1,8,NS)
      IYPL=1
      SEC=DSQRT(CTPI(1)**2 + CTPI(2)**2 + CTPI(3)**2)
C IS VECTOR LARGE ENOUGH? ...
      IF (SEC.LE.1.D-10) GOTO 260
C NORMALIZE YPL:
      CTPI(1)=CTPI(1)/SEC
      CTPI(2)=CTPI(2)/SEC
      CTPI(3)=CTPI(3)/SEC
C CTPI(4) = DOT PRODUCT OF YPL & BOUNDARY POINT:
      CTPI(4)=CTPI(1)*SPV(1,1,NS) + CTPI(2)*SPV(2,1,NS)
     *                            + CTPI(3)*SPV(3,1,NS)
      GOTO 270
  260 CONTINUE
C
C TRY YPL = CROSS PRODUCT OF V-PARTIALS AT V +/- DELTA:
C
      IYPL=0
      CTPI(1)=DXYZ(2,1)*DXYZ(3,2) - DXYZ(3,1)*DXYZ(2,2)
      CTPI(2)=DXYZ(3,1)*DXYZ(1,2) - DXYZ(1,1)*DXYZ(3,2)
      CTPI(3)=DXYZ(1,1)*DXYZ(2,2) - DXYZ(2,1)*DXYZ(1,2)
      SEC=DSQRT(CTPI(1)**2 + CTPI(2)**2 + CTPI(3)**2)
C IS VECTOR LARGE ENOUGH? ***
      IF (SEC.GE.1.D-20) GOTO 280
C
C USE YPL = U-PARTIAL AT U,V:
C
      IYPL=0
      CTPI(1)=SPV(1,J,NS)
      CTPI(2)=SPV(2,J,NS)
      CTPI(3)=SPV(3,J,NS)
      SEC=DSQRT(CTPI(1)**2 + CTPI(2)**2 + CTPI(3)**2)
  280 CONTINUE
C NORMALIZE CTPI:
      CTPI(1)=CTPI(1)/SEC
      CTPI(2)=CTPI(2)/SEC
      CTPI(3)=CTPI(3)/SEC
  270 CONTINUE
C
C COMPUTE PLANES TANGENT TO S1 & S2 BELOW PXYZ:
C ---------------------------------------------
C  COMPUTE PLANE DTP TANGENT TO DS:
      CALL INTTPL(2,P1,DTP,IRC)
C COMPUTE PLANE PTP TANGENT TO PS:
      CALL INTTPL(1,P2,PTP,IRC)
C
C RELOAD DT TABLES WITH SURFACE NORMAL OFFSETS
      UN(1,1,2)=DTP(1)
      UN(2,1,2)=DTP(2)
      UN(3,1,2)=DTP(3)
      UN(1,1,1)=PTP(1)
      UN(2,1,1)=PTP(2)
      UN(3,1,1)=PTP(3)
      DO 290 L=1,3
      UN(L,2,1)=UN(L,1,1)
      UN(L,2,2)=UN(L,1,2)
      UN(L,3,1)=UN(L,2,1)
      UN(L,3,2)=UN(L,2,2)
C EVALUATE THICKNESS
      SPV(L,1,NS)=SPV(L,1,NS) + UN(L,1,NS)*THICK(NS)
  290 CONTINUE
C IF BOUNDARY ALGORITHM 2 OR 3, YPL(4) = DOT PRODUCT OF YPL AND
C  OFFSET BOUNDARY POINT:
      IF(IYPL.EQ.0)
     *CTPI(4)=CTPI(1)*SPV(1,1,NS) + CTPI(2)*SPV(2,1,NS)
     *                            + CTPI(3)*SPV(3,1,NS)
C
C LOAD PL TABLE
      DO 300 L=1,4
      PL(L,1)=PTP(L)
      PL(L,2)=CTPI(L)
      PL(L,3)=DTP(L)
  300 CONTINUE
C
C SOLVE FOR PXYZ AT INTERSECTION OF PLANES PTP,YPL,DTP:
C -----------------------------------------------------
      DO 310 L=1,4
      I1=1
      J1=2
      K1=3
      IF(L.EQ.2) I1=4
      IF(L.EQ.3) J1=4
      IF(L.EQ.4) K1=4
C CRAMER'S RULE:
      DET=  PL(I1,1)*PL(J1,2)*PL(K1,3) + PL(I1,2)*PL(J1,3)*PL(K1,1)
     *    + PL(I1,3)*PL(J1,1)*PL(K1,2) - PL(I1,3)*PL(J1,2)*PL(K1,1)
     *    - PL(I1,2)*PL(J1,1)*PL(K1,3) - PL(I1,1)*PL(J1,3)*PL(K1,2)
      IF (L.NE.1) GOTO 330
      DEN=DET
C DEGENERATE SOLUTION?
      IF (DABS(DEN).LT.1.D-16) GOTO 320
      GOTO 340
  330 CONTINUE
      PXYZ(L-1)=DET/DEN
  340 CONTINUE
  310 CONTINUE
  320 CONTINUE
      IF (DABS(DEN).GE.1.D-16) GOTO 350
C DEGENERATE SOLN; COMPUTE TANGENT YABC & PXYZ ON DTP & PTP:
      SAL=PTP(1)*DTP(1) + PTP(2)*DTP(2) + PTP(3)*DTP(3)
      CALSQ=1.D0-SAL*SAL
      IF (CALSQ.LE.1.D-20) GOTO 360
      CAL=DSQRT(CALSQ)*CTP(4)
      CTP(1)=(DTP(2)*PTP(3)-PTP(2)*DTP(3))/CAL
      CTP(2)=(DTP(3)*PTP(1)-PTP(3)*DTP(1))/CAL
      CTP(3)=(DTP(1)*PTP(2)-PTP(1)*DTP(2))/CAL
      D1=(PTP(4)-SAL*DTP(4))/CALSQ
      D2=DTP(4)-SAL*D1
      D3=CTP(1)*PXYZ(1) + CTP(2)*PXYZ(2) + CTP(3)*PXYZ(3)
      PXYZ(1)=PTP(1)*D1 + DTP(1)*D2 + CTP(1)*D3
      PXYZ(2)=PTP(2)*D1 + DTP(2)*D2 + CTP(2)*D3
      PXYZ(3)=PTP(3)*D1 + DTP(3)*D2 + CTP(3)*D3
  360 CONTINUE
  350 CONTINUE
      DIS=DSQRT((PXYZ(1)-HTX)**2 + (PXYZ(2)-HTY)**2 + (PXYZ(3)-HTZ)**2)
C CONVERGENCE?
      IF (DIS.LT.1.D-12) GOTO 230
  220 CONTINUE
  230 CONTINUE
C
C DONE WITH THIS BOUNDARY; CHECK BOUNDS & TRY OTHER ONE IF NECESSARY
C ------------------------------------------------------------------
      IF (NT.EQ.1) GOTO 210
C
C BOTH U & V ARE OUT OF BOUNDS, CHECK IF NOW IN BOUNDS:
      HU = UV(1,1,NS)
      HV = UV(2,1,NS)
      CALL INTNRM(NS,HU,HV,PXYZ,SPV,IRC)
C POINT IS ALONG U BOUNDARY; IF TRULY WITHIN BOUNDS, RETURN: ***
      IF (IRC.EQ.0 .OR. J.EQ.3) GOTO 210
C
C SET VVV AT APPROPRIATE BOUNDARY:
      VVV = VBND
      J=3
      JJ=2
  200 CONTINUE
  210 CONTINUE
C
C LOAD THIS UV FOR LAST CALL TO INTTPL IN INTCON
      DO 370 M=1,3
      UV(1,M,NS)=UUU
      UV(2,M,NS)=VVV
  370 CONTINUE
C
  999 RETURN
      END
**** SOURCE FILE : M0004614.V01   ***
*
      SUBROUTINE INTCON(PT,NPT,KS)
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C SS - ARELEM - COMMON
      COMMON/SSARLM/BB(64,4),UU(4),VV(4),
     *              IITOP(6,4,4),IIFLAG(4,4),IPNUM(4)
C
C   COMMON FOR 2 SURFACE INTERSECTION
      COMMON/INTCOM/IKEEP(255)
C   LAST THREE U,V PAIRS OF PS AND DS
      DOUBLE PRECISION UV(2,3,2)
      EQUIVALENCE (IKEEP(129),UV(1,1,1))
C   HISTORY OF UNIT NORMALS AT INTERSECTION POINTS ON PS AND DS
      DOUBLE PRECISION UN(3,3,2)
      EQUIVALENCE (IKEEP(165),UN(1,1,1))
C   POINT OF INTERSECTION
      DOUBLE PRECISION PXYZ(3)
      EQUIVALENCE (IKEEP(205),PXYZ(1))
C   OLD POINT OF INTERSECTION
      DOUBLE PRECISION OXYZ(3)
      EQUIVALENCE (IKEEP(211),OXYZ(1))
C   DS TANGENT PLANE
      DOUBLE PRECISION DTP(4)
      EQUIVALENCE (IKEEP(217),DTP(1))
C   PS TANGENT PLANE
      DOUBLE PRECISION PTP(4)
      EQUIVALENCE (IKEEP(225),PTP(1))
C   PLANE PERPENTICULAR TO INTERSECTION DIRECTION
      DOUBLE PRECISION CTP(4)
      EQUIVALENCE (IKEEP(233),CTP(1))
C   8 TIMES ABSOLUTE TOLERANCE
      DOUBLE PRECISION CK
      EQUIVALENCE (IKEEP(241),CK)
C   MAXIMUM STEP
      DOUBLE PRECISION STEPMX
      EQUIVALENCE (IKEEP(243),STEPMX)
C   STEP LENGTH
      DOUBLE PRECISION STEP
      EQUIVALENCE (IKEEP(245),STEP)
C   OLD STEP LENGTH
      DOUBLE PRECISION OSTEP
      EQUIVALENCE (IKEEP(247),OSTEP)
C   TRACE
CCCCC EQUIVALENCE (IKEEP(249),ITRACE)
C   INTERNAL POINT COUNT
      EQUIVALENCE (IKEEP(250),IPTKNT)
C   MAXIMUM NUMBER OF POINTS
      EQUIVALENCE (IKEEP(251),NPTS)
C   OUT OF BOUND SIGNAL FOR PS AND DS
      INTEGER ISFER(2)
      EQUIVALENCE (IKEEP(252),ISFER(1))
C   PATCH NUMBER FOR PS AND DS (SURFACE RECNO*1000 + PATCH NO)
      INTEGER IPNR(2)
      EQUIVALENCE (IKEEP(254),IPNR(1))
C
      DOUBLE PRECISION PT(9,1),PL(4)
      DOUBLE PRECISION PT0(3)
      LOGICAL LPLANE, LSKIP
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C INITIAL STARTUP INFO.
C
CCCCC IF(ITRACE.EQ.1)
CCCCC*WRITE(6,1000)KS,PXYZ
C1000 FORMAT(' ***TRACE***INTCON-KS,START PXYZ=',I5,3G12.5)
      ISTATE = 1
      NBOUND = 0
      IPT=1
      NPT=0
      IPTKNT=NPTS
      IPTCK=IPTKNT-2
      HSTEP=STEPMX
C MAX. STEP = .25 FOR FIRST TWO POINTS:
      STEPMX=.25D0 * 25.4D0
      STMIN = 0.01D0 * 25.4D0
      IF (STEPMX.NE.0.D0) GOTO 50
      STEPMX = .25D0
      STMIN = .25D0
   50 CONTINUE
C
C SAVE INITIAL TANGENT FOR DETECTING LOOPAROUND TO START:
      PL(1)=CTP(1)
      PL(2)=CTP(2)
      PL(3)=CTP(3)
      PL(4)=CTP(1)*PXYZ(1) + CTP(2)*PXYZ(2) + CTP(3)*PXYZ(3)
      ICONT=1
      NDROP=-3
      STEP=0.D0
      OSTEP=STEP
      RADC=2000.D0
      DX=0.D0
      DY=0.D0
      DZ=0.D0
      ISTOUT=0
      CURVCK=CK*2.D0
      DIST = 0.D0
      LPLANE = .FALSE.
C IS S1 A PLANE?
      IF(IIFLAG(1,2).LE.0)LPLANE = .TRUE.
C
C PROCEED TO NEXT POINT; SAVE ALL CURRENT POSITIONS
  100 CONTINUE
C HISTORY OF UNIT NORMAL "UN":
      DO 110 I=1,3
      UN(I,3,1)=UN(I,2,1)
      UN(I,3,2)=UN(I,2,2)
      UN(I,2,1)=UN(I,1,1)
      UN(I,2,2)=UN(I,1,2)
  110 CONTINUE
C PREVIOUS TANGENT YABC & PREVIOUS INTERSECTION PT. PXYZ:
      OYA=CTP(1)
      OYB=CTP(2)
      OYC=CTP(3)
      OXYZ(1)=PXYZ(1)
      OXYZ(2)=PXYZ(2)
      OXYZ(3)=PXYZ(3)
C DISTANCE ALONG INTERSECTION:
      ODIST = DIST
C SHIFT U,V PARAMETERS FOR BOTH SURFACES WITHIN THE HISTORY TABLE
C  (LATEST U,V ARE STORED BY INTTPL):
      DO 114 I = 1,2
C STACK U HISTORY:
      UV(1,3,I) = UV(1,2,I)
      UV(1,2,I) = UV(1,1,I)
C STACK V HISTORY:
      UV(2,3,I) = UV(2,2,I)
  114 UV(2,2,I) = UV(2,1,I)
      ISFER(1)=0
      ISFER(2)=0
C AFTER FIRST TWO PTS. RESTORE MAX. STEP TO INPUT VALUE:
      IF(IPTCK.EQ.IPTKNT) STEPMX=HSTEP
C DECREMENT POINT COUNTDOWN COUNTER:
      IPTKNT=IPTKNT-1
      IF(IPTKNT.LE.0)GO TO 920
C IPAR = COUNTER OF RETRIES WHEN TANGENT PLANES ARE PARALLEL
      IPAR = 0
      LSKIP = .FALSE.
C
C CONTINUE ITERATING TO FIND A POINT:
  120 CONTINUE
C
C  EXTRAPOLATE NEXT POINT
C  ----------------------
      HX=OXYZ(1) + STEP*OYA
      HY=OXYZ(2) + STEP*OYB
      HZ=OXYZ(3) + STEP*OYC
      PXYZ(1)=HX + DX
      PXYZ(2)=HY + DY
      PXYZ(3)=HZ + DZ
C
  125 CONTINUE
C
C COMPUTE TANGENT PLANES
C ----------------------
C  COMPUTE SCALED DISTANCE ALONG INTERSECTION:
      DIST = ODIST + DSQRT((PXYZ(1)-OXYZ(1))**2
     *                   + (PXYZ(2)-OXYZ(2))**2 + (PXYZ(3)-OXYZ(3))**2)
C COMPUTE PLANE DTP, TANGENT TO DS
      CALL INTTPL(2,PXYZ,DTP,ISFER(2))
C COMPUTE PLANE PTP, TANGENT TO PS
      CALL INTTPL(1,PXYZ,PTP,ISFER(1))
C
C SAL = COS OF ANGLE BETWEEN PLANES:
      SAL=PTP(1)*DTP(1) + PTP(2)*DTP(2) + PTP(3)*DTP(3)
      CALSQ=1.D0-SAL*SAL
C
C ARE THE SURFACES PARALLEL?
      IF(CALSQ.GT.1.D-20)GO TO 260
C   ON FIRST PT., TRY ANYWAY:
      IF(KS.LT.0) GOTO 240
C TANGENT PLANES ARE PARALLEL; INCREASE STEP SIZE:
      STEP = STEP*1.7D0
      IPAR = IPAR + 1
C DON'T REDUCE STEP SIZE:
      IF(ISTATE.EQ.5)ISTATE=6
      IF(IPAR.LE.2)GO TO 120
      GOTO 920
  240 CALSQ=1.D-20
  260 CAL=DSQRT(CALSQ)*CTP(4)
C
C DS UNIT NORMALS
      UN(1,1,2)=DTP(1)
      UN(2,1,2)=DTP(2)
      UN(3,1,2)=DTP(3)
C PS UNIT NORMALS
      UN(1,1,1)=PTP(1)
      UN(2,1,1)=PTP(2)
      UN(3,1,1)=PTP(3)
C COMPUTE UNIT TANGENT VECTOR YABC:
      CTP(1)=(DTP(2)*PTP(3)-PTP(2)*DTP(3))/CAL
      CTP(2)=(DTP(3)*PTP(1)-PTP(3)*DTP(1))/CAL
      CTP(3)=(DTP(1)*PTP(2)-PTP(1)*DTP(2))/CAL
C HCO = COS OF ANGLE BETWEEN THIS TANGENT & PREVIOUS ONE:
      HCO=CTP(1)*OYA + CTP(2)*OYB + CTP(3)*OYC
C MAKE SURE CTP HAS NOT REVERSED:
      IF(HCO.GE.-.9D0)GO TO 270
      CTP(1) = -CTP(1)
      CTP(2) = -CTP(2)
      CTP(3) = -CTP(3)
      CTP(4) = -CTP(4)
      HCO = -HCO
C
C PROJECT EXTRAPOLATED POINT ONTO INTERSECTION OF TANGENT PLANES:
C ---------------------------------------------------------------
  270 D1=(PTP(4)-SAL*DTP(4))/CALSQ
      D2=DTP(4)-SAL*D1
      D3=CTP(1)*PXYZ(1) + CTP(2)*PXYZ(2) + CTP(3)*PXYZ(3)
      PXYZ(1)=PTP(1)*D1 + DTP(1)*D2 + CTP(1)*D3
      PXYZ(2)=PTP(2)*D1 + DTP(2)*D2 + CTP(2)*D3
      PXYZ(3)=PTP(3)*D1 + DTP(3)*D2 + CTP(3)*D3
C
C IF START UP (KS=-1), SAVE PT. & EXIT:
      IF(KS.LT.0) GOTO 540
C
C TEST FOR BOUNDARY, IF APPROPRIATE:
C ----------------------------------
C STILL WITHIN BOUNDS?
  280 IF(ISFER(1).EQ.0.AND.ISFER(2).EQ.0)GO TO 290
      IF(ISTATE.EQ.8.OR.ISTATE.EQ.10)GO TO 290
C NO; CUT STEP SIZE AND TRY FOR MORE POINTS:
      NBOUND = NBOUND + 1
      IF(ISTATE.LT.6.OR.ISTATE.EQ.9)ISTATE = 6
      ISTATE = ISTATE + 1
      STEP = STEP/10.D0
      IF(DABS(STEP).LT.STMIN)STEP = STMIN
      OSTEP = STEP
      IF(ISTATE.LT.8)GO TO 120
  290 CONTINUE
C
C BRANCH TO THE STEP CONTROL LOGIC:
C ---------------------------------
      GO TO (300,300,310,400,320,350,350,500,540,540),ISTATE
  300 STEP=0.D0
      ISTATE = ISTATE + 1
      GOTO 120
  310 STEP=STMIN
      ISTATE = 4
      GOTO 120
C
C DECREASE STEP SIZE UNLESS BEND IN INTERSECTION IS NEGLIGIBLE
C  AND TRY AGAIN WITH SAME POINT.
C -------------------------------
C  CHECK CHORDAL TOLERANCE
  320 NDROP=NDROP+1
      IF(NDROP.GE.0)ISTATE = 6
C CHECK CURVATURE FIRST
      CO=DABS(HCO)
      IF(CO.GT..999999997D0) GOTO 325
      SI=DSQRT(1.D0-CO*CO)
      FAC=SI*STEP/CURVCK
      IF(CO.LT..707D0) FAC=100.D0
      GOTO 326
C
C IF HERE, RADC IS CLOSE TO BEING STRAIGHT LINE, CHECK DROP
  325 D1=PXYZ(1)-OXYZ(1)
      D2=PXYZ(2)-OXYZ(2)
      D3=PXYZ(3)-OXYZ(3)
      SEC=DSQRT(D1*D1 + D2*D2 + D3*D3)
      IF(SEC.EQ.0.D0) SEC=1.D0
      D1=D1/SEC
      D2=D2/SEC
      D3=D3/SEC
      CO=DABS(D1*OYA + D2*OYB + D3*OYC)
      IF(CO.GT..9999999D0) GOTO 350
      SI=DSQRT(1.D0-CO*CO)
      FAC=SEC*SI/CK
  326 IF(FAC.LT.1.1D0) GOTO 350
C SCALE DOWN STEP SIZE:
      STEP=STEP/DSQRT(FAC)
C
C LOAD OLD UV FOR STEP FIX POINT ON SURFACE
      DO 340 J=1,2
      DO 340 I=1,3,2
      UV(1,I,J)=UV(1,2,J)
      UV(2,I,J)=UV(2,2,J)
  340 CONTINUE
      GOTO 120
C
C COMPUTE CORRECTION DX & STEP SIZE FOR NEXT POINT:
C -------------------------------------------------
  350 CONTINUE
      NDROP=-3
C IF NOT AT EDGE, ITERATE ON NEXT POINT:
      IF(ISTATE.EQ.6)ISTATE = 5
      DX=PXYZ(1)-HX
      DY=PXYZ(2)-HY
      DZ=PXYZ(3)-HZ
C
      IF(ISTOUT.NE.0) GOTO 400
      ISTOUT=1
      GOTO 120
C
C EXTRAPOLATE STEP SIZE FOR NEXT PXYZ
C -----------------------------------
  400 IF(CTP(1)**2 + CTP(2)**2 + CTP(3)**2.LT.1.D-10) GOTO 920
C
      OSTEP=DABS(STEP)
      IF(NBOUND.EQ.2)GO TO 540
      ORC=RADC
C COMPUTE STEP SIZE:
      D1=1.D0-HCO*HCO
      IF(D1-2.D-9) 410,410,420
C USE MAXIMUM STEP SIZE:
  410 STEP=STEPMX
      RADC=2000.D0
      GOTO 430
  420 SI=DSQRT(D1)
C
      IF(STEP.GT..001D0) RADC=DABS(STEP/SI)
      IF(ISTATE.EQ.4) ORC=RADC
C
C EXTRAP ONLY WHEN ORC & RADC IS REASONABLE
      RFAC=ORC/RADC
      IF(RFAC.GT.1.9D0.OR.RFAC.LT..55D0) ORC=RADC
      RCNEXT=2.D0*RADC-ORC
      IF(RCNEXT.LT..015D0) RCNEXT=.015D0
      STEP=DSQRT(CK*2.D0*RCNEXT)
      IF(STEP.LT..011D0) STEP=.011D0
C
C IF RAD. CURV. SMALL, REDUCE DXYZ CORRECTIONS
      IF(RADC.GT..1D0) GOTO 430
      RFAC=RADC*10.0D0
      DX=DX*RFAC
      DY=DY*RFAC
      DZ=DZ*RFAC
  430 CONTINUE
      IF(STEP.GT.STEPMX) STEP=STEPMX
C
      IF(OSTEP-.011D0) 460,460,450
  450 STEP2=OSTEP*1.5D0
      IF(STEP.GT.STEP2) STEP=STEP2
  460 CONTINUE
C GO TO NEXT POINT UNLESS 4TH ITERATION ON 1ST POINT:
      IF(ISTATE.GT.4)GO TO 530
      ISTATE = 5
      GO TO 120
C
C AT EDGE; SOLVE FOR BOUNDARY POINT:
C ----------------------------------
  500 IF(ISFER(1).NE.0) CALL INTBND(1,ISFER(1))
      IF(ISFER(2).NE.0) CALL INTBND(2,ISFER(2))
      ISTATE = 10
C SET IPTKNT FOR NORMAL RETURN:
      IPTKNT = -1
      GO TO 125
C
C STORE THE OUTPUT DATA
C ---------------------
C  IF BEND IN INTERSECTION > 100 DEG., EXIT:
  530 IF(HCO+.174D0) 920,920,540
C
C OUT OF BOUNDS?
  540 IF(ISFER(1).LT.0.OR.ISFER(2).LT.0)GO TO 920
C ACCUMULATE THE LENGTH ALONG INTERSECTION ***
      DIST = ODIST + DSQRT((PXYZ(1)-OXYZ(1))**2
     *                   + (PXYZ(2)-OXYZ(2))**2 + (PXYZ(3)-OXYZ(3))**2)
      IF (KS.NE.0) GOTO 510
      IF(IPT.GE.NPTS) GOTO 920
      IPT=IPT+1
  510 CONTINUE
C STORE  THE INTERSECTION PT
      PT(1,IPT)=PXYZ(1)
      PT(2,IPT)=PXYZ(2)
      PT(3,IPT)=PXYZ(3)
      IF (NPT.NE.0) GOTO 550
C SAVE THE START PT
      PT0(1) = PXYZ(1)
      PT0(2) = PXYZ(2)
      PT0(3) = PXYZ(3)
  550 CONTINUE
      IF (ISTATE.GE.10) GOTO 700
C
C CHECK FOR LOOPAROUND TO START (CLOSED SURFACE)
C ----------------------------------------------
C  HAS TANGENT VECTOR GONE NEGATIVE?
      IF (ICONT.NE.1) GOTO 560
      CS=PL(1)*CTP(1) + PL(2)*CTP(2) + PL(3)*CTP(3)
      IF(CS.LT.-.707D0) ICONT=-1
      GOTO 650
  560 CONTINUE
      IF (ICONT.NE.-1) GOTO 570
C HAS TANGENT VECTOR GONE NEGATIVE & BACK TO POSITIVE?
C  IF CS GOES POSITIVE, BEGIN CHECKS
      CS=PL(1)*CTP(1) + PL(2)*CTP(2) + PL(3)*CTP(3)
      IF(CS.GT..707D0) ICONT=0
      GOTO 650
  570 CONTINUE
C BACK TO START POSITION?
C  CONTINOUS CUT FLAG IS ON, CHECK CURRENT POSITION
      D1=PL(1)*PXYZ(1) + PL(2)*PXYZ(2) + PL(3)*PXYZ(3) - PL(4)
      IF(D1.LT.0.D0)GO TO 620
C
C PASSED START POSITION, CHECK DISTANCE FROM CURRENT POSITION
C  TO START POINT.
      DX1=PXYZ(1)-PT0(1)
      DY1=PXYZ(2)-PT0(2)
      DZ1=PXYZ(3)-PT0(3)
      D1=DABS(CTP(1)*DX1 + CTP(2)*DY1 + CTP(3)*DZ1)
      IF(D1.GT.3.D0*OSTEP) GOTO 620
      D1=DSQRT(DX1**2 + DY1**2 + DZ1**2)
      IF(D1.LT..01D0) GOTO 605
      CO=CTP(1)*DX1/D1 + CTP(2)*DY1/D1 + CTP(3)*DZ1/D1
      IF(DABS(CO).GT..9999999D0) GOTO 605
      SI=DSQRT(1.D0-CO*CO)
      IF(D1*SI/CK.GT.1.2D0) GOTO 620
C
C LOAD START POINT HERE & SET EXIT FLAG
  605 IPTKNT=-1
      ISTATE = 11
      IF (KS.NE.0) GOTO 640
C
C SET LAST POSITION DATA TO FIRST POSITION DATA
      DO 630 I=1,3
      PT(I,IPT)=PT(I,1)
      PT(I+3,IPT)=PT(I+3,1)
      PT(I+6,IPT)=PT(I+6,1)
  630 CONTINUE
      GO TO 920
  640 CONTINUE
  650 CONTINUE
  700 CONTINUE
  620 CONTINUE
      IF (KS.NE.0 .AND. ISTATE.LE.9 .AND. NPT.NE.0) GOTO 720
C STORE PT, NORMAL & TANGENT ...
C  TZCK = PXYZ(1)*DTP(1) + PXYZ(2)*DTP(2) + PXYZ(3)*DTP(3) - DTP(4)
C  TXCK = PXYZ(1)*PTP(1) + PXYZ(2)*PTP(2) + PXYZ(3)*PTP(3) - PTP(4)
C   COMPUTE PLANE DTP, TANGENT TO DS
      CALL INTTPL(2,PXYZ,DTP,ISFER(2))
C COMPUTE PLANE PTP, TANGENT TO PS
      CALL INTTPL(1,PXYZ,PTP,ISFER(1))
C SAL = COS OF ANGLE BETWEEN PLANES:
      SAL=PTP(1)*DTP(1) + PTP(2)*DTP(2) + PTP(3)*DTP(3)
      CALSQ=1.D0-SAL*SAL
      IF(CALSQ.LT.1.D-20)CALSQ = 1.D-20
      CAL=DSQRT(CALSQ)*CTP(4)
C COMPUTE UNIT TANGENT VECTOR YABC:
      CTP(1)=(DTP(2)*PTP(3)-PTP(2)*DTP(3))/CAL
      CTP(2)=(DTP(3)*PTP(1)-PTP(3)*DTP(1))/CAL
      CTP(3)=(DTP(1)*PTP(2)-PTP(1)*DTP(2))/CAL
      PT(4,IPT)=UV(1,1,2)
      PT(5,IPT)=UV(2,1,2)
      PT(6,IPT)=IPNR(2)
      PT(7,IPT)=UV(1,1,1)
      PT(8,IPT)=UV(2,1,1)
      PT(9,IPT)=IPNR(1)
  720 CONTINUE
      NPT = NPT+1
C START PT. ONLY?
      IF(KS.LT.0)GO TO 920
C IF OUTSIDE EDGE, QUIT; IF INTERPATCH BOUNDARY, CONTINUE:
      IF(ISTATE.EQ.10)GO TO 920
      IF(ISTATE.EQ.9)ISTATE = 5
C GO FOR ANOTHER PT. IF NOT AT EDGE OR BACK AT START:
      IF(ISTATE.LT.10)GO TO 100
C
C RETURN THE LENGTH ALONG INTERSECTION
C ------------------------------------
  920 CONTINUE
      IF(KS.EQ.0) NPT=IPT
      STEPMX=HSTEP
C
      RETURN
      END
**** SOURCE FILE : M0012393.V01   ***
*
      SUBROUTINE INTFA1 (FACE,PL,PF,IRC1)
C
      DOUBLE PRECISION FACE(6,3),PL(4),PF(3),V2(3),V3(3)
C
      IRC1=0
      DO 10 I=1,3
      V2(1)=PF(1)-FACE(1,I)
      V2(2)=PF(2)-FACE(2,I)
      V2(3)=PF(3)-FACE(3,I)
      CALL CROSS (V2,FACE(4,I),V3)
      IF(PL(1)*V3(1)+PL(2)*V3(2)+PL(3)*V3(3).LT.0.D0) GOTO 20
   10 CONTINUE
      IRC1=1
   20 CONTINUE
C
      RETURN
      END
**** SOURCE FILE : M0012399.V01   ***
*
      SUBROUTINE INTFA2 (FACE,PL,P1,P2,IRC1)
C
      DOUBLE PRECISION FACE(6,3),PL(4),P1(3),P2(3),PI(3),DIST,DIST1
C
      DIST1=-PL(4)
      DIST=0.D0
C
      DO 10 I=1,3
      DIST1=DIST1+PL(I)*P1(I)
   10 DIST=DIST+(P2(I)-P1(I))*PL(I)
C
      DIST=DIST1/DIST
C
      DO 20 I=1,3
   20 PI(I)=P1(I)+(P2(I)-P1(I))*DIST
C
      CALL INTFA1(FACE,PL,PI,IRC1)
C
      RETURN
      END
**** SOURCE FILE : M0012323.V01   ***
*
      SUBROUTINE INTNRM(NS,U,V,PTA,SPVA,IRC)
C
C     INTNRM COMPUTES THE POINT  ON A SURFACE FROM WHICH A SURFACE
C     NORMAL PASSES THRU POINT 'PTA'. THE UV VALUES ARE USED FOR A
C     CLOSE APPROXIMATION ON INPUT AND ARE ADJUSTED TO THE ACTUAL
C     UV OF SURFACE ON OUTPUT.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      DIMENSION PTA(3),SPVA(4,8),SPVI(4,8)
      DIMENSION XU(3),XV(3),XUU(3),XVV(3),XUV(3)
      EQUIVALENCE (SPVI(1,2),XU(1)),(SPVI(1,3),XV(1))
      EQUIVALENCE (SPVI(1,4),XUU(1))
      EQUIVALENCE (SPVI(1,5),XUV(1)),(SPVI(1,6),XVV(1))
C
C SS - ARELEM - COMMON
      COMMON/SSARLM/BB(64,4),UU(4),VV(4),
     *              IITOP(6,4,4),IIFLAG(4,4),IPNUM(4)
C
C   COMMON FOR 2 SURFACE INTERSECTION
      COMMON/INTCOM/IKEEP(255)
CCCCC EQUIVALENCE (IKEEP(249),ITRACE)
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
CCCCC IF(ITRACE.EQ.1)
CCCCC*WRITE(6,1000)
C1000 FORMAT(' ***TRACE***INTNRM')
      IRC=0
      DTOL=1.D-12
      UI=U
      VI=V
C
      ISCAN=0
      NTIM = 0
      GOTO 25
C
C SCAN ENTIRE SURFACE FOR GLOBAL MIN. DIST. POINT
C -----------------------------------------------
   15 ISCAN=1
      D1=90.D30
      U1=.5D0
      V1=.5D0
      TUVINC = 1.0D0
      DO 350 K=1,3
      TUVINC = TUVINC/10.0D0
      UVINC=TUVINC
      IF(K.GT.1) UVINC=UVINC*2.D0
      US=U1 - UVINC*5.D0
      VS=V1 - UVINC*5.D0
      DO 340 I=1,11
      V=VS + UVINC*(I-1)
      DO 330 J=1,11
      U=US + UVINC*(J-1)
      CALL CNSURF(U,V,BB(1,NS),SPVA,IIFLAG(1,NS),0)
      D2=(SPVA(1,1)-PTA(1))**2 + (SPVA(2,1)-PTA(2))**2
     *                         + (SPVA(3,1)-PTA(3))**2
      IF (D2.GE.D1) GOTO 320
      D1=D2
      U1=U
      V1=V
  320 CONTINUE
  330 CONTINUE
  340 CONTINUE
  350 CONTINUE
      U=U1
      V=V1
C
C ALLOW ONLY UNIT SQUARE UV
   25 IF(U.LT.0.D0) U=0.D0
      IF(V.LT.0.D0) V=0.D0
      IF(U.GT.1.D0) U=1.D0
      IF(V.GT.1.D0) V=1.D0
C SAVE BEST SOLN FOR RESET
      DSQMIN = 999.D0
      UMIN = U
      VMIN = V
      ULIM0 = 0.D0
      ULIM1 = 1.D0
      VLIM0 = 0.D0
      VLIM1 = 1.D0
      UX0 = 0.D0
      VX0 = 0.D0
      DUMIN = 1.D0
      DVMIN = 1.D0
C
C ITERATE (31 TIMES MAX.) TO FIND LOCAL MIN. DIST PTA
C ---------------------------------------------------
      DO 600 I=1,31
      NTIM=NTIM + 1
      USV=U
      VSV=V
      IF (I.LT.11) GOTO 440
C
C FIRST TIME HERE, DO DIAGONAL MINI-SEARCH FOR BEST SOLN
      IF (I.NE.11) GOTO 430
      D1=90.D30
      U = UX0
      DU = DUMIN/10.D0
      V = VX0
      DV = DVMIN/10.D0
      DO 420 K=1,2
      DO 410 J=1,9
      U = U + DU
      V = V + DV
      CALL CNSURF(U,V,BB(1,NS),SPVA,IIFLAG(1,NS),0)
      D2=(SPVA(1,1)-PTA(1))**2+(SPVA(2,1)-PTA(2))**2
     *                        +(SPVA(3,1)-PTA(3))**2
      IF (D2.GE.D1) GOTO 400
      D1=D2
      UI=U
      VI=V
  400 CONTINUE
  410 CONTINUE
C SEARCH OPPOSITE DIAGONAL
      U = UX0
      V = V + DV
      DV = -DV
  420 CONTINUE
      U = UI
      V = VI
  430 CONTINUE
C
C IF HERE, USE NEWTON'S METHOD
C ----------------------------
C  COMPUTE POINT, 1ST & 2ND DERIVATIVES
      CALL CNSURF(U,V,BB(1,NS),SPVI,IIFLAG(1,NS),2)
      DX=PTA(1) - SPVI(1,1)
      DY=PTA(2) - SPVI(2,1)
      DZ=PTA(3) - SPVI(3,1)
C SOLVE FOR F(U,V) & G(U,V) = 0 ***
      FUV = DX*XU(1) + DY*XU(2) + DZ*XU(3)
      GUV = DX*XV(1) + DY*XV(2) + DZ*XV(3)
C CONVERGENCE ?
      IF(DABS(FUV).LT.DTOL.AND.DABS(GUV).LT.DTOL)GO TO 110
C EVALUATE PARTIALS OF F & G
      DFDU = (DX*XUU(1) + DY*XUU(2) + DZ*XUU(3)) -
     *                       (XU(1)**2 + XU(2)**2 + XU(3)**2)
      DFDV = (DX*XUV(1) + DY*XUV(2) + DZ*XUV(3)) -
     *                       (XU(1)*XV(1) + XU(2)*XV(2) + XU(3)*XV(3))
      DGDU = DFDV
      DGDV = (DX*XVV(1) + DY*XVV(2) + DZ*XVV(3)) -
     *                       (XV(1)**2 + XV(2)**2 + XV(3)**2)
      DET = DFDU*DGDV - DFDV*DGDU
C COMPUTE CORRECTIONS TO U & V
      DELU = -(DGDV*FUV - DFDV*GUV)/DET
      DELV = -(DFDU*GUV - DGDU*FUV)/DET
C SAVE UPPER & LOWER BOUNDS ON U & V
      IF(DELU.GT.0.D0)ULIM0 = DMAX1(ULIM0,U)
      IF(DELU.GT.0.D0)ULIM1 = DMAX1(ULIM1,U)
      IF(DELV.GT.0.D0)VLIM0 = DMAX1(VLIM0,V)
      IF(DELV.GT.0.D0)VLIM1 = DMAX1(VLIM1,V)
      IF(DELU.LT.0.D0)ULIM1 = DMIN1(ULIM1,U)
      IF(DELU.LT.0.D0)ULIM0 = DMIN1(ULIM0,U)
      IF(DELV.LT.0.D0)VLIM1 = DMIN1(VLIM1,V)
      IF(DELV.LT.0.D0)VLIM0 = DMIN1(VLIM0,V)
      GOTO 490
  440 CONTINUE
C
C 1ST 11 TIMES USE  PLANE CONVERGENCE APPROACH
C --------------------------------------------
      CALL CNSURF(U,V,BB(1,NS),SPVI,IIFLAG(1,NS),2)
C
C GET LENGTH OF PARTIALS
      SECU=DSQRT(XU(1)**2 + XU(2)**2 + XU(3)**2)
      SECV=DSQRT(XV(1)**2 + XV(2)**2 + XV(3)**2)
C
      DX=PTA(1)-SPVI(1,1)
      DY=PTA(2)-SPVI(2,1)
      DZ=PTA(3)-SPVI(3,1)
      D1=(XU(1)*DX + XU(2)*DY + XU(3)*DZ)/SECU
      D2=(XV(1)*DX + XV(2)*DY + XV(3)*DZ)/SECV
C
C CAL. COS-1 BETWEEN PARTIALS
      COS=(XU(1)*XV(1)+XU(2)*XV(2)+XU(3)*XV(3))/(SECU*SECV)
      CS=1.D0-COS*COS
      IF(CS.LT.1.D-20) CS=1.D-20
C
      DELU=(D1-D2*COS)/CS
      IF(DABS(DELU).LT.1.D-20) DELU=1.D-20
      DSQ=DSQRT(DELU*DELU*CS + D2*D2)
C
C IF DISTANCE IS LT 1.D-12; EXIT
      IF(DSQ.LT.DTOL) GOTO 110
C SAVE BEST SOLN FOR RESET
      IF (DSQ.GE.DSQMIN) GOTO 450
      DSQMIN = DSQ
      UMIN = U
      VMIN = V
  450 CONTINUE
C
C RECALCULATE U & V
C -----------------
      DELV=(D2-DELU*COS)/SECV
      DELU=DELU/SECU
C SAVE MIN. OSCILLATION DIST. ***
      IF (I.EQ.1) GOTO 480
      IF (ODELU*DELU.GE.0.D0.OR.DABS(U-OU).GE.DABS(DUMIN)) GOTO 460
      UX0 = OU
      DUMIN = U - OU
  460 CONTINUE
      IF (ODELV*DELV.GE.0.D0.OR.DABS(V-OV).GE.DABS(DVMIN)) GOTO 470
      VX0 = OV
      DVMIN = V - OV
  470 CONTINUE
  480 CONTINUE
  490 CONTINUE
      IF(DABS(DELU).GT..25D0) DELU=.25D0*DELU/DABS(DELU)
      IF(DABS(DELV).GT..25D0) DELV=.25D0*DELV/DABS(DELV)
      DU=DELU
      DV=DELV
      IF (I.EQ.1.OR.I.EQ.11) GOTO 540
C AITKEN DEL SQUARE ALGORITHM ---------------------------
C  USE SECANT TO EXTRAPOLATE/INTERPOLATE NEXT U & V
      DEN=ODELU-DELU
      IF (DABS(DEN).LE.1.D-20) GOTO 510
      RNUM=U-OU
      IF (DABS(RNUM).LE.1.D-20) GOTO 500
      RTU=RNUM/DEN
      IF(RTU.GT.1.D-12) DU=DELU*RTU
      IF(ODELU*DELU.LT.0.D0) DU=DU*.67D0
  500 CONTINUE
  510 CONTINUE
C
C CAL. NEW V
      DEN=ODELV-DELV
      IF (DABS(DEN).LE.1.D-20) GOTO 530
      RNUM=V-OV
      IF (DABS(RNUM).LE.1.D-20) GOTO 520
      RTV=RNUM/DEN
      IF(RTV.GT.1.D-12) DV=DELV*RTV
      IF(ODELV*DELV.LT.0.D0) DV=DV*.67D0
  520 CONTINUE
  530 CONTINUE
  540 CONTINUE
C
C UPDATE U & V AND LOOP BACK  ---------------------------------
      OU=U
      U=U+DU
      U2 = OU + DELU
      ODELU=DELU
      OV=V
      V=V+DV
      V2 = OV + DELV
      ODELV=DELV
C
C KEEP U & V WITHIN LIMITS ------------------------------------
      IF(U.LT.0.D0)U=0.D0
      IF(V.LT.0.D0)V=0.D0
      IF(U.GT.1.D0)U=1.D0
      IF(V.GT.1.D0)V=1.D0
      IF(U2.LT.0.D0)U2=0.D0
      IF(V2.LT.0.D0)V2=0.D0
      IF(U2.GT.1.D0)U2=1.D0
      IF(V2.GT.1.D0)V2=1.D0
C
C CONVERGENCE ?
      IF(DABS(U-USV).LT.1.D-10.AND.DABS(V-VSV).LT.1.D-10)GO TO 110
C
C    NO CHANGE IN U OR V, USE THIS POINT NORMAL
C WHICH IS BETTER, (U,V) OR (U2,V2) ?
      CALL CNSURF(U,V,BB(1,NS),SPVI,IIFLAG(1,NS),0)
      DD1=(PTA(1)-SPVI(1,1))**2+(PTA(2)-SPVI(2,1))**2
     *                         +(PTA(3)-SPVI(3,1))**2
      CALL CNSURF(U2,V2,BB(1,NS),SPVI,IIFLAG(1,NS),0)
      DD2=(PTA(1)-SPVI(1,1))**2+(PTA(2)-SPVI(2,1))**2
     *                         +(PTA(3)-SPVI(3,1))**2
      IF (DD2.GE.DD1) GOTO 550
      U = U2
      V = V2
  550 CONTINUE
  600 CONTINUE
C
C END OF LOOP WITH NO SOL., SCAN ENTIRE SURFACE
      IF(ISCAN.EQ.0) GOTO 15
C
C IF U OR V ON OR BEYOND SURFACE BOUNDARY AND THE ENTRY POINT
C  DROPPED TO THE SURFACE IS OUT OF BOUNDS BY MORE THAN 1.D-4,
C  GENERATE A NEGATIVE RETURN CODE TO INITIATE ENDUP.
C  EVALUATE POINT, AND DERIVATIVES ----------------------------------
  110 CALL CNSURF(U,V,BB(1,NS),SPVA,IIFLAG(1,NS),2)
      UTOL=1.D-4
      VTOL=UTOL
      IF(DABS(U-.5D0).GE..5D0.AND.DABS(D1).GT.UTOL) IRC=-1
      IF(DABS(V-.5D0).GE..5D0.AND.DABS(D2).GT.VTOL) IRC=-1
C
  999 RETURN
      END
**** SOURCE FILE : M0012405.V03   ***
*
      SUBROUTINE INTOUT(IOUT,PTT,NP,IORD,J11,J12,SNAME,SINDEX)
C
C   OUTPUT OF INTERSECTION ROUTINES
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      DOUBLE PRECISION PTT(9,1)
C
C   OUTPUT FIELD FOR CANON
      CHARACTER*80 OF
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
C
C
C   COMMON FOR 2 SURFACE INTERSECTION
      COMMON/INTCOM/IKEEP(255)
C   EVALUATION VECTOR FOR PS AND DS
      DOUBLE PRECISION SPV(4,8,2)
      EQUIVALENCE (IKEEP(  1),SPV(1,1,1))
C   PATCH NUMBER FOR PS AND DS (SURFACE RECNO*1000 + PATCH NO)
      INTEGER IPNR(2)
      EQUIVALENCE (IKEEP(254),IPNR(1))
C
C SS - ARELEM - COMMON
      COMMON/SSARLM/BB(64,4),UU(4),VV(4),
     *              IITOP(6,4,4),IIFLAG(4,4),IPNUM(4)
C
C  EXFILE INTRODUCTION
      DOUBLE PRECISION LEIT(9)
      INTEGER ILEIT(18)
      EQUIVALENCE (LEIT(1),ILEIT(1))
C
C     BLANK-COMMON
      INCLUDE 'BLANKCOM.INC'
C
C SYSTEM - I/O NAMES
      INCLUDE 'SYMFIL.INC'
C
C   POINT STORAGE FOR TRANSFORMATION PURPOSE
      DOUBLE PRECISION PT(3),PT1(4)
      EQUIVALENCE(PT1(2),PT(1))
C   VECTOR STORAGE FOR TRANSFORMATION PURPOSE
      DOUBLE PRECISION VN(3),VT1(4),VT2(3)
      EQUIVALENCE(VT1(2),VN(1))
C
C  MOTION DIRECTION
      DOUBLE PRECISION DM(3)
C
      INTEGER Z4E,BCDF
      PARAMETER (Z4E=1308622848)
      LOGICAL FIRST
      SAVE FIRST,ILEIT
      DATA ILEIT/0,0,Z4E,0,Z4E,6,Z4E,1,0,0,Z4E,0,0,0,Z4E,0,Z4E,0/
      DATA PT1/19030000.0D0,3*.0D0/
      DATA VT1/20030000.0D0,3*.0D0/
      DATA FIRST/.TRUE./
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C     INITIALISE CHARACTER ITEMS FOR OUTPUT TO EXFILE
C
      IF (FIRST) THEN
        ILEIT(1)=BCDF('CLDA')
        ILEIT(2)=BCDF('TA  ')
        ILEIT(9)=BCDF('INTS')
        ILEIT(10)=BCDF('EC  ')
        ILEIT(13)=BCDF('    ')
        ILEIT(14)=ILEIT(13)
        FIRST=.FALSE.
      ENDIF
           
C  TYPE OF OPERATION
      ITYPE=IOUT+1
C
C  START AND INCREMENTS FOR OUTPUT
      IP=1
      IF(IORD.LT.0)IP=NP
      IPD=1
      IF(IORD.LT.0)IPD=-1
C
C  PREPARATION FOR EXFILE OUTPUT
      IF(ITYPE.NE.1)GOTO 10
      NR=0
      J=18
      CALL RECORD(ISEQNO)
      ILEIT(4)=ISEQNO
C  NAME
      LEIT(7)=SNAME
      ILEIT(16)=SINDEX
      ILEIT(18)=29
      CALL EWRITE(EXFILE,NR,LEIT,J,IR)
C
C  OUTPUT LOOP
   10 DO 50 I=1,NP
      GOTO (20,30,40),ITYPE
      RETURN
C
C   EXFILE OUTPUT ****************************************************
C
C  STORING INTERSECTION POINT
   20 DO 110 J=1,3
      TEK(J)=TE(J)
  110 PT(J)=PTT(J,IP)
      CALL TRANSM(TE,PT,2,3,0)
C
C LOAD PS PATCH IF NECESSARY
      IPATCH=PTT(9,IP)
      IPA=IPATCH-IPATCH/1000*1000
      IF(IPNR(1).NE.IPATCH)
     *CALL LODPCH(SSCAN(J12+1),BB(1,1),IIFLAG(1,1),IITOP(1,1,1),IPA,0)
      IPNR(1)=IPATCH
C
C STORE (U,V,P)-VALUES OF PS FOR ATAPE
      UU(1)=PTT(7,IP)
      VV(1)=PTT(8,IP)
      IPNUM(1)=IPA
C
C  EVALUATE POINT
      CALL CNSURF(UU(1),VV(1),BB(1,1),SPV(1,1,1),IIFLAG(1,1),2)
C
C STORE SURFACE POINT WITH NORMAL FOR ATAPE
      DO 120 J=1,3
      PT(J)=PTT(J,IP)
      VN(J)=SPV(J,8,1)
  120 CONTINUE
      CALL TRANSM(SP(1,IPS),PT,2,3,0)
      CALL TRANSM(SN(1,IPS),VN,3,3,0)
C
C LOAD DS PATCH IF NECESSARY
      IF(IIFLAG(1,2).LE.0)GOTO 124
      IPATCH=PTT(6,IP)
      IPA=IPATCH-IPATCH/1000*1000
      IF(IPNR(2).NE.IPATCH)
     *CALL LODPCH(SSCAN(J11+1),BB(1,2),IIFLAG(1,2),IITOP(1,1,2),IPA,0)
      IPNR(2)=IPATCH
C
C STORE (U,V,P)-VALUES OF PS FOR ATAPE
      UU(2)=PTT(4,IP)
      VV(2)=PTT(5,IP)
      IPNUM(2)=IPA
C
C  EVALUATE POINT
      CALL CNSURF(UU(2),VV(2),BB(1,2),SPV(1,1,2),IIFLAG(1,2),2)
      GOTO 126
C
C  PLANE DS
  124 UU(2)=0.D0
      VV(2)=0.D0
      IPNUM(2)=0
C
C STORE SURFACE POINT WITH NORMAL FOR ATAPE
  126 DO 130 J=1,3
      PT(J)=PTT(J,IP)
      IF(IIFLAG(1,2).LE.0)SPV(J,8,2)=BB(J,2)
      VN(J)=SPV(J,8,2)
  130 CONTINUE
      CALL TRANSM(SP(1,IDS),PT,2,3,0)
      CALL TRANSM(SN(1,IDS),VN,3,3,0)
C
C  NORMALIZE MOTION DIRECTION
      CALL CROSS(SPV(1,8,2),SPV(1,8,1),DM)
      VLL=DSQRT(DM(1)**2+DM(2)**2+DM(3)**2)
      DO 140 J=1,3
      DM(J)=DM(J)/VLL
  140 VN(J)=DM(J)
      CALL TRANSM(TI,VN,3,3,0)
C
C  STORE POSITION ON EXFILE
      ICL=2
      IF(I.EQ.NP)ICL=3
      CALL ATAPE
      GOTO 49
C
C   SSCAN OUTPUT *******************************************************
   30 CONTINUE
C   PS PATCH INDEX FOR POINT NAME
      IPA=PTT(9,IP)
      OF=' '
      CALL ICONV (IPA+10000,OF,1,5)
      CALL CFORM ('PT',OF,1,2)
      CALL CFORM ('(',OF,7,1)
C  POINT INDEX
      CALL ICONV (I,OF,8,4)
      CALL CFORM (')=POINT/',OF,12,8)
C  X,Y,Z
      CALL FCONV (PTT(1,IP),OF,20,16,6)
      CALL CFORM (',',OF,36,1)
      CALL FCONV (PTT(2,IP),OF,37,16,6)
      CALL CFORM (',',OF,53,1)
      CALL FCONV (PTT(3,IP),OF,54,16,6)
C  FILLER
      CALL CFORM ('  ',OF,70,2)
      GOTO 48
C
C   HEX OUTPUT *********************************************************
   40 CONTINUE
      OF=' HEX OUTPUT NOT SUPPORTED IN THIS VERSION'
      CALL CPRINT(OF)
      GOTO 30
C   PS PATCH INDEX FOR POINT NAME
C      IPA=PTT(9,IP)
C      CALL ICONV (IPA+10000,OF,1,5)
C      CALL CFORM ('PT',OF,0,2)
C      CALL CFORM ('  ',OF,6,2)
C  POINT INDEX
C      PP=I
C      CALL CFORM (PP,OF,8,8)
C  POINT TYPE AND LENGTH OF SSCANICAL FORM
C      CALL CFORM (1,OF,16,4)
C      CALL CFORM (6,OF,20,4)
C  FILLER
C      CALL CFORM (0.D0,OF,24,8)
C  X,Y,Z
C      CALL CFORM (PTT(1,IP),OF,32,8)
C      CALL CFORM (PTT(2,IP),OF,40,8)
C      CALL CFORM (PTT(3,IP),OF,48,8)
C  FILLER
C      CALL CFORM (0.D0,OF,56,8)
C      CALL CFORM (0.D0,OF,64,8)
C  COMMON OUTPUT OF SSCAN AND HEX
   48 CALL HOLFRM (SNAME,OF(73:80),1,6,N)
      CALL CFORM ('  ',OF,79,2)
      INDEX=SINDEX
      IF(INDEX.NE.0)CALL ICONV(INDEX,OF,79,2)
      CALL CPUNCH(OF,1)
C
C  POINT INDEX INCREMENTING
   49 IP=IP+IPD
   50 CONTINUE
C
C  END PUNCH OUTPUT FOR HEX FORMAT
C      IF(ITYPE.NE.3)GOTO 99
C      CALL CFORM ('(ENDPCH)',OF,1,8)
C      DO 60 I=8,65,8
C      CALL CFORM ('        ',OF,I,8)
C   60 CONTINUE
C      CALL CFORM (-1,OF,73,4)
C      CALL CFORM (-1,OF,77,4)
C      CALL CPUNCH(OF,1)
C
   99 RETURN
      END
**** SOURCE FILE : M0011516.V03   ***
*
      SUBROUTINE INTSEC
C
C ROUTINE TO INTERSEC A PLANE WITH SSURF'S  OR
C                       SSURF'S WITH SSURF'S
C
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C  INTERSECTION START POINT
      DOUBLE PRECISION STP(3)
C
C  POLYEDER STORAGE
      DOUBLE PRECISION POED1(3,5,5),POED2(3,5,5),DUMMY1(2),DUMMY2(2)
      EQUIVALENCE (POED1(3,5,5),DUMMY1(1))
      EQUIVALENCE (POED2(3,5,5),DUMMY2(1))
C
C   PLANE STORAGE FOR TRANSFORMATION PURPOSE
      DOUBLE PRECISION PL(4),PL1(6)
      EQUIVALENCE(PL1(2),PL(1))
C
C SS - ARELEM - COMMON
      COMMON/SSARLM/BB(64,4),UU(4),VV(4),
     *              IITOP(6,4,4),IIFLAG(4,4),IPNUM(4)
C
C   SECTION INDICATORS
      INTEGER INTDS(0:900),INTPS(0:900)
C
C   CONTOUR POINTER FIELD
C    JCON(1,X) : POINTER TO FIRST SEGMENT
C    JCON(2,X) : POINTER TO LAST SEGMENT
      INTEGER MCON
      PARAMETER (MCON=50)
      INTEGER JCON(2,MCON)
C    ICON : CURRENT CONTOUR
C    NCON : NEW CONTOUR
      INTEGER ICON,NCON
C
C   CONTOUR SEGMENT FIELD
C    JSIX(1,X) : POINTER TO FIRST POINT IN PT ARRAY
C    JSIX(2,X) : POINTER TO LAST POINT IN PT ARRAY
C    JSIX(3,X) : POINTER TO PREVIOUS CONTOUR SEGMENT
C    JSIX(4,X) : POINTER TO FOLLOWING CONTOUR SEGMENT
      INTEGER MSIX
      PARAMETER (MSIX=200)
      INTEGER JSIX(4,MSIX)
C    ISIX : CURRENT CONTOUR SEGMENT
C    NSIX : NEW CREATET CONTOUR SEGMENT
      INTEGER ISIX,NSIX
C
C   COMMON FOR 2 SURFACE INTERSECTION
      COMMON/INTCOM/IKEEP(255)
C   THICKNESS ON PS AND DS
      DOUBLE PRECISION THICK(2)
      EQUIVALENCE (IKEEP(201),THICK(1))
C   SUBROUTINE TRACE
CCCCC EQUIVALENCE (IKEEP(249),ITRACE)
C   PATCH NUMBER FOR PS AND DS (SURFACE RECNO*1000 + PATCH NO)
      INTEGER IPNR(2)
      EQUIVALENCE (IKEEP(254),IPNR(1))
C
C       TOTAL-LIBRARY.
C
      INCLUDE 'TOTAL.INC'
C
      INCLUDE 'SV.INC'
C
      INCLUDE 'IFXCOR.INC'
C
      DOUBLE PRECISION HMOD
C
C BLANK COMMON
      INCLUDE 'BLANKCOM.INC'
C
C SCRATCH AREA TO STORE THE RESULTING POINTS
      COMMON/SSPAD/NSCNMX,ISCAN,PT(9,1000)
C
C SWITCH FOR PLANE/SSURF (=1) OR SSURF/SSURF (=2) INTERSECTION
      INTEGER IWHAT
C
C CHECK DEFINITION FUNCTION
      LOGICAL CKDEF
C
C STORAGE FOR FIRST AND SECOND SET OF SSURF'S
      INTEGER IFIRST(50), ISECND(50)
C
C CONTROL WORDS
      CHARACTER*8 WITH,DCANON,HEX,TEST
C
      INTEGER BCDF
C
      DOUBLE PRECISION WORD
      INTEGER IWORD(2)
      EQUIVALENCE (WORD,IWORD(1))
      LOGICAL FIRST
      SAVE FIRST,PL1
C
      DATA STP/3*0.D0/
      DATA PL1/1030000.0D0,5*.0D0/
      DATA WITH/'WITH    '/,DCANON/'CANON   '/,HEX/'HEX     '/
      DATA FIRST/.TRUE./
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C.... INITIALISE CHARACTER ITEM FOR OUTPUT TO EXFILE
C
      IF (FIRST) THEN
        IWORD(1)=BCDF('SYSP')
        IWORD(2)=BCDF('L   ')
        PL1(6)=WORD
        FIRST=.FALSE.
      ENDIF
C
C SET THICKNESS FOR DRIVE-SURFACE
      THDOLD=TH(IDS)
      TOLD=.8D0*(TAU1(IDS)-TAU2(IDS))
      TH(IDS)=TH(IDS)+TAU2(IDS)+TOLD/8.D0
      THICK(1)=TH(IDS)
C
C SET THICKNESS FOR PART-SURFACE
      THPOLD=TH(IPS)
      TOLP=.8D0*(TAU1(IPS)-TAU2(IPS))
      TH(IPS)=TH(IPS)+TAU2(IPS)+TOLP/8.D0
      THICK(2)=TH(IPS)
C
C READ THE INTERSECTION ARGUMENT AND STORE THEM
      NFIRST=0
      NSECND=0
      IWHAT=1
      IOUT=0
      MSCAN=SSCAN(2)
      ISCAN=3
    1 IF(ISCAN.GE.MSCAN) GOTO 20
C
C GEOMETRY ?  (PLANE/LINE OR SSURF)
      IF((SSCAN(ISCAN).NE.1.D0.AND.SSCAN(ISCAN).NE.2.D0)
     *                       .AND.SSCAN(ISCAN).NE.29.D0) GOTO 10
C
C CHECK, IF GEOMETRY IS VALID
      IF(.NOT.CKDEF(SSCAN(ISCAN))) GOTO 2
C
C GEOMETRY ELEMENT IS NOT DEFINED: RETURN WITHOUT RESULT
      CALL ERROR(22830,'INTSEC  ')
      GOTO 999
C
C LINE / PLANE ?
    2 IF(SSCAN(ISCAN).NE.1.D0.AND.SSCAN(ISCAN).NE.2.D0) GOTO 5
C
C  NORMALIZE AND STORE THE PLANE
      SEC=DSQRT(SSCAN(ISCAN+1)**2 + SSCAN(ISCAN+2)**2
     *        + SSCAN(ISCAN+3)**2)
      DO 3 I=1,4
    3 PL(I)=SSCAN(ISCAN+I)/SEC
      PL(4)=SSCAN(ISCAN+4)/SEC+TH(IDS)
C
C INITIALIZE SYSTEM DS PLANE
      IS=IDS
      CALL APT234(HMOD,PL)
C
C   TRANSFORM PLANE FROM LOCAL TO BASIC COORDINATE SYSTEM
      CALL TRANSM(BB(1,2),PL,4,4,-1)
C   SIGNAL THE PLANE
      IIFLAG(1,2)=-1
      IPNR(2)=0
C   CONTINUE WITH SCANNING
      ISCAN=ISCAN+5
      IWHAT=2
      GOTO 1
C
C GET COMMON INDEX OF SSURF
    5 LDAFLG=7
      CALL APT094(LDAFLG,SSCAN(ISCAN+1),CANIND)
      INDCAN=CANIND
      ISCAN=ISCAN+3
      GOTO (7,8),IWHAT
C
C A FIRST SURFACE IS FOUND
    7 NFIRST=NFIRST+1
      IFIRST(NFIRST)=INDCAN
      IF(NFIRST.EQ.1) GOTO 1
C
      JFIRST=NFIRST-1
      DO 17 I=1,JFIRST
      IF(IFIRST(I).NE.INDCAN) GOTO 17
      NFIRST=NFIRST-1
C
C SAME SSURF FOUND TWICE BEFORE WITH, ONLY FIRST FOUND SSURF
C  IN FIRST PART OF THE STATEMENT WILL BE USED
      CALL AERR(-22832,'INTSEC  ')
      GOTO 1
   17 CONTINUE
      GOTO 1
C
C A SECOND SURFACE IS FOUND
    8 NSECND=NSECND+1
      ISECND(NSECND)=INDCAN
      IF(NSECND.EQ.1) GOTO 118
C
      JSECND=NSECND-1
      DO 18 I=1,JSECND
      IF(ISECND(I).NE.INDCAN) GOTO 18
      NSECND=NSECND-1
C
C SAME SSURF FOUND TWICE AFTER WITH, ONLY FIRST FOUND SSURF
C  IN SECOND PART OF THE STATEMENT WILL BE USED
      CALL AERR(-22833,'INTSEC  ')
      GOTO 118
   18 CONTINUE
C
C CHECK, IF SAME SSURF SHOULD BE INTERSECTED
  118 IF(NSECND.EQ.0) GOTO 1
      IF(NFIRST.EQ.0) GOTO 1
      DO 19 I=1,NFIRST
      IF(IFIRST(I).NE.ISECND(NSECND)) GOTO 19
C
C SAME SSURF WILL BE INTERSECTED BY ITSELF, THIS IS NOT POSSIBLE
      CALL ERROR(22834,'INTSEC  ')
      NSECND=NSECND-1
      GOTO 1
   19 CONTINUE
      GOTO 1
C
C CONTROL WORDS
   10 CALL HOLFRM(SSCAN(ISCAN+1),TEST,1,8,NWD)
      IF(TEST.NE.WITH) GOTO 11
      IWHAT=2
      ISCAN=ISCAN+2
      GOTO 1
C
C CANON POINT TO OUTPUT ?
   11 IF(TEST.NE.DCANON) GOTO 12
      IOUT=1
      ISCAN=ISCAN+2
      GOTO 1
C
C HEX OUTPUT ?
   12 IF(TEST.NE.HEX) GOTO 13
      IOUT=2
   13 ISCAN=ISCAN+2
      GOTO 1
C
C PREPARATION OF INTERSECTIONS
   20 IF(NSECND.NE.0) GOTO 21
C
C NO INTERSECTION POSSIBLE
      CALL ERROR(22831,'INTSEC  ')
      GOTO 999
   21 CONTINUE
C
C  INTERSECTIONS
C *********************************************************************
C
C  OUTER LOOP FOR FIRST ARGUMENT SURFACES (DS)
      N1=MAX0(1,NFIRST)
      DO 330 J1=1,N1
      N2=1
      IF(NFIRST.EQ.0)GOTO 210
C
C  LOCATE THE NON PLANE DRIVE SURFACE
      LDAFLG=3
      CALL APT094(LDAFLG,COM(IFIRST(J1)),J11)
      J11=J11-41
C  NUMBER OF PATCHES
      N2=SSCAN(J11+4)
C  SURFACE RECORD NUMBER TIMES 1000 FOR PATCH IDENTIFICATION
      IPNR(2)=SSCAN(J11+1)*1000
C
C  INITIALIZE DRIVE SURFACE
      IS=IDS
      CALL APT234 (HMOD,COM(IFIRST(J1)))
  210 CONTINUE
C
C  PREPARATION OF PATCH REFERENCE OF FIRST ARGUMENT SURFACES
      DO 410 J2=1,N2
  410 INTDS(J2)=0
C *********************************************************************
C
C  OUTER LOOP FOR SECOND ARGUMENT SURFACES (PS)
      DO 320 J3=1,NSECND
      DO 40 J33=1,3
C
C  LOCATE THE PART SURFACE
      LDAFLG=3
      CALL APT094(LDAFLG,COM(ISECND(J3)),J12)
      J12=J12-41
C
C  CHECK SURFACE LOCATION IF DS IS NOT A PLANE
      IF(IIFLAG(1,2).LE.0)GOTO 50
C
C  CHECK SURFACE RECORD NUMBER AND LENGTH
      IF(COM(IFIRST(J1)).EQ.SSCAN(J11+1).AND.
     *   COM(IFIRST(J1)+1).EQ.SSCAN(J11+8))GOTO 50
C
C  LOCATE THE NON PLANE DRIVE SURFACE
      LDAFLG=3
      CALL APT094(LDAFLG,COM(IFIRST(J1)),J11)
      J11=J11-41
   40 CONTINUE
C GET NAME AND INDEX OF SURFACE
   50 CALL UNPACK(COM(ISECND(J3)),MODE,ISIZE,ISBSCT)
      SNAME=COM(ISECND(J3)+ISIZE)
      IF(ISBSCT.GT.1)SNAME=COM(ISECND(J3)+(ISIZE+1)*ISBSCT-1)
      SINDEX=ISBSCT
C  NUMBER OF PATCHES
      N4=SSCAN(J12+4)
C  SURFACE RECORD NUMBER TIMES 1000 FOR PATCH IDENTIFICATION
      IPNR(1)=SSCAN(J12+1)*1000
C
C  INITIALIZE PART SURFACE
      IS=IPS
      CALL APT234 (HMOD,COM(ISECND(J3)))
C
C  PREPARATION OF PATCH REFERENCE OF SECOND ARGUMENT SURFACES
      DO 420 J4=1,N4
  420 INTPS(J4)=0
C
C   PREPARATION OF POINT STORAGE MANAGEMENT
      IPT=1
      MPT=NSCNMX/9
      NPT=0
C
C   PREPARATION OF CONTOUR SEGMENT XREF AND CONTOUR TABLE
      NSIX=0
      NCON=0
C *********************************************************************
C
C  INNER LOOP FOR FIRST ARGUMENT SURFACES OVER THE PATCHES (DS)
      DO 310 J2=1,N2
      IF(NFIRST.EQ.0)GOTO 220
      IF(INTDS(J2).EQ.1)GOTO 310
      CALL LODPCH(SSCAN(J11+1),BB(1,2),IIFLAG(1,2),IITOP(1,1,2),J2,0)
      IPNUM(2)=J2
C  SAVE PATCH POINTER
      J2S=J2
C  COMPUTE THE INDIVIDUAL PATCH
      IPNR(2)=IPNR(2)/1000*1000+J2
C
C   COMPUTE 5*5 POLYHEDRON
      CALL POLMTN (2,POED2,5,5)
  220 CONTINUE
C *********************************************************************
C
C  INNER LOOP FOR SECOND ARGUMENT SURFACES OVER THE PATCHES (PS)
      DO 300 J4=1,N4
      IF(INTPS(J4).EQ.1)GOTO 300
      CALL LODPCH(SSCAN(J12+1),BB(1,1),IIFLAG(1,1),IITOP(1,1,1),J4,0)
      IPNUM(1)=J4
C  SAVE PATCH POINTER
      J4S=J4
C  COMPUTE THE INDIVIDUAL PATCH
      IPNR(1)=IPNR(1)/1000*1000+J4
C
C   COMPUTE 5*5 POLYHEDRON
      CALL POLMTN (1,POED1,5,5)
C
C  SEARCH FOR INTERSECTION
      TOL=(TOLD+TOLP)/2.D0
      TOLTOL=TOL*TOL*2.D0
      IF(NFIRST.EQ.0)CALL PLAPOL(BB(1,2),POED1,5,5,TOL,STP,IRC)
      IF(NFIRST.NE.0)CALL POLPOL(POED2,5,5,POED1,5,5,TOL,STP,IRC)
      IF(IRC.EQ.0)GOTO 300
C
C  CUT!
  430 CONTINUE
C  SUBROUTINE TRACE SWITCH
CCCCC ITRACE=0
      IPT=IPT+NPT
      NPT=MPT-IPT+1
      CALL INTSRF (STP,TOL,PT(1,IPT),NPT,IRC)
      IF(NPT.EQ.0)GOTO 300
      LPT=IPT+NPT-1
C
C   MARK USED PATCHES
      INTDS(IPNUM(2))=1
      INTPS(IPNUM(1))=1
C
C   CREATE A CONTOUR SEGMENT ENTITY FOR A NEW SEGMENT FOUND
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      ISIX=NSIX
      JSIX(1,ISIX)=IPT
      JSIX(2,ISIX)=LPT
      JSIX(3,ISIX)=0
      JSIX(4,ISIX)=0
C
C   CREATE A CONTOUR TABLE ENTRY
      IF(NCON.GE.MCON)GOTO 999
      NCON=NCON+1
      JCON(1,NCON)=ISIX
      JCON(2,NCON)=ISIX
      ICON=NCON
C
C   TEST FOR CLOSED SEGMENT
      D12=(PT(1,IPT)-PT(1,LPT))**2+(PT(2,IPT)-PT(2,LPT))**2
     *                            +(PT(3,IPT)-PT(3,LPT))**2
      IF(D12.LE.TOLTOL)GOTO 470
C
C   SEARCH FOR PREVIOUS CONTOUR SEGMENT
  435 JSIX(3,ISIX)=0
      JSIX1=JSIX(1,ISIX)
      CALL INTTRC (J12,J11,PT(1,JSIX1), 1,IRC)
      IF(IRC.EQ.0)GOTO 449
C  INTERSECTION
      STP(1)=PT(1,JSIX1)
      STP(2)=PT(2,JSIX1)
      STP(3)=PT(3,JSIX1)
      IPT=IPT+NPT
      NPT=MPT-IPT+1
      CALL INTSRF (STP,TOL,PT(1,IPT),NPT,IRC)
      IF(NPT.EQ.0)GOTO 449
      LPT=IPT+NPT-1
C
C   MARK USED PATCHES
      INTDS(IPNUM(2))=1
      INTPS(IPNUM(1))=1
C
C  CHECK THE CONNECTION POINT
      D1=(PT(1,IPT)-PT(1,JSIX1))**2+(PT(2,IPT)-PT(2,JSIX1))**2
     *                             +(PT(3,IPT)-PT(3,JSIX1))**2
      IF(D1.GT.TOLTOL)GOTO 440
C  SAVE POINTERS FOR CLOSED CONTOUR CHECK
      JEND1=LPT
      JEND2=JSIX(2,JCON(2,ICON))
C
C  PREVIOUS SEGMENT, REVERSE ORDER
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      JSIX(1,NSIX)=LPT
      JSIX(2,NSIX)=IPT
      GOTO 442
C
C  CHECK THE CONNECTION POINT
  440 D2=(PT(1,LPT)-PT(1,JSIX1))**2+(PT(2,LPT)-PT(2,JSIX1))**2
     *                             +(PT(3,LPT)-PT(3,JSIX1))**2
      IF(D2.LE.TOLTOL)GOTO 441
C
C  NEW STAND ALLONE SEGMENT
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      JSIX(1,NSIX)=IPT
      JSIX(2,NSIX)=LPT
      JSIX(3,NSIX)=0
      JSIX(4,NSIX)=0
C
C   CREATE A CONTOUR TABLE ENTRY
      IF(NCON.GE.MCON)GOTO 999
      NCON=NCON+1
      JCON(1,NCON)=NSIX
      JCON(2,NCON)=NSIX
      GOTO 449
C  SAVE POINTERS FOR CLOSED CONTOUR CHECK
  441 JEND1=IPT
      JEND2=JSIX(2,JCON(2,ICON))
C
C  PREVIOUS SEGMENT, NORMAL ORDER
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      JSIX(1,NSIX)=IPT
      JSIX(2,NSIX)=LPT
  442 JSIX(3,NSIX)=0
      JSIX(3,ISIX)=NSIX
      JSIX(4,NSIX)=ISIX
      ISIX=NSIX
      JCON(1,ICON)=ISIX
C   TEST FOR CLOSED SEGMENT
      D12=(PT(1,JEND1)-PT(1,JEND2))**2+(PT(2,JEND1)-PT(2,JEND2))**2
     *                                +(PT(3,JEND1)-PT(3,JEND2))**2
      IF(D12.LE.TOLTOL)GOTO 470
      GOTO 435
C
C   SET ISIX TO FORWARD SEARCH
  449 ISIX=JCON(2,ICON)
C
C REINSTAL THE PREVIOUS PATCHES
      IF(IIFLAG(1,2).LE.0)GOTO 448
      CALL LODPCH(SSCAN(J11+1),BB(1,2),IIFLAG(1,2),IITOP(1,1,2),J2S,0)
      IPNUM(2)=J2S
      IPNR(2)=IPNR(2)/1000*1000+J2S
  448 CALL LODPCH(SSCAN(J12+1),BB(1,1),IIFLAG(1,1),IITOP(1,1,1),J4S,0)
      IPNUM(1)=J4S
      IPNR(1)=IPNR(1)/1000*1000+J4S
C
C   SEARCH FOR FOLLOWING CONTOUR SEGMENTS
  450 JSIX(4,ISIX)=0
      JSIX2=JSIX(2,ISIX)
      CALL INTTRC (J12,J11,PT(1,JSIX2),-1,IRC)
      IF(IRC.EQ.0)GOTO 469
C  INTERSECTION
      STP(1)=PT(1,JSIX2)
      STP(2)=PT(2,JSIX2)
      STP(3)=PT(3,JSIX2)
      IPT=IPT+NPT
      NPT=MPT-IPT+1
      CALL INTSRF (STP,TOL,PT(1,IPT),NPT,IRC)
      IF(NPT.EQ.0)GOTO 469
      LPT=IPT+NPT-1
C
C   MARK USED PATCHES
      INTDS(IPNUM(2))=1
      INTPS(IPNUM(1))=1
C
C  CHECK THE CONNECTION POINT
      D1=(PT(1,IPT)-PT(1,JSIX2))**2+(PT(2,IPT)-PT(2,JSIX2))**2
     *                             +(PT(3,IPT)-PT(3,JSIX2))**2
      IF(D1.GT.TOLTOL)GOTO 460
C  SAVE POINTERS FOR CLOSED CONTOUR CHECK
      JEND1=LPT
      JEND2=JSIX(1,JCON(1,ICON))
C
C  FOLLOWING SEGMENT, NORMAL ORDER
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      JSIX(1,NSIX)=IPT
      JSIX(2,NSIX)=LPT
      GOTO 462
C
C  CHECK THE CONNECTION POINT
  460 D2=(PT(1,LPT)-PT(1,JSIX2))**2+(PT(2,LPT)-PT(2,JSIX2))**2
     *                             +(PT(3,LPT)-PT(3,JSIX2))**2
      IF(D2.LE.TOLTOL)GOTO 461
C
C  NEW STAND ALLONE SEGMENT
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      JSIX(1,NSIX)=IPT
      JSIX(2,NSIX)=LPT
      JSIX(3,NSIX)=0
      JSIX(4,NSIX)=0
C
C   CREATE A CONTOUR TABLE ENTRY
      IF(NCON.GE.MCON)GOTO 999
      NCON=NCON+1
      JCON(1,NCON)=NSIX
      JCON(2,NCON)=NSIX
      GOTO 469
C  SAVE POINTERS FOR CLOSED CONTOUR CHECK
  461 JEND1=IPT
      JEND2=JSIX(1,JCON(1,ICON))
C
C  FOLLOWING SEGMENT, REVERSE ORDER
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      JSIX(1,NSIX)=LPT
      JSIX(2,NSIX)=IPT
  462 JSIX(4,NSIX)=0
      JSIX(4,ISIX)=NSIX
      JSIX(3,NSIX)=ISIX
      ISIX=NSIX
      JCON(2,ICON)=ISIX
C   TEST FOR CLOSED SEGMENT
      D12=(PT(1,JEND1)-PT(1,JEND2))**2+(PT(2,JEND1)-PT(2,JEND2))**2
     *                                +(PT(3,JEND1)-PT(3,JEND2))**2
      IF(D12.LE.TOLTOL)GOTO 470
      GOTO 450
  469 CONTINUE
C
C REINSTAL THE PREVIOUS PATCHES
  470 IF(IIFLAG(1,2).LE.0)GOTO 471
      CALL LODPCH(SSCAN(J11+1),BB(1,2),IIFLAG(1,2),IITOP(1,1,2),J2S,0)
      IPNUM(2)=J2S
      IPNR(2)=IPNR(2)/1000*1000+J2S
  471 CALL LODPCH(SSCAN(J12+1),BB(1,1),IIFLAG(1,1),IITOP(1,1,1),J4S,0)
      IPNUM(1)=J4S
      IPNR(1)=IPNR(1)/1000*1000+J4S
  300 CONTINUE
C **********************************************************************
  310 CONTINUE
C
C  OUTPUT OF A SINGLE SURFACE/SURFACE INTERSECTION
      IF(NCON.EQ.0)GOTO 560
      DO 550 ICON=1,NCON
      ISIX=JCON(1,ICON)
  520 IP1=JSIX(1,ISIX)
      IP2=JSIX(2,ISIX)
      INEXT=JSIX(4,ISIX)
      IF(IP2.LT.IP1)GOTO 530
      NPT=IP2-IP1+1
      IPT=IP1
      IDIR=1
      GOTO 540
  530 NPT=IP1-IP2+1
      IPT=IP2
      IDIR=-1
  540 CONTINUE
      CALL INTOUT(IOUT,PT(1,IPT),NPT,IDIR,J11,J12,SNAME,SINDEX)
      IF(INEXT.EQ.0)GOTO 550
      ISIX=INEXT
      GOTO 520
  550 CONTINUE
  560 CONTINUE
C **********************************************************************
  320 CONTINUE
C **********************************************************************
  330 CONTINUE
C **********************************************************************
C
C SET THICKNESS BACK TO OLD VALUES
  999 TH(IDS)=THDOLD
      TH(IPS)=THPOLD
C
      RETURN
      END
**** SOURCE FILE : M0012321.V02   ***
*
      SUBROUTINE INTSRF(SP,TOL,PT,NPT,IRC)
C
C     EXECUTIVE ROUTINE TO COMPUTE THE INTERSECTION BETWEEN TWO
C     ARBITRARY SURFACES.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C SS - ARELEM - COMMON
      COMMON/SSARLM/BB(64,4),UU(4),VV(4),
     *              IITOP(6,4,4),IIFLAG(4,4),IPNUM(4)
C
C   COMMON FOR 2 SURFACE INTERSECTION
      COMMON/INTCOM/IKEEP(255)
C   EVALUATION VECTOR FOR PS AND DS
      DOUBLE PRECISION SPV(4,8,2)
      EQUIVALENCE (IKEEP(  1),SPV(1,1,1))
C   LAST THREE U,V PAIRS OF PS AND DS
      DOUBLE PRECISION UV(2,3,2)
      EQUIVALENCE (IKEEP(129),UV(1,1,1))
C   HISTORY OF UNIT NORMALS AT INTERSECTION POINTS ON PS AND DS
      DOUBLE PRECISION UN(18)
      EQUIVALENCE (IKEEP(165),UN(1))
C   POINT OF INTERSECTION
      DOUBLE PRECISION PXYZ(3)
      EQUIVALENCE (IKEEP(205),PXYZ(1))
C   PLANE PERPENTICULAR TO INTERSECTION DIRECTION
      DOUBLE PRECISION CTP(4)
      EQUIVALENCE (IKEEP(233),CTP(1))
C   MULTIBLE OF ABSOLUT TOLERANCE
      DOUBLE PRECISION CK
      EQUIVALENCE (IKEEP(241),CK)
C   MAXIMUM STEP
      DOUBLE PRECISION STEPMX
      EQUIVALENCE (IKEEP(243),STEPMX)
C   STEP LENGTH
      DOUBLE PRECISION STEP
      EQUIVALENCE (IKEEP(245),STEP)
C   OLD STEP LENGTH
      DOUBLE PRECISION OSTEP
      EQUIVALENCE (IKEEP(247),OSTEP)
C   INTERNAL POINT COUNT
      EQUIVALENCE (IKEEP(250),IPTKNT)
C   MAXIMUM NUMBER OF POINTS
      EQUIVALENCE (IKEEP(251),NPTS)
C   OUT OF BOUND SIGNAL FOR PS AND DS
      INTEGER ISFER(2)
      EQUIVALENCE (IKEEP(252),ISFER(1))
C
C ARGUMENTS
      DIMENSION SP(3),PT(9,1)
C
C LOCAL VARIABLES
      LOGICAL LXBND1, LXBND2, START
C
      INCLUDE 'XUNITS.INC'
C
      DOUBLE PRECISION SCALE(4)
C
C                  MM    CM    INCH   FEET
      DATA SCALE/25.4D0,2.54D0,1.D0,0.0833333333D0/
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
      NPTS = NPT
      LXBND1 = .FALSE.
      LXBND2 = .FALSE.
      IRC=0
      NPT=0
C
C         INITIAL STARTUP INFO
      CTP(1)=1.D0
      CTP(2)=1.D0
      CTP(3)=1.D0
      CTP(4)=1.D0
      PXYZ(1)=SP(1)
      PXYZ(2)=SP(2)
      PXYZ(3)=SP(3)
      PT(1,1)=SP(1)
      PT(2,1)=SP(2)
      PT(3,1)=SP(3)
      TL=DABS(TOL)
      IF(TL.LT..00001D0) TL=.00001D0
      CK=TL*8.D0
      STEPMX=.01D0*SCALE(IOLD) + TL*1000.D0
C MAX. STEP IS <= 4.0 INCHES *** AEQUIVALENT TO 100 MM
      SMAX = 4.D0 * SCALE(IOLD)
C
      IF(STEPMX.GT.SMAX) STEPMX=SMAX
      STEP=0.D0
      OSTEP=STEP
C TURN CUT FLAG OFF FOR PASS 1:
      MCUT=1
      DO 10 I=1,18
      UN(I)=0.D0
   10 CONTINUE
C
C I N I T I A L I Z A T I O N
C  LOOP UNTIL START POINT "PXYZ" CONVERGES (MAX. 15 LOOPS) ****
      DO 130 II=1,15
      ITIM=II
      IF (II.GT.2) GOTO 60
C
C ON FIRST TWO ITERATIONS, SCAN SURFACES FOR START U,V:
      DO 50 I=1,2
C
C IF SURFACE IS A PLANE, FORGET IT
      IF (IIFLAG(1,I).LE.0) GOTO  50
C
C SCAN SURFACE FOR PT. ON SURFACE CLOSEST TO "PXYZ":
      DIS=90.D20
      V=-.1D0
      DO 40 J=1,5
      U=-.1D0
      V=V+.2D0
      DO 30 K=1,5
      U=U+.2D0
      CALL CNSURF(U,V,BB(1,I),SPV(1,1,I),IIFLAG(1,I),0)
      D1=(PXYZ(1)-SPV(1,1,I))**2 + (PXYZ(2)-SPV(2,1,I))**2
     *                           + (PXYZ(3)-SPV(3,1,I))**2
      IF (DIS.LT.D1) GOTO 30
      DIS=D1
C
C SAVE UV OF SURFACE
      DO 20 L=1,3
      UV(1,L,I)=U
      UV(2,L,I)=V
   20 CONTINUE
   30 CONTINUE
   40 CONTINUE
   50 CONTINUE
C
C UV OF SURFACE IS KNOWN; COMPUTE A SINGLE INTERSECTION PT.:
   60 CONTINUE
      KS=-1
      DO 70 L=1,3
      CALL INTCON(PT,NP,KS)
      IF (L.GT.2) GOTO 70
      PT(1,1)=PXYZ(1)
      PT(2,1)=PXYZ(2)
      PT(3,1)=PXYZ(3)
   70 CONTINUE
C
C IF POINT NOT OVER DS, MOVE IT TO DS BOUNDARY
      IF (ISFER(2).GE.0) GOTO 80
      NS=2
C SET SURFACE 2 BOUNDARY FLAG:
      LXBND2 = .TRUE.
C
C IF POINT NOT OVER PS, MOVE IT TO PS BOUNDARY
      GOTO 90
   80 CONTINUE
      IF (ISFER(1).GE.0) GOTO 100
      NS=1
C SET SURFACE 1 BOUNDARY FLAG:
      LXBND1 = .TRUE.
  100 CONTINUE
   90 CONTINUE
C
      IF (.NOT. LXBND1.AND..NOT. LXBND2) GOTO 110
C FIND AN INTERSECTION PT. ON THE BOUNDARY:
      CALL INTBND(NS,IRC)
C STILL OUT OF BOUNDS? ***
      IF (IRC.LT.0) GOTO 130
  110 CONTINUE
C
C EXIT IF NO CHANGE IN PXYZ
      DSQ=(PT(1,1)-PXYZ(1))**2 + (PT(2,1)-PXYZ(2))**2
     *                         + (PT(3,1)-PXYZ(3))**2
      START = (DSQ.LT.1.D-8.AND.II.GT.1)
      IF (START) GOTO 140
      PT(1,1)=PXYZ(1)
      PT(2,1)=PXYZ(2)
      PT(3,1)=PXYZ(3)
  130 CONTINUE
  140 CONTINUE
C END OF LOOP TO FIND START POINT
C  IF HERE; CANNOT FIND A START INTERS. POINT
      IF(.NOT.START)GOTO 999
C
C COMPUTE START UP DIR OF YA YB YC
C  SET DIR. FROM CURRENT POS. TO UV=.5
      HX=PXYZ(1)
      HY=PXYZ(2)
      HZ=PXYZ(3)
      KS=1
      ITIM=0
C IF S1 IS A PLANE, USE S2 FOR START DIRECTION:
      IF(IIFLAG(1,2).LE.0) GOTO 120
C IF NEAR EDGE OF S2, USE S2 FOR START DIRECTION:
      IF(LXBND2.AND..NOT.LXBND1) GOTO 120
C
C USE SURFACE 1 FOR START DIR.
      CALL CNSURF(.5D0,.5D0,BB(1,2),SPV(1,1,1),IIFLAG(1,2),0)
      GOTO 135
C
C USE SURFACE 2 FOR START DIR.
  120 CALL CNSURF(.5D0,.5D0,BB(1,1),SPV(1,1,1),IIFLAG(1,1),0)
C
C COMPUTE DIR. FROM PXYZ TO TO SPV(1-3,1,1)
  135 DX=SPV(1,1,1)-PXYZ(1)
      DY=SPV(2,1,1)-PXYZ(2)
      DZ=SPV(3,1,1)-PXYZ(3)
      SEC=DSQRT(DX*DX + DY*DY + DZ*DZ)
      IF(SEC.EQ.0.D0) SEC=1.D0
      DX=DX/SEC
      DY=DY/SEC
      DZ=DZ/SEC
      CS=DX*CTP(1) + DY*CTP(2) + DZ*CTP(3)
C IS "YABC" ORIENTED TOWARD MIDDLE OF SURFACE?
      IF (CS.GE.0.D0) GOTO 150
C
C  FLIP CURRENT DIR. OF YA YB YC
      CTP(1)=-CTP(1)
      CTP(2)=-CTP(2)
      CTP(3)=-CTP(3)
      CTP(4)=-CTP(4)
  150 CONTINUE
  160 CONTINUE
C
C P A S S   1  &  2
C  COMPUTE POINTS UNTIL A BOUNDARY IS INTERSECTED
      CALL INTCON(PT,NP,KS)
      ITIM=ITIM+1
C ERROR?
      IF (IPTKNT.GT.0) GOTO 220
C
C NORMAL ENDUP IF IPTKNT.LT.0
C   IS INTERSECTION PASS 2 COMPLETE?
      IF (MCUT.NE.0) GOTO 190
C
C IF POINTS, EXIT; ELSE TURN FORWARD AROUND AND REDO
      IF (NP.GT.2) GOTO  220
      IF(ITIM.GT.2)GO TO 999
      IF (ITIM.NE.2) GOTO 180
C
C RELOAD FIRST START POSITION & UV
      PXYZ(1)=HTX
      PXYZ(2)=HTY
      PXYZ(3)=HTZ
      DO 170 I=1,3
      UV(1,I,1)=U1
      UV(2,I,1)=V1
      UV(1,I,2)=U2
      UV(2,I,2)=V2
  170 CONTINUE
C
C FLIP CURRENT DIR. OF YA YB YC
      CTP(1)=-CTP(1)
      CTP(2)=-CTP(2)
      CTP(3)=-CTP(3)
      CTP(4)=-CTP(4)
  180 CONTINUE
      GOTO 210
  190 CONTINUE
C
C PASS 1 COMPLETE; REVERSE DIRECTION & DO PASS 2.
C  SAVE CURRENT POSITION:
      HTX=PXYZ(1)
      HTY=PXYZ(2)
      HTZ=PXYZ(3)
      IF (NP.GT.2) GOTO 200
      PXYZ(1)=HX
      PXYZ(2)=HY
      PXYZ(3)=HZ
      HTX=PXYZ(1)
      HTY=PXYZ(2)
      HTZ=PXYZ(3)
  200 CONTINUE
      U1=UV(1,2,1)
      V1=UV(2,2,1)
      U2=UV(1,2,2)
      V2=UV(2,2,2)
      KS=0
C SET CUT FLAG ON FOR PASS 2:
      MCUT=0
      CK=TL*4.D0
C
C FLIP CURRENT DIR. OF YA YB YC
      CTP(1)=-CTP(1)
      CTP(2)=-CTP(2)
      CTP(3)=-CTP(3)
      CTP(4)=-CTP(4)
  210 CONTINUE
      GO TO 160
  220 CONTINUE
C
C MAX. POINT REACHED, IF CUT ON, RETURN THESE
      IF(MCUT.EQ.1) GOTO 999
      NPT=NP
C
  999 RETURN
      END
**** SOURCE FILE : M0012369.V02   ***
*
      SUBROUTINE INTTPL(NS,PT,PL,IRC)
C
C     COMPUTES THE NORMALIZED COEFFICIENTS OF A PLANE TANGENT TO SURFACE
C     "NS" WHOSE NORMAL PASSES THROUGH POINT "PT".
C     INTTPL IS CALLED BY INTERSECTION ROUTINES INTCON & INTBND.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C SS - ARELEM - COMMON
      COMMON/SSARLM/BB(64,4),UU(4),VV(4),
     *              IITOP(6,4,4),IIFLAG(4,4),IPNUM(4)
C
C   COMMON FOR 2 SURFACE INTERSECTION
      COMMON/INTCOM/IKEEP(255)
C   EVALUATION VECTOR FOR PS AND DS
      DOUBLE PRECISION SPV(4,8,2)
      EQUIVALENCE (IKEEP(  1),SPV(1,1,1))
C   LAST THREE U,V PAIRS OF PS AND DS
      DOUBLE PRECISION UV(2,3,2)
      EQUIVALENCE (IKEEP(129),UV(1,1,1))
C   POINT OF TANGENCY ON PS AND DS
      DOUBLE PRECISION PTT(3,2)
      EQUIVALENCE (IKEEP(153),PTT(1,1))
C   THICKNESS ON PS AND DS
      DOUBLE PRECISION THICK(2)
      EQUIVALENCE (IKEEP(201),THICK(1))
C  TRACE
CCCCC EQUIVALENCE (IKEEP(249),ITRACE)
C   INTERNAL POINT COUNT
      EQUIVALENCE (IKEEP(250),IPTKNT)
C   MAXIMUM NUMBER OF POINTS
      EQUIVALENCE (IKEEP(251),NPTS)
C
      DIMENSION PT(3),PL(4),HN(3,2)
      INTEGER IPKNT(2)
      DATA IPKNT/0,0/
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
CCCCC IF(ITRACE.EQ.1)
CCCCC*WRITE(6,1000)
C1000 FORMAT(' ***TRACE***INTTPL')
C
C IS SURFACE NOT A PLANE ?
      IF (IIFLAG(1,NS).GT.0)GOTO 30
C
C LOAD THE PLANE
      DO 20 I=1,4
   20 PL(I)=BB(I,NS)
      IRC=0
      GOTO 999
C
C SURFACE IS NOT A PLANE; FIND TANGENT PLANE.
   30 CONTINUE
      IRC=1
      IF (NS.NE.1.AND.NS.NE.2) GOTO 100
      IRC=0
      U=UV(1,1,NS)
      V=UV(2,1,NS)
C
C EXTRAPOLATE NEXT UV IF 2 POINTS HAVE BEEN CALCULATED.
      IF (NPTS.LE.IPTKNT+2.OR.IPTKNT.EQ.IPKNT(NS)) GOTO 50
      U=U + 2.D0*(U-UV(1,2,NS)) - (UV(1,2,NS)-UV(1,3,NS))
      V=V + 2.D0*(V-UV(2,2,NS)) - (UV(2,2,NS)-UV(2,3,NS))
   50 CONTINUE
C
C CALL NORMAL DISTANCE ROUTINE
      CALL INTNRM(NS,U,V,PT,SPV(1,1,NS),IRC)
C
C SAVE SURFACE POINT
      PTT(1,NS)=SPV(1,1,NS)
      PTT(2,NS)=SPV(2,1,NS)
      PTT(3,NS)=SPV(3,1,NS)
C
C SAVE UV POSITION (NOTE: RECALCULATED IN SUB INTNRM)
      UV(1,1,NS)=U
      UV(2,1,NS)=V
      IPKNT(NS) = IPTKNT
C
C LOAD SURFACE NORMAL
      PL(1)=SPV(1,8,NS)
      PL(2)=SPV(2,8,NS)
      PL(3)=SPV(3,8,NS)
C
C HECK DIR. OF THIS NORMAL
      IF (IPTKNT.GE.NPTS-1) GOTO 80
      CS=HN(1,NS)*PL(1) + HN(2,NS)*PL(2) + HN(3,NS)*PL(3)
C IS THE NORMAL ORIENTED THE SAME AS LAST TIME?
      IF (CS.GE.0.D0) GOTO 70
C
C NO; FLIP DIR.
      PL(1)=-PL(1)
      PL(2)=-PL(2)
      PL(3)=-PL(3)
   70 CONTINUE
   80 CONTINUE
C
C SAVE THIS NORMAL FOR NEXT SOL. & CAL. CONSTANT
      HN(1,NS)=PL(1)
      HN(2,NS)=PL(2)
      HN(3,NS)=PL(3)
      PL(4)=PL(1)*SPV(1,1,NS) + PL(2)*SPV(2,1,NS) + PL(3)*SPV(3,1,NS)
  100 CONTINUE
      PL(4)=PL(4) + THICK(NS)
C
  999 RETURN
      END
**** SOURCE FILE : M0005847.V01   ***
*
      SUBROUTINE INTTRC (J12,J11,PT,IDIR,IRC)
C
C   J12 : I: SURFACE INDEX OF PS
C   J11 : I: SURFACE INDEX OF DS
C   PT  : I: POINT STORAGE OF SEGMENT END
C   IDIR: I: FIRST (=1) OR LAST (=-1) SEGMENT POINT
C   IRC : O: =0: NO CONNECTING PAIR OF PATCHES FOUND ; =1: FOUND
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C BLANK COMMON
      INCLUDE 'BLANKCOM.INC'
C
C   COMMON FOR 2 SURFACE INTERSECTION
      COMMON/INTCOM/IKEEP(255)
C   PATCH NUMBER FOR PS AND DS (SURFACE RECNO*1000 + PATCH NO)
      INTEGER IPNR(2)
      EQUIVALENCE (IKEEP(254),IPNR(1))
C
C SS - ARELEM - COMMON
      COMMON/SSARLM/BB(64,4),UU(4),VV(4),
     *              IITOP(6,4,4),IIFLAG(4,4),IPNUM(4)
      DOUBLE PRECISION PT(9,1)
C
C   FIRST BORDER NUMBER FIELD
      INTEGER IBO1(3,3)
C
C   SECOND BORDER NUMBER FIELD
      INTEGER IBO2(3,3)
C
      DATA IBO1/2,1,1,2,0,3,4,4,3/
      DATA IBO2/1,0,3,0,0,0,2,0,4/
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C   RETURN CODE
      IRC=0
C
C  PS SEARCH
      JU=2
      IF(DABS(PT(7,1)).LT.1.D-5)JU=1
      IF(DABS(PT(7,1)-1.D0).LT.1.D-5)JU=3
      JV=2
      IF(DABS(PT(8,1)).LT.1.D-5)JV=1
      IF(DABS(PT(8,1)-1.D0).LT.1.D-5)JV=3
C
C  BOUNDARY NUMBER
      NB1=IBO1(JU,JV)
      IF(NB1.EQ.0)GOTO 50
C
C  NEXT PATCH
      NP=IITOP(2,NB1,1)
      IF(NP.EQ.0)GOTO 50
C
C  LOAD PATCH
      M=0
      NB2=IBO2(JU,JV)
      IF(NB2.NE.0)M=2
      CALL LODPCH(SSCAN(J12+1),BB(1,1),IIFLAG(1,1),IITOP(1,1,1),NP,M)
      IPNR(1)=IPNR(1)/1000*1000+NP
      IPNUM(1)=NP
C
C   CORNER PATCH ?
      IF(NB2.NE.0)GOTO 20
      IRC=1
      GOTO 50
C  NEXT PATCH AT CORNER
   20 NP=IITOP(2,NB2,1)
      IF(NP.EQ.0)GOTO 50
C
C  LOAD PATCH
      CALL LODPCH(SSCAN(J12+1),BB(1,1),IIFLAG(1,1),IITOP(1,1,1),NP,0)
      IPNR(1)=IPNR(1)/1000*1000+NP
      IPNUM(1)=NP
      IRC=1
C
C  DS SEARCH
   50 IF(IIFLAG(1,2).LE.0)GOTO 99
      JU=2
      IF(DABS(PT(4,1)).LT.1.D-5)JU=1
      IF(DABS(PT(4,1)-1.D0).LT.1.D-5)JU=3
      JV=2
      IF(DABS(PT(5,1)).LT.1.D-5)JV=1
      IF(DABS(PT(5,1)-1.D0).LT.1.D-5)JV=3
C
C  BOUNDARY NUMBER
      NB1=IBO1(JU,JV)
      IF(NB1.EQ.0)GOTO 99
      NB2=IBO2(JU,JV)
C
C  NEXT PATCH
      NP=IITOP(2,NB1,2)
      IF(NP.EQ.0)GOTO 99
C
C  LOAD PATCH
      M=0
      NB2=IBO2(JU,JV)
      IF(NB2.NE.0)M=2
      CALL LODPCH(SSCAN(J11+1),BB(1,2),IIFLAG(1,2),IITOP(1,1,2),NP,M)
      IPNR(2)=IPNR(2)/1000*1000+NP
      IPNUM(2)=NP
C
C   CORNER PATCH ?
      IF(NB2.NE.0)GOTO 70
      IRC=1
      GOTO 99
C  NEXT PATCH AT CORNER
   70 NP=IITOP(2,NB2,2)
      IF(NP.EQ.0)GOTO 99
C
C  LOAD PATCH
      CALL LODPCH(SSCAN(J11+1),BB(1,2),IIFLAG(1,2),IITOP(1,1,2),NP,0)
      IPNR(2)=IPNR(2)/1000*1000+NP
      IPNUM(2)=NP
      IRC=1
C
   99 RETURN
      END
**** SOURCE FILE : M0012316.V02   ***
*
      SUBROUTINE NUMVER(U1,V1,U2,V2,ADRESS,UV,NSEG)
C
C ROUTINE TO CALCULATE THE SECTIONS OF A SINGLE PATH, GIVEN IN
C  U/V-SPACE ON A GIVEN REGION.
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C INPUT : (U1,V1) START POINT
C  -"-  : (U2,V2) END   POINT
C  -"-  : ADRESS  CANONICAL FORM OF SURFACE
C OUTPUT: UV(2,I) RESULT POSITIONS (U,V) OF INTERSECTIONS
C                 (I=2*NSEG)
C  -"-  : NSEG    NUMBER OF SEGMENTS FOUND
C
C CANONICAL FORM OF SURFACE
      DOUBLE PRECISION ADRESS(2)
C
C RESULT POSITIONS (50 ELEMENTS ASSUMED)
      PARAMETER (MAXSEG=50)
      DOUBLE PRECISION UV(2,MAXSEG)
C
C HELP-STORAGE FOR ORDERING THE POINT-SEQUENCE
C  DISTANCE OF UV(...,I) FROM (U1,V1)
      DOUBLE PRECISION HS(MAXSEG)
C
C CROSSING CHARACTERISTIC:
C  AT THE CROSS-POINT BETWEEN THE GIVEN PATH AND THE REGION BOUNDARY
C  THE SITUATION >OUT TO IN< IS MARKED WITH 1, AND >IN TO OUT> WITH 2
C  THE PRIMARY POINTS (U1,V1) AND (U2,V2) ARE MARKED WITH 0.
      INTEGER MARK(MAXSEG)
C
C BLANK COMMON
      INCLUDE 'BLANKCOM.INC'
C
C STORAGE FOR GIVEN PATH IN UV-SPACE
      DOUBLE PRECISION W1(4),W1A(4)
C
C COMMON FOR REGIONAL STARTUP AND RETRACT VALUES
      COMMON/CCLEAR/ DIRMOT(3,4)
     *              ,GOFEED(4)
     *              ,GLFEED
     *              ,REGLDA(2)
     *              ,IRETRO(4)
     *              ,IDIRMO(4)
     *              ,ICANIN(4)
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
      LDAFLG=3
      CALL APT094(LDAFLG,REGLDA,LREG)
C
C ADDRESSING WITH BLANK COMMON VARIABLE COM:
      LREG=LREG-1
C
C COMPARE SURFACE OF GIVEN REGION WITH THE SURFACE INVOLVED
C  IN THE CUT-SEQUENCE
      I=INT(COM(LREG+2))
      IF(ADRESS(1).EQ.COM(I) .AND.
     *   ADRESS(2).EQ.COM(I+1) ) GOTO 10
C
C WARNING: ACTIVE REGION BELONGS NOT TO THE SURFACE INVOLVED
C          IN THIS MOTION (NO SEGMENTATION TAKES PLACE)
      CALL AERR(-22820,'NUMVER  ')
      UV(1,1)=U1
      UV(2,1)=V1
      UV(1,2)=U2
      UV(2,2)=V2
      RETURN
C
C PRESENT INTERSECTION ROUTINE WITH GIVEN SINGLE PATH
   10 W1(1)=U1
      W1(2)=V1
      W1(3)=U2-U1
      W1(4)=V2-V1
C
C RESET RESULT POSITIONS UV WITH THE START AND END POINT
      UV(1,1)=U1
      UV(2,1)=V1
      UV(1,2)=U2
      UV(2,2)=V2
C
      MARK(1)=0
      MARK(2)=0
      HS(1)=0.D0
      HS(2)=(U2-U1)**2 +(V2-V1)**2
C
C OUTSIDE POINTS
      AB1=(COM(LREG+5)-U1)*W1(3)+(COM(LREG+7)-V1)*W1(4)
      AB2=(COM(LREG+6)-U1)*W1(3)+(COM(LREG+7)-V1)*W1(4)
      AB3=(COM(LREG+6)-U1)*W1(3)+(COM(LREG+8)-V1)*W1(4)
      AB4=(COM(LREG+5)-U1)*W1(3)+(COM(LREG+8)-V1)*W1(4)
C
C MINIMUM OUTSIDE POINT
      HS(3)=DMIN1(AB1,AB2,AB3,AB4,HS(1))-1.D0
      UV(1,3)=W1(1)+W1(3)*HS(3)/HS(2)
      UV(2,3)=W1(2)+W1(4)*HS(3)/HS(2)
C
C MAXIMUM OUTSIDE POINT
      HS(4)=DMAX1(AB1,AB2,AB3,AB4,HS(2))+1.D0
      UV(1,4)=W1(1)+W1(3)*HS(4)/HS(2)
      UV(2,4)=W1(2)+W1(4)*HS(4)/HS(2)
      W1A(1)=UV(1,3)
      W1A(2)=UV(2,3)
      W1A(3)=UV(1,4)-UV(1,3)
      W1A(4)=UV(2,4)-UV(2,3)
      CALL SETVER(W1A)
C
C SET OUT TO IN
      MARK(3)=1
      MARK(4)=2
      IF(COM(LREG+4).EQ.1.D0) GOTO 15
C
C SET OUT TO IN, IF REGION/...IN
      MARK(3)=2
      MARK(4)=1
   15 NPT=4
C
C CALCULATE INTERSECTIONS
C  NUMBER OF ELEMENTS
      NREGE=COM(LREG+3)
      DO 90 I=1,NREGE
      J=LREG+5+I*4
      CALL GETVER(COM(J),UV(1,NPT+1),IRES)
      IF(IRES.EQ.0) GOTO 80
      IF(IRES.NE.1) GOTO 30
C
C SINGLE POINT FOUND, >OUT TO IN< OR >IN TO OUT< IS TO BE DETERMINED
      NPT=NPT+1
      MARK(NPT)=1
      HS(NPT)=(UV(1,NPT)-U1)*W1(3)+(UV(2,NPT)-V1)*W1(4)
      IF(COM(J+2)*(UV(2,3)-COM(J+1))
     *  -COM(J+3)*(UV(1,3)-COM(J  )).GT.0.D0.OR.
     *   COM(J+2)*(UV(2,4)-COM(J+1))
     *  -COM(J+3)*(UV(1,4)-COM(J  )).LT.0.D0) GOTO 80
C
C MUST BE >IN TO OUT<
      MARK(NPT)=2
C
C PATH NEAR PARALLEL TO SEGMENT
   30 IF(IRES.NE.2) GOTO 80
C
C CONCAVE/CONVEX CONDITION ON 1ST COMER OF
C  REGION SEGMENT INVOLVED (CONCAVE IF NEGATIVE)
      I1=I-1
      IF(I1.EQ.0) I1=NREGE
      J1=LREG+5+I1*4
      CONV1=COM(J+2)*COM(J1+3)-COM(J+3)*COM(J1+2)
C
C CONCAVE/CONVEX CONDITION ON 2ND CCSSER OF
C  REGION SEGMENT INVOLVED
      I1=I-1
      IF(I1.GT.NREGE) I1=1
      J1=LREG+5+I1*4
      CONV2=COM(J1+2)*COM(J+3)-COM(J1+3)*COM(J+2)
C
C NO MARK, IF BOTH SEGMENT ENDS ARE CONCAVE
      IF(CONV1.LT.0.D0.AND.CONV2.LT.0.D0) GOTO 80
C
C POSITION OF INPUT POINTS ON GIVEN REGION SEGMENT
      AB=COM(J+2)**2 +COM(J+3)**2
      POS1=((UV(1,3)-COM(J))*COM(J+2)+(UV(2,3)-COM(J+1))*COM(J+3))/AB
      POS2=((UV(1,4)-COM(J))*COM(J+2)+(UV(2,4)-COM(J+1))*COM(J+3))/AB
C
C   NO POINT IF BOTH POINTS ARE ON SEGMENT
      IF(POS1.GE.0.D0.AND.POS1.LE.1.D0
     *.AND.POS2.GE.0.D0.AND.POS2.LE.1.D0)GOTO 80
C
C   PARALLEL OR ANTIPARALLEL
      IF(POS2.GT.POS1)GOTO 40
C
C   SINGL PATH AND SEGMENT ARE PARALLEL
C    1. POINT
      IF(POS1.GE.0.D0.OR.CONV1.GT.0.D0)GOTO 35
      NPT=NPT+1
      MARK(NPT)=2
      UV(1,NPT)=COM(J)
      UV(2,NPT)=COM(J+1)
      HS(NPT)=(UV(1,NPT)-U1)*W1(3)+(UV(2,NPT)-V1)*W1(4)
C    2. POINT
   35 IF(POS2.LE.1.D0.OR.CONV2.GT.0.D0)GOTO 80
      NPT=NPT+1
      MARK(NPT)=1
      UV(1,NPT)=COM(J)  +COM(J+2)
      UV(2,NPT)=COM(J+1)+COM(J+3)
      HS(NPT)=(UV(1,NPT)-U1)*W1(3)+(UV(2,NPT)-V1)*W1(4)
      GOTO 80
C   SINGL PATH AND SEGMENT ARE ANTIPARALLEL
C    1. POINT
   40 IF(POS1.LE.1.D0.OR.CONV2.GT.0.D0)GOTO 45
      NPT=NPT+1
      MARK(NPT)=2
      UV(1,NPT)=COM(J)  +COM(J+2)
      UV(2,NPT)=COM(J+1)+COM(J+3)
      HS(NPT)=(UV(1,NPT)-U1)*W1(3)+(UV(2,NPT)-V1)*W1(4)
C    2. POINT
   45 IF(POS2.GE.0.D0.OR.CONV1.GT.0.D0)GOTO 80
      NPT=NPT+1
      MARK(NPT)=1
      UV(1,NPT)=COM(J)
      UV(2,NPT)=COM(J+1)
      HS(NPT)=(UV(1,NPT)-U1)*W1(3)+(UV(2,NPT)-V1)*W1(4)
      GOTO 80
C
C   CHECK IF NOT MORE THAN 50 SEGMENT END POINTS
   80 IF(NPT.LT.MAXSEG-1)GOTO 90
C
C WARNING : MORE THAN 24 SEGMENTS TO BE PROCESSED (REST IS SCIPPED)
      CALL AERR(-22821,'NUMVER  ')
      GOTO 95
   90 CONTINUE
C
C  SORT THE RESULTS
   95 NPT1=NPT-1
      DO 110 I=1,NPT1
      K=I
      I1=I+1
      DO 100 J=I1,NPT
      IF(HS(K).LE.HS(J))GOTO 100
      K=J
  100 CONTINUE
      IF(K.EQ.I)GOTO 110
      U=UV(1,I)
      V=UV(2,I)
      AB=HS(I)
      MARK1=MARK(I)
      UV(1,I)=UV(1,K)
      UV(2,I)=UV(2,K)
      HS(I)=HS(K)
      MARK(I)=MARK(K)
      UV(1,K)=U
      UV(2,K)=V
      HS(K)=AB
      MARK(K)=MARK1
  110 CONTINUE
C  TEST **************************************************************
C     NSEG=0
C     WRITE(6,200)NSEG,NPT,(UV(1,I),UV(2,I),MARK(I),HS(I),I=1,NPT)
C  TEST **************************************************************
C
C  SEARCH FOR START POINT
      DO 120 I=1,NPT
      IF(MARK(I).NE.0)GOTO 120
C
C  NO PATH IN REGION IF PREVIOUS POINT IS >IN TO OUT< (2)
C                    AND NEXT POINT IS THE GIVEN END POINT OF PATH
      IF(MARK(I-1).EQ.2.AND.MARK(I+1).EQ.0)GOTO 150
C
C  CASE: PREVIOUS POINT IS >OUT TO IN< (1)
      NPT1=I
      MARK(I)=1
      IF(MARK(I-1).EQ.1)GOTO 125
C
C  CASE: NEXT POINT IS >OUT TO IN< (1)
      NPT1=I+1
      GOTO 125
  120 CONTINUE
  125 CONTINUE
C
C  COMPRESS DATA
      DO 130 I=1,NPT
      UV(1,I)=UV(1,NPT1)
      UV(2,I)=UV(2,NPT1)
      MARK(I)=MARK(NPT1)
C
C   CHECK FOR THE END POINT OF THE PATH
      IF(MARK(NPT1).NE.0)GOTO 130
C
C THIS IS NO END POINT OF THE PATH IF THE PREVIOUS POINT IS >IN TO OUT<
      MARK(I)=2
      NPT1=I
      IF(MARK(I-1).EQ.2)NPT1=NPT1-1
      GOTO 135
  130 NPT1=NPT1+1
  135 CONTINUE
C
C  CHECK THE >OUT TO IN< AND >IN TO OUT< SEQUENCE
      NSEG=0
      DO 140 I=1,NPT1,2
      IF(MARK(I).EQ.1.AND.MARK(I+1).EQ.2) GOTO 140
      GOTO 150
  140 NSEG=NSEG+1
      GOTO 999
C
C  NO PATH IN REGION
  150 NSEG=0
C
  999 RETURN
      END
**** SOURCE FILE : M0012375.V01   ***
*
      SUBROUTINE PLAPOL(PL,POED,M,N,TOL,SP,IRC)
C
C  TO CHECK THE INTERFERENCE BETWEEN A PLANE AND A POLYHEDRON
C      PL  : I : PLANE
C      POED: I : POLYHEDRAL DATA OF SURFACE 2
C      TOL : I : INTERSECTION TOLERANCE
C      SP  : O : INTERSECTION NEAR POINT
C      IRC : O : RETURNCODE : NO INTERSECTION: IRC=0
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DOUBLE PRECISION PL(4),TOL,POED(3,M,N),SP(3),DIST(5),DISTMI
C
      IRC=0
      DISTMI=1.D20
C
C  DISTANCE TO PLANE
      DO 10 J=1,N
      DO 10 I=1,M
      DISTI=POED(1,I,J)*PL(1)+POED(2,I,J)*PL(2)+POED(3,I,J)*PL(3)
     * -PL(4)
C
C   MINIMUM DISTANCE SELECTION
      IF(DISTMI.LT.DABS(DISTI)) GOTO 2
      DISTMI=DABS(DISTI)
      II=I
      JJ=J
C
C   CROSS OF PLANE IN V-DIRECTION ?
    2 IF(J.EQ.1) GOTO 5
      IF(DISTI*DIST(I).GT.0.D0) GOTO 5
C
C   CROSS OR TUCH POINT FOUND
      II=I
      JJ=J
      GOTO 20
C
C   CROSS OF PLANE IN U-DIRECTION ?
    5 IF(I.EQ.1) GOTO 7
      IF(DISTI*DIST(I-1).GT.0.D0) GOTO 7
C
C   CROSS OR TUCH POINT FOUND
      II=I
      JJ=J
      GOTO 20
C
C   STORE DISTANCE
    7 DIST(I)=DISTI
   10 CONTINUE
C
C   RETURN IF THE SURFACES ARE NOT CLOSE ENOUGH
      IF(TOL*100.D0.LT.DISTMI) RETURN
C
C  STORE NEAR POINT
   20 DO 30 K=1,3
   30 SP(K)=POED(K,II,JJ)
      IRC=1
C
      RETURN
      END
**** SOURCE FILE : M0012387.V01   ***
*
      SUBROUTINE POLMTN(NS,POED,M,N)
C
C  TO COMPUTE A M*N POLYEDRON TO SEARCH FOR ROUGH INTERSECTION
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DOUBLE PRECISION POED(3,M,N)
C
C SS - ARELEM - COMMON
      COMMON/SSARLM/BB(64,4),UU(4),VV(4),
     *              IITOP(6,4,4),IIFLAG(4,4),IPNUM(4)
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
      DO 1 J=1,N
      V=J-1
      V=V/4.D0
      DO 1 I=1,M
      U=I-1
      U=U/4.D0
      CALL CNSURF(U,V,BB(1,NS),POED(1,I,J),IIFLAG(1,NS),0)
    1 CONTINUE
C
      RETURN
      END
**** SOURCE FILE : M0012381.V01   ***
*
      SUBROUTINE POLPOL(POED1,M1,N1,POED2,M2,N2,TOL,SP,IRC)
C
C  TO CHECK THE INTERFERENCE BETWEEN A PLANE AND A POLYHEDRON
C      POED1: I : POLYHEDRAL DATA OF SURFACE 1
C      POED2: I : POLYHEDRAL DATA OF SURFACE 2
C      TOL  : I : INTERSECTION TOLERANCE
C      SP   : O : INTERSECTION NEAR POINT
C      IRC  : O : RETURNCODE : NO INTERSECTION: IRC=0
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DOUBLE PRECISION POED1(3,M1,N1),TOL,POED2(3,M2,N2),SP(3),DIST(5),D
      DOUBLE PRECISION P1(3),P2(3),P3(3),V1(3),V2(3),V3(3),PL(4)
      DOUBLE PRECISION FACE(3,6),PF(3)
      EQUIVALENCE (FACE(1,1),P1(1))
      EQUIVALENCE (FACE(1,2),V1(1))
      EQUIVALENCE (FACE(1,3),P2(1))
      EQUIVALENCE (FACE(1,4),V2(1))
      EQUIVALENCE (FACE(1,5),P3(1))
      EQUIVALENCE (FACE(1,6),V3(1))
C
C
      IRC=0
      DISTMI=1.D20
      N1M1=N1-1
      M1M1=M1-1
      DO 50 L=1,N1M1
      DO 50 K=1,M1M1
C
C   COMPUTE INDICES OF TRIANGLE FACES ON DS PATCH
      K1=K
      L1=L
      L2=L+1
      K3=K+1
      DO 50 M=1,2
      K2=K+M-1
      L3=L+2-M
C
C  EXTRACT FACE CORNER POINTS
      DO 40 N=1,3
      P1(N)=POED1(N,K1,L1)
      P2(N)=POED1(N,K2,L2)
      P3(N)=POED1(N,K3,L3)
      V1(N)=P2(N)-P1(N)
      V2(N)=P3(N)-P2(N)
   40 V3(N)=P1(N)-P3(N)
C
C  GENERATE PLANE COEFFICENTS
      CALL CROSS(V2,V1,PL)
      SEC=DSQRT(PL(1)**2+PL(2)**2+PL(3)**2)
      PL(1)=PL(1)/SEC
      PL(2)=PL(2)/SEC
      PL(3)=PL(3)/SEC
      PL(4)=PL(1)*P1(1)+PL(2)*P1(2)+PL(3)*P1(3)
C
C  DISTANCE BETWEEN FACES ON DS PATCH AND POINTS OF PS PATCH
      DO 10 J=1,N2
      DO 10 I=1,M2
      DISTI=POED2(1,I,J)*PL(1)+POED2(2,I,J)*PL(2)+POED2(3,I,J)*PL(3)
     * -PL(4)
C
C   MINIMUM DISTANCE SELECTION
      IF(DISTMI.LT.DABS(DISTI)) GOTO 2
C
C  CALCULATE FOOT POINT ON PLANE
      PF(1)=POED2(1,I,J)-DISTI*PL(1)
      PF(2)=POED2(2,I,J)-DISTI*PL(2)
      PF(3)=POED2(3,I,J)-DISTI*PL(3)
C
C   CALCULATE IF FOOT POINT IS IN PLANE
      CALL INTFA1 (FACE,PL,PF,IRC1)
      IF(IRC1.EQ.0) GOTO 2
C
C  DISTANCE TO PLANE
      DISTMI=DABS(DISTI)
      II=I
      JJ=J
C
C   CROSS OF PLANE IN V-DIRECTION ?
    2 IF(J.EQ.1) GOTO 5
      IF(DISTI*DIST(I).GT.0.D0) GOTO 5
      CALL INTFA2 (FACE,PL,POED2(1,I,J-1),POED2(1,I,J),IRC1)
      IF(IRC1.EQ.0) GOTO 5
C
C   CROSS OR TUCH POINT FOUND
      II=I
      JJ=J
      GOTO 20
C
C   CROSS OF PLANE IN U-DIRECTION ?
    5 IF(I.EQ.1) GOTO 7
      IF(DISTI*DIST(I-1).GT.0.D0) GOTO 7
      CALL INTFA2 (FACE,PL,POED2(1,I-1,J),POED2(1,I,J),IRC1)
      IF(IRC1.EQ.0) GOTO 7
C
C   CROSS OR TUCH POINT FOUND
      II=I
      JJ=J
      GOTO 20
C
C   STORE DISTANCE
    7 DIST(I)=DISTI
   10 CONTINUE
   50 CONTINUE
C
C   RETURN IF THE SURFACES ARE NOT CLOSE ENOUGH
      IF(TOL*100.D0.LT.DISTMI) RETURN
C
C  STORE NEAR POINT
   20 DO 30 K=1,3
   30 SP(K)=POED2(K,II,JJ)
      IRC=1
C
      RETURN
      END
**** SOURCE FILE : M0012108.V03   ***
*
C
C              FORTRAN SUBROUTINE PRO028
C
C LINKAGE      SUBROUTINE PRO028(ERAS)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ALARM           SUBROUTINE    PRO026
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    ARGGEN
C          SUBROUTINE    CALLZZ
C          INTEGER FCT.  GETTMP
C          INTEGER FCT.  MODE
C          SUBROUTINE    OPCODE
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    REFGEN
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  SEARCH
C          SUBROUTINE    TWOARG
C
      SUBROUTINE PRO028(ERAS)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE 'NAMETB.INC'
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),NUMBER(2),TEMP(2),PERMID(2),VBL(2)
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C
C       10.    TABLE STORAGE FOR GEOMETRIC FUNCTION PROCESSOR
C
      INCLUDE 'GMTY.INC'
C GEOLOC:      GEOMETRIC PRODUCTION STARTING INDEX IN GEOMTB
C PMIDTB:      INTERNAL BIT REPRESENTATIONS FOR EACH ELEMENT OF GEOMTB
C GEOMTB:      GEOMETRIC FORMAT PRODUCTIONS ARRANGED BY SURFACE TYPE
C
C        8.    NAME TABLE POINTERS TO BCD LITERALS
C
      COMMON/BCDPTR/BCDPTR
      DIMENSION BCDPTR(7)
C ERASB:       NAMTBL POINTER TO ALPHAMERIC LITERAL 'APTER'
      EQUIVALENCE (ERASB,BCDPTR(5))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(12)
C ZEROPT:      NAMTBL POINTER TO '0.    '
      EQUIVALENCE (ZEROPT,NUMPTR(2))
C ONEPT:       NAMTBL POINTER TO '1.    '
      EQUIVALENCE (ONEPT,NUMPTR(4))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C REPL:        CONTAINS COMMAND CODE (17) FOR REPL COMMAND
      EQUIVALENCE (REPL,IL(17))
C MOVE:        CONTAINS COMMAND CODE (19) FOR MOVE COMMAND
      EQUIVALENCE (MOVE,IL(19))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C VECTOR:      MODE CODE (20) FOR VECTOR
      EQUIVALENCE (VECTOR,MODX(20))
C REAL:        MODE CODE (24) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C NOUGHT:      CONTAINS OPERAND TYPE 0
      EQUIVALENCE (NOUGHT,OPMOD(1))
C QUIDLR:      CONTAINS OPERAND TYPE CODE 5
      EQUIVALENCE (QUIDLR,OPMOD(6))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136)
C TLAXIS:      NAMTBL POINTER FOR XECUTION SUBROUTINE TLAXIS
      EQUIVALENCE (TLAXIS,SUBLST(135))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C*
      LOGICAL ERAS
      DIMENSION LENGTH(22)
      CHARACTER HCS*6,HPS*2
      DATA HCS/'CS    '/,HPS/'PS'/
      DATA LENGTH/7,5,5,3,2,1,1,1,1,4,2,6,4,4,2,4,3,4,3,3,2,2/
C**
C     PREPARE MODES AND PERMANENT IDENTIFIERS OF THE ARGSTK ARGUMENTS
C          AND MOVE THEM TO STACK(2,TOP+1) AND HIGHER ADDR.
C
      IF(ARGTOP.LT.1)GOTO 4100
      TP=TOP+1
      STACK(2,TP)=-1
      DO 40 ERRPT=1,ARGTOP
      NN=0
      J=ARGSTK(ERRPT)
      IF(J.GT.NAMMAX)GOTO 20
      CLASS=NAMTBL(J)/MODULO*MODULO
      MM=NAMTBL(J)-CLASS
      IF(MM.GT.MODHLF)MM=MM-MODHLF
      IF(CLASS.NE.PERMID(1))GOTO 10
      NN=50
      MM=MM+NN
      GOTO 30
   10 IF(CLASS.EQ.VBL(1).OR.CLASS.EQ.TEMP(1))GOTO 30
      IF(CLASS.NE.NUMBER(1))GOTO 4300
   20 MM=REAL
   30 TP=TP+1
      STACK(1,TP)=MM-NN
   40 STACK(2,TP)=PMIDTB(MM)
C
C
C     SEARCH FOR THE PRODUCTION NUMBER AND BRANCH
C
      MM=ARGTOP
      LL=MM
      NN=GEOLOC(49)
      LPROD=0
      II=0
   50 ERRPT=LL
      TP2=TP*2
      PROD=SEARCH(STACK,TP2,GEOMTB(NN),ERRPT)
C
C                   ERROR DIAGNOSTICS
C
      IF(PROD.EQ.200)GOTO 4400
      IF((LL-ERRPT).GT.LENGTH(PROD))GOTO 4500
      IF(PROD.LT.6)GOTO 90
      IF(ERRPT.NE.0)GOTO 4200
C
C                   PRODUCTION NUMBERS
C             1    2    3    4    5    6    7    8    9   10   11
   90 GOTO( 100, 200, 200, 400, 500, 600, 700, 800, 800,1000,1000,
C            12   13   14   15   16   17   18   19   20   21   22
     *     1200,1300,1300,1500,2200,2200,2200,2200,2000,2100,2200),PROD
C                                                          PS
C                PRODUCTION 1, 2, 3, 4  -->  TLAXIS/ATANGL,DS,.......
C
  100 ARGSTK(ARGTOP-5)=ARGSTK(ARGTOP-6)
      ARGSTK(ARGTOP-6)=ARGSTK(ARGTOP-2)
      ARGSTK(ARGTOP-3)=ARGSTK(ARGTOP-1)
      ARGSTK(ARGTOP-2)=ARGSTK(ARGTOP  )
      ARGTOP=ARGTOP-2
      MM=ARGTOP
      GOTO 410
C
  200 JJ=ARGSTK(ARGTOP-2)
      ARGSTK(ARGTOP-2)=ARGSTK(ARGTOP-4)
      ARGSTK(ARGTOP-3)=ARGSTK(ARGTOP-4)
      ARGSTK(ARGTOP-4)=JJ
      GOTO 410
C
  400 ARGTOP=ARGTOP+2
      ARGSTK(ARGTOP)=ARGSTK(ARGTOP-2)
      ARGSTK(ARGTOP-1)=ARGSTK(ARGTOP-3)
      ARGSTK(ARGTOP-2)=ZEROPT
      ARGSTK(ARGTOP-3)=ZEROPT
  410 MM=ARGTOP
      IF(CNAMTB(ARGSTK(MM-1)).EQ.HCS)GOTO 4600
      LPROD=PROD
      IF(ERRPT.EQ.0)GOTO 3000
      JJ=LENGTH(PROD)-1
      STACK(2,TP-JJ)=STACK(2,TP)
      TP=TP-JJ
      LL=LL-JJ
      GOTO 50
C
C            PRODUCTION 5    TLAXIS/<REAL>,<REAL>,.......,<REAL>
C
  500 IF(ARGTOP-3)3000,510,530
  510 ERRPT=1
      IF(MODE(ARGSTK(ERRPT)).NE.REAL)GOTO 4300
      KK=GETTMP(VECTOR)
      CALL OPCODE(MOVE)
      CALL TWOARG(NOUGHT,KK)
      DO 520 I=1,MM
  520 CALL ARGCVT(ARGSTK(MM+1-I))
      CALL RLSLIN
      CALL REFGEN(3,KK)
      CALL PUTTMP(VECTOR)
      PROD=7
      GOTO 3900
C
  530 IF(ARGTOP.LT.10)GOTO 540
      CALL ALARM(2052,9-ARGTOP,4,'PRO028  ')
      MM=9
  540 DO 550 ERRPT=4,MM
      IF(MODE(ARGSTK(ERRPT)).NE.REAL)GOTO 4300
  550 CONTINUE
      GOTO 3000
C                 PRODUCTION 6  -->  TLAXIS/ LAST
C                 PRODUCTION 7  -->  TLAXIS/<VECTOR>
C                 PRODUCTION 8  -->  TLAXIS/NORMDS ; TLAXIS/NORMPS
C                 PRODUCTION 9  -->  TLAXIS/ 1.
  600 KK=ONEPT
      PROD=9
      GOTO 3900
  700 MM=3
  800 KK=ARGSTK(ARGTOP)
      IF(CNAMTB(KK)(5:6).EQ.HPS)PROD=6
      GOTO 3900
C
C                 PRODUCTION 10 -->  TLAXIS/PARLEL,<REAL>,<REAL>,<REAL>
C                 PRODUCTION 11 -->  TLAXIS/PARLEL,<REAL>
C
 1000 GOTO 3000
C                                                          PS
C                PRODUCTION 12,13,14,15  ->  TLAXIS/PARLEL,DS,.......
C
 1200 ARGSTK(ARGTOP-4)=ARGSTK(ARGTOP-3)
      ARGSTK(ARGTOP-3)=ARGSTK(ARGTOP-1)
      ARGSTK(ARGTOP-2)=ARGSTK(ARGTOP  )
      ARGTOP=ARGTOP-2
      GOTO 1520
C
 1300 ARGSTK(ARGTOP-2)=ARGSTK(ARGTOP-3)
      GOTO 1520
C
 1500 ARGTOP=ARGTOP+2
      ARGSTK(ARGTOP)=ARGSTK(ARGTOP-2)
      ARGSTK(ARGTOP-1)=ARGSTK(ARGTOP-3)
      ARGSTK(ARGTOP-2)=ZEROPT
      ARGSTK(ARGTOP-3)=ZEROPT
 1520 MM=ARGTOP
      IF(CNAMTB(ARGSTK(MM-1)).EQ.HCS)GOTO 4600
      GOTO 3000
C                                                          ..,MOTDIR,..
C                PRODUCTION 16 BIS 22  -->  TLAXIS/ATANGL,...,CUTANG,..
C                                                          ..,PERPTO,..
 2000 II=ARGSTK(1)
      I=3
      DO 2010 JJ=I,ARGTOP
 2010 ARGSTK(JJ-2)=ARGSTK(JJ)
      ARGTOP=ARGTOP-2
      GOTO 2200
C
 2100 II=ARGSTK(1)
      I=2
 2110 DO 2120 JJ=I,ARGTOP
 2120 ARGSTK(JJ-1)=ARGSTK(JJ)
      ARGTOP=ARGTOP-1
C
 2200 MM=ARGTOP
      IF(LPROD.EQ.0)GOTO 4600
      PROD=100*LPROD+PROD
C
C      I. L. OUTPUT
C
 3000 IF(ERAS)GOTO 3100
      CALL RESRVZ(ERASB,0,9,1)
      ERAS=.TRUE.
C
 3100 CALL OPCODE(MOVE)
      CALL TWOARG(NOUGHT,ERASB)
      CALL ARGGEN
      CALL RLSLIN
      IF(II.EQ.0)GOTO 3800
C
C          REPLACE FOR PLANE, LINE OR VECTOR DEFINITION
C
      CALL OPCODE(REPL)
      CALL ONEARG(3)
      CALL TWOARG(-6,ERASB)
      CALL ARGCVT(II)
      CALL RLSLIN
      MM=MM+3
C
 3800 KK=ERASB
 3900 CALL CALLZZ(TLAXIS)
      CALL TWOARG(QUIDLR,MM)
      CALL TWOARG(QUIDLR,PROD)
      CALL ARGCVT(KK)
      CALL RLSLIN
C
 4000 RETURN
C
 4100 ERRPT=1-TOP
 4200 CALL ALARM(2052,-ERRPT,8,'PRO028  ')
      GOTO 4000
 4300 CALL ALARM(2021,-ERRPT,8,'PRO028  ')
      GOTO 4000
 4400 IF(ERRPT.LE.0)ERRPT=1
      CALL ALARM(2001,-ERRPT,8,'PRO028  ')
      GOTO 4000
 4500 ERRPT=ERRPT+1
      GOTO 4200
 4600 ERRPT=ARGTOP-1
      GOTO 4300
C
      END
**** SOURCE FILE : QABPST.ORG   ***
*
      DOUBLE PRECISION FUNCTION QABPST(P1,P2,P3)
C
C  PURPOSE: TO COMPUTE THE DISTANCE OF A POINT FROM A SPACE LINE
C
C  ARGUMENTS:
C            P1    D.P.  1ST POINT OF SPACE LINE
C            P2    D.P.  2ND POINT OF SPACE LINE
C            P3    D.P.  POINT
C
      DOUBLE PRECISION P1,P2,P3,V2,V3,A,B,H,D,ZEM10
      DIMENSION P1(3),P2(3),P3(3),V2(3),V3(3),H(3)
C
      PARAMETER (ZEM10=1.D-10)
C
      DO 10 I=1,3
        V2(I)=P2(I)-P1(I)
        V3(I)=P3(I)-P1(I)
  10  CONTINUE
C
      CALL DOTF(A,V3,V2)
      CALL DOTF(B,V2,V2)
C
      IF (B.GT.ZEM10) THEN
        A=A/B
      ELSE
C.... IF LINE PIS VERY SHORT ASSUME PERPENDICULAR MEETS LINE AT MIDPOIN
        A=0.5
      ENDIF
C
      DO 20 I=1,3
        H(I)=V3(I)-A*V2(I)
  20  CONTINUE
C
      CALL DOTF(D,H,H)
C
      QABPST=SQRT(D)
C
      END
**** SOURCE FILE : M0012301.V02   ***
*
      SUBROUTINE REGION(ARG1,ARG2)
C
C PROCESSES THE REGION/ ... STATEMENT
C
C       ARG1 : REAL NUMBER OF THE CLDAT-SECTION
C       ARG2 : IN, OUT OR OFF
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C---     REGION FLAG
      INCLUDE 'GLFLGS.INC'
C
      DOUBLE PRECISION PAT
      CHARACTER*4 IN,OUT,OFF,TEST
      INTEGER IPPS,IPAT(2)
      EQUIVALENCE (PAT,IPAT(1))
C
      DIMENSION RESULT(6)
      EQUIVALENCE(RESULT(1),U1),(RESULT(2),V1),(RESULT(3),P)
C
C SCULPTURED SURFACES CANONICAL FORM IN BLANK COMMON
      INCLUDE 'BLANKCOM.INC'
      DIMENSION ARYLDA(2)
C
C REGION STORAGE
      INTEGER MAXREG
      PARAMETER (MAXREG=50)
      DIMENSION IREGIO(4,MAXREG)
      INTEGER NUMREG,NUMRE1
C
C SCULPTURED SURFACES INTERMEDIATE STORAGE
      INCLUDE 'SSPAD.INC'
C
      DIMENSION W(2), VPREV(2), VCURR(2)
C
C COMMON FOR REGIONAL STARTUP AND RETRACT VALUES
C              (1) : START
C              (2) : AWAY
C              (3) : BACK
C              (4) : THRU
C DIRMOT(3,4): ARRAY FOR MOTDIR, NORMAL OR VECTOR VALUES
C              (1,I) : VALUES OF MOTDIR AND/OR NORMAL
C              (2,I)
C           OR (1,I) : VALUES OF VECTOR
C              (2,I)
C              (3,I)
C GOFEED(4)  : ARRAY FOR MOTION FEEDRAT
C              (1)   : FEDRAT OF START-MOTION (START AT FIRST POINT)
C              (2)   : FEDRAT OF AWAY-MOTION
C              (3)   : FEDRAT OF BACK-MOTION
C              (4)   : FEDRAT OF THRU-MOTION (RETRACT AT LAST POINT)
C GLFEED     : VARIABLE FOR NORMAL FEDRAT BEFORE GOMILL OR GOLOFT
C IRETRO(4)  : ARRAY FOR START, AWAY, BACK, THRU
C              (1) : START
C              (2) : AWAY
C              (3) : BACK
C              (4) : THRU
C                    0 : NOT USED
C                    1 : CONDITION SET
C IDIRMO(4)  : ARRAY FOR START ON AND END CONDITION
C                    0 : NOT SET
C                    1 : MOTDIR AND/OR NORMAL
C                    2 : VECTOR
C ICANIN(4)  : ARRAY FOR THE CANONICAL FORM INDEX OF THE SURFACE
C                    0 : NOT SET
C                    IC: INDEX
      COMMON/CCLEAR/ DIRMOT(3,4)
     *              ,GOFEED(4)
     *              ,GLFEED
     *              ,REGLDA(2)
     *              ,IRETRO(4)
     *              ,IDIRMO(4)
     *              ,ICANIN(4)
C
C CONTROL OF TEST-OUTPUT
      COMMON/SSPRT/SSPRT,SSTEST
      LOGICAL SSPRT,SSTEST
C
      CHARACTER*20 BADMSG
      INTEGER BCDF
      LOGICAL FIRST
      SAVE FIRST,PAT,IPPS
C
      DATA IN  /'IN  '/,OUT /'OUT '/,OFF /'OFF '/
      DATA NUMREG/0/, NUMRE1/0/
      DATA FIRST/.TRUE./
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C.... INITIALIZE CHARACTER ITEMS
      IF (FIRST) THEN
        IPAT(1)=BCDF('CLDA')
        IPAT(2)=BCDF('TA  ')
        IPPS=BCDF('PPS ')
        FIRST=.FALSE.
      ENDIF
           
      CALL HOLFRM(ARG2,TEST,1,4,NWD)
C
C    SWITCH OFF REGION FLAG IF >REGION/...,OFF<
      IF(TEST.NE.OFF) GOTO 1
      REGFLG=0
      GOTO 999
C
C SEARCH FOR ALREADY PROCESSED REGION
    1 IARG1=ARG1
      IF(TEST.EQ.IN) OUTIN=0.D0
      IF(TEST.EQ.OUT) OUTIN=1.D0
      IF(NUMREG.EQ.0) GOTO 3
      INOUT=OUTIN
      DO 2 I=1,NUMREG
      IF(IREGIO(1,I).NE.IARG1) GOTO 2
      IF(IREGIO(2,I).NE.INOUT) GOTO 2
      REGLDA(1)=IREGIO(3,I)
      REGLDA(2)=IREGIO(4,I)
      REGFLG=1
      GOTO 700
    2 CONTINUE
C
C FETCH THE NUMBER OF POINTS IN THE ID-AREA OUT OF EXFILE
    3 CALL NUMF2(R,PAT,ARG1)
      NUMP=R
C
C COMPUTE RECORD NUMBER OF ASSOCIATED SSURF
      CALL CLDATF(P,ARG1,IPPS,1.D0)
      NPA=P
      NPA=NPA/1000
      ARYLDA(1)=NPA
C
C GET BLANK COMMON STORAGE INDEX OF SSURF CANONICAL FORM
      LDAFLG=7
      CALL APT094(LDAFLG,ARYLDA,CANIND)
C
C GET LENGTH OF SURFACE FROM ORIGINAL CANONICAL FORM
      ARYLDA(2)=CANON(INT(CANIND+1.D0))
C
C GET STORAGE LOCATION OF SSURF DATA
      LDAFLG=3
      CALL APT094(LDAFLG,ARYLDA,LOCCAN)
      LOCCAN=LOCCAN-41
C
C GET NUMBER OF PATCHES IN U- AND V-DIRECTION
      NUMSPL=SSCAN(LOCCAN+ 9)-1.D0
      NUMCRS=SSCAN(LOCCAN+10)-1.D0
C
C FETCH THE U/V VALUES OF THE CLDAT-SECTION, BELONGING TO A PATCH
      IUVSC=ISCAN
      DO 100 I=1,NUMP
C
C  GET U,V,P DATA
      CALL ATAPER(RESULT,I,IARG1,9,IEE)
      IF(IEE.EQ.0)GOTO 4
C
C  ERROR : REGION DATA CAN NOT BE FETCHED
      CALL ERROR(22806,'REGION  ')
      GOTO 999
    4 NP=P
      ITAUS=NP/1000
      IF(ITAUS.EQ.NPA) GOTO 5
C
C ERROR: REGION DATA BELONGS TO MORE THAN ONE SURFACE
      CALL ERROR(22801,'REGION  ')
      GOTO 999
    5 NUMPAT=NP-ITAUS*1000
C
C TRANSFORM U1/V1 VALUES TO BASIC U/V VALUES
      IU=MOD(NUMPAT-1,NUMCRS)+1
      IV=(NUMPAT-1)/(NUMCRS)+1
      U=U1+IU-1
      V=V1+IV-1
      SCAN(ISCAN+1)=U
      SCAN(ISCAN+2)=V
C
C NO CHECK AT FIRST POINT
      IF(I.EQ.1) GOTO 90
C
C CHECK, CLOSE POINT TO LAST POINT
      DU=U-SCAN(ISCAN-1)
      DV=V-SCAN(ISCAN)
      IF(DU*DU+DV*DV.LT.1.D-12) GOTO 100
C
C NO CHECK AT 2ND POINT
      IF(I.LE.2) GOTO 90
C
C CHECK, IF LINEAR EXTENSION
      IF(DABS(DU*(V-SCAN(ISCAN-2))
     *       -DV*(U-SCAN(ISCAN-3))).GT.1.D-5) GOTO 90
C
C REPLACE PREVIOUS POINT
      SCAN(ISCAN-1)=U
      SCAN(ISCAN  )=V
      GOTO 100
C
   90 ISCAN=ISCAN+2
      IF(ISCAN.GT.NSCNMX) GOTO 992
  100 CONTINUE
C
C CHECK, CLOSE POINT TO FIRST POINT
      DU=SCAN(IUVSC+1)-SCAN(ISCAN-1)
      DV=SCAN(IUVSC+2)-SCAN(ISCAN)
      IF(DU*DU+DV+DV.GE.1.D-12) GOTO 110
      ISCAN=ISCAN-2
C
C CHECK, IF LINEAR EXTENSION
  110 IF(DABS((SCAN(IUVSC+1)-SCAN(ISCAN-1))
     *       *(SCAN(IUVSC+4)-SCAN(ISCAN))
     *       -(SCAN(IUVSC+2)-SCAN(ISCAN))
     *       *(SCAN(IUVSC+3)-SCAN(ISCAN-1)))
     *        .GT.1.D-5) GOTO 120
      SCAN(IUVSC+1)=SCAN(ISCAN-1)
      SCAN(IUVSC+2)=SCAN(ISCAN)
      ISCAN=ISCAN-2
C
C RECALCULATE THE NUMBER OF POINTS
  120 NUMP=(ISCAN-IUVSC)/2
      IF(NUMP.GE.3) GOTO 130
C
C ERROR: LESS THAN 3 POINTS AS REGION BOUNDARY
      CALL ERROR(22802,'REGION  ')
      GOTO 999
  130 CONTINUE
C
C TEST OF RIGHT (CLOCWISE) OR LEFT SENSE OF CONTOUR
C
C  DIRECTION SENSE VECTOR
      W(1)=SCAN(IUVSC+3)-SCAN(IUVSC+1)
      W(2)=SCAN(IUVSC+4)-SCAN(IUVSC+2)
C
C NUMBER OF 90 DEGREE TURNS
      IQ=0
C
C PRESET OF PREVIOUS CENTER DIRECTION
      VPREV(1)=W(1)
      VPREV(2)=W(2)
C
C START-INDEX
      IA=IUVSC+2
      NUMP1=NUMP+1
C
C SENSE LOOP
      DO 600 I=2,NUMP1
      IA1=IA+2
      IF(I.EQ.NUMP) IA1=IUVSC
C
C CURRENT CONTOUR DIRECTION
      VCURR(1)=SCAN(IA1+1)-SCAN(IA+1)
      VCURR(2)=SCAN(IA1+2)-SCAN(IA+2)
C
C IS THE DIRECTION SENSE VECTOR TO BE CHANGED
      IF(W(1)*VCURR(1)+W(2)*VCURR(2).GT.0.D0) GOTO 610
C
C CROSS PRUDUCT BETWEEN SENSE VECTOR AND CONTOUR DIRECTION
      WCV=W(1)*VCURR(2)-W(2)*VCURR(1)
C
C LEFT/RIGHT CORNER
      IF(VPREV(1)*VCURR(2)-VPREV(2)*VCURR(1).GT.0.D0) GOTO 605
C
C CORNER TO RIGHT
      IF(WCV.GE.0.D0) GOTO 603
      IQ=IQ+2
      W(1)=-W(1)
      W(2)=-W(2)
      GOTO 610
C
  603 IQ=IQ+1
      WW=W(1)
      W(1)=W(2)
      W(2)=-WW
      GOTO 610
C
C CORNER TO LEFT
  605 IF(WCV.LE.0.D0) GOTO 608
      IQ=IQ-2
      W(1)=-W(1)
      W(2)=-W(2)
      GOTO 610
C
  608 IQ=IQ-1
      WW=W(1)
      W(1)=-W(2)
      W(2)=WW
      GOTO 610
C
  610 IA=IA+2
      IF(I.EQ.NUMP) IA=IUVSC
      VPREV(1)=VCURR(1)
      VPREV(2)=VCURR(2)
  600 CONTINUE
      IF(IQ.NE.0.OR.IABS(IQ).LE.4) GOTO 140
C
C ERROR: REGION BOUNDARY IS INCORRECT
      CALL ERROR(22803,'REGION  ')
      GOTO 999
C
C RESERVE REGION DATA SPACE
  140 LDAFLG=5
      REGLDA(1)=0.D0
      REGLDA(2)=8+4*NUMP
      CALL APT094(LDAFLG,REGLDA,SSCAN(1))
C
C PUT REGION-VALUES INTO SSCAN (BLANK COMMON)
      J=1
      SSCAN(J)=NP
      SSCAN(J+1)=CANIND
      SSCAN(J+2)=NUMP
      SSCAN(J+3)=OUTIN
      J=J+3
C
C FIND THE MIN/MAX-VALUES OF U/V
      UMIN=SCAN(IUVSC+1)
      UMAX=SCAN(IUVSC+1)
      VMIN=SCAN(IUVSC+2)
      VMAX=SCAN(IUVSC+2)
C
      IA=IUVSC+2
      IE=ISCAN-2
      DO 800 I=IA,IE,2
      UMIN=DMIN1(SCAN(I+1),UMIN)
      UMAX=DMAX1(SCAN(I+1),UMAX)
      VMIN=DMIN1(SCAN(I+2),VMIN)
      VMAX=DMAX1(SCAN(I+2),VMAX)
  800 CONTINUE
C
C PUT THE MIN/MAX-VALUES INTO SSCAN
      SSCAN(J+1)=UMIN
      SSCAN(J+2)=UMAX
      SSCAN(J+3)=VMIN
      SSCAN(J+4)=VMAX
      J=J+4
C
C PUT THE U/V-VALUES AND DISTANCES INTO SSCAN ( IN NORMAL ORDER)
      IF(IQ.GT.0.AND.OUTIN.EQ.1.D0.OR.
     *   IQ.LT.0.AND.OUTIN.EQ.0.D0) GOTO 810
      DO 801 I=IUVSC,IE,2
      I1=I+2
      SSCAN(J+1)=SCAN(I+1)
      SSCAN(J+2)=SCAN(I+2)
      IF(I.EQ.IE)I1=IUVSC
      SSCAN(J+3)=SCAN(I1+1)-SCAN(I+1)
      SSCAN(J+4)=SCAN(I1+2)-SCAN(I+2)
      J=J+4
  801 CONTINUE
      NUMD=J
      GOTO 820
C
C PUT THE U/V-VALUES AND DISTANCES INTO SSCAN (REVERSE ORDER)
  810 J=J+(NUMP-1)*4
      DO 811 I=IUVSC,IE,2
      I1=I-2
      SSCAN(J+1)=SCAN(I+1)
      SSCAN(J+2)=SCAN(I+2)
      IF(I.EQ.IUVSC)I1=IE
      SSCAN(J+3)=SCAN(I1+1)-SCAN(I+1)
      SSCAN(J+4)=SCAN(I1+2)-SCAN(I+2)
      J=J-4
  811 CONTINUE
      NUMD=J+(NUMP+1)*4
C
C TEST OF SELF-INTERSECTION OF REGION BOUNDARY
  820 IF(NUMP.EQ.3) GOTO 920
      NUMPM2=NUMP-2
      DO 900 I=1,NUMPM2
C
C PREPARE INTERSECTION TEST
      CALL SETVER(SSCAN(5+I*4))
C
C LOOP INDICES FOR INNNER LOOP
      J1=I+2
      J2=NUMP
      IF(I.EQ.1) J2=NUMP-1
C
C INNER LOOP
      DO 900 J=J1,J2
      CALL GETVER(SSCAN(5+J*4),RESULT,IRES)
      IF(IRES.EQ.0) GOTO 900
C
C ERROR: REGION BOUNDARY CONTAINS INTERSECTIONS
      CALL ERROR(22804,'REGION  ')
      GOTO 999
  900 CONTINUE
  920 CONTINUE
C
C WRITE ALL REGION-DATA TO LDA
      LDAFLG=1
      REGLDA(1)=0.D0
      REGLDA(2)=NUMD
      CALL APT094(LDAFLG,REGLDA,SSCAN(1))
C
C COMPUTE THE REGION STORAGE INDEX AND STORE THE REGION
      NUMRE1=NUMRE1+1
      IF(NUMRE1.GT.MAXREG) NUMRE1=1
      IREGIO(1,NUMRE1)=IARG1
      IREGIO(2,NUMRE1)=OUTIN
      IREGIO(3,NUMRE1)=REGLDA(1)
      IREGIO(4,NUMRE1)=REGLDA(2)
C
C INCREASE NUMBER OF STORED REGIONS
      IF(NUMREG.LT.MAXREG) NUMREG=NUMREG+1
      REGFLG=1
  700 CONTINUE
C
C TEST-OUTPUT, IF PRINT/SSTEST,ON
      IF(.NOT.SSTEST) GOTO 999
      CALL RECORD(NSEQ)
      LDAFLG=3
      CALL APT094(LDAFLG,REGLDA,J11)
      J11=J11-41
      J111=J11+1
      J12=J11+8
      BADMSG=' REGION DATA:'
      CALL CPRINT(BADMSG)
      CALL BAD(-1,0,'ISN ',NSEQ)
C
      CALL BAD( 1,1,'REG1',REGLDA(1))
      CALL BAD( 1,1,'REG2',REGLDA(2))
      CALL BAD(-1,0,'J11 ',J11)
      DO 807 I1=J111,J12,8
      CALL BAD( 1,1,'S  1',SSCAN(I1))
      CALL BAD( 1,1,'S  2',SSCAN(I1+1))
      CALL BAD( 1,1,'S  3',SSCAN(I1+2))
      CALL BAD(-1,1,'S  4',SSCAN(I1+3))
      CALL BAD( 1,1,'S  5',SSCAN(I1+4))
      CALL BAD( 1,1,'S  6',SSCAN(I1+5))
      CALL BAD( 1,1,'S  7',SSCAN(I1+6))
  807 CALL BAD(-1,1,'S  8',SSCAN(I1+7))
      J13=J12+1
      J14=SSCAN(J11+3)*4+J13-1
      DO 808 I=J13,J14,4
      CALL BAD( 1,1,'    ',SSCAN(I))
      CALL BAD( 1,1,'    ',SSCAN(I+1))
      CALL BAD( 1,1,'    ',SSCAN(I+2))
      CALL BAD( 1,1,'    ',SSCAN(I+3))
  808 CALL BAD(-1,1,'    ',0)
      GOTO 999
C
C ERROR: TOO MANY REGION POINTS TO PROCESS
  992 CALL ERROR(22805,'REGION  ')
C
  999 RETURN
      END
**** SOURCE FILE : M0012349.V02   ***
*
      SUBROUTINE TLCONV
C
C ROUTINE WILL SET AND CONVERT TOOLDATA OF THE CUTTER
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C  CONTROL OF TEST-OUTPUT
      COMMON/SSPRT/SSPRT,SSTEST
      LOGICAL SSPRT,SSTEST
C
      INCLUDE 'GLFLGS.INC'
C
      INCLUDE 'FXCOR.INC'
C
C  COMMON FOR  >PLOTFT/GOLOFT<
C
C
C  VALUES FOR  >PLOTFT/GOLOFT<
      INTEGER IPLGO(26)
C
C  USED CUTTER SEGMENT
      INTEGER JCSEG
C
C  NUMBER OF VALID CUTTER SEGMENTS
      INTEGER NCSEG
C
C  CUTTER SEGMENT IN TLLDAT ARRAYS
      INTEGER ICSEG(10)
C
C  NATURE OF SEGMENT
      INTEGER NLIOCI(10)
C
C  COMPONENTS OF SEGMENT AND UNIT NORMAL POINTING INTO THE CUTTER
      DOUBLE PRECISION COSAL(10)
      DOUBLE PRECISION SINAL(10)
C
C  DISTANCE PARALLEL TO THE CUTTER AXIS
      DOUBLE PRECISION CUTY(10)
C
C  DISTANCE TO THE CUTTER AXIS
      DOUBLE PRECISION CUTX(10)
C
C  ELEMENT LENGTH
      DOUBLE PRECISION CUTL(10)
C  VECTOR COMPONENTS OF THE TOOL AXIS VECTOR
      DOUBLE PRECISION VTA(3)
C
      COMMON/PLGOL/IPLGO,JCSEG,NCSEG,ICSEG,NLIOCI,
     *             COSAL,SINAL,
     *             CUTY,CUTX,CUTL,VTA
C
      CHARACTER*12 BADMSG
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C  THE FOLLOWING DATA ARE SET, IF CUTDAT(1).GE. 0.001:
      IF(CUTDAT(1).LT.1.D-3) GOTO 999
      NCSEG=0
      JCSEG=0
C
C FIND THE NUMBER OF VALID SEGMENTS, ==> NCSEG
      DO 801 I=0,7
      IF(TCONT(I).NE.-1.D0) GOTO 801
      N=I+1
      GOTO 802
  801 CONTINUE
C
  802 DO 800 J=N,8
      IF(TCONT(J).EQ.0.D0) GOTO 800
      NCSEG=NCSEG+1
C
C NUMBER OF RELATET SEGMENT IN TLLDAT
      ICSEG(NCSEG)=J
C
C SEGMENT LINE OR CIRCLE
      NLIOCI(NCSEG)=TLINC(J)
C
      IF(TLINC(J).NE.0.D0) GOTO 10
C
C SEGMENT IS AN ARC (CIRCLE)
      IF(TANHI(J).GT.-1.D38) GOTO 11
      SINAL(NCSEG)=0.D0
      GOTO 12
   11 SINAL(NCSEG)=1.D0/DSQRT(1.D0+(TANHI(J)*TANHI(J)))
C
   12 IF(TANHI(J).GT.-1.D38) GOTO 13
      COSAL(NCSEG)=-1.D0
      GOTO 14
   13 COSAL(NCSEG)=TANHI(J)*SINAL(NCSEG)
C
   14 CUTY(NCSEG)=TLHITE(J)
      CUTX(NCSEG)=RI(J)
      CUTL(NCSEG)=CORRAD(J)
      GOTO 800
C
   10 IF(TLINC(J).NE.1.D0) GOTO 20
C
C SEGMENT IS A LINE
      SINAL(NCSEG)=SINL(J)
      COSAL(NCSEG)=COSL(J)
      CUTY(NCSEG)=TLHITE(J)
      CUTX(NCSEG)=RI(J)
      CUTL(NCSEG)=UMAX(J)
      GOTO 800
C
C WRONG DATA IN TLINC, VALUE NOT LINE OR NOT CIRCLE
   20 CALL AERR(22218,'TLCONV  ')
  800 CONTINUE
C
C TEST PRINT-OUT OF THE CONVERTET AND CALCUALTED VALUES
      IF(.NOT.SSTEST) GOTO 999
      CALL RECORD(NSEQ)
      BADMSG=' NEW CUTTER:'
      CALL CPRINT(BADMSG)
      CALL BAD (-1,0,'ISN ',NSEQ)
C
      DO 808 I=1,NCSEG
      LIOC=NLIOCI(I)
      CALL BAD ( 1,0,'LIOC',LIOC)
      CALL BAD ( 1,1,'COAL',COSAL(I))
      CALL BAD ( 1,1,'SIAL',SINAL(I))
      CALL BAD ( 1,1,'CUTY',CUTY(I))
      CALL BAD ( 1,1,'CUTX',CUTX(I))
      CALL BAD (-1,1,'CUTL',CUTL(I))
  808 CONTINUE
C
  999 RETURN
      END
