**** SOURCE FILE : M0011439.W02   ***
*
C
C
      SUBROUTINE AERR(NUMBER,SBNAM)
      IMPLICIT DOUBLE PRECISION (A-H), DOUBLE PRECISION (O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'IFXCOR.INC'
C
C...  20. SYSTEM I/O FILE NAMES
C
      INCLUDE 'SYMFIL.INC'
C
C     25. COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM/  IAERFG,NPCTPT,PCTPTS,PCTPLN,ERRPTS
      DIMENSION  PCTPTS(3,20), PCTPLN(4), ERRPTS(3,3)
C
      INCLUDE 'DARRAY.INC'
C
C...      32.  PARAMETERS REQUIRED BY SUPERVISOR
C
          COMMON/SUPER/ERR,XC,CL,PX,ERRX,END,FINI,ASM,ABEND,XTRAS
          DIMENSION XTRAS(7),CFLAGS(4),LXTRAS(7)
          INTEGER   ERRX,XTRAS
          LOGICAL   ERR,FINI,XC,CL,ASM,LXTRAS,CFLAGS,PX,END,ABEND
          EQUIVALENCE (LXTRAS(1),XTRAS(1)),(CFLAGS(1),ERR)
C
      INTEGER NUM
      CHARACTER*8 SUBNAM,SBNAM*(*)
      INTEGER BCDF
      LOGICAL FIRST
      SAVE FIRST,KERR
C
      INTEGER Z4E
      PARAMETER (Z4E=1308622848)
      DIMENSION KERR(10),ISN(2)
      DATA KERR/0,0,Z4E,1,Z4E,1,Z4E,1,2*0/
      DATA FIRST/.TRUE./
C
C     ------------------------------------------------------------
C
      IF (FIRST) THEN
        KERR(1) = BCDF('AERR')
        KERR(2) = BCDF('    ')
        FIRST=.FALSE.
      ENDIF
C
      SUBNAM=SBNAM
      IF(NUMBER.LT.0)GO TO 10
      CALL AERR2(NUMBER,SUBNAM)
      GO TO 20
C
C        WARNING DIAGNOSTIC - NO VARIABLE INFORMATION OUTPUT
C
   10 XTRAS(2)=XTRAS(2)+1
      IAERR=1
      CALL ATAPE
      NR = 0
      KERR(4)=1
      KERR(6)=2
      KERR(8)=NUMBER
      KERR( 9) = BCDF(SUBNAM(1:4))
      KERR(10) = BCDF(SUBNAM(5:8))
      CALL EWRITE (EXFILE,NR,KERR,10,IR)
      IF (ERRX .LT. 4) ERRX=4
      CALL CPRINT(DARRAY)
      NUM=ABS(NUMBER)
      IAERR=0
      IAERFG=0
      CALL RECORD(ISN(1))
      CALL CFORM(' ***** WARNING DIAGNOSTIC ',DARRAY,1,26)
      CALL ICONV(NUM,DARRAY,27,5)
      CALL CFORM('ISN',DARRAY,36,3)
      CALL ICONV(ISN(1),DARRAY,39,5)
      CALL CFORM(' FROM SUBROUTINE ',DARRAY,44,17)
      CALL CFORM(SUBNAM,DARRAY,61,8)
      CALL CFORM('*****',DARRAY,69,5)
      CALL CPRINT(DARRAY)
      CALL ERROUT(NUMBER)
   20 RETURN
      END
**** SOURCE FILE : M0001934.V11   ***
*
C....    FORTRAN SUBROUTINE                 AERR2
C
C... THIS ROUTINE WRITES ONTO THE EXFILE TAPE ALL THE INFORMATION
C       REQUIRED BY THE CLTAPE EDITOR TO PROCESS ARELEM DIAGNOSTICS
C
C   SUBSIDIARIES   ATAPE, APT242, CUTTER, QSD
C
C
      SUBROUTINE AERR2 (NUMBER,SUBNAM)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C...  20. SYSTEM I/O FILE NAMES
C
      INCLUDE 'SYMFIL.INC'
C
C
C...  21. ADDCOM BLOCK
C
      COMMON/ADDCOM/ ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),  (ADDCOM( 2),CLNGTH),
     1            (ADDCOM(23),IBTFLG),  (ADDCOM(24),JLIN)
C
C
C        COMMON BLOCKS FOR SURFACE NAME AND SUBSCRIPT STORAGE
C
C     23. DSNAME BLOCK
      COMMON/DSNAME/DSNAME,NAMSUB
C
C     24. SRFNAM BLOCK
      COMMON /SRFNAM/ PSNAME,CS1NAM,CS2NAM,IPSSUB,ICS1SB,ICS2SB
C
C     25. COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM/  IAERFG,NPCTPT,PCTPTS,PCTPLN,ERRPTS
      DIMENSION  PCTPTS(3,20), PCTPLN(4), ERRPTS(3,3)
      INTEGER BCDF
      CHARACTER*8 SUBNAM
      LOGICAL FIRST
      SAVE FIRST,KERR
      INCLUDE 'DARRAY.INC'
C
      INTEGER Z4E
      PARAMETER (Z4E=1308622848)
C
      DIMENSION DSHARE(100)
C
C        BLANK COMMON CONTAINING CANONICAL FORM OF SURFACES
C
      INCLUDE 'BLANKCOM.INC'
C
C        CANONICAL SIZE ARRAY FOR VARIOUS MODES OF A SURFACE
C
      DIMENSION ICANSZ(30)
C
C        DIMENSION FOR ARGUMENTS IN CALL TO QSD AND CUTTER
      DIMENSION  CANFRM(10), COEFF(10), TRANS(12)
C
      DIMENSION ITEMP(8),DTEMP(4)
      EQUIVALENCE (ITEMP(1),DTEMP(1))
C
C...      32.  PARAMETERS REQUIRED BY SUPERVISOR
C
          COMMON/SUPER/ERR,XC,CL,PX,ERRX,END,FINI,ASM,ABEND,XTRAS
          DIMENSION XTRAS(7),CFLAGS(4),LXTRAS(7)
          INTEGER   ERRX,XTRAS
          LOGICAL   ERR,FINI,XC,CL,ASM,LXTRAS,CFLAGS,PX,END,ABEND
          EQUIVALENCE (LXTRAS(1),XTRAS(1)),(CFLAGS(1),ERR)
C
      DIMENSION KERR(10),ISN(2)
      DATA KERR/0,0,Z4E,1,Z4E,1,Z4E,1,2*0/
      DATA       ICANSZ  / 4,  4,  7,  7,  4,    10, 10, 10,  7, 10,
     +                     2,  2,  2, 10, 10,     1,  1, 12,  3,  3,
     +                     1,  1,  1,  1, 12,     2,  1,  1,  2,  2/
      DATA  IPOW/Z4E/
      DATA  FIRST/.TRUE./
C     ------------------------------------------------------------
C
C
      TAL(1)=FWD(1)
      TAL(2)=FWD(2)
      TAL(3)=FWD(3)
      XTRAS(1) = XTRAS(1) + 1
      IAERR=K1
      IF (FIRST)THEN
        KERR(1) = BCDF('AERR')
        KERR(2) = BCDF('    ')
        FIRST=.FALSE.
      ENDIF
      NERR=NUMBER
      KERR( 9)= BCDF(SUBNAM(1:4))
      KERR(10)= BCDF(SUBNAM(5:8))
      NUMRTN=NERR/100
      CALL ATAPE
      CALL RECORD(ISN(1))
      CALL CPRINT(DARRAY)
      CALL CFORM(' ***** RESTART DIAGNOSTIC ',DARRAY,1,26)
      CALL ICONV(NERR,DARRAY,27,5)
      CALL CFORM('ISN',DARRAY,36,3)
      CALL ICONV(ISN(1),DARRAY,39,5)
      CALL CFORM(' FROM SUBROUTINE ',DARRAY,44,17)
      CALL CFORM(SUBNAM,DARRAY,61,8)
      CALL CFORM('*****',DARRAY,69,5)
      CALL CPRINT(DARRAY)
      CALL ERROUT(NERR)
C
C..   ***** RESTART DIAGNOSTIC - OUTPUT SURFACE VARIABLE DATA *****
C
C        SET ERROR LEVEL FLAG TO VALUE 8
   20 ERRX=K8
C
C        CHECK FOR POCKET ERROR PROCESSING
      IF (NUMRTN-35) 22,90,22
C
C...     IF ERROR IS FOR MISSING CUTTER USE A POINT CUTTER
   22 IF (ICTDEF .NE. K1) GO TO 23
C
      ICTDEF=0
      NR = 0
      KERR(4)=1
      KERR(6)=2
      KERR(8)=NERR
      CALL EWRITE (EXFILE,NR,KERR,10,IR)
      IAERR=0
      NR=7
      DO 21 I=1,9
      CANFRM(I)=0.0
   21 CONTINUE
      CALL CUTTER(NR,CANFRM)
      GO TO 100
C
C        OUTPUT ERROR NUMBER AND CUTTER PARAMETERS
C
   23 KERR(4)=1
      KERR(6)=9
      KERR(8)=NERR
      CALL AFORM(DSHARE(1),KERR,5)
      CALL AFORM(DSHARE(6),CUTDAT,7)
      NR=0
      CALL EWRITE (EXFILE,NR,DSHARE,24,IR)
C
C        CHECK FOR NO SURFACE VARIABLE OUTPUT
   24 IF (IAERFG) 25,25,99
C
C        WRITE NECESSARY SV AND ISV VARIABLES FOR PS ON EXFILE
   25 L=K2
      J=IPS
      SFNAME=PSNAME
      ISUB=IPSSUB
C
C
C.... *** PRIMARY OUTPUT LOOP FOR EACH SURFACE ***
C
   30 L=L+K1
      IC=ICANON(J)
      MODE=ISFIDN(J)
C
C        SAVE CANONICAL FORM
      ISIZE=ICANSZ(MODE)
      ICC=IC
      DO  32 I=1,ISIZE
      CANFRM(I)=CANON(ICC)
      ICC=ICC+1
   32 CONTINUE
C
C        CALCULATE VT VALUES FOR ERRORS FROM AMIND ASSOCIATED ROUTINES
C              (SINCE THEY MAY BE MISSING AT THIS TIME)
      IF (NUMRTN.LT.260 .OR. NUMRTN.GT.272) GO TO 34
C
   33 VT(1,J)=TP(1,J)-TH(J)*TN(1,J)  -TE(1)
      VT(2,J)=TP(2,J)-TH(J)*TN(2,J)-TE(2)
      VT(3,J)=TP(3,J)-TH(J)*TN(3,J)-TE(3)
C
C        PRIMARY OUTPUT STATEMENT CONTAINING NECESSARY SV AND ISV
C        VARIABLES, SURFACE NAME AND TYPE, AND CANONICAL FORM
C
   34 JSIZE=ISIZE+30
      JL=J+K2
      KERR(4)=L
      KERR(6)=JSIZE
      KERR(8)=NERR
      CALL AFORM(DSHARE(1),KERR,5)
      ITEMP(1)=IPOW
      ITEMP(2)=ITLON(J)
      ITEMP(3)=IPOW
      ITEMP(4)=ISFTYP(J)
      ITEMP(5)=IPOW
      ITEMP(6)=IFL4(J)
      ITEMP(7)=IPOW
      ITEMP(8)=IFAR(J)
      CALL AFORM(DSHARE(6),DTEMP,4)
      CALL AFORM(DSHARE(10),TAU1(J),1)
      CALL AFORM(DSHARE(11),TAU2(J),1)
      CALL AFORM(DSHARE(12),TH(J),1)
      CALL AFORM(DSHARE(13),S(J),1)
      CALL AFORM(DSHARE(14),RC(J),1)
      CALL AFORM(DSHARE(15),SP(1,J),3)
      CALL AFORM(DSHARE(18),SN(1,J),3)
      CALL AFORM(DSHARE(21),TN(1,J),3)
      CALL AFORM(DSHARE(24),CC(1,J),3)
      CALL AFORM(DSHARE(27),VT(1,J),3)
      CALL AFORM(DSHARE(30),SFNAME,1)
      ITEMP(2)=ISUB
      ITEMP(4)=MODE
      ITEMP(6)=ISIZE
      CALL AFORM(DSHARE(31),DTEMP,3)
      CALL AFORM(DSHARE(34),CANFRM,ISIZE)
      NR=0
      N=(JSIZE+3)*2
      CALL EWRITE (EXFILE,NR,DSHARE,N,IR)
C
C        CHECK FOR QUADRIC, LCONIC, OR GCONIC TYPE SURFACES,
C        IF FOUND, CALL QSD TO IDENTIFY AND SOLVE FOR PARAMETERS
C
      GO TO (35,35,35,35,35,  80,80,80,35,80,  35,35,35,80,35,
     +35,35,35,35,35,35,35,35,35,35,35,35,35,35,35),MODE
C
C        CHECK FOR FURTHER SURFACE OUTPUT
   35 IF (((NUMSUR+K2).EQ.L) .OR. (NUMSUR.LE.K0)) GO TO 95
      IF(L-K4) 40,50,60
C
C        WRITE NECESSARY SV AND ISV VARIABLES FOR DS ON EXFILE
   40 J=IDS
      IGOTO=K1
      ISRCH=K1
      SFNAME=DSNAME
      ISUB=NAMSUB
      GO TO 30
C
C        WRITE NECESSARY SV AND ISV VARIABLES FOR CS1 ON EXFILE
   50 J=ICS
      SFNAME=CS1NAM
      ISUB=ICS1SB
      GO TO 30
C
C        WRITE NECESSARY SV AND ISV VARIABLES FOR CS2 ON EXFILE
   60 J=J+LSV1
      SFNAME=CS2NAM
      ISUB=ICS2SB
      GO TO 30
C
C        OUTPUT QUADRIC INFORMATION
C
   80 CALL QSD (CANFRM,IQSDFG,COEFF,TRANS)
      KERR(4)=7
      KERR(6)=24
      KERR(8)=IQSDFG
      NR=0
      CALL AFORM(DSHARE(1),KERR,5)
      CALL AFORM(DSHARE(6),COEFF,10)
      CALL AFORM(DSHARE(16),TRANS,12)
      CALL EWRITE (EXFILE,NR,DSHARE,54,IR)
      GO TO 35
C
C        OUTPUT POCKET INFORMATION AND RETURN
C
   90 JSZ=3*NPCTPT
      JSIZE=JSZ+16
      KERR(4)=8
      KERR(6)=JSIZE
      KERR(8)=NERR
      NR=0
      N=(JSIZE+3)*2
      CALL AFORM(DSHARE(1),KERR,5)
      ITEMP(2)=NPCTPT
      CALL AFORM(DSHARE(6),DTEMP,1)
      CALL AFORM(DSHARE(7),ERRPTS,9)
      CALL AFORM(DSHARE(16),PCTPLN,4)
      CALL AFORM(DSHARE(20),PCTPTS,3*NPCPT)
      CALL EWRITE(EXFILE,NR,DSHARE,N,IR)
      GO TO 99
C
C        WRITE NECESSARY VARIABLES FOR IDENTIFICATION OF SURFACE
C
   95 NR=0
      KERR(4)=2
      KERR(6)=20
      KERR(8)=ICSCNT
      CALL AFORM(DSHARE(1),KERR,5)
      ITEMP(2)=IGO
      ITEMP(4)=ISTRUP
      CALL AFORM(DSHARE(6),DTEMP,2)
      CALL AFORM(DSHARE(8),DPMAX,1)
      ITEMP(2)=NMPNTS
      CALL AFORM(DSHARE(9),DTEMP,1)
      CALL AFORM(DSHARE(10),ELMAX,1)
      CALL AFORM(DSHARE(11),TI,3)
      CALL AFORM(DSHARE(14),TE,3)
      ITEMP(2)=IS
      CALL AFORM(DSHARE(17),DTEMP,1)
      CALL AFORM(DSHARE(18),TAL,3)
      CALL AFORM(DSHARE(21),TA,3)
      CALL EWRITE (EXFILE,NR,DSHARE,46,IR)
C
      CALL APT236
      CALL APT242
   99 IAERFG=0
  100 RETURN
      END
**** SOURCE FILE : ALTCMV.ORG   ***
*
      SUBROUTINE ALTCMV(JC,TN,S,IP,ID,VCS,DCS,EPS1CS,CMOVE,LRET)
C
C.... COMPUTE CMOVE BY ALTERNATIVE METHODS
C
C ARGUMENTS:
C           JC      FLAG INDICATING GAUSS FAILURE CONDITION USED
C                   TO SELECT ALTERNATIVE METHOD FOR COMPUTING CMOVE
C           TN      TOOL NORMAL DIRECTIONS
C           S       DIRECTED DISTANCES
C           IP      INDEX FOR PS
C           ID      INDEX FOR DS
C           VCS     CHECK SURFACE DIRECTION
C           SCS     CHECK SURFACE DIRECTED DISTANCE
C           EPS1CS  TOLERANCE EQ .1*TAU FOR CHECK SURFACE
C           CMOVE   MOVE REQUIRED TO BRING TOOL INTO CONTACT WITH
C                   3 SURFACES
C           LRET    RETURN FLAG = .TRUE. IF WITHIN TOLERANCE WHEN
C                                        PS PARALLEL TO CS
C                               = .FALSE. OTHERWISE
C
      INCLUDE 'ZNUMBR.INC'
C
      INTEGER JC,IP,ID,IVZ,J,I,II
      DOUBLE PRECISION TN,S,VCS,DCS,EPS1CS,CMOVE,C1,C2
      DIMENSION TN(3,5),S(5),VCS(3),CMOVE(3)
      LOGICAL LRET
C
      LRET=.FALSE.
      IVZ=SIGN(1,JC)
      J=ABS(JC)
C
      IF (J.EQ.1) THEN
C.... SELECT LARGER OF PS AND DS MOVES
        IF (ABS(S(IP)).GT.ABS(S(ID))) THEN
          I=IP
        ELSE
          I=ID
        ENDIF
C.... SET MOVE TO .9*LARGER S(I) + CHECK SURF MOVE
        C1=Z9EM1*S(I)
        C2=DCS
        CALL SETMOV(CMOVE,C1,TN(1,I),C2,VCS)
C
      ELSE IF (J.EQ.12) THEN
C
C.... PS PARALLEL TO DS
C
C.... SELECT LARGER OF PS AND DS MOVES
        IF (ABS(S(IP)).GT.ABS(S(ID))) THEN
          I=IP
          II=ID
        ELSE
          I=ID
          II=IP
        ENDIF
C
        IF ( (S(I)*S(II)*IVZ).GT.0) THEN
C.... SET MOVE TO .9*LARGER + .9*CHECK SURF MOVE
          C1=Z9EM1*S(I)
        ELSE
C.... SET MOVE TO .9*(MEAN S(I) IN DIRECTION OF LARGER)
C                           + .9*CHECK SURF MOVE
          C1=Z9EM1*SIGN(Z1,S(I))*Z5EM1*(S(I)+S(II))
        ENDIF
        C2=Z9EM1*DCS
        CALL SETMOV(CMOVE,C1,TN(1,I),C2,VCS)
C
      ELSE IF (J.EQ.13) THEN
C
C.... PS PARALLEL TO CS
C
C.... COMPUTE .9* MEAN (PS AND CS DISTANCES)
        C1=Z9EM1*Z5EM1*(S(IP)+IVZ*DCS)
        IF (ABS(C1).LT.(Z1EM2*EPS1CS)) THEN
C.... CONSIDER AS SUCCESSFUL MOVE
          LRET=.TRUE.
        ELSE
C.... SET MOVE TO .9* MEAN (PS AND CS DISTANCES) IN PS DIRECTION
C               + .9* DS MOVE
          C2=Z9EM1*S(II)
          CALL SETMOV(CMOVE,C1,TN(1,IP),C2,TN(1,ID))
        ENDIF
C
      ELSE
C
C.... DS PARALLEL TO CS
C
C.... SELECT LARGER OF DS AND CS MOVES
        IF (ABS(S(ID)).GT.ABS(DCS)) THEN
C.... DS LARGER
C.... SET MOVE TO .9*IN DIRECTION OF DS + .9*PS MOVE
          C1=Z9EM1
          C2=Z9EM1*S(IP)
          CALL SETMOV(CMOVE,C1,TN(1,ID),C2,TN(1,IP))
        ELSE
C.... CS LARGER
          IF ((S(IP)*S(ID)*IVZ).GT.0) THEN
C.... SET MOVE TO .9*PS MOVE + .9* CHECK SURF MOVE
            C1=Z9EM1*S(IP)
          ELSE
C.... SET MOVE TO .9* MEAN (PS AND DS DISTANCES) IN PS DIRECTION
C               + .9* CHECK SURF MOVE
            C1=Z9EM1*SIGN(Z1,S(I))*Z5EM1*(S(IP)+S(ID))
          ENDIF
          C2=Z9EM1*DCS
          CALL SETMOV(CMOVE,C1,TN(1,IP),C2,VCS)
        ENDIF
      ENDIF
C
      END
      SUBROUTINE SETMOV(CM,A,V1,B,V2)
C
C.... CALCULATE VECTOR MOVE = A*V1 + B*V2
C
      INTEGER I
      DOUBLE PRECISION CM,A,V1,B,V2
      DIMENSION CM(3),V1(3),V2(3)
C
      DO 10 I=1,3
        CM(I)=A*V1(I)+B*V2(I)
   10 CONTINUE
C
      END
**** SOURCE FILE : M0002918.W05   ***
*
C.....FORTRAN SUBROUTINE  ....AMIND          8/68                 PH,HG
      SUBROUTINE AMIND
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
C
C...  21. ADDCOM BLOCK
      COMMON/ADDCOM/ ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),  (ADDCOM( 2),CLNGTH),
     1            (ADDCOM(23),IBTFLG),  (ADDCOM(24),JLIN),
     2            (ADDCOM(25),KDYNFL)
C
      INCLUDE 'BLANKCOM.INC'
C
      DIMENSION TPSAV(3),TNSAV(3),SPSAV(3),SNSAV(3),U1SAV(3)
      COMMON/MODESS/MODESS,MSSCHK,MSSARL
      DIMENSION OLDU1(3),TE1(3)
C
      INCLUDE 'CHEKFL.INC'
      INCLUDE 'CGOUG.INC'
      CHARACTER*70 MSG
      INCLUDE 'CSTART.INC'
C
      DATA ONE,ZERO,ZLIT1,ZLIT2/1.0D0,0.0D0,.99995D0,.995D0/
      DATA ZLIT5/0.99D0/
      DATA Z2,Z9EM1/2.0D0,0.9D0/
C
C------------AMIND - FIND MINIMUM DISTANCE FROM CUTTER TO SURFACE.
C             /-IC IS INDEX TO THE CANON FORM OF IS SURFACE
      IC=ICANON(IS)
C             /-SPECIAL LOGIC FOR SSURF ONLY.  A FAST LOGIC IS
C             /-USED FOR POINT AND BALL CUTTERS AT TIMES ON SSURFS
C             /-MSSCHK SET TO 1 FOR SPECIAL LOGIC, 0 FOR NORMAL
      FLIPMX = ZERO
      FLIPAB = ZERO
      SSAV=1.0D5
      SMODS=1.0D5
      MODESS=0
      MSSCHK=0
      ISTART=0
      UVDIST=ZERO
      DIST=ZERO
      IF(MSSARL.NE.1) GO TO 1101
      IF(ISFIDN(IS).NE.29) GO TO 1101
C             /-JTLFLG IS 1 IF 8 TH CUTTER SEGMENT RQD, 0 OTHERWISE.
      IF(JTLFLG(IS).EQ.1) GO TO 1101
      W1=CUTDAT(2)-CUTDAT(1)
      IF(DABS(W1).GT.0.0001D0) GO TO 1101
      MSSCHK=1
 1101 CONTINUE
      ICBOT=IC-1
C             /-JMIN SWITCH=1 FOR ERR IN AMIND, =0 OTHERWISE
C             /-IAMDCT IS COUNT OF NUMBER OF ITERATIONS WITHIN AMIND
      JMIN=0
      IAMDCT=0
C
C             /-SAVE TN ONLY FOR CHECK SURFACES
      IF(IS.LT.ICS) GO TO 1102
      DO 1105 I=1,3
      TNL(I,IS)=TN(I,IS)
 1105 CONTINUE
 1102 IF(KDYNFL.NE.0) CALL APT238(3)
C              /-DYNDMP(103) --------.
C             /-REPLACE TOOL BY POINT TOOL AT TP(IT) IF TANGENT
C             /-CS IS BEING REFERENCED.
C             /-IOP=1 FOR SMALLEST POSITIVE DIRECTED DISTANCE
C             /-IOP=0 FOR SMALLEST ABSOLUTE DIRECTED DISTANCE
      IOP(IS)=0
C             /-ITLON=0 FOR TOOL ON THIS SURF, =1 OTHERWISE
      ITLON1=ITLON(IS)
      DO 1103 I=1,3
 1103 TE1(I)=TE(I)
C             /-ITLON -2 MEANS FIND DIST FROM DS CONTACT PT TO SURF
C             /-ITLON=-3 MEANS FIND DIST FROM PS CONTACT PT TO SURF
C             /-THESE CASES ARE FORCED BY CHANGING TE TO TP AND TOOL ON.
      IF(ITLON(IS).LT.2) GO TO 1104
      IF(ITLON(IS).EQ.2) K=IDS
      IF(ITLON(IS).EQ.3) K=IPS
      ITLON(IS)=0
C             /-TE IS THE CURRENT TOOL END AND VT IS THE VECTOR FROM THE
C             /-TO THE CONTACT POINT ON THE CUTTER WITH THE SURFACE.
      DO 1107 I=1,3
      TE(I)=TP(I,K)-TH(K)*TN(I,K)
      VT(I,IS)=ZERO
 1107 CONTINUE
C
C             /-FOR INITIAL ENTRY FOR A GIVEN SURFACE,JENT=1. THEN
C             /-FOLLOW INITIAL ENTRY ROUTES. START WITH TP = TM.
 1104 CONTINUE
C
C     SPECIAL HANDLING WHEN GFLG=1
C
      IF (GFLG.GT.ZERO) THEN
        CFAKT=ONE
        GFLG=-ONE
77008   CONTINUE
        DO 7008 I=1,3
          TP(I,IS)=TE(I)+CFAKT*CUTDAT(1)*TI(I)
C.... SAVE TN
          TNSAV(I)=TN(I,IS)
 7008   CONTINUE
        ITSEG(IS)=IBEGIN
        MODESS=11
        CALL AJUNDD
        MODESS=0
C
C.... TN,SN TROUBLE ? (ITNCHG=1)
C
        IF (ITNCHG.EQ.0) THEN
          GOTO 252
        ELSE
          DO 77011 I=1,3
            TN(I,IS)=TNSAV(I)
77011     CONTINUE
          IF (CFAKT.LT.0.3D0) THEN
            GOTO 252
          ELSE
            CFAKT=CFAKT-0.1D0
            GOTO 77008
          ENDIF
        ENDIF
      ENDIF
C-----------------------------------------------
C             /-JENT =1 FOR FIRST ENTRY TO AMIND, 0 OTHERWISE.
      IF(JENT(IS).EQ.0) GO TO 2012
C             /-INITIAL ENTRY - CONSTRUCT FIRST TP IN MIDDLE OF CUTTER
      W1=CUTDAT(7)/2.0
      IF(MSSCHK.EQ.1) W1=CUTDAT(2)
      DO 1108 I=1,3
      TP(I,IS)=TM(I)
 1108 CONTINUE
C
      BLONGD=2.0D0*W1
      IF (BLONGD.LT.15.0D0) BLONGD=1.D5
C
C             /-Z ADJUSTS SURFACE NORMAL TO POINT TO CUTTER SIDE
C             /-RC IS THE RADIUS OF CURVATURE AT THE SURFACE POINT.
C             /-RC1 INITIALLY 4500 INCHES(ENGLISH UNITS)
      RC(IS)=RC1
      Z(IS)=ONE
C
C             /-IAFL = 0 IF PS PLANE PERPTO TA,OR DS,CS PLANE LL TA.
C             /-IAFL = 1 IF SURF LINE ELEMENT LL TA
C             /-IAFL = -1 OTHERWISE
C             /-FOLLOW SPECIAL ANALYTIC ROUTE FOR IAFL = 0
      IF(IAFL(IS).EQ.0) GO TO 202
      IF(IAFL(IS).GT.0) GO TO 1109
C             /-SINCE IAFL IS LT 0, SET TOOL SEG TO FIRST SEG.
      ITSEG(IS)=IBEGIN
      GO TO  251
 1109 CONTINUE
C             /-IAFL(IS) IS GT 0, SO SET TP TO TOP OF TOOL
C             /-TOOLHT ARE TOOL TOP COORDS(HT*TA)- RELATED TO SURFACE
      DO 1111 I=1,3
 1111 TP(I,IS)=TE(I)+TOOLHT(I,IS)
C
  251 CONTINUE
C             /-INITIAL ENTRY ROUTE,NORMAL CASE. PROBLEM IS TO SET
C             /-SIGN OF SN(IS) AND HENCE Z(IS) CORRECTLY.
C             /-BRANCH TO SURFACE DISTANCE CALCULATION FROM HERE.
C             /-USE TP,TN TO FIND SP,SN,S SO THAT TP+S*TN=SP
      MODESS=11
      CALL AJUNDD
      MODESS=0
C
  252 CONTINUE
      IAMDCT=1
C***       BRANCH TO 2999 ON FATAL ERROR
       IF(IAERR.NE.0) GO TO 2999
C             /-JTN FLAG IS 1 FOR TN CONTROL OF SURFACE(LIKE CS)
C             /-JTN FLAG IS SET TO 0 FOR SN CONTROL(LIKE PS,DS)
      IF(JTN(IS).EQ.0) GO TO 1110
C             /-TN CONTROL CASE, SET TN TO CURRENT SURF NORMAL , GO ON
      DO 1115 I=1,3
      TN(I,IS)=SN(I,IS)
 1115 CONTINUE
      GO TO 2009
C
 1110 CONTINUE
C             /-SN CONTROL, SET Z SO Z*SN POINTS TO CUTTER SIDE OF SURF
      CALL DOTF(Z(IS),TN(1,IS),SN(1,IS))
      IF(DABS(Z(IS)).GT.0.000001) GO TO 1112
C             /-INNER PRODUCT SMALL, TN AND SN PERPENDICULAR. TRY NEW TN
      DO 1113 I=1,3
      TN(I,IS)=SN(I,IS)+TN(I,IS)
 1113 CONTINUE
      CALL VNORM(TN(1,IS),TN(1,IS))
C             /-RESORE Z
      Z(IS)=ONE
C             /-CALL SURFACE DISTANCE CALC AGAIN
      GO TO  251
C
 1112 CONTINUE
C             /-SET Z SO THAT Z*SN AND TP-SP ARE IN SAME DIRECTION
      IF(S(IS).NE.ZERO) Z(IS)=S(IS)*Z(IS)
      Z(IS)=-DSIGN(ONE,PAST(IS)*Z(IS))
C             /-PAST IS -1 IF ISFTYP=2 (PAST CASE ), 1 OTHERWISE
C             /-ADJUST SN BY Z AND SET TN TO -SN
      DO 1114 I=1,3
        SN(I,IS)=Z(IS)*SN(I,IS)
        TN(I,IS)=-SN(I,IS)
 1114   CONTINUE
      GO TO 2009
C
C -------------------------------------------------------
C             /-NORMAL ENTRY ROUTE. SET FIRST TRIAL TP USING VT.
C             /-SWITCH TO SPECIAL ANALYTIC IAFL = 0 ROUTES IF NEEDED
C             /-ALSO USE SPECIAL ROUTE IF CYLINDER LL TA.
 2012 CONTINUE
C             /-PLACE TOOL POINT ON THICK ENVELOPE IN DIRECTION OF TN
      DO 1122 I=1,3
      TP(I,IS)=VT(I,IS)+TH(IS)*TN(I,IS)+TE(I)
 1122 CONTINUE
C             /-IAFL -1, GENERAL SURF PATH
      IF(IAFL(IS).LT.0) GO TO 2009
C             /-IAFL =0, PLANE SURF PERPEN, OR PLANE DRIVE SURF PARLLEL
      IF(IAFL(IS).EQ.0) GO TO 212
C             /-IAFL +1, SURF ELEMENT PARALLEL TO TA
C             /-IF SURFACE TYPE LT 5,(IE PLANE,LINE,CYLIN) GO TO 4000
      IF(ISFIDN(IS).GE.5) GO TO 2009
C
C-------------------------------------------------------
C             /-SPECIAL U1COMP ROUTE FOR TA LL CYLINDER AXIS.
C             /-USEFUL IF CUTTER RADIUS NEARLY CYLINDER RADIUS
C             /-BRANCH TO SURFACE DISTANCE CALCULATION FROM HERE.
C
      MODESS=12
      CALL AJUNDD
      MODESS=0
C
      CALL CCURV(IS,SP(1,IS),SPL(1,IS),SN(1,IS))
      DO 1142 I=1,3
      TEMP(I+3)=CC(I,IS)
 1142 CC(I,IS)=CANON(ICBOT+I)
      CALL U1COMP
      DO 1143 I=1,3
 1143 CC(I,IS)=TEMP(I+3)
      GO TO 2038
C
C-------------------------* CALL SURFACE FOR DIRECTED DISTANCE *--------
C             /-OTHERWISE, GO THE GENERAL SURFACE PATH
C             /-2ND PHASE OF INITIAL ENTRY TO AMIND(JENT=1)
C             /-WITH CURRENT TP,TN CALL SURFACE ROUTINE FOR SP,SPL,SN
C             /-THEN USE CCURV TO FIND RC,CC.  USE CENTER OF CURVATURE C
C             /-TO FIND THE CORRECT SIDE OF THE CUTTER.
C             /-BRANCH TO SURFACE DISTANCE CALCULATION FROM HERE.
 2009 CONTINUE
      IF(MSSCHK.EQ.1) GO TO 2038
      MODESS=13
      CALL AJUNDD
      MODESS=0
C
C***        TERMINATE FOR FATAL ERROR
      IF(IAERR.NE.0) GO TO 2999
C             /-FIND ISIGCR, RC AND CC.  CENTER OF CURV= SP-RC*SN.
      CALL CCURV(IS,SP(1,IS),SPL(1,IS),SN(1,IS))
C             /-ISIGCR -1 FOR PLANE, 0 NORMAL CASE, 1 IF PREV RC USED
      IF(ISIGCR(IS).GE.0) GO TO 1116
C             /-SPECIAL CALC OF CC IN PLANE CASE
      DO 1117 I=1,3
        CC(I,IS)=TP(I,IS)-RC(IS)*SN(I,IS)
 1117 CONTINUE
 1116 CONTINUE
C             /-IF TOOL IS ON THIS SURF, SKIP U1(TOOL SIDE) CALCULATION
      IF(ITLON(IS).EQ.0) GO TO 338
C             /-DETERMINE THE SIDE OF THE CUTTER TO CONTACT SURFACE
      CALL U1COMP
C
      IF(IAERR.NE.0) GO TO 2999
      IF(JENT(IS).LE.0) GO TO 1118
C             /-FURTHER ADJUSTMENT NEEDED FOR FIRST AMIND ENTRY
      IF(JTN(IS).NE.0) GO TO 1118
C             /-SURFACE NORMAL CONTROL, JTN=0
      IF(RC(IS).GE.ZERO) GO TO 1118
C             /-RC NEGATIVE  ADJUST U1 IF CC-TE.U1 IS POSITIVE
      DO 1119 I=1,3
 1119 TEMP(I)=CC(I,IS)-TE(I)
      CALL DOTF(TEM,U1(1,IS),TEMP)
      IF(TEM(1).LE.ZERO) GO TO 1118
C             /-SET U1 TO OTHER SIDE OF CUTTER
      DO 1120 I=1,3
      U1(I,IS)=-U1(I,IS)
 1120 CONTINUE
 1118 CONTINUE
      DO 1121 I=1,3
 1121 OLDU1(I)=U1(I,IS)
C
C -------------------------------------------------------
  338 CONTINUE
      IF(KDYNFL.NE.0) CALL APT238(4)
C              /-DYNDMP(104) --------.
C             /-***** START ITERATIVE LOOP. CALL TLNORM FOR TP,TN **
C             /-***** CALL AJUNDD FOR SP,SN,S. COMPUTE FLIPCK=TN.SN
 2038 CONTINUE
C             /-MAP IS A RESTART FLAG, =0 REVERSE U1 AND TRY AGAIN
C             /-MAP=1 MEANS RESTART EFFECTIVE, ERROR IS FATAL NOW.
      MAP=0
C
C             /-TLNORM CALL GETS LINEUP FROM SURF TO TOOL IN U1 DIREC.
 2712 CONTINUE
C
C.... VW MODIFICATION FOR SITUATION WHEN DISTANCE BETWEEN TOOL
C     AND SURFACE IS LARGE - ONLY APPLIES TO DS AND PS
C
      IF (IS.LT.ICS) THEN
        IF (JENT(IS).NE.0) THEN
          IF ((UVDIST.LT.0.4D0).OR.(DIST.LT.BLONGD)) THEN
            ISTART=0
          ELSE
            ISTART=1
            DO 27121 I=1,3
              TN(I,IS)=SPBOND(I)-TP(I,IS)
              SP(I,IS)=SPBOND(I)
27121       CONTINUE
            CALL VNORM(TN(1,IS),TN(1,IS))
            DO 27123 I=1,3
              SN(I,IS)=-TN(I,IS)
27123       CONTINUE
            IF (S(IS).GT.BLONGD) S(IS)=BLONGD
            GOTO 711
          ENDIF
        ENDIF
      ENDIF
C             /-GENERATE TP ON TOOL SURFACE CLOSE TO CC.
      CALL TLNORM(U1(1,IS))
C-------------------------* TLNORM CALLS SURF FOR DIRECTED DIST *---
C             /-PLACE TP OUT ON THICK ENVELOPE OFF TOOL SURF
      DO 1163 I=1,3
        TP(I,IS)=TP(I,IS)+TH(IS)*TN(I,IS)
 1163 CONTINUE
C***        TERMINATE ON FATAL ERROR
      IF(IAERR.NE.0) GO TO 2999
      IF(KDYNFL.NE.0) CALL APT238(5)
C              /-DYNDMP(105) --------.
C
C             /-BRANCH TO SURFACE DISTANCE CALCULATION FROM HERE.
      MODESS=14
      IF(MSSCHK.EQ.0) CALL AJUNDD
      MODESS=0
C
C***        TERMINATE ON FATAL ERROR
      IF(IAERR.NE.0) GO TO 2999
      IF (ISTART.EQ.1) GOTO 711
C             /-CHECK LINEUP BETWEEN TN AND SN.
      CALL DOTF(FLIPCK,TN(1,IS),SN(1,IS))
C             /-SPECIAL ROUTE. IF FLIPCK WRONG SIGN AFTER 10
C             /-ITERATIONS,REVERSE SIGN OF U1
      IF(IAMDCT.LE.10) GO TO 1123
      TEM(7)=JTN(IS)-0.5
      IF(TEM(7)*FLIPCK.LT.ZERO.AND.MAP.EQ.0) GO TO 710
 1123 IF(KDYNFL.NE.0) CALL APT238(6)
C              /-DYNDMP(106) --------.
C             /-FLIPCK TEST. IF TN.SN WELL ALIGNED EXIT FROM LOOP
C             /-FLIPCK SHOULD BE VERY NEAR 1 FOR CONVERGENCE
      IF(DABS(FLIPCK).GT.ZLIT1) GO TO 2041
C
C --- WEAKER CONVERGENCE-TEST
C
      IF(DABS(FLIPCK).LE.ZLIT2.OR.DABS(FLIPCK).LE.FLIPAB) GO TO 29
      IF ((MDIC.LE.0).AND.(((JTN(IS)-.5)*FLIPCK).LT.ZERO)) GO TO 29
      IF (IPL(IS).LE.0) THEN
        TEMP(1)=TAU(IS)-EPS8(IS)
        IF (RC(IS).GT.ZERO.AND.JTN(IS).NE.0) TEMP(1)=EPS8(IS)
        IF (RC(IS).LE.ZERO.AND.JTN(IS).EQ.0) TEMP(1)=EPS8(IS)
        SMOD=S(IS)-TAU2(IS)-TEMP(1)
      ENDIF
      IF ((FLIPAB.GT.ZLIT2).AND.(ABS(SMOD).GT.ABS(SMODS))) GO TO 29
C
C --- STORE DATA, IF WEAKER CONVERGENCE-TEST IS OK
C
      FLIPMX = FLIPCK
      FLIPAB = DABS(FLIPCK)
      RCSAV = RC(IS)
      SSAV = S(IS)
      SMODS=SMOD
      ITSAV = ITSEG(IS)
      DO 2900 I=1,3
      TPSAV(I) = TP(I,IS)
      TNSAV(I) = TN(I,IS)
      SPSAV(I) = SP(I,IS)
      SNSAV(I) = SN(I,IS)
      U1SAV(I) = U1(I,IS)
 2900 CONTINUE
C             /-INCREMENT AMIND COUNT AND TRY AGAIN TO IMPROVE LINEUP
C
   29 CONTINUE
      IAMDCT=IAMDCT+1
      IF(IAMDCT.LT.25) GO TO 32
      IF(IAMDCT.GT.25) GO TO 1124
C             /-IAMDCT IS 25, ONE LAST TRY WITH WEAKER CONVERGENCE TEST
      IF(FLIPAB.EQ.ZERO) GO TO 1124
C
      IF (FLIPAB.GT.ZLIT5) THEN
        CONTINUE
      ELSE IF (FLIPAB.GT.ZLIT2) THEN
C... PRINT WARNING
        WRITE(MSG,7100) FLIPAB
 7100 FORMAT('*** WARNING *** FLIPAB = ',D12.5,
     +       ' AT 3RD (WEAKER) CONVERGENCE TEST IN AMIND')
        CALL OUTMSG(MSG)
      ELSE
        GOTO 1124
      ENDIF
C
C --- RESTORE DATA OF WEAKER CONVERGENCE-TEST
C
      RC(IS) = RCSAV
      S(IS) = SSAV
      ITSEG(IS) = ITSAV
      DO 2910 I=1,3
      TP(I,IS) = TPSAV(I)
      TN(I,IS) = TNSAV(I)
      SP(I,IS) = SPSAV(I)
      SN(I,IS) = SNSAV(I)
      U1(I,IS) = U1SAV(I)
 2910 CONTINUE
      GO TO 2041
 1124 CONTINUE
C             /-JMINR IS SET TO 1 IF NO AERR CALL SHOULD BE MADE, 0 OTHE
C***        AMIND ITERATIONS FAILED TO CONVERGE AFTER ALL TRIES.
      IF(JMINR.NE.1) CALL AERR(26002,'AMIND   ')
C             /-JMIN SET TO 1 FOR AMIND FAILURE, 0 OTHERWISE
      JMIN=1
      GO TO 2999
C -------------------------------------------------------
C             /-FLIPCK TEST FAILS. CALL CCURV, U1COMP, AND NEW
C             /-ITERATION. FUDGE ROUTE IF TA LL SURF LINE ELEMENT
C             /-AND IAFL NOT EQUAL TO 1
   32 CONTINUE
      IF(IAMDCT.LT.10) GO TO 1126
C             /-RC1 USED FOR PROPER UNITS/ IMPLEMENTATION
      IF(DABS(RC(IS)).NE.RC1/100.D0) GO TO 1126
      CALL DOTF(W1,TA,TN(1,IS))
      CALL DOTF(TEM(7),TA,TNL(1,IS))
      IF(DSIGN(ONE,W1).NE.DSIGN(ONE,TEM(7))) GO TO 1126
      TEM(7)=DSIGN((100000.D0*RC1/4500.D0),RC(IS))
      DO 1127 I=1,3
        CC(I,IS)=SP(I,IS)-TEM(7)*SN(I,IS)
 1127 CONTINUE
C             /-RETURN TO TLNORM WITH NEW CC AIMING POINT.
      GO TO 2038
C
 1126 CONTINUE
      CALL CCURV(IS,SP(1,IS),SPL(1,IS),SN(1,IS))
      IF(ITLON(IS).EQ.0) GO TO 2038
      CALL U1COMP
C***        TERMINATE ON FATAL ERROR
      IF(IAERR.NE.0) GO TO 2999
C             /-JU1 LOGIC. USE IF U1.OLDU1 .LT. ZERO
C             /-JU1 SET TO 1 MEANS U1 SHOULD BE CHKED WITH OLDU1
      IF(JU1(IS).NE.0) GO TO 2038
      CALL DOTF(TEM,OLDU1,U1(1,IS))
      IF(TEM(1).GE.ZERO) GO TO 2038
C             /-U1 AND OLDU1 CHANGED CUTTER SIDES
      CALL DOTF(TEM,SN(1,IS),SNL(1,IS))
      IF(TEM(1).GE.Z9EM1) GO TO 2038
      IF (TEM(1).EQ.ZERO) GOTO 2038
C             /-SURFACE NORMALS CHANGED SIGNIFICANTLY
      IF (ICHEKF.EQ.1) GOTO 2038
      DO 1128 I=1,3
      OLDU1(I)=-U1(I,IS)
      U1(I,IS)=-U1(I,IS)
      TN(I,IS)=-TN(I,IS)
      TP(I,IS)=TP(I,IS)+Z2*TH(IS)*TN(I,IS)
 1128 CONTINUE
C             /-IOP SET TO 1 TO FIND SMALLEST POSITIVE DIRECTED DISTANCE
      IOP(IS)=1
C             /-BRANCH TO SURFACE DISTANCE CALCULATION FROM HERE.
      MODESS=15
      IF(MSSCHK.EQ.0) CALL AJUNDD
      MODESS=0
C
C             /-RESET IOP TO FIND SMALLEST ABSOLUTE DISTANCE
      IOP(IS)=0
      DO 1129 I=IS,ISLIM
      TN(I,IS)=-TN(I,IS)
 1129 CONTINUE
      S(IS)=-S(IS)
      CALL CCURV(IS,SP(1,IS),SPL(1,IS),SN(1,IS))
      GO TO 2038
C
C             /-IF RADAR USED,DO ANOTHER ITERATION (TE MAY BE OUT)
 2041 CONTINUE
C             /-MDIC, COUNT OF NUM OF RADAR TRIALS
      IF(MDIC.LE.0) GO TO 1130
C             /-IF CUTTER NOT ON AND NOT A POINT, GO TO 29
      IF(ITLON(IS)*IPT1.NE.0) GO TO 29
C             /-TOOL-ON OR POINT TOOL CASE
C             /-EPS1 IS .1*TAU(INITIALLY .00005)
      W1=ZERO
      DO 1133 I=1,3
 1133 W1=W1+DABS(TP(I,IS)-TE(I))
      IF(W1.GT.EPS1(IS)) GO TO 29
C             /-IFL1PCK WRONG SIGN, REVERSE U1. SET MAP=1.
 1130 CONTINUE
      TEM(7)=JTN(IS)-.5
      IF(TEM(7)*FLIPCK.GE.ZERO) GO TO 711
C***          ERROR IN AMIND - SET JMIN AND RETURN.
      IF(MAP.GT.0) JMIN=1
      IF(MAP.GT.0) GO TO 2999
  710 MAP=1
      DO 1131 I=1,3
        U1(I,IS)=-U1(I,IS)
 1131 CONTINUE
C             /-GO BACK AND FIND TOOL TO SURF RELATIONSHIP
      GO TO 2712
C
C             /-MINIMUM DISTANCE S(IS)O.K.. ADJUST TO CORRECT PART
C             /-TOLERANCE BAND
  711 CONTINUE
      JMIN=0
C             /-IPL=1 FOR PLANE, 0 OTHERWISE
      IF(IPL(IS).GT.0) GO TO 1132
C             /-TAU = TOTAL TOLERANCE TAU1-TAU2
C             /-EPS8 =EPS1 OR 2*EPS1 WHERE EPS1=.1*TAU
C             /-PLACE CUTTER WITHIN 10PC OF TOLERANCE BAND OF LEAST CURV
      TEMP(1)=TAU(IS)-EPS8(IS)
      IF(RC(IS).GT.ZERO.AND.JTN(IS).NE.0) TEMP(1)=EPS8(IS)
      IF(RC(IS).LE.ZERO.AND.JTN(IS).EQ.0) TEMP(1)=EPS8(IS)
C             /-TAU2 IS NEGATIVE AND IS INNER TOLERANCE(AWAY FROM CUTTER
      S(IS)=S(IS)-TAU2(IS)-TEMP(1)
C
C             /-UPDATE SPK,TPK,SNK ETC. JENT = 0. COMPUTE VT
C             /-********* EXIT  ROUTE **********.
 1132 CONTINUE
      IF(JENT(IS).EQ.0) GO TO 2046
C
C             /-FOR FIRST ENTRY SAVE LAST GOOD VALUES
 2044 CONTINUE
      DO 1134 I=1,3
      TPK(I,IS)=TP(I,IS)
      SPK(I,IS)=SP(I,IS)
      U1K(I,IS)=U1(I,IS)
      SNK(I,IS)=SN(I,IS)
 1134 CONTINUE
      IF (ISTART.EQ.0) JENT(IS)=0
C             /-SET ENTRY FLAG TO ZERO, INITIAL ENTRY FINISHED
      JENT(IS)=0
C             /-SAVE INDEX TO PERTINENT TOOL SEGMENT
      ITSEGK(IS) = ITSEG(IS)
C
 2046 CONTINUE
      MSSCHK=0
C             /-SAVE DISPLACEMENT VECTOR FROM TE TO CONTACT PT
      DO 1135 I=1,3
        VT(I,IS)=TP(I,IS)-TH(IS)*TN(I,IS)-TE(I)
 1135 CONTINUE
      IF(KDYNFL.NE.0) CALL APT238(7)
C              /-DYNDMP(107) --------.
C***       ERROR EXIT PATH AND END OF NORMAL EXIT
 2999 CONTINUE
      ITLON(IS)=ITLON1
      DO 1136 I=1,3
 1136 TE(I)=TE1(I)
      RETURN
C
C
C     -------------------------------------------------*
C             /-IAFL(IS)=0 SPECIAL ANALYTIC ROUTE. INITIAL ENTRY.
C             /-SURF IS PLANE PERPEN TO TA OR PLANE PARL TO DS,CS
C             /-CANON(IC+0,+1,+2)=I,J,K NORMAL, AND CN(IC+3)=ORIGIN DIST
  202 CONTINUE
      DO 1150 I=1,3
 1150 TN(I,IS)=CANON(ICBOT+I)
      AJENT=JENT(IS)
      CALL DOTF(TEM,TP(1,IS),CANON(IC))
      SAVE(IS)=ONE
      IF(JENT(IS).EQ.0) GO TO 204
C             /-CHANGE SIGN OF PLANE NORMAL IF TP IS ON OPPOSITE SIDE
      IF(PAST(IS)*(CANON(IC+3)-TEM(1)).GE.ZERO) GO TO 204
      SAVE(IS)=-ONE
      DO 1154 I=1,3
        TN(I,IS)=-TN(I,IS)
 1154 CONTINUE
  204 CONTINUE
      IF(ITLON(IS).NE.0) GO TO 327
C             /-USE TE FOR TP IF TOOL IS ON SURF
      DO 1151 I=1,3
 1151 TP(I,IS)=TE(I)
      GO TO 305
  327 CONTINUE
C             /-COMPUTE A NEW TOOL POINT
      IF(IS.NE.IPS) GO TO 303
      W1=CUTDAT(7)/2.0
      DO 1152 I=1,3
        TP(I,IS)=TP(I,IS)+W1*TN(I,IS)
 1152 CONTINUE
      GO TO 305
  303 CONTINUE
C             /-SET TP AT TOP PERIPHERY OF TOOL FOR DS,CS
      DO 1153 I=1,3
        TP(I,IS)=TE(I)+TOOLHT(I,IS)+TOOLWD(IS)*TN(I,IS)
 1153 CONTINUE
C             /-FIND SIGNED NORMAL DISTANCE OF TP FROM PLANE USING SAVE.
  305 CALL DOTF(TEM,TP(1,IS),CANON(IC))
      S(IS)=SAVE(IS)*(CANON(IC+3)-TEM(1))
C             /-COMPUTE SN,S AND MAYBE U1
      IF(JTN(IS).EQ.0) GO TO 208
      Z(IS)=SAVE(IS)
      DO 1155 I=1,3
        SN(I,IS)=TN(I,IS)
        U1(I,IS)=TN(I,IS)
 1155 CONTINUE
      GO TO 209
  208 Z(IS)=-SAVE(IS)
      DO 1156 I=1,3
        SN(I,IS)=-TN(I,IS)
 1156 CONTINUE
  209 RC(IS)=RC1
      DO 1157 I=1,3
        SNL(I,IS)=SN(I,IS)
 1157 CONTINUE
      ISIGCR(IS)=-1
C             /-COMPENSATE DISTANCE S BY THICK PARAMETER
      S(IS)=S(IS)-TH(IS)
C             /-TOOL POINT IS PLACED OUT ON THICK ENVELOPE ARND TOOL
      DO 1158 I=1,3
        TP(I,IS)=TP(I,IS)+TH(IS)*TN(I,IS)
 1158 CONTINUE
C
  213 CONTINUE
      DO 1161 I=1,3
        SP(I,IS)=TP(I,IS)+S(IS)*TN(I,IS)
        CC(I,IS)=SP(I,IS)-RC(IS)*SN(I,IS)
 1161 CONTINUE
C             /-RETURN WITH MINOR HOUSEKEEPING
      IF(JENT(IS).EQ.0) GO TO 2046
C             /-SAVE SPL FOR THE INTITIAL ENTRY ONLY
      DO 1159 I=1,3
        SPL(I,IS)=SP(I,IS)
 1159 CONTINUE
C             /-RETURN WITH HOUSEKEEPING - SAVE LAST VALUES(SPK,TPK,..)
      GO TO 2044
C
C-------------------------------------------------------
C             /-IAFL(IS)=0 SPECIAL ANALYTIC ROUTE. NORMAL ENTRY.
  212 CONTINUE
      IF(JTN(IS).EQ.0) GO TO 307
C             /-TOOL NORMAL CONTROL, GENERATE TP,TN.
      CALL DOTF(TEM,TN(1,IS),U1(1,IS))
      IF(TEM(1).LT.ZERO) GO TO 309
      DO 310 I=1,3
        TN(I,IS)=U1(I,IS)
        TP(I,IS)=TE(I)+VT(I,IS)+TH(IS)*TN(I,IS)
  310 CONTINUE
      GO TO 307
C
  309 CONTINUE
      Z(IS)=-Z(IS)
      SAVE(IS)=-SAVE(IS)
      DO 311 I=1,3
      TN(I,IS)=-U1(I,IS)
      SNL(I,IS)=SN(I,IS)
      SN(I,IS)=-SN(I,IS)
      U1(I,IS)=TN(I,IS)
      TP(I,IS)=TE(I)+TOOLHT(I,IS)+(TH(IS)+TOOLWD(IS))*TN(I,IS)
  311 CONTINUE
C
  307 CONTINUE
      CALL DOTF(TEM,TP(1,IS),CANON(IC))
      S(IS)=SAVE(IS)*(CANON(IC+3)-TEM(1))
      DO 312 I=1,3
        SPL(I,IS)=SP(I,IS)
  312 CONTINUE
C             /-FINISH UP WITH SP,CC AND RETURN WITH HOUSEKEEPING
      GO TO 213
C
      END
**** SOURCE FILE : M0002819.V04   ***
*
C.....FORTRAN SUBROUTINE  ....APT200         8/68                    PH
C.....FORTRAN SUBROUTINE             APT200...              3/1/68   GK
      SUBROUTINE APT200 (HMOD,ADRESS,XNTSCT)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DIMENSION ADRESS(*)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C     25. COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM/ IAERFG,NPCTPT,PCTPTS,PCTPLN,ERRPTS
      DIMENSION PCTPTS(3,20),PCTPLN(4),ERRPTS(3,3)
C
C
C...  ESTABLISHES CHECK SURFACE PARAMETERS FOR EACH CHECK SURFACE
C...  ADVANCE THE CHECK SURFACE COUNTER
      IF(IAERR.EQ.1) GO TO 1000
      ICSCNT=ICSCNT+K1
      IF(NUMSFS.GE.(ICSCNT+K2)) GO TO 1
      IAERFG=1
      CALL AERR(20001,'APT200  ')
      GO TO 1000
    1 IS=ICS+(ICSCNT-K1)*LSV1
      CALL APT234(HMOD,ADRESS)
      IF(IAERR)5,5,1000
C...  SET IFL4=1 IF PSTAN,0 IF TANTO
    5 IF(ISFTYP(IS)-K4)30,10,20
   10 IFL4(IS)=0
      GO TO 30
   20 IFL4(IS)=K1
C...  SET CS INTERSECTION COUNTER
   30 IFAR(IS) = XNTSCT
      JCS=.TRUE.
 1000 CONTINUE
      RETURN
       END
**** SOURCE FILE : M0000852.V02   ***
*
C.....FORTRAN SUBROUTINE             APT232...              4/1/68   GK
      SUBROUTINE APT232(NUMBER,TOLRNS,TAUS,ONE)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      DATA ZLIT1/.02D0/
C
C
C
      DIMENSION TOLRNS(4),TAUS(1)
      IS=IPS
      DO 50 I=1,NUMSFS
   10 TAUS(IS)=ONE*TOLRNS(I)
      TAU(IS)=TAU1(IS)-TAU2(IS)
      EPS1(IS)=Z1EM1*TAU(IS)
      EPS2(IS)=Z1-EPS1(IS)
      EPS3(IS)=Z2*EPS1(IS)
      EPS4(IS)=Z2*TAU(IS)
      EPS6(IS) = ZLIT1*EPS1(IS)
      EPS8(IS)=EPS1(IS)
      IF(IS-ICS)20,30,30
   20 IS=IS+LSV
      IF(NUMBER-I)10,10,50
   30 IF(I-NUMBER)40,60,60
   40 IS=IS+LSV1
   50 CONTINUE
   60 JENT(IPS) = K1
      JENT(IDS) = K1
C
C
      RETURN
       END
**** SOURCE FILE : M0000853.V08   ***
*
C.....FORTRAN SUBROUTINE  ....APT233         8/68                 HG,AR
C.....FORTRAN SUBROUTINE             APT233...              3/1/68   GK
      SUBROUTINE APT233
      IMPLICIT DOUBLE PRECISION (A-H), DOUBLE PRECISION (O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      DIMENSION IFERM(2)
      EQUIVALENCE (IFERM,FERMOD)
      INTEGER BCDF
      LOGICAL FIRST
      SAVE FIRST,KCLDAT
C
      INTEGER Z4E
      PARAMETER (Z4E=1308622848)
C
      DIMENSION KCLDAT(18),DCLDAT(9)
      EQUIVALENCE (DCLDAT(1),KCLDAT(1))
      CHARACTER*6 HGDLTA
C
      COMMON/DSNAME/DSNAME,NAMSUB
C
C...            SYSTEM I/O FILE NAMES
C
      INCLUDE 'SYMFIL.INC'
      DATA FIRST/.TRUE./
      DATA KCLDAT/0,0,Z4E,0,Z4E,2,Z4E,1,
     C 0,0,Z4E,0,0,0,Z4E,0,Z4E,0/
      DATA HGDLTA/'GODLTA'/
      DATA ZLIT1 /.997D0/
C
      IF (FIRST)THEN
        KCLDAT(1) = BCDF('CLDA')
        KCLDAT(2) = BCDF('TA  ')
        KCLDAT(9) = BCDF('    ')
        KCLDAT(10) = KCLDAT(9)
        KCLDAT(13) = KCLDAT(9)
        KCLDAT(14) = KCLDAT(9)
        FIRST=.FALSE.
      ENDIF
C...  STORES THE CUTTER POSITION (TE) IN TCDAT
C...  CALLED BY SUBROUTINES FROM,GODLTA,AND GOTO
      CALL RECORD(ISEQNO)
      IFERM(1) = BCDF(MODFER(1:4))
      IFERM(2) = BCDF(MODFER(5:6))
      IF(MODFER.NE.HGDLTA)GO TO 10
      NR=0
      KCLDAT(4)=ISEQNO
      DCLDAT(5)=FERMOD
      CALL EWRITE(EXFILE,NR,KCLDAT,10,IR)
      GO TO 70
C...  TI IS THE NORMALIZED CUT VECTOR
   10 DO 20 J=1,3
   20 TEMP(J)=TE(J)-TEK(J)
      CALL VNORM(TEMP,TI)
      IF(IER)25,25,50
   25 IF(DABS(TI(1)*TA(1)+TI(2)*TA(2)+TI(3)*TA(3))-ZLIT1) 30,30,50
C...  IF TI IS NOT IN LINE WITH TA,SAVE IN PMOVE
   30 DO 40 J=1,3
   40 PMOVE(J)=TI(J)
   50 NR=0
      KCLDAT(4)=ISEQNO
      KCLDAT(6)=6
      DCLDAT(5)=FERMOD
      DCLDAT(7)=DSNAME
      KCLDAT(16)=NAMSUB
      CALL EWRITE(EXFILE,NR,KCLDAT,18,IR)
      KCLDAT(6)=2
   70 ICL=K3
      CALL ATAPE
      RETURN
       END
**** SOURCE FILE : M0000854.W01   ***
*
C.....FORTRAN SUBROUTINE  ....APT234         8/68                 AR
C
      SUBROUTINE APT234 (HMOD,ADRESS)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DIMENSION ADRESS(1000)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
      LOGICAL CKDEF
C
      INCLUDE 'BLANKCOM.INC'
C
      CHARACTER*8 TEST
C
C...  ESTABLISHES SURFACE PARAMETERS FOR PS,DS,CS AND CALCULATES THE
C...  INDEX OF CANON FOR THE CANONICAL INFORMATION STORAGE
C...  CALLED BY SUBPROGRAMS - APT200,APT201,GO,PSIS
      IF(IAERR.NE.0)GO TO 900
      IF(CKDEF(ADRESS))GO TO 900
C...  PRE-SET SURFACE CONDITION FLAGS
      IPL(IS)=0
      LIMFL(IS)=0
      IUNFL(IS)=0
      PAST(IS)=K1
      JENT(IS)=1
C...  SET ISFTYP BASED ON HOLERITH CONTENTS OF HMOD
      CALL HOLFRM(HMOD,TEST,1,8,NWD)
      IF(TEST.EQ.HDS) GO TO 10
      ISFTYP(IS)=K1
      IF(TEST.EQ.HTO)GO TO 10
      ISFTYP(IS)=K2
      IF(TEST.EQ.HPAST)GO TO 60
      ISFTYP(IS)=K3
      IF(TEST.EQ.HON)GO TO 10
      ISFTYP(IS)=K4
      IF(TEST.EQ.HTANTO)GO TO 10
      ISFTYP(IS)=K8
      IF(TEST.EQ.HPSTAN)GO TO 10
      ISFTYP(IS)=K1
C...  SET SURFACE TYPE CODE IN ISFIDN
   10 ISRFLG=IS/LSV-1
      CALL APT202(ADRESS,ISRFLG)
      CALL UNPACK(ADRESS,ISFIDN(IS),J,K)
      L=(IS-K2)*K10+K1
      ICANON(IS)=L
      IF(.NOT.REFFLG.AND..NOT.REFMOT) GOTO 88
      KIS = ISFIDN(IS)
      IF(KIS.LE.0.OR.KIS.GT.20) GO TO 88
      GO TO(82,82,83,83,84,85,85,85,83,85,88,
     * 88,88,85,88,88,88,88,84,86),KIS
      GOTO 88
   82 IR = 4
      GO TO 87
   83 IR = 5
      GO TO 87
   84 IR = 2
      GO TO 87
   85 IR = 1
      GO TO 87
   86 IR = 3
   87 CALL TRANSM (CANON(L),ADRESS,IR,J,0)
      GO TO 13
   88 DO 12 I = 1,J
      CANON(L) = ADRESS(I)
   12 L = L + 1
   13 IF(ISFIDN(IS) - K3) 50,55,20
   20 IF(ISFIDN(IS)-K5)55,55,30
   30 IF(ISFIDN(IS).EQ.9)GO TO 55
      IF(ISFIDN(IS).EQ.29.OR.ISFIDN(IS).EQ.30) GO TO 1000
      GO TO 1000
   50 IPL(IS)=K1
C...  SET IUNFL=1 IF UN CAN BE CALCULATED USING AN OFF SURFACE POINT,
C...  SET TO 0 OTHERWISE
   55 IUNFL(IS)=K1
 1000 CONTINUE
      RETURN
C...  SET PAST=-1 IF A CONDITION OF PAST EXISTS, -1 OTHERWISE
   60 PAST(IS)=-K1
      GO TO 10
C     SURFACE NOT CORRECTLY DEFINED
  900 IAERR=1
      GO TO 1000
       END
**** SOURCE FILE : M0002730.V08   ***
*
C
C.....FORTRAN SUBROUTINE                APT235...            8/1/68  AR
      SUBROUTINE APT235
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DEF.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
C
C...            SYSTEM I/O FILE NAMES
C
      INCLUDE 'SYMFIL.INC'
C
      INTEGER Z4E
      PARAMETER (Z4E=1308622848)
C
      INTEGER HCLDTA
      DIMENSION HCLDTA(32)
      DIMENSION HCL(16)
      DOUBLE PRECISION HCL
      EQUIVALENCE(HCL(1),HCLDTA(1))
      DIMENSION IFERM(2)
      EQUIVALENCE(IFERM,FERMOD)
      COMMON/DSNAME/DSNAME,NAMSUB
C
      INCLUDE 'BLANKCOM.INC'
C
      INTEGER BCDF
      LOGICAL FIRST
      SAVE FIRST,HCLDTA
      CHARACTER*8 HGO
      LOGICAL CKDEF,FLAG
C
      DATA HCLDTA /0,0,Z4E,0,Z4E,6,Z4E,1,
     * 0,0,Z4E,0,0,0,Z4E,0,Z4E,0,
     * 14*0/
      DATA HGO/'GO      '/
      DATA FIRST/.TRUE./
C
C
      IF (FIRST)THEN
        HCLDTA(1) = BCDF('CLDA')
        HCLDTA(2) = BCDF('TA  ')
        HCLDTA(9) = BCDF('    ')
        HCLDTA(10) = HCLDTA(9)
        HCLDTA(13) = HCLDTA(9)
        HCLDTA(14) = HCLDTA(9)
        FIRST=.FALSE.
      ENDIF
      FLAG = .FALSE.
      NUMSUR=ICSCNT+K2
C...  PRINT  IDENTIYING FIRST CUT SEQUENCE RECORD ON EXFILE
      CALL RECORD(ISEQNO)
      HCLDTA(4)=ISEQNO
      IFERM(1) = BCDF(MODFER(1:4))
      IFERM(2) = BCDF(MODFER(5:6))
      HCL(5)=FERMOD
      HCLDTA(12)=ISFTYP(IDS)
      HCL(7)=DSNAME
      HCLDTA(16)=NAMSUB
      HCLDTA(18)=ISFIDN(IDS)
      IF(ISFIDN(IDS).EQ.K4.AND.MODFER.NE.HGO) GO TO 10
      HCLDTA(6)=K6
      NR=0
      CALL EWRITE(EXFILE,NR,HCLDTA,18,IR)
      GO TO 15
   10 HCLDTA(6)=K13
      J=ICANON(IDS)
      DO 11 I=10,16
      HCL(I)=CANON(J)
   11 J=J+1
      NR=0
      CALL EWRITE(EXFILE,NR,HCLDTA,32,IR)
   15 IF(IPSDEF)9,9,8
    8 TEMP(1) = TE(3)
      TE(3)=Z0
      CALL AUTOPS
      TE(3) = TEMP(1)
    9 J=IPS
      L=LSV
      DO 1 I = 1,NUMSUR
      M=ICANON(J)
      IF (CKDEF(CANON(M))) FLAG = .TRUE.
      IF (J-ICS)  2,3,4
    2 ITLON(J)=ISFTYP(J)-K3
      GO TO 5
    3 L=LSV1
    4 IF(ISFTYP(J)-K4)2,6,7
    6 ITLON(J)=ITLON(IDS)
      IF(ITLON(J).NE.0) ITLON(J)=2
      GO TO 5
    7 ITLON(J)=ITLON(IPS)
      IF(ITLON(J).NE.0) ITLON(J)=3
      ISFTYP(J)=K4
    5 IAFL(J)=-K1
    1 J=J+L
      IF (FLAG)  CALL AERR(23501,'APT235  ')
      RETURN
       END
**** SOURCE FILE : M0000856.V03   ***
*
C.....FORTRAN SUBROUTINE             APT236...              4/1/68   GK
      SUBROUTINE APT236
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C...  21. ADDCOM BLOCK
C
      COMMON/ADDCOM/ ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),  (ADDCOM( 2),CLNGTH),
     1            (ADDCOM(23),IBTFLG),  (ADDCOM(24),JLIN)
C
      DATA ZLIT1,KLIT2/.997D0,11/
C
C
C
C
C
      DO 1 K = 1,3
      INOPS=0
      ICSCNT=0
      TEMP(K) = TE(K) - TEK(K)
      TPK(K,IPS) = TP(K,IPS)
      SPK(K,IPS) = SP(K,IPS)
      U1K(K,IPS) = U1(K,IPS)
      SNK(K,IPS) = SN(K,IPS)
    1 CONTINUE
      ITSEGK(IPS) = ITSEG(IPS)
      CALL VNORM (TEMP,TEMP)
      IF(IER)2,2,4
    2 IF(DABS(TEMP(1)*TA(1)+TEMP(2)*TA(2)+TEMP(3)*TA(3))-ZLIT1) 3,3,4
    3 PMOVE(1) = TEMP(1)
      PMOVE(2)=TEMP(2)
      PMOVE(3)=TEMP(3)
    4 I=IPS
      DO 5 J = 1,NUMSUR
      INDIR(I)=0
      ISVFL(I)=0
      IF (I .GE. ICS)  GO TO 7
    6 I=I+LSV
      GO TO 5
    7 I=I+LSV1
    5 CONTINUE
      RETURN
       END
**** SOURCE FILE : M0001132.W01   ***
*
C.....FORTRAN SUBROUTINE  ....APT238         8/68                    HG
C.....FORTRAN SUBROUTINE             APT238...              3/1/68   GK
      SUBROUTINE APT238 (NUMBER)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IBRKPT.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      N = NUMBER
      IF(IBRKPT(N)) 2,1,2
    2 KFIX = STRTNO
      IF(NMPNTS-NUMPT1.LT.KFIX) GO TO 1
      IS01 = IS+1
      IS02 = IS + 2
      CALL BAD(-1,0,' ',0)
      NN1=NUMBER/10+1
      NN2=MOD(NUMBER,10)
      NN1=100*NN1+NN2
      CALL BAD(1,0,'DYND',NN1)
      CALL BAD(-1,0,'SEQN',ISEQNO)
      GO TO (101,102,103,104,105,106,107,999,999,999,
     1       201,202,203,204,205,206,207,208,209,210,
     2     211,212,213,214,215,216,217,999,999,999,
     3       401,402,403,404,999,999,999,999,999,999,
     4       501,502,503,504,505,999,999,999,999,999),N
C*101 CALL APT239(1,S(IS),TP(IS),TP(IS01),TP(IS02),TN(IS),TN(IS01),
C*   C TN(IS02))
C*    GO TO 1
C*102 CALL APT239(2,S(IS),SP(IS),SP(IS01),SP(IS02),SN(IS),
C*   C SN(IS01),SN(IS02))
C*    GO TO 1
C*103 CALL APT239(3,IS,JENT(IS),JTN(IS),IOPSET(IS),JU1(IS),
C*   C TE(1),TE(2),TE(3),TA(1),TA(2),TA(3))
C*    GO TO 1
C*104 CALL APT239(4,IS,S(IS),ISIGCR(IS),Z(IS),RC(IS),CC(IS),CC(IS01),
C*   C CC(IS02),SP(IS),SP(IS01),SP(IS02),SPL(IS),SPL(IS01),SPL(IS02),
C*   2 SN(IS),SN(IS01),SN(IS02))
C*    GO TO 1
C*105 CALL APT239 (5,IS,TP(IS),TP(IS01),TP(IS02),TN(IS),
C*   C TN(IS01),TN(IS02))
C*    GO TO 1
C*106 CALL APT239(6,IS,S(IS),Z(IS),FLIPCK,IAMDCT,SP(IS),
C*   C SP(IS01),SP(IS02),SN(IS),SN(IS01),SN(IS02),
C*   2 TP(IS),TP(IS01),TP(IS02),TN(IS),TN(IS01),TN(IS02))
C*    GO TO 1
C*107 CALL APT239(7,IS,S(IS),TAU1(IS),TAU2(IS),Z(IS),
C*   C FLIPCK,IAMDCT,TH(IS),RC(IS),
C*   2 SP(IS),SP(IS01),SP(IS02),SN(IS),SN(IS01),SN(IS02),TP(IS),TP(IS01)
C*   3,TP(IS02),TN(IS),TN(IS01),TN(IS02),CC(IS),CC(IS01),CC(IS02),
C*   4 VT(IS),VT(IS01),VT(IS02))
C*    GO TO 1
C*201 CALL APT239(11,TEK(1),TEK(2),TEK(3),TAK(1),TAK(2),TAK(3),
C*   C TIK(1),TIK(2),TIK(3),SPK(IPS),SPK(IPS+1),SPK(IPS+2),
C*   2 TPK(IPS),TPK(IPS+1),TPK(IPS+2),SPK(IDS),SPK(IDS+1),SPK(IDS+2),
C*   3 TPK(IDS),TPK(IDS+1),TPK(IDS+2))
C*    GO TO 1
C*202 CALL APT239(12,DP,DPI)
C*    GO TO 1
C*203 CALL APT239(13,IS,CSD(IS),DPI)
C*    GO TO 1
C*204 CALL APT239(14,DP,CMOVE(1),CMOVE(2),CMOVE(3),TEL(1),TEL(2),TEL(3),
C*   C TAL(1),TAL(2),TAL(3),TE(1),TE(2),TE(3),TA(1),TA(2),TA(3))
C*    GO TO 1
C*205 CALL APT239(15,IS,JCR,TE(1),TE(2),TE(3),TA(1),TA(2),TA(3))
C*    GO TO 1
C*206 CALL APT239(16,JDR,DP)
C*    GO TO 1
C*207 CALL APT239(17,IS,JCKR,CSD(IS))
C*    GO TO 1
C*208 CALL APT239(18,VL,NUMPT1)
C*    GO TO 1
C*209 CALL APT239(19,JCR,IWS,TEE(IS),TEE(IS01),TEE(IS02))
C*    GO TO 1
C*210 CALL APT239(20,IS,S(IS),Z(IS),J23(IS),STCK(IS),STCK1(IS))
C*    GO TO 1
C*211 CALL APT239(21,IS,J23(IS),STCK2(IS),STCK(IS),
C*   C SN(IS),SN(IS01),SN(IS02))
C*    GO TO 1
C*212 CALL APT239 (22,IS,JDR,DP,VL)
C*    GO TO 1
C*213 CALL APT239(23,IS,DP)
C*    GO TO 1
C*214 CALL APT239(24,IS,JPR,CSD(IS))
C*    GO TO 1
C*215 CALL APT239(25,IS,ISFTYP(IS),J23(IS),S(IS),Z(IS),STCK(IS),
C*   C STCK1(IS),STCK2(IS))
C*    GO TO 1
C*216 CALL APT239(26,ISFTYP(IS),J23(IS),STCK2(IS),STCKN(IS),
C*   C SN(IS),SN(IS01),SN(IS02),TI(1),TI(2),TI(3))
C*    GO TO 1
C*217 CALL APT239(27,IS,IFAR(IS),TE(1),TE(2),TE(3),TA(1),TA(2),TA(3))
C*    GO TO 1
C*401 CALL APT239(31,JPXR,PLND(IS),PLNV(IS),PLNV(IS01),PLNV(IS02),
C*   C CMOVE(1),CMOVE(2),CMOVE(3))
C*    GO TO 1
C*402 CALL APT239(32,CPTST(IS),CPLFL(IS),PLND(IS),PLNV(IS),PLNV(IS01),
C*   C PLNV(IS02))
C*    GO TO 1
C*403 CALL APT239(33,IS,PLND1(IS),PLTST(IS))
C*    GO TO 1
C*404 CALL APT239(34,IT,S(IT),ISIGCR(IT),Z(IT),RC(IT),SP(IT),SP(IT+1),
C*   C SP(IT+2),CC(IT),CC(IT+1),CC(IT+2),SPL(IT),SPL(IT+1),SPL(IT+2),
C*   2 SN(IT),SN(IT+1),SN(IT+2))
C*    GO TO 1
C*501 CALL APT239(41,INOPS,NUMSUR,IAUTPS)
C*    GO TO 1
C*502 CALL APT239(42,IS,INDIR(IS))
C*    GO TO 1
C*503 CALL APT239(43,IS,VNDIR(IS),VNDIR(IS01),VNDIR(IS02),
C*   C TE(1),TE(2),TE(3))
C*    GO TO 1
C*504 CALL APT239(44,IS,ISVFL(IS),CSD(IS),SN(IS),SN(IS01),SN(IS02))
C*999 GO TO 1
C*505 CALL APT239(45,TE(1),TE(2),TE(3))
C*  1 RETURN
C*    END
  101 CONTINUE
      CALL BAD(1,1,'S   ',S(IS))
      CALL BAD(-1,1,'Z   ',Z(IS))
      CALL BAD(3,1,'TP  ',TP(1,IS))
      CALL BAD(-3,1,'TN  ',TN(1,IS))
      GO TO 1
  102 CONTINUE
      CALL BAD(1,1,'S   ',S(IS))
      CALL BAD(-1,1,'Z   ',Z(IS))
      CALL BAD(3,1,'SP  ',SP(1,IS))
      CALL BAD(-3,1,'SN  ',SN(1,IS))
      GO TO 1
  103 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,0,'JENT',JENT(IS))
      CALL BAD(1,0,'JTN ',JTN(IS))
      CALL BAD(1,0,'IOPS',IOPSET(IS))
      CALL BAD(1,0,'JU1 ',JU1(IS))
      CALL BAD(-1,0,'ITLN',ITLON(IS))
      CALL BAD(3,1,'TE  ',TE)
      CALL BAD(-3,1,'TA  ',TA)
      GO TO 1
  104 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,1,'S   ',S(IS))
      CALL BAD(1,0,'ISGC',ISIGCR(IS))
      CALL BAD(1,1,'Z   ',Z(IS))
      CALL BAD(-1,1,'RC  ',RC(IS))
      CALL BAD(3,1,'SP  ',SP(1,IS))
      CALL BAD(-3,1,'SN  ',SN(1,IS))
      CALL BAD(3,1,'SPL ',SPL(1,IS))
      CALL BAD(-3,1,'CC  ',CC(1,IS))
      GO TO 1
  105 CONTINUE
      CALL BAD(-1,0,'IS  ',IS)
      CALL BAD(3,1,'TP  ',TP(1,IS))
      CALL BAD(-3,1,'TN  ',TN(1,IS))
      GO TO 1
  106 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,1,'S   ',S(IS))
      CALL BAD(1,1,'Z   ',Z(IS))
      CALL BAD(1,1,'FLCK',FLIPCK)
      CALL BAD(-1,0,'AMCT',IAMDCT)
      CALL BAD(3,1,'SP  ',SP(1,IS))
      CALL BAD(-3,1,'SN  ',SN(1,IS))
      CALL BAD(3,1,'TP  ',TP(1,IS))
      CALL BAD(-3,1,'TN  ',TN(1,IS))
      GO TO 1
  107 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,1,'S   ',S(IS))
      CALL BAD(1,1,'TAU1',TAU1(IS))
      CALL BAD(1,1,'TAU2',TAU2(IS))
      CALL BAD(1,1,'Z   ',Z(IS))
      CALL BAD(-1,1,'FLCK',FLIPCK)
      CALL BAD(1,0,'AMCT',IAMDCT)
      CALL BAD(1,1,'TH  ',TH(IS))
      CALL BAD(-1,1,'RC  ',RC(IS))
      CALL BAD(3,1,'SP  ',SP(1,IS))
      CALL BAD(-3,1,'SN  ',SN(1,IS))
      CALL BAD(3,1,'TP  ',TP(1,IS))
      CALL BAD(-3,1,'TN  ',TN(1,IS))
      CALL BAD(3,1,'CC  ',CC(1,IS))
      CALL BAD(-3,1,'VT  ',VT(1,IS))
      GO TO 1
  201 CONTINUE
      CALL BAD(3,1,'TEK ',TEK)
      CALL BAD(-3,1,'TAK ',TAK)
      CALL BAD(3,1,'SPKP',SPK(1,IPS))
      CALL BAD(-3,1,'SPKD',SPK(1,IDS))
      CALL BAD(3,1,'TPKP',TPK(1,IPS))
      CALL BAD(-3,1,'TPK ',TPK(1,IDS))
      CALL BAD(-3,1,'TIK ',TIK)
      GO TO 1
  202 CONTINUE
      CALL BAD(1,1,'DP  ',DP)
      CALL BAD(-1,1,'DPI ',DPI)
      GO TO 1
  203 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,1,'CSD ',CSD(IS))
      CALL BAD(-1,1,'DPI ',DPI)
      GO TO 1
  204 CONTINUE
      CALL BAD(3,1,'CMOV',CMOVE)
      CALL BAD(-1,1,'DP  ',DP)
      CALL BAD(3,1,'TE  ',TE)
      CALL BAD(-3,1,'TA  ',TA)
      CALL BAD(3,1,'TEL ',TEL)
      CALL BAD(-3,1,'TAL ',TAL)
      GO TO 1
  205 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(-1,0,'JCR ',JCR)
      CALL BAD(3,1,'TE  ',TE)
      CALL BAD(-3,1,'TA  ',TA)
      GO TO 1
  206 CONTINUE
      CALL BAD(1,0,'JDR ',JDR)
      CALL BAD(-1,0,'DP  ',DP)
      GO TO 1
  207 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,0,'JCKR',JCKR)
      CALL BAD(-1,0,'CSD ',CSD(IS))
      GO TO 1
  208 CONTINUE
      CALL BAD(1,0,'NMPT',NUMPT1)
      CALL BAD(-1,1,'VL  ',VL)
      GO TO 1
  209 CONTINUE
      CALL BAD(1,0,'JCR ',JCR)
      CALL BAD(1,0,'IWS ',IWS)
      CALL BAD(-3,1,'TEE ',TEE(1,IS))
      GO TO 1
  210 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,1,'S   ',S(IS))
      CALL BAD(1,1,'Z   ',Z(IS))
      CALL BAD(1,0,'J23 ',J23(IS))
      CALL BAD(1,1,'STCK',STCK(IS))
      CALL BAD(-1,1,'STK1',STCK1(IS))
      GO TO 1
  211 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,0,'J23 ',J23(IS))
      CALL BAD(1,1,'STK2',STCK2(IS))
      CALL BAD(-1,1,'STCK',STCK(IS))
      CALL BAD(-3,1,'SN  ',SN(1,IS))
      GO TO 1
  212 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,0,'JDR ',JDR)
      CALL BAD(1,1,'DP  ',DP)
      CALL BAD(-1,1,'VL  ',VL)
      GO TO 1
  213 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(-1,1,'DP  ',DP)
      GO TO 1
  214 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,0,'JPR ',JPR)
      CALL BAD(-1,1,'CSD ',CSD(IS))
      GO TO 1
  215 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,0,'ISFT',ISFTYP(IS))
      CALL BAD(1,0,'J23 ',J23(IS))
      CALL BAD(1,1,'S   ',S(IS))
      CALL BAD(-1,1,'Z   ',Z(IS))
      CALL BAD(1,1,'STCK',STCK(IS))
      CALL BAD(1,1,'STK1',STCK1(IS))
      CALL BAD(-1,1,'STK2',STCK2(IS))
      GO TO 1
  216 CONTINUE
      CALL BAD(1,0,'ISFT',ISFTYP(IS))
      CALL BAD(1,0,'J23 ',J23(IS))
      CALL BAD(1,1,'STK2',STCK2(IS))
      CALL BAD(-1,1,'STKN',STCKN(IS))
      CALL BAD(3,1,'SN  ',SN(1,IS))
      CALL BAD(-3,1,'TI  ',TI)
      GO TO 1
  217 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(-1,0,'IFAR',IFAR(IS))
      CALL BAD(3,1,'TE  ',TE)
      CALL BAD(-3,1,'TA  ',TA)
      GO TO 1
  401 CONTINUE
      CALL BAD(1,0,'JPXR',JPXR)
      CALL BAD(-1,1,'PLND',PLND(IS))
      CALL BAD(3,1,'PLNV',PLNV(1,IS))
      CALL BAD(-3,1,'CMOV',CMOVE)
      GO TO 1
  402 CONTINUE
      CALL BAD(1,1,'CPTS',CPTST(IS))
      CALL BAD(1,1,'CPLF',CPLFL(IS))
      CALL BAD(1,1,'PLND',PLND(IS))
      CALL BAD(-3,1,'PLNV',PLNV(1,IS))
      GO TO 1
  403 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,1,'PLD1',PLND1(IS))
      CALL BAD(-1,1,'PLTS',PLTST(IS))
      GO TO 1
  404 CONTINUE
      CALL BAD(1,0,'IT  ',IT)
      CALL BAD(1,1,'S   ',S(IT))
      CALL BAD(1,0,'ISGC',ISIGCR(IT))
      CALL BAD(1,1,'Z   ',Z(IT))
      CALL BAD(-1,1,'RC  ',RC(IT))
      CALL BAD(3,1,'SP  ',SP(1,IT))
      CALL BAD(-3,1,'SN  ',SN(1,IT))
      CALL BAD(3,1,'SPL ',SPL(1,IT))
      CALL BAD(-3,1,'CC  ',CC(1,IT))
      GO TO 1
  501 CONTINUE
      CALL BAD(1,0,'INPS',INOPS)
      CALL BAD(1,0,'NMSR',NUMSUR)
      CALL BAD(-1,0,'IAUT',IAUTPS)
      GO TO 1
  502 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(-1,0,'INDR',INDIR(IS))
      GO TO 1
  503 CONTINUE
      CALL BAD(-1,0,'IS  ',IS)
      CALL BAD(3,1,'VNDR',VNDIR(1,IS))
      CALL BAD(-3,1,'TE  ',TE)
      GO TO 1
  504 CONTINUE
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(1,0,'ISVF',ISVFL(IS))
      CALL BAD(1,1,'CSD ',CSD(IS))
      CALL BAD(-3,1,'SN  ',SN(1,IS))
  999 CONTINUE
      GO TO 1
  505 CONTINUE
      CALL BAD(-3,1,'TE  ',TE)
    1 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0002734.V07   ***
*
C.....FORTRAN SUBROUTINE  ....APT240         8/68                 RN,PH
C.....FORTRAN SUBROUTINE             APT240...              4/16/68  GK
C
C              FORTRAN SUBROUTINE APT240 (NUMDIM)
C
C PURPOSE      TO SET THE IAFL FLAG FOR AMIND AND THE NUMDIM FLAG FOR
C              APT201. THIS ROUTINE CALLED BY APT201 AND GO.
C                FLAG SETTINGS
C                 IAFL = -1  NORMAL CASE
C                 IAFL = 0   TOOL PERP. TO PS PLANE OR PARL. TO DS OR CS
C                 IAFL = 1   TA PARLEL SURF. LINE ELEMENT
C                 NUMDIM = 0  USE 2D ROURES
C                 NUMDIM = 1  USE 3D ROUTES
C
      SUBROUTINE APT240 (NUMDIM)
      IMPLICIT DOUBLE PRECISION (A-H), DOUBLE PRECISION(O-Z)
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C    ALIGN J11 ON DOUBLE WORD BOUNDRY.
      EQUIVALENCE  (J11,REAL8)
C
      INCLUDE 'BLANKCOM.INC'
C
      NUMDIM = K0
      IF (K2- MANTAX) 22,22,3
   22 NUMDIM = K1
      GO TO 14
    3 L = LSV
      M = ICS + LSV1*(ICSCNT - K1)
      N = IPS
      IF (ISFIDN(IPS).GT.K2) GO TO 7
      IC = ICANON(IPS)
      CALL DOTF (TEMP,TA,CANON(IC))
      IF(DABS(TEMP(1)).LT..9999999) GO TO 10
      IAFL(N) = 0
      ITSEG(N) = 1
   23 IT = ITSEG(N)
      TOOLHT(1,N) = TLHITE(IT)*TA(1)
      TOOLHT(2,N) = TLHITE(IT)*TA(2)
      TOOLHT(3,N) = TLHITE(IT)*TA(3)
      TOOLWD(N) = CORRAD(IT)+RI(IT)
      GO TO 10
    7 NUMDIM = K1
   10 IF (N.GE.M) GO TO 14
      N = N+ L
      IF (N.EQ.ICS) L = LSV1
      IC = ICANON(N)
      JSW = ISFIDN(N)
      IF(JSW.EQ.29.OR.JSW.EQ.30) GO TO 115
      IF((JSW.LE.0).OR.(JSW.GT.15)) GO TO 8010
      GO TO (110,110,111,111,115,112,112,112,115,112,113,115,115,115,
     +       115), JSW
  110 CALL DOTF (TEMP,TA,CANON(IC))
      IF(DABS(TEMP(1)).GT..0000001) GO TO 115
      IAFL(N) = 0
      GO TO 117
  111 CALL DOTF (TEMP,TA,CANON(IC+3))
      IF (DABS(TEMP(1)).LT..9999999) GO TO 115
  116 IAFL(N) = K1
      GO TO 117
  115 NUMDIM = K1
      GO TO 10
  112 NUMDIM = K1
      IF(DABS(TA(3)).EQ.Z1) GO TO 116
      GO TO 10
  113 CALL APT094(3,CANON(IC),J11)
      J11=J11-1
      CALL DOTF(TEMP,TA,CANON(J11+8) )
      IF (DABS(TEMP(1)).LT..9999999) GO TO 115
      NUMDIM = K1
      GO TO 116
  117 IF (ITLON(N).EQ.0) GO TO 120
      IF(COSL(7)) 200,300,119
  200 IAFL(N)=KM1
      GO TO 115
  300 CONTINUE
      IF (TCONT(5).NE.0.)GO TO 122
      ITSEG(N) = 4
      GO TO 23
  120 ITSEG(N) = 1
      GO TO 23
  119 ITSEG(N) = 7
      GO TO 23
  122 ITSEG(N) = 5
      GO TO 23
 8010 CALL AERR (20101,'APT240  ')
   14 RETURN
      END
**** SOURCE FILE : M0002738.V06   ***
*
C
C
C.....FORTRAN SUBROUTINE             ARLM2...               4/8/68   GK
      SUBROUTINE ARLM2
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      EQUIVALENCE  (CCENTR(1),CNRMAL(1))
      EQUIVALENCE    (ZMOSHN(1),TI(1))
      DIMENSION  CNRMAL(3),   ZMOSHN(3)
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR5.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C
      DIMENSION  CANSTO(3), A(3,3), B(3,3)
      DIMENSION DAXIS(3),CAXIS(3)
C
      INCLUDE 'BLANKCOM.INC'
C
      DOUBLE PRECISION TEMDIF
      DATA ZLIT1/.0001D0/
      TEK(1) = TE(1)
      TEK(2)=TE(2)
      TEK(3)=TE(3)
      IS=ICS
      I=ICANON(IDS)
      DCENTR(1) = CANON(I)
      DCENTR(2)=CANON(I+1)
      DCENTR(3) = CANON(I+2)
      DAXIS(1)=CANON(I+3)
      DAXIS(2)=CANON(I+4)
      DAXIS(3)=CANON(I+5)
      DRDIUS=CANON(I+6)
      I=ICANON(ICS)
      CCENTR(1) = CANON(I)
      CCENTR(2)=CANON(I+1)
      CCENTR(3) = CANON(I+2)
      CAXIS(1)=CANON(I+3)
      CAXIS(2)=CANON(I+4)
      CAXIS(3)=CANON(I+5)
      CRDIUS=CANON(I+6)
C
C     PRELIMINARY Z-CORRECTION CALCULATIONS
C
      IFROT = 0
      IDONE = 0
      I = ICANON(IPS)
      TEM(1)=TA(1)*CANON(I)+TA(2)*CANON(I+1)+TA(3)*CANON(I+2)
      FLIP=Z1
      IF(TEM(1).LT.Z0)FLIP=-Z1
      CANSTO(1)=CANON(I)*FLIP
      CANSTO(2) = CANON(I+1)*FLIP
      CANSTO(3) = CANON(I+2)*FLIP
      DVALUI=TE(1)*CANSTO(1)+TE(2)*CANSTO(2)+TE(3)*CANSTO(3)
      DOPSTA=TA(1)*CANSTO(1)+TA(2)*CANSTO(2)+TA(3)*CANSTO(3)
C
C     DETERMINE IF ROTATION NECCESSARY. IF SO, ROTATE.
C
      IF(DABS(TA(3)).EQ.Z1) GO TO  90
      IFROT = 1
C
C     ROTATION MATRIX  CONSTRUCTION.
C
      SINZTA=DSQRT(TA(1)*TA(1)+TA(2)*TA(2))
      COSXTA=TA(1)/SINZTA
      SINXTA=TA(2)/SINZTA
      A(1,1) =TA(3)*COSXTA
      A(2,1) =TA(3)*SINXTA
      A(3,1) =-SINZTA
      A(1,2) =-SINXTA
      A(2,2) =COSXTA
      A(3,2) =0.0
      A(1,3) =TA(1)
      A(2,3) =TA(2)
      A(3,3) =TA(3)
      DO 10 I=1,3
      DO 10 J=1,3
 10   B(I,J) = A(J,I)
C
C     ROTATIONS DEPEND ON SURFACE TYPE
C
11    IF(JBR-2)12,14,16
C
12    CALL ROTAT(CCENTR,A)
      IF(ISFIDN(ICS).GT.K2) CALL ROTAT(CAXIS,A)
      CALL ROTAT(DCENTR,A)
      CALL ROTAT(DAXIS,A)
      I=ICANON(IDS)
      CANON(I )=DCENTR(1)
      CANON(I+1)=DCENTR(2)
      CANON(I+2)=DCENTR(3)
      CANON(I+3)=DAXIS(1)
      CANON(I+4)=DAXIS(2)
      CANON(I+5)=DAXIS(3)
      CALL ROTAT(TEK,A)
      GO TO 20
C
14    CALL ROTAT(CCENTR,A)
      CALL ROTAT(CAXIS,A)
      CALL ROTAT(SN(1,IDS),A)
      GO TO 20
C
16    CALL ROTAT(CNRMAL,A)
C
20    CALL ROTAT(TE,A)
      I=ICANON(ICS)
      CANON(I) = CNRMAL(1)
      CANON(I+1) = CNRMAL(2)
      CANON(I+2) = CNRMAL(3)
      CANON(I+3)=CAXIS(1)
      CANON(I+4)=CAXIS(2)
      CANON(I+5)=CAXIS(3)
      IF(IDONE.NE.1)GO TO 24
      ASSIGN 24 TO IRETN
      GO TO 1341
24    CALL ROTAT(TI,A)
C
C     DO NECCESSARY INVERSE ROTATIONS AND Z-CORRECTIONS
C
      IF(IDONE.NE.1) GO TO 90
      CALL ROTAT(TN(1,ICS),A)
      CALL ROTAT(TP(1,ICS),A)
      IF(DOPSTA.EQ.Z0)GO TO 1410
      PROJ=TN(1,ICS)*CANSTO(1)+TN(2,ICS)*CANSTO(2)+TN(3,ICS)*CANSTO(3)
      PROK=TP(1,ICS)*CANSTO(1)+TP(2,ICS)*CANSTO(2)+TP(3,ICS)*CANSTO(3)
      PROJ=(PROJ-DVALUI)/DOPSTA
      PROK=(PROK-DVALUI)/DOPSTA
      DO 29 I=1,3
      TN(I,ICS)=TN(I,ICS)+PROJ*(-TA(I))
29    TP(I,ICS)=TP(I,ICS)+PROK*(-TA(I))
      GO TO 1410
C
90    TEN=DSQRT(TI(1)*TI(1)+TI(2)*TI(2))
      ZMOSHN(1)=TI(1)/TEN
      ZMOSHN(2)=TI(2)/TEN
      ZMOSHN(3)=Z0
C
C     BEGIN CUTTER OFFSET CALCULATIONS
C
      TEMP(7)=CUTDAT(1)
      IF(ISFTYP(IDS).EQ.K3)TEMP(7)=Z0
      JSW=ISFTYP(IS)
      TEMP(20)=IFAR(IS)-K1
      RADNO=(IFAR(IS)-K1)/K2
      IFAR(IS)=K2-(IFAR(IS)-K2*(IFAR(IS)/K2))
      GO TO (140,140,170,130),JSW
  130 RADNO=TEMP(20)
      OFFSET=TEMP(7)
      GO TO 180
140   OFFSET=CUTDAT(1)
      IF(IFAR(IS).EQ.JSW)OFFSET=-OFFSET
      GO TO 180
  170 OFFSET=Z0
  180 IF(JBR-K2)190,810,1310
C
C...  2D ROUTE--CIRCLE DS,CIRCLE OR LINE CS
C
190   RZERO(1)=DCENTR(1)-TE(1)
      RZERO(2)=DCENTR(2)-TE(2)
      RZEROL = DSQRT(RZERO(1)**2+RZERO(2)**2)
      IF (RZEROL.LE.Z1EM6) GO TO 1410
      TEMP(15)=DSIGN(Z1,RZERO(1)*TI(2)-RZERO(2)*TI(1))
      TEMP(1) = Z1
      TEMP(2)=Z1
      TEMP(5)=DABS(OFFSET)
      TEMP(6)=-PAST(IS)*TEMP(15)
      IF (RZEROL.GE.DRDIUS) GO TO 250
      IF(ISFTYP(IS).EQ.K4)OFFSET=-OFFSET
      DIF=DRDIUS-TEMP(7)-DABS(TAU2(IDS))
      TEMDIF=DRDIUS-TEMP(7)
      IF(DIF)1380,1380,260
  250 DIF=DRDIUS+TEMP(7)+TAU1(IDS)
      TEMDIF=DRDIUS+TEMP(7)
  260 IF(ISFIDN(IS).GT.K2)GO TO 440
C
C     LINE  CS, CYLINDER DS.
C
      TP(1,IS) = DCENTR(1)
      TP(2,IS)=DCENTR(2)
      TP(3,IS)=TE(3)
      TN(1,IS)=CNRMAL(1)
      TN(2,IS)=CNRMAL(2)
      TN(3,IS)=Z0
      ASSIGN 270 TO LRETN
      GO TO 1420
270   IF(S(IS).GE.Z0)GO TO 280
      S(IS)=-S(IS)
      TN(1,IS)=-TN(1,IS)
      TN(2,IS)=-TN(2,IS)
  280 IF(ISFTYP(IS).NE.K4)GO TO 300
      IF(DABS(S(IS)-DRDIUS)-TAU(IS).GE.Z0)GO TO 1370
      TEN=S(IS)+OFFSET
      FIPNT(1)=TP(1,IS)+TEN*TN(1,IS)
      FIPNT(2)=TP(2,IS)+TEN*TN(2,IS)
      GO TO 1030
 300  TEMP(9) = S(IS)+RZERO(1)*TN(1,IS)+RZERO(2)*TN(2,IS)
      IF (TEMP(9).LT.Z0) TEMP(2) = -Z1
      TEMP(10)=S(IS)-TEMP(5)-Z1EM5
      IF (TEMP(10).GE.DIF) GO TO 1390
      IF((TEMP(10)+DIF).LE.Z0)GO TO 1380
      IF((DIF-S(IS)-TEMP(5)).GT.ZLIT1)GO TO 360
      RADNO=TEMP(20)
      GO TO 430
  360 IF ((DABS(TEMP(9))-TEMP(5)).GT.Z1EM5) GO TO 420
      IF (PAST(IS).GE.Z0) GO TO 390
      IF ((DABS(TEMP(9))+Z1EM5).GT.TEMP(5)) GO TO 420
  390 ZDOTC = RZERO(1)*TN(2,IS)-RZERO(2)*TN(1,IS)
      IF(DABS(ZDOTC)-Z1EM7.GT.Z0) GO TO 410
      TEMP(1) = PAST(IS)*TEMP(2)
      GO TO 420
  410 TEMP(1) = TEMP(2)*TEMP(6)*DSIGN(Z1,ZDOTC)
  420 TEMP(6)=-TEMP(1)*TEMP(2)*TEMP(15)
      IF(IFAR(IS).EQ.K2)TEMP(6)=-TEMP(6)
  430 TEMP(3)=S(IS)+TEMP(6)*TEMP(15)*PAST(IS)*TEMP(5)
      TEMP(4)=DSQRT(DABS(TEMDIF**2-TEMP(3)**2))
      FIPNT(1)=TP(1,IS)+TEMP(3)*TN(1,IS)+TEMP(6)*TEMP(4)*TN(2,IS)
      FIPNT(2)=TP(2,IS)+TEMP(3)*TN(2,IS)-TEMP(6)*TEMP(4)*TN(1,IS)
      GO TO 1030
C
C     CYLINDER CS, CYLINDER DS.
C
  440 CEND(1) = CCENTR(1) - DCENTR(1)
      CEND(2)=CCENTR(2)-DCENTR(2)
      CTOCL = DSQRT(CEND(1)**2+CEND(2)**2)
      IF(CTOCL.LE.Z1EM7) GO TO 1360
      CEND(1)=CEND(1)/CTOCL
      CEND(2)=CEND(2)/CTOCL
      IF(JSW.NE.K4) GO TO 520
      IF ((CTOCL-CRDIUS+Z1EM3).GE.DRDIUS) GO TO 800
      IF (DABS(CTOCL+DRDIUS-CRDIUS).LT.Z1EM3) GO TO 500
      IF(DABS(CTOCL+CRDIUS-DRDIUS)-Z1EM3) 510,1370,1370
  500 TEMP(1) = -Z1
510   D=(DRDIUS+OFFSET)*TEMP(1)
      FIPNT(1)=DCENTR(1)+D*CEND(1)
      FIPNT(2)=DCENTR(2)+D*CEND(2)
      GO TO 1030
  520 TEMP(9)=TEMDIF-CTOCL
      TEMP(11)=TEMP(5)
      IF(DABS(TEMP(9))-CRDIUS-TEMP(11)) 530,1390,1390
  530 TEMP(10)=CTOCL-CRDIUS
      IF(TEMP(10)+TEMDIF+TEMP(5)+Z1EM5) 1390,1390,540
  540 IF(DABS(TEMP(10)+TEMDIF).GT.TEMP(11)) GO TO 570
      IF (TEMP(10).GE.Z0) GO TO 1380
      TEMP(1) = -Z1
  570 IF (DABS(CRDIUS-TEMP(9)).GT.TEMP(11)) GO TO 600
      IF (TEMP(1)) 1380,1380,720
  600 IF(DABS(TEMP(10)-TEMDIF).GT.TEMP(11)) GO TO 620
      IF(TEMP(1)) 1380,1380,720
  620 IF(TEMP(1)) 740,720,630
 630  TEMP(4)=DSQRT((TE(1)-CCENTR(1))**2+(TE(2)-CCENTR(2))**2)-CRDIUS
      IF (TEMP(4).LT.Z0) TEMP(2) = -Z1
      IF(DABS(TEMP(4)).GT.TEMP(11)) GO TO 700
      ZDOTC = RZERO(1)*CEND(2) - RZERO(2)*CEND(1)
      IF (ZDOTC.EQ.Z0) GO TO 1380
      IF (PAST(IS).GE.Z0) GO TO 690
      IF(DABS(TEMP(4))-TEMP(5)+ZLIT1) 690,700,700
  690 TEMP(1) = TEMP(2)*TEMP(6)*DSIGN(Z1,ZDOTC)
 700  TEMP(6) =-TEMP(1)*TEMP(2)*TEMP(15)
      IF(IFAR(IS).EQ.K2)TEMP(6)=-TEMP(6)
      IF(PAST(IS)*TEMP(15)*TEMP(6))730,1380,750
  720 RADNO=TEMP(20)
  730 HAFDIA=CRDIUS+TEMP(11)
      GO TO 760
  740 RADNO=TEMP(20)
      TEMP(6)=-TEMP(6)
  750 HAFDIA=CRDIUS-TEMP(5)
  760 DSMOV=(CTOCL**2+TEMDIF**2-HAFDIA**2)/(Z2*CTOCL)
      TEMP(1)=TEMDIF**2-DSMOV**2
      IF(TEMP(1).GE.Z0) GO TO 790
      IER=23908
      GO TO 1400
790   TEN=DSQRT(TEMP(1))*TEMP(6)
      FIPNT(1)=DCENTR(1)+DSMOV*CEND(1)+TEN*CEND(2)
      FIPNT(2)=DCENTR(2)+DSMOV*CEND(2)-TEN*CEND(1)
      GO TO 1030
  800 IF(CTOCL-CRDIUS-DRDIUS-Z1EM3) 510,510,1370
C
C     LINE DS, CYLINDER CS
C
  810 CEND(1) = CCENTR(1) - TE(1)
      CEND(2)=CCENTR(2)-TE(2)
      CENLEN = DSQRT(CEND(1)**2+CEND(2)**2)
      S(IS) = CEND(1)*ZMOSHN(1)+CEND(2)*ZMOSHN(2)
      DSMOV=CEND(1)*SN(1,IDS)+CEND(2)*SN(2,IDS)
      IF(JSW.EQ.K4) GO TO 950
      OFFSET=DABS(OFFSET)
      IF(S(IS).LE.Z0)OFFSET=-OFFSET
      IF(JSW.EQ.K2)GO TO 900
      IF ((CENLEN-OFFSET-CRDIUS).LT.TAU1(IS)) GO TO 880
      IF(IFAR(IS).EQ.K2)GO TO 880
      ZIGN=-Z1
  870 DIF=CRDIUS+DABS(OFFSET)
      GO TO 990
  880 ZIGN=Z1
  890 DIF=CRDIUS-DABS(OFFSET)
      GO TO 990
  900 IF ((CENLEN+OFFSET-CRDIUS).LT.TAU1(IS)) GO TO 940
      IF (S(IS).LE.Z0) GO TO 1390
      IF(IFAR(IS).EQ.K2) GO TO 940
      IF(DABS(DSMOV)+CUTDAT(1)-CRDIUS-TAU2(IS)) 930,930,940
  930 ZIGN=-Z1
      GO TO 890
  940 ZIGN=Z1
      GO TO 870
  950 IF (S(IS).LE.Z0) GO TO 1380
      DSMOV=DSMOV+OFFSET
      IF (DABS(CRDIUS-DABS(DSMOV+S(IDS))).GT.TAU(IS)) GO TO 1370
      TEN=OFFSET-DSIGN(Z1,DSMOV)*CRDIUS
      FIPNT(1)=CCENTR(1)+TEN*SN(1,IDS)
      FIPNT(2)=CCENTR(2)+TEN*SN(2,IDS)
      GO TO 1300
  990 TEMP(1)=DIF**2-DSMOV**2
      IF (TEMP(1)) 1380,1010,1000
 1000 S(IS)=S(IS)+ZIGN*DSQRT(TEMP(1))
 1010 IF(S(IS)+Z1EM5)1390,1390,1020
 1020 FIPNT(1) = TE(1)+S(IS)*ZMOSHN(1)
      FIPNT(2) = TE(2)+S(IS)*ZMOSHN(2)
      GO TO 1300
C
C     COMPUTE INTERMEDIATE CUT VECTORS AROUND CYLINDRICAL DS
C
 1030 DIFOUT=DIF
      RONE=DABS(DIF-TAU(IDS))
      COSTH=RONE/RZEROL
      TEMP(1)=Z1-COSTH**2
      IF(TEMP(1)+Z1EM5)1350,1350,1050
 1050 SINTH = DSQRT(DABS(TEMP(1)))
      HCHORD=SINTH*RZEROL
      CHORD=Z2*HCHORD
      DNMOT(1)=RZERO(1)/RZEROL
      DNMOT(2)=RZERO(2)/RZEROL
      ZIGN=Z1
      TANMOT(1)=DNMOT(2)
      TANMOT(2)=-DNMOT(1)
      IF(TANMOT(1)*TI(1)+TANMOT(2)*TI(2))1070,1080,1080
 1070 TANMOT(1)=-TANMOT(1)
      TANMOT(2)=-TANMOT(2)
      ZIGN=-Z1
 1080 TE(1)=TEK(1)+CHORD*(SINTH*DNMOT(1)+COSTH*TANMOT(1))
      TE(2)=TEK(2)+CHORD*(SINTH*DNMOT(2)+COSTH*TANMOT(2))
      D2(1)=TE(1)-TEK(1)
      D2(2)=TE(2)-TEK(2)
      D2(3)=Z0
      D=DSQRT(D2(1)*D2(1)+D2(2)*D2(2))
      IF(D.LE.Z0)GO TO 1095
      D2(1)=D2(1)/D
      D2(2)=D2(2)/D
      GO TO 1100
1095  D2(1)=ZMOSHN(1)
      D2(2) = ZMOSHN(2)
      HCHORD=Z0
 1100 TEMP(10) = DSQRT(DIFOUT**2-RONE**2)
      DELMOT(1)=TEMP(10)-HCHORD
      TE(1)=TE(1)+DELMOT(1)*D2(1)
      TE(2)=TE(2)+DELMOT(1)*D2(2)
      STVEC(1)=FIPNT(1)-DCENTR(1)
      STVEC(2)=FIPNT(2)-DCENTR(2)
      TEMP(1)=DSQRT(STVEC(1)**2+STVEC(2)**2)
      TEMP(2)=STVEC(1)/TEMP(1)
      TEMP(3)=STVEC(2)/TEMP(1)
      IF (RONE.LE.Z1EM5) GO TO 1250
      TEMP(1)=TEMP(2)*DNMOT(1)+TEMP(3)*DNMOT(2)
      TEMP(8) = ZMOSHN(1)*STVEC(1)+ZMOSHN(2)*STVEC(2)
      IF(DABS(TEMP(1))-Z1EM7.LT.Z0) GO TO 1150
      TEMP(11)=Z1-TEMP(1)**2
      IF (TEMP(11).LT.Z0) TEMP(11) = Z0
      ZGAMMA=DATAN(DSQRT(TEMP(11))/TEMP(1))
      IF(TEMP(1))1160,1190,1190
 1150 ZGAMMA= -PI/Z2
 1160 IF(TEMP(8)-Z1EM7) 1180,1180,1170
 1170 PSI=-ZGAMMA
      GO TO 1220
 1180 PSI = Z2*PI + ZGAMMA
      GO TO 1220
 1190 IF (TEMP(8).LT.Z0) GO TO 1210
      PSI = PI - ZGAMMA
      GO TO 1220
 1210 PSI = PI + ZGAMMA
 1220 TEMP(1) = DATAN (TEMP(10)/RONE)
      THETA = TEMP(1) + DATAN (SINTH/COSTH)
      ALPHA = Z2*TEMP(1)
      PSI=PSI+Z2*PI*RADNO
      IF(PSI-THETA)1230,1240,1240
 1230 IF(DSQRT((FIPNT(1)-TEK(1))**2+(FIPNT(2)-TEK(2))**2)-Z2*EPS1(IS))
     1    1260,1300,1300
 1240 IF(PSI-THETA-ALPHA)1250,1270,1270
 1250 CONTINUE
      ZZ = Z1
      IA = K2
      IB = K1
      IF ((TEMP(2)*DNMOT(1)+TEMP(3)*DNMOT(2))-Z1) 1251,1252,1251
 1251 ZZ = -Z1
      IA = K1
      IB = K2
 1252 CONTINUE
      TEMP(1) = TEMP(2) + ZZ*DNMOT(1)
      TEMP(2) = TEMP(3) + ZZ*DNMOT(2)
      TEMP(3)=Z0
      CALL VNORM(TEMP(1),TEMP(1))
C     CALCULATE TOOL POSITION AFTER FIRST CUT AS BEING MIDWAY BETWEEN
C     STARTING POSITION AND FINAL POINT
      TE(1) = DIFOUT*TEMP(IA)+DCENTR(1)
      TE(2) = -ZZ*DIFOUT*TEMP(IB)+DCENTR(2)
      ASSIGN 1300 TO JRETN
      IF (IA - K1) 1255,1255,1253
 1253 IF (TE(1)*ZMOSHN(1) + TE(2)*ZMOSHN(2)) 1254,1255,1255
 1254 TE(1) = -TE(1)
      TE(2) = -TE(2)
C
C     INTERMEDIATE TE OUTPUT. INVERSE ROTATE + Z-CORRECT.
C
1257  TEK(3)=TE(3)
1258  TEK(1)=TE(1)
      TEK(2)=TE(2)
1255  IF(IFROT.EQ.1) CALL ROTAT(TE,B)
      ASSIGN 1256 TO IRETN
      GO TO 1341
1256  CALL ATAPE
      GO TO JRETN,(1271,1281,1300)
 1260 PSI = PSI+Z2*PI
 1270 PSI=PSI-THETA
      ASSIGN 1271 TO JRETN
      GO TO 1257
1271  NPTS=(PSI/ALPHA)+Z1
      ZNPTS=NPTS
      THETA=Z5EM1*PSI/ZNPTS
      COSTH=DCOS(THETA)
      SINTH=DSIN(THETA)
      CHORD=Z2*DIFOUT*SINTH
      EL1=CHORD*COSTH
      EL2=CHORD*SINTH
      DNMOT(1)=DCENTR(1)-TEK(1)
      DNMOT(2)=DCENTR(2)-TEK(2)
      TEMP(1)=DSQRT(DNMOT(1)**2+DNMOT(2)**2)
      DNMOT(1)=DNMOT(1)/TEMP(1)
      DNMOT(2)=DNMOT(2)/TEMP(1)
 1280 TANMOT(1)=DNMOT(2)*ZIGN
      TANMOT(2)=-DNMOT(1)*ZIGN
      DELMOT(1) = EL1*TANMOT(1) + EL2*DNMOT(1)
      DELMOT(2) = EL1*TANMOT(2) + EL2*DNMOT(2)
      DNMOT(1)=(DCENTR(1)-TEK(1)-DELMOT(1))/TEMP(1)
      DNMOT(2)=(DCENTR(2)-TEK(2)-DELMOT(2))/TEMP(1)
      TE(1)=DCENTR(1)-DIFOUT*DNMOT(1)
      TE(2)=DCENTR(2)-DIFOUT*DNMOT(2)
      TE(3)=TEK(3)
      NPTS=NPTS-K1
      ASSIGN 1281 TO JRETN
      GO TO 1258
C
C     INTERMEDIATE TE OUTPUT. INVERSE ROTATE + Z-CORRECT.
C
1281  IF(NPTS-K1)1300,1300,1280
 1300 TE(1)=FIPNT(1)
      TE(2)=FIPNT(2)
      TN(3,ICS) = 0.
      IF (ISFIDN(IS).GT.K2) GO TO 1301
      TN(1,ICS) = CCENTR(1)
      TN(2,ICS) = CCENTR(2)
      GO TO 1302
 1301 TN(1,ICS) = CCENTR(1) - TE(1)
      TN(2,ICS) = CCENTR(2) - TE(2)
      CALL VNORM(TN(1,ICS),TN(1,ICS))
 1302 IF (ITLON(ICS)) 1305,1304,1305
 1304 TP(1,ICS) = TE(1)
      TP(2,ICS) = TE(2)
      TP(3,ICS) = TE(3)
      GO TO 1306
 1305 TP(1,ICS) = TE(1) + TOOLWD(ICS)*TN(1,ICS)
      TP(2,ICS) = TE(2) + TOOLWD(ICS)*TN(2,ICS)
      TP(3,ICS) = TE(3) + TOOLHT(3,ICS)
C
C     SYSTEM INVERSE ROTATION + ZCORRECTION
C
 1306 IF(IFROT.EQ.K0) GO TO 1308
      IDONE = 1
      DO 1307 I=1,3
      DO 1307 J=1,3
 1307 A(I,J) = B(I,J)
      GO TO 11
1308  ASSIGN 1410 TO IRETN
      GO TO 1341
C
C     LINE DS, LINE CS
C
1310  TN(1,IS)=ZMOSHN(1)
      TN(2,IS)= ZMOSHN(2)
      TN(3,IS)= Z0
      TP(1,IS)=TE(1)
      TP(2,IS)=TE(2)
      TP(3,IS)=TE(3)
      ASSIGN 1320 TO LRETN
      GO TO 1420
1320  IF(ISFTYP(IS).EQ.K3)GO TO 1010
      DINC = CUTDAT(1)/DABS(CNRMAL(1)*ZMOSHN(1)+CNRMAL(2)*ZMOSHN(2))
      IF(ISFTYP(IS).NE.K1) GO TO 1340
      S(IS)=S(IS)-DINC
      GO TO 1010
 1340 S(IS)=S(IS)+DINC
      GO TO 1010
1341  IF(DOPSTA.EQ.Z0)GO TO 1345
      PROJ=TE(1)*CANSTO(1)+TE(2)*CANSTO(2)+TE(3)*CANSTO(3)
      PROJ=(PROJ-DVALUI)/DOPSTA
      TE(1)=TE(1)-PROJ*TA(1)
      TE(2)=TE(2)-PROJ*TA(2)
      TE(3)=TE(3)-PROJ*TA(3)
1345  GO TO IRETN,(24,1256,1410)
 1350 IER= 23901
      GO TO 1400
 1360 IER= 23902
      GO TO 1400
 1370 IER= 23903
      GO TO 1400
 1380 IER= 23904
      GO TO 1400
 1390 IER= 23905
 1400 CALL AERR(IER,'ARLM2   ')
 1410 ICL=K3
      CALL ATAPE
      GO TO 1470
1420  IC=ICANON(IS)
      IF(ISFIDN(IS).GT.K2)GO TO 1430
C
C     ***PLANES AND LINES***
C
      DK=CANON(IC+3)-CANON(IC)*TP(1,IS)-CANON(IC+1)*TP(2,IS)
     1   -CANON(IC+2)*TP(3,IS)
      DOT=CANON(IC)*TN(1,IS)+CANON(IC+1)*TN(2,IS)+CANON(IC+2)*TN(3,IS)
C--- CII UPDATE TO DIAGNOZE NON-PARALLEL DRIVE-CHECK SURFACE
      IF(DABS(DOT).LT.Z1EM7) GO TO 1390
      S(IS)=DK/DOT
      GO TO 1460
C
C     ***CIRCLES AND CYLINDERS***
C
1430  TEM(1)=TP(1,IS)-CANON(IC)
      TEM(2)=TP(2,IS)-CANON(IC+1)
      DK=DSQRT(TEM(1)*TEM(1)+TEM(2)*TEM(2))
      IF(DK.GE..0001)GO TO 1440
      SNL(1,1)=TN(1,IS)
      SNL(2,1)=TN(2,IS)
      V=1.0
      GO TO 1450
1440  SNL(1,1)=TEM(1)/DK
      SNL(2,1)=TEM(2)/DK
      DK=-SNL(1,1)*TEM(1)-SNL(2,1)*TEM(2)
      V=DSIGN(Z1,DK)
1450  SP(1,IS)=V*SNL(1,1)*CANON(IC+6)
      SP(2,IS)=V*SNL(2,1)*CANON(IC+6)
      S(IS)=(SP(1,IS)-TEM(1))*TN(1,IS)+(SP(2,IS)-TEM(2))*TN(3,IS)
1460  GO TO LRETN,(270,1320)
1470  RETURN
      END
**** SOURCE FILE : M0004302.W04   ***
*
C.....FORTRAN SUBROUTINE   ...ARLM3              8/68                PH
C.....FORTRAN SUBROUTINE             ARLM3...               4/8/68   GK
      SUBROUTINE ARLM3
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C...  21. ADDCOM BLOCK
C
      COMMON/ADDCOM/ ADDCOM
      DIMENSION ADDCOM(25),TNSAV(3),TPSAV(3),U1SAV(3)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),  (ADDCOM( 2),CLNGTH),
     1            (ADDCOM(23),IBTFLG),  (ADDCOM(24),JLIN),
     2            (ADDCOM(25),KDYNFL)
C
      DIMENSION VTSAV(3),SPSAV(3)
      INCLUDE 'CGOUG.INC'
C
      DATA ZLIT1,K11,K14,K17,K20,K21,K22/.125D0,11,14,17,20,21,22/
      DATA ZERO/0.D0/
C
C        USE RC1SC FOR PROPER UNITS/ IMPLEMENTATION
      RC1SC = RC1/4500.D0
      GFLG=ZERO
      NUMPT1=NMPNTS
      CLNGTH = K0
      JPR1 = K0
      JPR2 = ICSCNT
      ILS1=ICS+(ICSCNT-K1)*LSV1
C                  INITIALIZATION FOR EACH CS.
      DO 100 I=1,3
      TEK(I)=TE(I)
      TEW(I)=TE(I)
  100 TAK(I)=TA(I)
      IF((IPL(IPS).EQ.K0).OR.(IPL(IDS).EQ.K0)) GO TO 130
      IPDPL=K1
      GO TO 140
  130 IPDPL=0
  140 DO 150 I=1,3
C... SAVE PREVIOUS TI VALUE IN TALT
      TALT(I)=TI(I)
      TIK(I)=TI(I)
      DO 150 K=ICS,ILS1,LSV1
      TN(I,K)=TI(I)
  150 CONTINUE
  160 J12=0
      JAA = K0
      IS=ICS
      J10=K1
      DP=DPMAX
      DPL=DPMAX
      DO 170 I=ICS,ILS1,LSV1
      J20(I)=0
      J23(I)=K1
      J50(I)=-IPDPL
      J51(I)=0
      JPH(I)=0
      NOTAN(I) = 0
  170 DPMX1(I)=DPMAX
      INMBR = K11
      ASSIGN 175 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
  175 IF(IPDPL) 180,310,180
C                  CALL CHECK FOR CSD. ADJUST DP SO CS NOT PASSED ON
C                  FIRST DP STEP-OUT.
  180 CONTINUE
      INMBR = K12
      ASSIGN 190 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
  190 DO 200 L=1,3
  200 TA(L)=TAK(L)
  210 IS=ICS
      JPR2 = -K1
      IWS=IS
      DP1 = Z1E6*RC1SC
  220 IF (ISFTYP(IS) - 99) 221,460,460
  221 TE(1) = TEW(1)
      TE(2)=TEW(2)
      TE(3)=TEW(3)
      JPR2 = ICSCNT
      ASSIGN 230 TO IRETN
      GO TO 9010
  230 IF (IER.NE.0) THEN
C.... OUTPUT WARNING IF NEGATIVE DISTANCE TO CS AT START OF CUT
        INMBR=-24007
        CALL AERR(INMBR,'ARLM3')
      ENDIF
      J50(IS)=(J50(IS)+K1)/K2
  231 CONTINUE
      IF(Z1*RC1SC-CSD(IS)) 232,238,238
  232 IF(IPDPL) 236,260,236
  260 IF(DP-CSD(IS)) 234,234,239
  234 IF(CSD(IS)-Z2*DP) 235,241,241
  235 DP=Z6EM1*CSD(IS)
      GO TO 241
  236 IF(CSD(IS)-DP) 237,237,241
  237 DP=Z9EM1*CSD(IS)
      GO TO 241
  238 IF(DABS(CSD(IS))-TAU(IS)) 240,260,260
  239 DP=CSD(IS)
      GO TO 241
  240 DP=TAU(IS)
  241 GO TO 430
C                  DS AND PS NOT BOTH PLANE. THUS INITIAL STEP-OUT +
C                  CENTR + DELTA FOR INITIAL VALUE DP.
  310 DO 320 L=1,3
  320 TE(L) = TE(L)+ZLIT1*RC1SC*TI(L)
      ASSIGN 330 TO IRETN
      GO TO 9020
  330 IF (JCR.EQ.K0) GO TO 350
      DP=Z1EM2*DPMAX
      GO TO 180
  350 ASSIGN 360 TO IRETN
      GO TO 9030
  360 IF (JDR.NE.K0) GO TO 180
      IF(DPL.GT.DPMAX) GO TO 390
      DP=DPL
      GOTO 180
C
  390 DP=DPMAX
      GO TO 180
C                  DO ADJUSTMENT OF DP FOR ALL CS. SET DP TO ITS MIN
C                  VALUE, AND IWS TO THE CORRESPONDING IS.
  430 CONTINUE
      INMBR = K13
      ASSIGN 440 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
  440 IF(DP-DP1)450,460,460
  450 IWS=IS
      DP1=DP
  460 IS=IS+LSV1
      IF (ILS1.GE.IS) GO TO 220
      IS=IWS
      IF (JPR2)461,462,462
 461  INMBR = 24006
      GO TO 9040
C                  SET DPCNT TO 10. (ERROR 801 WHEN 0.0). IF CS NEAR
C                  (J50=1) AND PS,DS NOT BOTH PLANE THEN BRANCH
  462 DPCNT=30.0
      DP=DP1
      IF((J50(IS).GT.K0).AND.(IPDPL.EQ.K0)) GO TO 750
  490 DO 500 I=1,3
  500 TEL(I)=TE(I)
      IF (IPDPL.NE.K0) GO TO 600
      ITSAV=ITSEG(IPS)
      DO 520 I=1,3
      TNSAV(I)=TN(I,IPS)
      TPSAV(I)=TP(I,IPS)
      U1SAV(I)=U1(I,IPS)
      VTSAV(I)=VT(I,IPS)
      SPSAV(I)=SP(I,IPS)
  520 TES(I)=TEK(I)
C                  ********** MAIN LOOP. STEP-OUT DP. *****************
C                  ***** BRANCH IF DS,PS BOTH PLANE. ELSE CENTR TO ****
C                  ***** PS,DS AND THEN DELTA. IF CUT VECTOR TOO   ****
C                  ***** LONG (JDR=1),THEN TRY AGAIN WITH SHORTER  ****
C                  ***** CUT VECTOR. IF DPCNT=1, FAIL           *******
C                        CODING 580 TO 600 FOR SETTING CS FAR AWAY
 530  DO 540 I=1,3
      TA(I)=TAK(I)
      CMOVE(I)=DP*TIK(I)
  540 TE(I)=TES(I)+CMOVE(I)
      INMBR = K14
      ASSIGN 550 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
  550 IF (IPDPL.NE.K0) GO TO 1250
      ASSIGN560 TO IRETN
      GO TO 9020
  560 INMBR = K15
      ASSIGN 565 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
  565 IF (JCR.EQ.K0) GO TO 620
      IF(DPCNT.GT.Z1) GO TO 636
      INMBR = 24001
      GO TO 9040
  580 J20(IS)=K1
      J21(IS)=K1
      CSD(IS)=Z0
      STCK(IS)=Z1
      JPH(IS) = K1
      DO 590 I=1,3
      TE(I)=TEK(I)
  590 TA(I)=TAK(I)
      J50(IS)=0
      J51(IS)=0
      GO TO 490
  600 DO 610 I=1,3
  610 TES(I)=TE(I)
      GO TO 530
  620 J10=0
      ASSIGN 630 TO IRETN
      GO TO 9030
  630 INMBR = K16
      ASSIGN 635 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
  635 IF (JDR.EQ.K0) GO TO 700
      IF (DPCNT.EQ.Z1) GO TO 1460
  636 DPCNT=DPCNT-Z1
      ITSEG(IPS)=ITSAV
      DO 660 I=1,3
      TP(I,IPS)=TPSAV(I)
      TN(I,IPS)=TNSAV(I)
      U1(I,IPS)=U1SAV(I)
      VT(I,IPS)=VTSAV(I)
      SP(I,IPS)=SPSAV(I)
  660 CONTINUE
      GO TO 530
C                  CUT VECTOR OKED BY DELTA. COMPUTE NEW TI
  670 IF(TI(1)*TIK(1)+TI(2)*TIK(2)+TI(3)*TIK(3)) 680,730,730
  680 DO 690 I=1,3
  690 TI(I)=-TI(I)
      GO TO 730
  700 CONTINUE
      DO 701 I=1,3
        TALT(I)=TI(I)
  701 CONTINUE
      CALL CROSS (SN(1,IPS),SN(1,IDS),TI)
      CALL VNORM(TI,TI)
      IF(IER)710,670,710
  710 DO 720 I=1,3
  720 TI(I)=TE(I)-TEK(I)
      CALL VNORM(TI,TI)
C                  CALL CHECK FOR CSD. IF JCKR = 0, CS NOT NEAR AND TE
C                  IS OUTPUT TO ATAPE. IF JCKR = 1, CS NEAR. THEN SET
C                  TEE TO TE AND DO 3 SURF CENTR,DS,PS,CS.
  730 ASSIGN 740 TO IRETN
      GO TO 9010
  740 INMBR = K17
      ASSIGN 745 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
  745 IF (JCKR.EQ.K0) GO TO 840
  750 TEE(1,IS)=TE(1)
      TEE(2,IS)=TE(2)
      TEE(3,IS)=TE(3)
      ASSIGN 760 TO IRETN
      GO TO 9020
C                  JCR RETURN FROM 3 SURF PS,DS,CS CENTR  HAS 3 VALUES.
C                  JCR =-1,RESTART CONDITION. IF GT 1 CS, SET FIRST
C                  CS FAR AWAY. STEP-OUT DP ETC. JCR =2, FALSE TANGENCY.
C                  IN THIS CASE IF CENTR MOVE IN TI DIRECTION, RESET
C                  CS FAR AWAY. OTHERWISE IGNORE THIS CENTR MOVE.
C                  IF JCR=0, 3 SURF O.K. GO TO 940.
  760 IF(JCR-K1)770,940,790
  770 IF (ICSCNT.GT.K1) GO TO 830
      INMBR = 24002
      GO TO 9040
  790 IF((TE(1)-TEE(1,IS))*TI(1)+(TE(2)-TEE(2,IS))*TI(2)+(TE(3)-
     1  TEE(3,IS))*TI(3)) 800,800,1090
  800 S(IS)=Z0
      TE(1)=TEE(1,IS)
      TE(2)=TEE(2,IS)
      TE(3)=TEE(3,IS)
      ISTO=IS
      IS=IPS
      ASSIGN 810 TO IRETN
      GO TO 9050
  810 IS=IDS
      ASSIGN 820 TO IRETN
      GO TO 9050
  820 IS=ISTO
      GO TO 840
  830 S(IS)=Z5*DP
      GO TO 180
C                  CS NOT REACHED IN DP STEP-OUT. THEREFORE TE OUTPUT.**
C                  CHECK NMPNTS AND CLNGTH O.K. UPDATE TEK ETC
  840 ASSIGN 846 TO IRETN
      GO TO 9060
  846 DO 847 I = 1,3
  847 TEMP(I) = TE(I) - TEK(I)
  848 TEMP(4) =DSQRT(TEMP(1)*TEMP(1)+TEMP(2)*TEMP(2)+TEMP(3)*TEMP(3))
      CLNGTH = CLNGTH + TEMP(4)
      IF (ELMAX - CLNGTH) 849,850,850
  849 INMBR = 24005
      GO TO 9040
  850 IF (NUMPT1.GT.K0) GO TO 870
      INMBR = 24003
      GO TO 9040
  870 NUMPT1=NUMPT1-K1
      INMBR = K18
      ASSIGN 875 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
  875 DO 900 I=1,3
      TEK(I)=TE(I)
      TAK(I)=TA(I)
      TIK(I)=TI(I)
      DO 900 J=IPS,NUMSUR
      TPK(I,J)=TP(I,J)
      SPK(I,J)=SP(I,J)
      SNK(I,J)=SN(I,J)
      SK(I,J) = S(J)
      U1K(I,J)=U1(I,J)
  900 CONTINUE
      IPCHNL=IPCHN
      DP1=DP
      ITSEGK(IPS) = ITSEG(IPS)
      ITSEGK(IDS) = ITSEG(IDS)
      IF (J20(IS).NE.K2) GO TO 920
C                  TERMINATING CUT SEQUENCE COMPUTATION. RESTORE SURF
C                  DATA AT TEE POSITION.
      TE(1)=TEE(1,IS)
      TE(2)=TEE(2,IS)
      TE(3)=TEE(3,IS)
      TA(1)=TAL(1)
      TA(2)=TAL(2)
      TA(3)=TAL(3)
      TP(1,IPS)=PS1
      TP(2,IPS)=PS2
      TP(3,IPS)=PS3
      SN(1,IPS)=PS4
      SN(2,IPS)=PS5
      SN(3,IPS)=PS6
      SP(1,IPS)=PS7
      SP(2,IPS)=PS8
      SP(3,IPS)=PS9
      TP(1,IDS)=DS1
      TP(2,IDS)=DS2
      TP(3,IDS)=DS3
      SN(1,IDS)=DS4
      SN(2,IDS)=DS5
      SN(3,IDS)=DS6
      SP(1,IDS)=DS7
      SP(2,IDS)=DS8
      SP(3,IDS)=DS9
      GO TO 1070
C                  NON-TERMINATING CUT VECTOR. IF MORE THAN ONE CS,
C                  RETURN TO FIND CRITICAL CS.ELSE GO TO DP STEP-OUT.
  920 IS=ICS
      IF (ICSCNT.LE.K1) GO TO 260
      TEW(1)=TE(1)
      TEW(2)=TE(2)
      TEW(3)=TE(3)
      GO TO 220
C                  3 SURF CENTR TO PS,DS,CS O.K. IF ANY CS VIOLATED
C                  IN THIS MOVE,INDEX THIS AS CRITICAL CS,AND AGAIN DO
C                  3 SURF CENTR.
  940 TEE(1,IS)=TE(1)
      TEE(2,IS)=TE(2)
      TEE(3,IS)=TE(3)
      IWS=IS
      IS=ICS
      INMBR = K19
      ASSIGN 950 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
  950 IF (IS.GT.ILS1) GO TO 1040
      IF (IS.EQ.IWS) GO TO 1030
      ASSIGN 980 TO IRETN
      GO TO 9050
  980 IF (ISFTYP(IS) - K4) 981,1010,981
  981 IF (J23(IS).GT.K0) GO TO 1030
      STCK(IS)=S(IS)*Z(IS)*STCK1(IS)
      INMBR = K20
      ASSIGN 1000 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
 1000 IF(STCK(IS))750,750,1030
 1010 IF(J22(IS))1030,1030,1020
 1020 IT = IDS
      IF (IFL4(IS)) 1021,1022,1021
 1021 IT = IPS
 1022 TEMP(1) = (SP(1,IS)-SP(1,IT))*TN(1,IS)
     1        + (SP(2,IS)-SP(2,IT))*TN(2,IS)
     2        + (SP(3,IS)-SP(3,IT))*TN(3,IS)
      STCKN(IS) = TEMP(1)*(TN(1,IS)*TI(1)+TN(2,IS)*TI(2)+TN(3,IS)*TI(3))
      INMBR  = K21
      ASSIGN 1025 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
 1025 IF(STCKN(IS))750,750,1030
 1030 IS=IS+LSV1
      GO TO 950
C                  CRITICAL CS INDEXED. COMPUTE TI AND SAVE SURF DATA.
C                  COMPUTE V=TEE - TEK. IF THIS MOVE BACKWARDS,SET
C                  S = 5*DP TO  SET THIS CS FAR AWAY
 1040 IS=IWS
      TAL(1)=TA(1)
      TAL(2)=TA(2)
      TAL(3)=TA(3)
      CALL CROSS(SN(1,IPS),SN(1,IDS),TIL)
      CALL VNORM(TIL,TIL)
      IF (IER.EQ.K0) GO TO 1060
      TIL(1)=TE(1)-TEK(1)
      TIL(2)=TE(2)-TEK(2)
      TIL(3)=TE(3)-TEK(3)
      CALL VNORM(TIL,TIL)
 1060 PS1=TP(1,IPS)
      PS2=TP(2,IPS)
      PS3=TP(3,IPS)
      PS4=SN(1,IPS)
      PS5=SN(2,IPS)
      PS6=SN(3,IPS)
      PS7 = SP(1,IPS)
      PS8 = SP(2,IPS)
      PS9 = SP(3,IPS)
      DS1=TP(1,IDS)
      DS2=TP(2,IDS)
      DS3=TP(3,IDS)
      DS4=SN(1,IDS)
      DS5=SN(2,IDS)
      DS6=SN(3,IDS)
      DS7 = SP(1,IDS)
      DS8 = SP(2,IDS)
      DS9 = SP(3,IDS)
 1070 DO 1080 I=1,3
 1080 V(I)=TE(I)-TEK(I)
      AAB = V(1)*TIK(1)+V(2)*TIK(2)+V(3)*TIK(3)
C     IF(DABS(AAB)- 0.2*TAU(IS))1090,1090,1085
 1085 IF(AAB)1090,1100,1100
 1090 S(IS)=Z5*DP
      GO TO 580
C                  MOVE V FORWARD. REVERSE TN(CS) AND RE-DO 3 SURF
C                  CENTR FOR 'PAST' CASE. TEST IF V O.K. BY DELTA
 1100 VL=DSQRT(V(1)*V(1)+V(2)*V(2)+V(3)*V(3))
      IF (ISFTYP(IS).EQ.K4) GO TO 1130
      IF((TN(1,IS)*(TE(1)-TEK(1))+TN(2,IS)*(TE(2)-TEK(2))+
     1TN(3,IS)*(TE(3)-TEK(3)))*PAST(IS))1120,1130,1130
 1120 J50(IS)=K1
      J51(IS)=K1
      PLND1(IS)=0
      NOTAN(IS)=0
      TN(1,IS)=-TN(1,IS)
      TN(2,IS)=-TN(2,IS)
      TN(3,IS)=-TN(3,IS)
      GOTO 750
 1130 J10=K1
      ASSIGN 1140 TO IRETN
      GO TO 9030
 1140 INMBR = K22
      ASSIGN 1145 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
 1145 IF (JDR.EQ.K0) GO TO 1200
C                  MOVE V NOT O.K. BY DELTA. CSD = 1.2*LENGTH V
C                  ADJUST VALUE OF DP. SET J20=2 FOR SPECIAL
C                  CUT SEQUENCE TERMINATING CALCULATIONS.
      CSD(IS) = Z12EM1*VL
      IF (DP.GT.CSD(IS)) GO TO 1180
      IF (CSD(IS).LT.Z2*DP) DP = Z6EM1*CSD(IS)
      GO TO 1190
 1180 DP=CSD(IS)
 1190 DPCNT=Z10
      J50(IS)=0
      J51(IS)=0
      J20(IS)=K2
      INMBR = K23
      ASSIGN 490 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
      GO TO 490
C                  MOVE V O.K.. TEST IFAR FOR CORRECT INTERSECTION
 1200 JPR2 = ICSCNT
      IF (IFAR(IS).EQ.K1) GO TO 1420
      IFAR(IS)=IFAR(IS)-K1
      IF (IPDPL.NE.K0) GO TO 1230
      ASSIGN 1220 TO IRETN
      GO TO 9060
1220  TV=TI(1)*TIL(1)+TI(2)*TIL(2)+TI(3)*TIL(3)
      TEMP(1)=DSIGN(Z1,TV)
      TI(1)=TEMP(1)*TIL(1)
      TI(2)=TEMP(1)*TIL(2)
      TI(3)=TEMP(1)*TIL(3)
 1230 DO 1240 I=1,3
      TEK(I)=TE(I)
      TAK(I)=TA(I)
 1240 TEW(I)=Z3*TAU(IS)*TI(I)+TE(I)
      JAA = K1
      GO TO 140
C
C                  ********** SPECIAL ROUTE. DS,PS BOTH PLANE,
C
 1250 ASSIGN 1260 TO IRETN
      GO TO 9070
 1260 INMBR = K24
      ASSIGN 1265 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
 1265 IF (JPR) 1280,1270,1266
 1266 JPR1 = 0
      GO TO 1290
 1270 TEW(1)=TE(1)
      TEW(2)=TE(2)
      TEW(3)=TE(3)
      GO TO 210
C
C     FALSE TANGENCY - MOVE AWAY FROM STOPPING POINT.
C
 1280 IF (JPR+K2) 1351,1351,1281
 1281 IF ((TE(1)-TEW(1))*TI(1)+(TE(2)-TEW(2))*TI(2)+(TE(3)-TEW(3))*TI(3)
     1    ) 1352,1352,1282
 1282 TE(1) = Z5EM1*RC1SC*TI(1)+TE(1)
      TE(2) = Z5EM1*RC1SC*TI(2)+TE(2)
      TE(3) = Z5EM1*RC1SC*TI(3)+TE(3)
C
C     IS THIS THE ONLY CHECK SURFACE
C
 1290 IWS=IS
      IS=ICS
 1300 IF(ILS1-IS)1310,1330,1330
 1310 IS=IWS
      IF (JPR) 1311,1200,1200
C     LOOK FOR TRUE INTERSECTION WITH CHECK SURFACE
 1311 TEW(1) = TE(1)
      TEW(2) = TE(2)
      TEW(3) = TE(3)
      GO TO 160
 1320 IS=IS+LSV1
      GO TO 1300
 1330 IF (IS-IWS) 1331,1320,1331
 1331 IF (ISFTYP(IS)-99)1332,1320,1320
 1332 IF (JPR2) 1310,1310,1333
 1333 IF (ISFTYP(IS)-K4) 1334,1340,1340
 1334 TN(1,IS) = PAST(IS)*TI(1)
      TN(2,IS) = PAST(IS)*TI(2)
      TN(3,IS) = PAST(IS)*TI(3)
 1340 JWR =0
      JENT(IS)=K1
      IOPSET(IS)=0
      JTN(IS) = K1
      JU1(IS) = K1
      JIOPS(IS) = 0
      ASSIGN 1348 TO IRETN
      GO TO 9050
 1348 IF (ISFTYP(IS)-K4)1349,1400,1349
 1349 IF (J23(IS).GT.K0) GO TO 1320
      STCK(IS)=STCK1(IS)*Z(IS)*S(IS)
      INMBR = K25
      ASSIGN 1350 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
 1350 IF (STCK(IS).GT.K0) GO TO 1320
      GO TO 1380
C     MOVE WAS BACKWARDS - RESTART TWICE THEN GIVE UP
C
 1351 JPR1 = JPR1 + K1
      IF (JPR1 - K2) 1270,1353,1352
C     THIS SURFACE INVALID - ELIMINATE FROM CONSIDERATION
C
 1352 ISFTYP(IS) = 99
      JPR1 = 0
      TE(1) = TEK(1)
      TE(2) = TEK(2)
      TE(3) = TEK(3)
      GO TO 1270
 1353 S(IS) = S(IS)+Z2*DP
      GO TO 1270
 1380 DO 1390 I=1,3
 1390 TE(I)=TEL(I)
      JPR2 = JPR2 - K1
      DP=Z11EM1*CSD(IS)
      GO TO 1250
 1400 IF(J22(IS))1320,1320,1410
 1410 IT = IDS
      IF (IFL4(IS)) 1411,1412,1411
 1411 IT = IPS
 1412 TEMP(1) = (SP(1,IS)-SP(1,IT))*TN(1,IS)
     1         +(SP(2,IS)-SP(2,IT))*TN(2,IS)
     2         +(SP(3,IS)-SP(3,IT))*TN(3,IS)
      STCKN(IS)=TEMP(1)*(TN(1,IS)*TI(1)+TN(2,IS)*TI(2)+TN(3,IS)*TI(3))
      INMBR = K26
      ASSIGN 1415 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
 1415 IF(STCKN(IS))1380,1380,1320
 1420 CONTINUE
      INMBR = K27
      ASSIGN 1430 TO IRETN
      IF (KDYNFL.NE.K0) GO TO 9000
 1430 ICL=K3
 1440 ASSIGN 1445 TO IRETN
      GO TO 9060
 1445 TEMP(1)=((IS-ICS)/LSV1)+K1
 1450 CONTINUE
      RETURN
 1460 INMBR = 24004
      GO TO 9040
C
C     ALL CALLS EXCEPT THOSE TO VNORM AND CROSS HAVE BEEN PLACED IN THIS
C     SECTION TO MINIMIZE STORAGE REQUIREMENTS OF THE 360
C
 9000 CALL APT238(INMBR)
      GO TO IRETN, (175,190,550,565,635,745,875,950,1000,1025,1145,
     1   440,490,1265,1350,1415,1430)
 9010 CALL CHECK
      IF (IAERR.GT.K0) GO TO 1450
      GO TO IRETN, (230,740)
 9020 CALL CENTR
      IF (IAERR.GT.K0) GO TO 1450
      GO TO IRETN, (330,560,760)
 9030 CALL DELTA
      IF (IAERR.GT.K0) GO TO 1450
      GO TO IRETN, (360,630,1140)
 9040 CALL AERR (INMBR,'ARLM3   ')
      GO TO 1450
 9050 CALL AMIND
      IF (IAERR.GT.K0) GO TO 1450
      GO TO IRETN, (810,820,980,1348)
 9060 CALL ATAPE
      GO TO IRETN, (846,850,1220,1445)
 9070 CALL PLANE
      IF (IAERR.GT.K0) GO TO 1450
      GO TO IRETN, (1260)
      END
**** SOURCE FILE : M0000869.V05   ***
*
C...  FORTRAN SUBROUTINE               AUTOPS
      SUBROUTINE AUTOPS
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
C
      INCLUDE 'BLANKCOM.INC'
C
      IF(JDS) CALL APT201(0,'NOCS    ')
      CANON(1)=Z0
      CANON(2)=Z0
      CANON(3)=Z1
      CANON(4)=TE(3)
      ISFIDN(IPS)=K2
      ICANON(IPS)=K1
      ISFTYP(IPS)=K3
      IUNFL(IPS)=K1
      IPL(IPS)=K1
      PAST(IPS)=Z1
      LIMFL(IPS)=0
      IPSDEF=0
      TN(1,IPS)=Z0
      TN(2,IPS)=Z0
      TN(3,IPS)=-Z1
      JENT(IPS) = K1
      RETURN
       END
**** SOURCE FILE : M0000702.W03   ***
*
C
C.....FORTRAN BLOCK DATA ROUTINE  ...APT227      2/69   RC,HG,RN,AR
C
C
C
C...  THIS ROUTINE CONTAINS A LISTING OF ALL CDE PACKAGES
C...      IN THE EXECUTION COMPLEX EXCEPT:
C...  BLOCKS 4., 5., AND 17. ARE LISTED IN APT228
C...  BLOCKS 6.,16., AND 18. ARE LISTED IN APT229
C...  NOTE.APT228 AND APT229 ARE DUMMY ROUTINES AND
C...  SHOULD NOT BE LINK EDITED
C
      BLOCK DATA BDA227
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      COMMON /APT227/ APT227
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DEF.INC'
      INCLUDE 'DSHAR3.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IBRKPT.INC'
      INCLUDE 'IDEF.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C...  21. ADDCOM BLOCK
C
      COMMON/ADDCOM/ ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),  (ADDCOM( 2),CLNGTH),
     1            (ADDCOM(23),IBTFLG),  (ADDCOM(24),JLIN),
     2            (ADDCOM(25),KDYNFL)
C
C...  22. TRACE BLOCK
      COMMON /TRACFL/TRACFL
      LOGICAL TRACFL
C
C...  23. DSNAME BLOCK
C
      COMMON /DSNAME/DSNAME,NAMSUB
C
C
C     24.   SRFNAM BLOCK
      COMMON /SRFNAM/ PSNAME,CS1NAM,CS2NAM,IPSSUB,ICS1SB,ICS2SB
C
C
C     25.   COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM/  IAERFG,NPCTPT,PCTPTS,PCTPLN,ERRPTS
      DIMENSION  PCTPTS(3,20), PCTPLN(4), ERRPTS(3,3)
C
C
C          29.  COMMON FOR HOLD INFORMATION
C
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
C
      INCLUDE 'DARRAY.INC'
      INCLUDE 'XUNITS.INC'
C*****   DATA FOR DEF BLOCK   ****************************************
C
C
      DATA  A/24*0./, AHOLD/8*0./, C1/70000.D0,7*0./,
C
     1      LN1/40000.D0,4*0./, R/5*0.,1.D0,4*0./, REF/8*0./
C
C
C*****   DATA FOR FXCOR BLOCK *******************************
C
C** B FXCOR. ARELEM REAL ENVIROMENTAL VARIABLES.
C     EVERY VARIABLE IN THIS BLOCK MUST RETAIN A MINIMUM OF
C     7 DECIMAL FIGURES OF RELATIVE SIGNIFICANCE.
C
      DATA AX4/ 3*0./, CAGL/0./, CUTDAT/7*0./, GAMMA/0./,
C
     +    HI/0./, PMOVE/3*0./, RA/0./, RC1/4500.D0/,
C
     +    SAGL/0./, SURD/0./,  TA/0.,0.,1.D0/, TAK/3*0./,
C
     +    TE/3*0./, TEK/3*0/, TEL/3*0./, TEM/10*0./,
C
     +    TEMP/24*0./, TI/3*0./, TIK/3*0./, TIL/3*0./,
C
     +    TM/3*0./, VTEM/0./, ALP/0./, TAL/3*0./,
C
     +    DPMAX/10./, STRTNO/0./, MODFER/'BLANK'/, TLHIT/5./
C        TOOL HT. ALWAYS 5 INCH.
C
C  ***** DATA FOR NEW TLLDAT BLOCK ************
C
      DATA TLHITE/8*0./, SINL/6*0.,2*-1.D38/, COSL/6*0.,2*1.D38/,
C
     +     UMAX/8*0./, RI/8*0./, CORRAD/8*0./,
C
     +     TCONT/6*0.,-1.,1.,-1./, TLINC/9*0./
C
C
C  ***** DATA FOR HOLRTH BLOCK ************************
C
      DATA HPS/'PS    '/, HDS/'DS    '/, HCS/'CS    '/, HLFT/'GOLFT '/,
C
     +     HRGT/'GORGT '/, HFWD/'GOFWD '/, HBACK/'GOBACK'/,
C
     +     HUP/'GOUP  '/, HDOWN/'GODOWN'/, HTO/'TO    '/,
C
     +     HPAST/'PAST  '/, HON/'ON    '/, HTANTO/'TANTO '/,
C
     +     HPSTAN/'PSTAN '/, HDYNP/'DYNDMP'/, HAERR/'AERR  '/,
C
     +     HCLDAT/'CLDATA'/, HGERR/'GERR  '/
C
C *****  DATA FOR SV BLOCK *********************************
C
C      EVERY VARIABLE IN THIS BLOCK MUST RETAIN A MINIMUM OF
C      7 DECIMAL FIGURES OF RELATIVE SIGNIFICANCE.
C
C      FOR ONE DIMENSIONAL ARRAYS - INDEX INDICATES SURFACE
C      FOR TWO DIMENSIONAL ARRAYS - 1ST INDEX INDICATES VECTOR COMPONENT
C                                   2ND INDES INDICATES SURFACE
C      ***** SURFACE *** INDEX *****
C             GOUGE        1
C             PART         2
C             DRIVE        3
C             CHECK1       4
C             CHECK2       5
C
      DATA  CC/15*0./
      DATA  EPS1/0.,4*.00005D0/,  EPS2/0.,4*.99995D0/,
     +      EPS3/0.,4*.0001D0/,   EPS4/0.,4*.001D0/,
     +      EPS6/0.,4*1.D-6/,     EPS8/0.,4*.00005D0/
      DATA  PAST/5*0./,       PLND/5*0./,  PLNV/15*0./
      DATA  RC/0.,4*4500.D0/,    S/5*0./,   SAVE/5*0./
      DATA  SFVCT/15*0./,  SLX/15*0./,   SN/15*0./,  SNK/15*0./,
     +        SNL/15*0./,   SP/15*0./,  SPK/15*0./,  SPL/15*0./
      DATA  TAU/0.,4*.0005D0/,  TAU1/0.,4*.0005D0/,  TAU2/5*0./
      DATA  TH/5*0./
C
      DATA  TN/3*0., 0.,0.,-1, 1.,0.,0., 1.,0.,0., 0.,0.,-1./
      DATA  TOOLHT/15*0./, TOOLWD/5*0./
      DATA  TP/15*0./, TPK/15*0./,  U1/15*0./, VNDIR/15*0./,
     +      VT/15*0./, Z/5*0./, VARBLE/5*0./, U1K/15*0./, SK/15*0./
      DATA    COS1/5*0./, CPLFL/5*0./, CPTST/5*0./,   CSD/5*0./,
     +      DPLAN/15*0./, DPMX1/5*0./, PLNCS/5*0./, PLND1/5*0./,
     +       PLTST/5*0./,  STCK/5*0./, STCKN/5*0./, STCK1/5*0./,
     +       STCK2/5*0./,  TEE/15*0./,  TNL/15*0./
C
C
C
C  ***** DATA FOR ZNUMBR BLOCK ************************
C
      DATA    Z0/    0./,     Z1/  1.D0/,    Z2/  2.D0/,   Z3/   3.D0/,
     1        Z5/  5.D0/,    Z10/ 10.D0/,   Z90/ 90.D0/,  Z1E6/  1.D6/,
     2     Z1E38/ 1.D19/,  Z5EM1/  .5D0/, Z6EM1/  .6D0/, Z9EM1/  .9D0/,
     3    Z11EM1/ 1.1D0/, Z12EM1/ 1.2D0/, Z1EM2/ .01D0/, Z1EM3/.001D0/,
     4     Z1EM5/ 1.D-5/,  Z5EM6/ 5.D-6/, Z1EM6/ 1.D-6/, Z1EM7/ 1.D-7/,
     5     Z1EM9/ 1.D-9/,  Z1EM1/  .1D0/,   ZM1/ -1.D0/,
     6    DEGRAD/  .0174532925D0/,   PI/  3.14159265D0/
C
C
C  ***** DATA FOR LDEF BLOCK **************************
C
      DATA     JCS/.FALSE./,  PRNTON/.FALSE./,  REFFLG/.FALSE./,
     +      SUBFLG/.FALSE./,  UNFLAG/.FALSE./,    ZFLAG/.TRUE./,
     +         JDS/.FALSE./,  BOUNDF/.FALSE./,  PCHLST/.FALSE./,
     +      CANFLG/.FALSE./,  BNDERR/.FALSE./,  TABPRT/.FALSE./,
     +      REFMOT/.FALSE./,  ALTMLT/.FALSE./
C
C
C  ***** DATA FOR ISV BLOCK ***************************
C
      DATA  IAFL/0,4*-1/,  ICANON/5*0/, INDEX/5*0/,  INDIR/5*0/,
     +      IOP/5*0/,      IOPSET/5*0/, IPL/5*0/,    ISFIDN/5*0/,
     +      ISFTYP/5*0/,   ISIGCR/5*0/, ISVFL/5*0/,  ITLON/5*0/,
     +      ITSEG/5*0/,    IUNFL/5*0/,  JENT/0,4*1/, JIOPS/5*0/,
     +      JTLFLG/5*0/,   JTN/5*0/,    JU1/5*0/,    LIMFL/5*0/,
     +      ITSEGK/5*0/
      DATA  IFAR/3*0,2*1/, IFL4/5*0/,   J20/5*0/,    J21/5*0/,
     +      J22/5*0/,      J23/5*0/,    J50/5*0/,    J51/5*0/,
     +      NOTAN/5*0/,    JPH/5*0/
C
C
C    *** IBRKPT BLOCK DATA ***
C
      DATA IBRKPT/51*0/
C
C    *** KNUMBR BLOCK DATA--EACH VARIABLE NAME IS ITS VALUE (K0=0 ETC.)
C
      DATA  K0/ 0/,  K1/ 1/,  K2/ 2/,  K3/ 3/,  K4/ 4/,  K5/ 5/,
     +      K6/ 6/,  K7/ 7/,  K8/ 8/,  K9/ 9/, K10/10/, K12/12/,
     +     K13/13/, K15/15/, K16/16/, K18/18/, K19/19/, K23/23/,
     +     K24/24/, K25/25/, K26/26/, K27/27/, K29/29/, K30/30/,
     +     K31/31/, K32/32/, K33/33/, K34/34/, K44/44/, K45/45/,
     +     K46/46/, K47/47/, K48/48/, K50/50/, K51/51/, K52/52/,
     +     K1013/1013/,  K1E4/10000/,    K1E6/1000000/, KM1/-1/
C
C
C    *** IDEF BLOCK DATA ***
C
      DATA LDASIZ/0/,IERROR/0/,SURFAD/4*0/,KWRDSZ/8/,IBLK1/0/
C
C
C    *** IFXCOR BLOCK DATA ***
C
      DATA  IAERR/0/  IAUTPS/0/, IBEGIN/0/,      IC/0/,    ICL/0/,
     +        ICS/4/, ICSCNT/0/, ICTDEF/1/,    ICUT/0/,    IDS/3/,
     +        IER/0/,    IGO/0/,  IGOTO/1/,   IGOUG/0/,    IGS/1/,
     +      INOPS/0/, IPSDEF/1/,    IPS/2/,    IPT1/0/,     IS/0/,
     +     ISEQNO/0/,  ISRCH/0/, ISTRUP/0/,      IT/0/, I3DFLG/0/,
     +        JBR/0/,    JSW/0/,    LSV/1/,    LSV1/1/, MOTMOD/0/,
     +     MULOUT/0/, MANTAX/1/, NMPNTS/400/,  NREC/0/,  NUMAX/0/,
     +     NUMCNT/0/,   NUMP/5/, NUMPT1/0/,  NUMSFS/4/, NUMSUR/0/,
     +         NW/0/, ICHECK/0/,   ISEG/0/,  NMBSEG/0/,   NWDS/0/,
     +       MSAV/0/
C
C  ***** DATA FOR ADDCOM BLOCK **************
C
C
      DATA ELMAX/ 200./,CLNGTH/0./,(ADDCOM(I),I=3,22)/20*0./
      DATA  IBTFLG /-1/,  JLIN /0/,  KDYNFL /0/
C
C
C  ****  TRACFL BLOCK DATA ******************
C     INITIALIZED FALSE SET TRUE BY FIRST ENTRY INTO APT024.
C
      DATA TRACFL/.FALSE./
C
C
C...  ***** DATA FOR AERR BLOCK ******
      DATA   IAERFG, NPCTPT, PCTPTS, PCTPLN, ERRPTS / 2*0,  73*0.0 /
C
C     ***** DATA FOR HOLD **********
      DATA JHLDFG,ITHCNT /0,1/
C
C     *****DATA FOR DARRAY ***********
C
      DATA DARRAY/'
     +
     + '/
C---    INITIALIZATION FOR UNITS
      DATA OLDMOD/'INCHES'/,IOLD/3/,TABEXT/10.0/,SSEXT/10.0/
      END
**** SOURCE FILE : M0011532.W01   ***
*
C
      BLOCK DATA BDCLDT
C
C
      INCLUDE 'CLDT.INC'
C
      DATA CLDFG,ICLCOD,ICLCNT,ICLINE,ICLBLK,ICLRCD,ICLTAB
     *   /.FALSE.,    0,     0,     0,     0,     0, 500*0/
      DATA IPTVEC /2,3,5,7,11,13,17,19,23/
      DATA PNTVCT /'TP      ','TA      ','TV      ','PDS     ',
     *  'NDS     ','PPS     ','NPS     ','UVPDS   ','UVPPS   '/
C
      END
**** SOURCE FILE : BLDGOU.ORG   ***
*
C
C.... BLOCK DATA PROGRAM TO INITIALIZE COMMON/CGOUG/
C
      BLOCK DATA BLDGOU
C
      INCLUDE 'CGOUG.INC'
C
      DOUBLE PRECISION Z0
      PARAMETER (Z0=0.D0)
C
      DATA TALT/3*Z0/,SVGL/Z0/,SHILF/Z0/,GFLG/Z0/,TPG/3*Z0/,SPG/3*Z0/
C
      END
**** SOURCE FILE : M0001877.V04   ***
*
C.....FORTRAN SUBROUTINE             CCURV ...              3/1/68   GK
      SUBROUTINE CCURV(ISSTO,SP3,SPL3,SN3)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
C
      DIMENSION SP3(3),SPL3(3),SN3(3)
      DATA Z1EM3,Z1EM4,Z1EM9,ZERO,Z100/1.D-3,1.D-5,1.D-9,0.D0,100.D0/
C
C             /-INPUT SURFACE PT -SP3, AND NORMAL SN3, AND LAST POINT SP
C             /-ISSTO IS INDEX TO CURRENT SURFACE(2=PART,3=DRIVE ETC)
C             /-FIND SURFACE CENTER OF CURVATURE AND RADIUS(CC,RC)
C
      IF(IPL(ISSTO).EQ.0) GO TO 1
C             /-PLANAR SURFACE CASE - IPL=1
      ISIGCR(ISSTO)=-1
      GO TO 6
    1 CONTINUE
C             /-NON-PLANAR GENERAL CASE
C             /-CHECK FOR SIGNIFICANCE OF SP-SPL
C             /-N=0 MEANS SP-SPL IS TOO SMALL FOR CALCULATION
      N=1
      DO 2 I=1,3
      TEMP(I)=SP3(I)-SPL3(I)
      IF(DABS(TEMP(I)).GT.Z1EM3) N=0
    2 CONTINUE
      IF(N.LE.0) GO TO 3
C             /-SP-SPL INSIGNIFICANT, USE LAST RC
      ISIGCR(ISSTO)=1
      GO TO 6
    3 CONTINUE
C             /-NORMAL CASE FOR GENERAL SURFACE
      CALL VNORM(TEMP,TEMP(4))
      CALL DOTF(W1,TEMP(4),SN3)
      IF(DABS(W1).GE.Z1EM4) GO TO 4
C             /-SP-SPL ALMOST PERPENDICULAR TO SN . SET RC 45 INCH
   30 RC(ISSTO)=DSIGN((RC1/Z100),RC(ISSTO))
      ISIGCR(ISSTO)=-1
      GO TO 6
    4 CONTINUE
C     CHECK, WHETHER SURFACE IS LOCALLY ALMOST PLANAR
      CALL DOTF (W1,TA,SN3)
      IF (DABS(W1).GE.1.D0-Z1EM4.AND.MANTAX.LT.2) GO TO 30
C             /-GENERAL CASE, CALCULATE R SO THAT (SP-R*SN-SPL)**2=R**2
C             /-CENTER OF CURV. IS ON SIDE OF SN IF RC NEGATIVE.
      CALL DOTF(W1,TEMP,SN3)
      CALL DOTF(RC(ISSTO),TEMP,TEMP)
C             /-R=D**2/(2*(D,SN)) WHERE D=SP-SPL
      RC(ISSTO)=RC(ISSTO)/(W1+W1)
C             /-SET FLAG TO NORMAL CASE
      ISIGCR(ISSTO)=0
C             /-COMMON RETURN POINT FOR ALL CASES
    6 CONTINUE
      DO 7 I=1,3
      CC(I,ISSTO)=SP3(I)-RC(ISSTO)*SN3(I)
      IF(DABS(CC(I,ISSTO)).LT.Z1EM9) CC(I,ISSTO)=ZERO
    7 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0002742.W07   ***
*
C.....FORTRAN SUBROUTINE  ....CENTR          8/68                    HG
C...  FORTRAN SUBROUTINE               CENTR
      SUBROUTINE CENTR
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C...  21. ADDCOM BLOCK
C
      COMMON /ADDCOM/ ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM(25),KDYNFL)
C
C
      INCLUDE 'CHANG.INC'
      DIMENSION TEZA(3)
C
      DIMENSION P(3)
      DIMENSION SAVETE(3),SAVETA(3)
C
      LOGICAL LRET
C
C                   ACC       FUDGE TERM FOR DISTANCE MEASUREMENTS, SET
C                             AT 5.E-6
C                  IM       FLAG USED IN ORIENTING TANGENT CS NORMAL
C                           WITH OTHER SURFACE NORMAL.
C                   PTOL      FRACTION OF TOTAL TOLERANCE BAND ABOUT
C                             PLANES WITHIN WHICH TOOL IS CONSTRAINED
C                             TO LIE. INITIALLY .2, ENLARGED TO 1.0 AS
C                             ITERATION COUNT INCREASES.
C                   SAVETA(3) SAVES TOOL AXIS DURING NOTAN STEP.
C                   SAVETE(3) SAVES TOOL END POSITION DURING NOTAN STEP.
C                   SAVES     SAVES DISTANCE TO ALL 3 SURFACES ON ENTRY
C                             TO NOTAN STEP.  USED AS A CRITERION FOR
C                             POSSIBLE RESTART FROM ENTRY TO NOTAN.
C                   SMOVE     MAGNITUDE OF SMALLEST VECTOR WHICH CAN BE
C                             ADDED TO TOOL END WITHIN SINGLE PRECISION.
C                             SET ON ENTRY TO CENTR.   ALL MOVE VECTORS
C                             ARE ENLARGED TO THIS SIZE IF NECESSARY
C                   TANANG    CRITERION FOR ESTABLISHING PSEUDO-TANGENCY
C                             IS DOT(CHECK SURF NORMAL, OTHER SURF
C                             NORMAL) .GT. TANANG.  SET AT 1-.5*TAU.
C
C                   PURPOSE   TO ITERATE CUTTER TO DESIRED POSITION
C                             RELATIVE TO 2 OR 3 SURFACES
C
C-----------------------------------------------------------------------
C
C     MAIN ROUTINE
C...                INITIALIZATIONS
C
      ITINK=0
      ITOLFL=0
      JTKF=0
C
      DO 1 I=1,3
        TEZA(I)=TE(I)
   1  CONTINUE
C                                       TINKR FAILURE COUNTER
      JTRC=10
C                                       PLANE TOLERANCE LIMIT FACTOR
      PTOL=.2
C                                       PARALLEL SURFACE TOLERANCE
      TANANG=1.-.5*TAU(IS)
      IF (TANANG.LT.Z9EM1) TANANG=Z9EM1
C                                       EPSILON FOR DISTANCES
      ACC=5.D-6
C                                       MAGNITUDE OF SMALLEST MOVE WHICH
C                                       CAN BE MADE IN SINGLE PRECISION
      SMOVE=1.D-7*DMAX1(DABS(TE(1)),DABS(TE(2)),DABS(TE(3)))
C                                       CPLAN FLAGS
      CPLFL(IS)=0.
      CPTST(IS)=0.
C
C
C
C
C...                SET ITERATION COUNTERS
C
C                                       5-AXIS RESTART COUNTER
      JCNT3=25
C                                       NOTAN CPLAN COUNTER
  100 JCNT2=25
C                                       BASIC CMOVE ITERATION COUNTER
      JCNT1=25
C
C...                CALL 2 SURF IF 2 SURFACE ITERATION
C
  105 IF (J51(IS)) 200,200,120
C
C...                CALL TANTO FOR TANGENT CS, OTHERWISE 3 SURF
C
  120 IF (ISFTYP(IS)-4) 300,400,300
C
C                                       GO TO EXIT
  130 GO TO 1100
C
C
C
C
C
C-----------------------------------------------------------------------
C     2 SURF - ITERATE TOOL INTO PART AND DRIVE ONLY
C
C
C
C...                CALL 2 SURF ITERAT
C
  200 ASSIGN 210 TO J2SURF
      GO TO 600
C
C...                SET FLAG, 2 SURFACE ITERATION SUCCESSFUL
C
  210 JCR=0
C
C...                RETURN TO MAIN PROGRAM
C
      GO TO 130
C
C
C
C
C
C-----------------------------------------------------------------------
C     3 SURF - ITERATE TOOL TO PART, DRIVE, AND CHECK SURFACES
C
C
C
C...                FIND PART AND DRIVE SURFACES
C
  300 ASSIGN 1000 TO JFPD
C
C...                FIND CHECK SURFACE
C
      ASSIGN  302 TO JFNDCK
      GO TO 800
C
C...                FETCH CHECK DATA
C
C                                       NORMAL
  302 DO  305 I=1,3
      PLNV(I,IS)=TN(I,IS)
  305 CONTINUE
C                                       DISTANCE
      PLND(IS)=S(IS)
C
C...                TEST PART AND DRIVE SURFACES
C
      ASSIGN 310 TO JTSTPD
      GO TO 900
  310 IF (JTOL) 330,330,315
C
C...                BOTH WITHIN LIMIT, CALL TEST CHECK SURF
C
  315 ASSIGN 320 TO JTSTCK
      GO TO 1300
  320 IF (JTOL) 330,330,380
C
C...                TEST IF PSEUDO-TANGENCY ALREADY HANDLED
C
  330 IF (NOTAN(IS)) 365,340,340
C
C...                TEST IF PSEUDO-TANGENCY HAS DEVELOPED
C
C                                       TEST CHECK SURF BEYOND STEP
  340 IF (DABS(S(IS))-DP)  350,350,365
C                                       TEST SURFACE TANGENCY
  350 DO 360 I= IPS,IDS,LSV
      IF (TANANG-DABS( SN(1,IS)*SN(1,I)
     1                +SN(2,IS)*SN(2,I)
     2                +SN(3,IS)*SN(3,I))) 370,360,360
  360 CONTINUE
C                                       NO PSEUDO-TAN
C
C...                CALL CMOVE AND LOOP
C
  365 ASSIGN 300 TO JCMOVE
      GO TO 700
C
C...                PSEUDO TANGENCY CASE
C
C                                       SET FLAG FOR TANGENT SURF
  370 IFL4(IS)=(IDS-I)/LSV
C                                       CALL NOTAN AND LOOP
      GO TO 500
C
C...                SET FLAG, SUCCESSFUL 3-SURF ITERATION
C
  380 JCR=1
      GO TO 1100
C
C
C
C
C-----------------------------------------------------------------------
C     TANTO -  3 SURFACE ITERATION IN TANTO OR PSTAN CASE
C
C
C
C...                CALL FIND PART AND DRIVE
C
  400 CONTINUE
      IF(IFL4(IS).EQ.0.AND.
     X   (ISFIDN(IDS).GT.2.OR.ISFIDN(ICS).GT.2)) GO TO 402
      IF(IFL4(IS).EQ.1.AND.
     X   (ISFIDN(IPS).GT.2.OR.ISFIDN(ICS).GT.2)) GO TO 402
      IF(ISFIDN(IPS).LE.2) CALL AERR(25009,'CENTR   ')
  402 IM=-1
      ASSIGN 410 TO JFPD
      GO TO 800
C
C...                CALL FIND CHECK
C
  410 ASSIGN 1400 TO JFNDCK
C
C...                CALL CPLAN SURF
C
      ASSIGN 420 TO JCPLAN
      GO TO 1000
C
C...                TEST WHETHER NORMALS HAVE SAME ORIENTATION
C
  420 IF (PLNCS(IS)) 430,460,460
C
C...                OPPOSITE, TEST WHETHER TOOL NORMAL ALREADY REVERSED
C
  430 IF (IM) 440,450,450
C
C...                NOT REVERSED, REVERSE AND SET FLAG
C
  440 DO 445 I=1,3
      TN(I,IS)=-TN(I,IS)
  445 CONTINUE
      IM=0
      GO TO 410
C
C...                NORMAL REVERSED, TEST WHETHER NORMALS NEAR ORTHOG
C
  450 IF (DABS(PLNCS(IS))-.01) 455,452,452
C
C...                NEAR ORTHOGONAL, ERROR EXIT
C
 452  CALL AERR(25008,'CENTR   ')
C
C...                RESET TOOL NORM REVERSAL FLAG
C
  455 IM=-1
C
C...                TEST WHETHER WITHIN 2*TAU OF CPLAN
C
  460 IF(DABS (PLND(IS))-EPS4(IS) ) 462,462,464
C
C...                WITHIN 2*TAU, TEST WHETHER NORMALS PARALLEL
C
  4620IF( TANANG-DABS(SN(1,IS)*SN(1,IT)
     1               +SN(2,IS)*SN(2,IT)
     2               +SN(3,IS)*SN(3,IT))) 480,480,464
C
C...                CALL CMOVE, USING CPLAN DATA
C
  464 ASSIGN 471 TO JCMOVE
      GO TO 700
C
C...                CALL 2 SURFACE ITERATION AND LOOP
C
 471  IM = -1
      IF(KDYNFL.NE.K0) CALL APT238(K31)
      ASSIGN 410 TO J2SURF
      GO TO 600
C
C...                NORMALS PARALLEL, CALL TEST CHECK SURF
C                                       RETURN TO MAIN IF IN TOL
  480 ASSIGN 482 TO JTSTCK
      GO TO 1300
  482 IF (JTOL) 486,486,483
  483 JCR=1
      GO TO 130
C
C...                NOT WITHIN TOL, TEST WHETHER WITHIN 8*TAU
C
  486 IF (8.*TAU(IS)-DABS(S(IS))) 488,488,464
C
C...                NOT WITHIN 8*TAU, FALSE TANGENCY EXIT
C
  488 JCR=2
      GO TO 1100
C
C
C
C
C-----------------------------------------------------------------------
C     NOTAN - PSEUDO-TANGENCY CALCULATION
C
C
C                                       FLAG- PSEUDO TANGENCY DONE
  500 NOTAN(IS)=-1
C                                       SAVE CUTTER POSITION FOR
C                                       RESET IF NECESSARY
      DO 502 I=1,3
      SAVETE(I)=TE(I)
      SAVETA(I)=TA(I)
  502 CONTINUE
C                                       CURRENT DISTANCE FROM SURFACES
      SAVES=DABS(S(IS))+DABS(S(IDS))+DABS(S(IPS))
C
C...                CALL FIND PART AND DRIVE
C
      ASSIGN 510 TO JFPD
      GO TO 800
C
C...                CALL FIND CHECK
C
  510 ASSIGN 1400 TO JFNDCK
C
C...                CALL CPLAN SURF
C
      ASSIGN 520 TO JCPLAN
      GO TO 1000
C
C...                TEST WHETHER WITHIN 2*TAU OF CPLAN
C
  520 IF (DABS(PLND(IS))-EPS4(IS))  540,540,530
C
C...                                    CALL CMOVE
C
  530 ASSIGN 600 TO JCMOVE
C
C...                                    CALL 2 SURF ITERAT
C
      ASSIGN 531 TO J2SURF
      GO TO 700
C
C...                CALL FIND CHECK
C
  531 ASSIGN 532 TO JFNDCK
      GO TO 1000
C
C...                RESTORE IF MOVED AWAY FROM SURFACES
C
  532 IF (DABS(S(IS))-2.0*SAVES) 510,510,535
  535 DO 537 I=1,3
      TE(I)=SAVETE(I)
      TA(I)=SAVETA(I)
  537 CONTINUE
C                                       RETURN TO 3 SURF
      GO TO 300
C
C...                TEST WHETHER CHECK SURF WITHIN TOL
C
  540 ASSIGN 550 TO JTSTCK
      GO TO 1300
  550 IF (JTOL)  555,555,565
C
C...                TEST WHETHER CHECK SURF WITHIN 8*TAU
C                                       RETURN TO 3 SURF IF SO
 555  IF(8*TAU(IS)-DABS(S(IS)))560,560,535
C
C...                SET FALSE TANGENCY FLAG AND EXIT
C
  560 JCR=2
      GO TO 1100
C
C...                CALL TEST PART AND DRIVE
C
  565 ASSIGN 570 TO JTSTPD
      GO TO 900
C
C...                RETURN TO 3-SURF IF BOTH WITHIN TOL,
C...                FALSE TANGENCY IF NOT
C
  570 IF (JTOL) 560,560,300
C
C
C
C
C-----------------------------------------------------------------------
C     2 SURF ITERATE - ITERATE TOOL INTO PART AND DRIVE SURFACES
C
C
C
C...                FIND PART AND DRIVE SURFACES
C
  600 ASSIGN 900 TO JFPD
C
C...                TEST PART AND DRIVE SURFACES
C
      ASSIGN 605 TO JTSTPD
      GO TO 800
C
C...                RETURN IF BOTH WITHIN TOL
C
  605 IF (JTOL) 615,615,610
C                                       RETURN
  610 GO TO J2SURF, (210,410,510,531)
C
C...                CREATE PSEUDO CHECK SURFACE NORMAL TO
C...                PART AND DRIVE
C
  615 CALL CROSS(  TN(1,IPS),  TN(1,IDS),PLNV(1,IS))
      CALL VNORM(PLNV(1,IS),PLNV(1,IS))
      PLND(IS)=0.0
C
C...                CALL CMOVE AND LOOP
C
      ASSIGN 600 TO JCMOVE
      GO TO 700
C
C
C
C
C-----------------------------------------------------------------------
C     CMOVE - COMPUTE AND APPLY MOVE VECTOR
C
C
C
C...                IN CASE OF PLANE PART AND DRIVE SURFACES, MODIFY
C...                DISTANCES TO DIRECT TOOL TOWARD CENTER OF TOLERANCE
C...                BAND AS ITERATION COUNT INCREASES
C
  700 DO 701 I=IPS,IDS,LSV
C                                       SKIP IF SURF NOT A PLANE
      IF (IPL(I)) 705,701,705
C                                       ADAUST DIST TOWARD CENTER
  705 S(I)=S(I) - (TAU1(I)+TAU2(I))/2.0 * (PTOL-.2)/.8
C
  701 CONTINUE
C.... SPECIAL TREATMENT FOR 2 SURFACE APPROACH WHEN DIST TO
C     ONE SURFACE IS ZERO
      IF (J51(IS).EQ.0) THEN
        IF (S(IDS).NE.Z0) THEN
          CONTINUE
        ELSE
          DO 702 III=1,3
            CMOVE(III)=Z9EM1*TN(III,IPS)*S(IPS)
  702     CONTINUE
          GOTO 720
        ENDIF
      ENDIF
C
C...                COMPUTE MOVE VECTOR
C
     0CALL GAUSS(  TN(1,IPS),   S(IPS),
     1             TN(1,IDS),   S(IDS),
     2           PLNV(1,IS),PLND( IS),CMOVE,JPXR)
C
C....  DETERMINE MAXIMUM DIST TO SURFACES
C
      SIMAX=MAX(ABS(S(IPS)),ABS(S(IDS)),ABS(PLND(IS)))
C
      IF (JPXR.NE.0) THEN
C.... GAUSS FAILED - COMPUTE CMOVE BY ALTERNATIVE METHODS
        CALL ALTCMV(JPXR,TN,S,IPS,IDS,PLND(IS),PLNV(1,IS),EPS1(IS),
     +              CMOVE,LRET)
        JPXR=1
C.... IS TOOL IN TOLERANCE OD CS WHEN PS PARALLEL TO CS
        IF (LRET) GOTO 380
      ENDIF
C
C...                TEST FOR ITERATION 10, 5, OR 3 OF 3 SURF
C
  720 IF ( (JCNT1-18)*(JCNT1-9)*(JCNT1-3)+(JCNT1-22) ) 735,725,735
C
C...                IF SO, WIDEN TOLERANCE LIMIT AND HALVE MOVE
C
  725 EPS8(IPS)=1.709976*EPS8(IPS)
      EPS8(IDS)=1.709976*EPS8(IDS)
      EPS8(IS )=1.709976*EPS8(IS )
      PTOL     =1.709976*PTOL
      DO 730 I=1,3
      CMOVE(I)=.5*CMOVE(I)
  730 CONTINUE
C
C.... ENSURE CMOVE IS LESS THAN LARGEST ACTUAL DISTANCE TO SURFACES
      BCMOV=SQRT(CMOVE(1)*CMOVE(1)+CMOVE(2)*CMOVE(2)
     +          +CMOVE(3)*CMOVE(3))
      IF (BCMOV.GT.SIMAX) THEN
        DO 731 IK=1,3
          CMOVE(IK)=SIMAX/BCMOV*CMOVE(IK)
  731   CONTINUE
      ENDIF
C
C...                ADD MOVE TO TOOL END
C
C                                       FACTOR TO ENLARGE MOVE TO MINIM-
C                                       AL SIZE IF NECESSARY
  735 TEMP(1) = DMAX1(Z1,SMOVE/DMAX1(DABS(CMOVE(1)),
     1                         DABS (CMOVE(2)),
     2                         DABS (CMOVE(3)) ) )
C                                       ADD MOVE
      DO 740 I=1,3
      TE(I)=TE(I)+TEMP(1)*CMOVE(I)
  740 CONTINUE
C
C...                 STEP COUNTER, AND RETURN
C
      IF (JCNT1) 750,750,745
  745 JCNT1=JCNT1-1
C                                       RETURN
      GO TO JCMOVE ,(300,600,471)
C
C
C...                IF COUNTER EXHAUSTED, ISSUE WARNING
C
C                                       BRANCH TO ERROR
  750 GO TO 1600
C
C
C
C-----------------------------------------------------------------------
C     FIND PART DRIVE - DETERMINE NORMALS AND DISTANCES FOR PART
C                       AND DRIVE SURFACES
C
C
C                                       SAVE INDEX
  800 ISSTO=IS
C                                       CALL FOR PART SURFACE
      IS=IPS
      JMINR=1
      CALL AMIND
      IS=ISSTO
      IF(JMIN.EQ.1) GO TO 1600
C                                       CALL FOR DRIVE SURFACE
C
      IS=IDS
      JMINR=1
      CALL AMIND
      IS=ISSTO
      IF(JMIN.EQ. 1) GO TO 1600
C                                       RESTORE INDEX
C
C                                       RETURN
      GO TO JFPD,(1000,410,510,900,922)
C
C
C
C
C-----------------------------------------------------------------------
C     TEST PART DRIVE - SET JTOL +1 IF BOTH PART AND DRIVE SURFACE
C                       DISTANCES ARE ACCEPTABLE
C
C
C...                CALL TINKR FOR 5-AXIS CASE
C
  900 IF (MANTAX-2) 925,910,910
  910 IF (ITINK.LE.0) GOTO 925
      CALL TINKR
C                                       TEST IF TA MOVED
      IF (JTR)915,921,925
  915 JTRC=JTRC-1
      IF (JTRC) 920,925,925
C                                       ERROR IF COUNTER EXHAUSTED
 920  CALL AERR(25007,'CENTR   ')
C                                       IF SO,REESTABLISH
C                                       FIND PART AND DRIVE
  921 ASSIGN 922 TO JFPD
      GO TO 800
C                                       RE-ADJUST AXIS
  922 IF (ITINK.LE.0) GOTO 925
      CALL TINKR
C
C
C...                TEST PART AND DRIVE SURFACES
C
  925 DO  950  I=IPS,IDS,LSV
C                                       TEST WHETHER SURFACE A PLANE
      IF (IPL(I)) 930,930,935
C                                       NON-PLANAR
  930 IF (DABS(S(I))-EPS8(I)) 950,950,965
C                                       PLANE, TEST WHICH SIDE
  935 IF (S(I)) 940,950,945
  940 IF (S(I)-PTOL*TAU2(I)+1.E-6) 965,950,950
  945 IF (S(I)-PTOL*TAU1(I)-1.E-6) 950,950,965
  950 CONTINUE
C
C...                BOTH WITHIN TOLERANCE
C
  960 JTOL=1
      GO TO 970
C
C...                NOT BOTH WITHIN TOL
C
  965 JTOL=-1
C
C...                RETURN
C
  970 GO TO JTSTPD, (310,570,605)
C
C
C
C
C-----------------------------------------------------------------------
C     FIND CHECK - DETERMINE NORMAL AND DISTANCE TO CHECK SURFACE
C
C
C
C...                CALL AMIND FOR CHECK SURFACE
C
C                                       RETURN IF AMIND ERROR
 1000 JMINR=1
      CALL AMIND
C                                       RESET RETURN FLAG
      JMINR=0
C                                       BRANCH IF ERROR
      IF (JMIN) 1010,1010,1600
C                                       RETURN
 1010 GO TO JFNDCK, (1400,302,532)
C
C
C
C
C-----------------------------------------------------------------------
C     EXIT - RESET QUANTITIES AND RETURN
C
C
C...                IF 5-AXIS CASE, VERIFY TOOL AXIS SATISFACTORY
C
 1100 IF(2-MANTAX) 1102,1102,1108
C
 1102 IF (ITINK.EQ.0) THEN
        ITINK=1
        GOTO 105
      ELSE IF (ITINK.EQ.-1) THEN
        GOTO 1108
      ELSE
C                                       RESET AXIS IF NECESSARY
        CALL TINKR
      ENDIF
C                                       TEST WHETHER AXIS MOVED
      IF (JTR) 1103,1104,1108
C                                       TINKR ERROR
 1103 CALL AERR(25004,'CENTR   ')
C                                       AXIS MOVED, INDEX COUNTER
C                                       AND RESTART
 1104 IF(JCNT3) 1105,1106,1106
C                                       COUNTER EXHAUSTED
 1105 CALL AERR(25003,'CENTR   ')
C
 1106 JCNT3=JCNT3-1
      GO TO 100
C
C...                RESET   3-SURFACE FLAGS AND TOLERANCE BAND LIMITS
C
 1108 IF (J51(IS)) 1120,1120,1110
 1110 J50(IS)=0
      J51(IS)=0
      EPS8(IPS)=EPS1(IPS)
      EPS8(IDS)=EPS1(IDS)
      EPS8(IS)=EPS1(IS)
      NOTAN(IS)=0
C
C...                RETURN TO CALLING PROGRAM
C
 1120 CONTINUE
C... HAS TE CHANGED
      IF ( (TEZA(1).NE.TE(1)) .OR. (TEZA(2).NE.TE(2)) .OR.
     +     (TEZA(3).NE.TE(3)) ) THEN
        JTENEU=1
      ELSE
        JTENEU=0
      ENDIF
      RETURN
C
C
C
C
C-----------------------------------------------------------------------
C     TEST CHECK SURFACE
C
C
C
C                                       BRANCH IF SURF A PLANE
 1300 IF (IPL(IS)) 1310,1310,1330
C                                       TEST FOR INNER OR OUTER SIDE
 1310 IF (DFLOAT(2*JTN(IS)-1)*RC(IS)*S(IS)) 1315,1350,1320
C                                       INNER SIDE
 1315 IF (DABS(S(IS))-EPS8(IS)-5.D-6) 1350,1350,1360
C                                       OUTER SIDE
 1320 IF (DABS(S(IS))-(TAU(IS)-EPS8(IS)+Z5EM6)) 1350,1350,1360
C                                       PLANE SURFACE
C                                       TEST INNER OR OUTER
 1330 IF (S(IS)) 1340,1340,1335
C                                       INNER
 1335 IF (S(IS)-ACC-TAU1(IS)) 1350,1350,1360
C                                       OUTER
 1340 IF (S(IS)+ACC-TAU2(IS)) 1360,1350,1350
C
C...                WITHIN TOLERANCE BAND
C
 1350 JTOL=1
      GO TO 1370
C
C...                NOT WITHIN TOLERANCE BAND
C
 1360 JTOL=-1
C                                       RETURN
 1370 GO TO JTSTCK, (320,482,550)
C
C
C
C
C-----------------------------------------------------------------------
C     CPLAN SURF - OBTAIN PSEUDO CHECK SURFACE DATA FROM CPLAN
C                  ROUTINE
C
C
C
C
 1400 CALL CPLAN
      IT=IT
C
C...                BRANCH IF CPLAN FAILURE
C
      IF (JCPR) 1420,1410,1420
C
C...                RETURN
C
 1410 GO TO JCPLAN, (420,520)
C
C...                CPLAN ERROR
C
 1420 CALL AERR(25005,'CENTR   ')
C
C
C
C
C-----------------------------------------------------------------------
C     ERROR -                REDUCE STEPSIZE IF POSSIBLE, AND SET
C                            FLAG FOR RESTART
C
C
C
C                                       BRANCH IF 3 SURFACE CALL
 1600 IF (J51(IS)) 1610,1610,1630
C                                       REDUCE STEPSIZE
 1610 DP=.6*DP
C                                       ERROR IF STEPSIZE .LT. TOLERANCE
      IF (DP-DABS(TAU(IS))) 1620,1620,1630
C                                       ERROR ROUTINE
 1620 CALL AERR(25002,'CENTR   ')
C                                       SET FLAG FOR RESTART
 1630 JCR=-1
C                                       BRANCH TO EXIT
      GO TO 1100
C
C
C
C
C
       END
**** SOURCE FILE : M0002746.W04   ***
*
C.....FORTRAN SUBROUTINE  ....CHECK          8/68                 PH,HG
C
      SUBROUTINE CHECK
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
      INCLUDE 'CHEKFL.INC'
C
      DIMENSION TIOLD(3)
      DIMENSION TNHELP(3)
C
C
C
      IF(ISFTYP(IS).GE.K4) GO TO 401
      ITANG=0
      TEMP(8)=Z10*DPMAX
      IF (JENT(IS).NE.K1) THEN
        CALL DOTF(DTISN,TI,SN(1,IS))
        IF (ABS(DTISN).LT.0.05D0) THEN
          ITANG=1
          J21(IS)=K1
          GOTO 401
        ENDIF
      ENDIF
      TN(1,IS)=PAST(IS)*TI(1)
      TN(2,IS)=PAST(IS)*TI(2)
      TN(3,IS)=PAST(IS)*TI(3)
  401 IF(J20(IS)-K1)1,8,3
    1 JWR=0
      STCK(IS)=Z1E6
      CSD(IS)=Z0
      J20(IS)=K1
      J21(IS)=K1
      J22(IS)=0
      JENT(IS)=K1
    2 IOPSET(IS)=0
      JTN(IS)=K1
      JU1(IS)=K1
      JIOPS(IS)=0
      GO TO 9
    3 IF(TIK(1)*(TEE(1,IS)-TEK(1))+TIK(2)*(TEE(2,IS)-TEK(2))+TIK(3)
     1*(TEE(3,IS)-TEK(3))-EPS1(IS))4,4,66
    4 CALL AERR(-24201,'CHECK   ')
      S(IS)=Z3*DP
      CSD(IS)=Z0
      GOTO11
   66 J21(IS)=0
      CMOVE(1)=TEE(1,IS)-TEK(1)
      TEMP(1)=TE(1)-TEK(1)
      CMOVE(2)=TEE(2,IS)-TEK(2)
      TEMP(2)=TE(2)-TEK(2)
      CMOVE(3)=TEE(3,IS)-TEK(3)
      TEMP(3)=TE(3)-TEK(3)
      CALL VNORM(CMOVE,TEM)
      CSD(IS)=VTEM
      CALL VNORM(TEMP,TEMP)
      IF(DABS(ZL).LT.Z1EM9) ZL=Z1EM9
      CSD(IS)=(CSD(IS)-VTEM)*(DPI/ZL)*Z11EM1
      IF(CSD(IS)-EPS1(IS))7,7,16
    7 TE(1)=TEE(1,IS)
      TE(2)=TEE(2,IS)
      TE(3)=TEE(3,IS)
      GO TO 18
 8    IF(ISFTYP(IS)-4)85,84,84
 84   IF(JPH(IS))11,9,11
   85 S(IS) = S(IS) - DP
      IF ((S(IS).LT.Z5).OR.(S(IS).LT.Z5*DP)) GOTO 9
 86   IF(TI(1)*TIOLD(1)+TI(2)*TIOLD(2)+TI(3)*TIOLD(3)-0.9)9,11,11
    9 CONTINUE
      ITRY=0
      ICHEKF=1
  901 DO 98 I=1,3
        TNHELP(I)=TN(I,IS)
   98 CONTINUE
      ITRY=ITRY+1
      JMINR=K1
   99 CALL AMIND
      ICHEKF=0
      JMINR=K0
      DO 87 I=1,3
        TIOLD(I) = TI(I)
   87 CONTINUE
      IF(IAERR)17,91,17
   91 IF(JMIN)10,19,10
   10 IF (ITRY.EQ.1) GOTO 901
      S(IS)=Z0
   11 J21(IS)=0
   12 IF(CSD(IS)-EPS1(IS))13,15,15
   13 IF(ISTRUP)14,14,16
   14 CSD(IS)=Z2*DPMX1(IS)
   15 IF(STCK(IS).LE.Z0) GOTO 18
      IF ( (ITANG.EQ.K1) .AND. (TEMP(8).LT.DP)
     +  .AND.  (STCK(IS).LT.Z2*TAU(IS)) ) GOTO 18
   16 JCKR=0
   17 CONTINUE
      JPH(IS) = K0
      RETURN
   18 J50(IS)=K1
      J51(IS)=K1
      PLND1(IS)=Z0
      NOTAN(IS)=0
      JCKR=K1
      GO TO 17
   19 IF(ISFTYP(IS)-K4)190,22,22
  190 IF(J23(IS))20,21,20
   20 IF(DABS(S(IS)).LT.Z1EM9) GO TO 2001
      STCK1(IS)=DSIGN(Z1,Z(IS)*S(IS))
      J23(IS) = 0
      GO TO 22
 2001 J20(IS) = 0
      GO TO 16
   21 STCK(IS)=STCK1(IS)*Z(IS)*S(IS)
 22   COS1(IS)=TN(1,IS)*TI(1)+TN(2,IS)*TI(2)+TN(3,IS)*TI(3)
C
      IF(ISFTYP(IS)-K2 )23,30,39
   23 IF(COS1(IS))24,25,25
   24 TN(1,IS)=-TN(1,IS)
      TN(2,IS)=-TN(2,IS)
      TN(3,IS)=-TN(3,IS)
      RC(IS)=-RC(IS)
      J23(IS)=K1
      GO TO 99
   25 IF (TAU(IS).GT.S(IS)) GOTO 32
      IF ( (ITANG.EQ.K1).AND.(Z5*TAU(IS).GT.S(IS))) GOTO 32
   26 IF(COS1(IS))27,28,27
   27 CSD(IS)=DABS(S(IS)/COS1(IS))
      GO TO 29
   28 CSD(IS)=DABS(S(IS))+TAU(IS)
   29 IF(DP-CSD(IS))11,201,201
  201 IF ( CSD(IS).GT.Z9EM1*DP ) THEN
        IF ( DP.GT.(DPMAX*TAU(IS))) THEN
          DP=0.75D0*DP
          GOTO 11
        ENDIF
      ENDIF
      IF(J50(IS))202,18,18
  202 IF(TAU(IS)-CSD(IS))11,18,18
   30 IF(COS1(IS))31,31,24
   31 IF(TAU(IS)-S(IS)) 32,32,26
   32 IF(J21(IS))301,301,33
  301 IF(IPDPL)15,15,18
   33 DO 37 K=1,3
      TEMP(K)=TP(K,IS)
      TEMP(K+3)=TN(K,IS)
      TP(K,IS)=SP(K,IS)+TAU(IS)*TI(K)
   37 TN(K,IS)=TI(K)
      IOP(IS)=K1
      TEMP(7)=S(IS)
      IF(LIMFL(IS))34,35,34
   34 CALL DDLIM
      GO TO 36
   35 ICHEKF=1
      CALL DDST
      ICHEKF=0
   36 DO 361 K=1,3
      TP(K,IS)=TEMP(K)
      TN(K,IS)=TEMP(K+3)
  361 CONTINUE
      IF(IER)38,55,38
   38 CSD(IS)=0
      S(IS)=Z5*DP
      GO TO 12
   39 IF(K3-ISFTYP(IS))40,23,40
   40 CPTST(IS)=Z0
      CPLFL(IS)=Z0
      CALL CPLAN
      IT=IT
      IF(JCPR) 41,45,41
   41 CALL AERR(-24202,'CHECK   ')
      GO TO 11
   45 IF (PLNCS(IS)) 24,46,46
   46 TEMP(1)=PLNV(1,IS)*TI(1)+PLNV(2,IS)*TI(2)+PLNV(3,IS)*TI(3)
      IF (TEMP(1)) 47,48,47
   47 CSD(IS) =DABS(PLND(IS)/TEMP(1))
   48 TEMP(1) = (SP(1,IS)-SP(1,IT))*TN(1,IS)
     1         +(SP(2,IS)-SP(2,IT))*TN(2,IS)
     1         +(SP(3,IS)-SP(3,IT))*TN(3,IS)
      TEMP(1) = TEMP(1)*(TN(1,IS)*TI(1)+TN(2,I)*TI(2)+TN(3,IS)*TI(3))
      IF (J22(IS))607,51,607
  607 STCKN(IS) = STCK2(IS)*TEMP(1)
C                   STPCK IF SURFACE PASSED
      IF (STCKN(IS)) 18,6071,6071
C                   STPCK IF SURFACE NEARBY
 6071 IF(DABS(PLND(IS)) - Z2*DP) 6072,6072,11
 6072 IF(DABS(S(IS))-DP) 18,18,11
   51 STCK2(IS) = TEMP(1)
      IF (STCK2(IS)) 11,502,502
  502 J22(IS) = K1
      GO TO 11
   52 IF(CSD(IS)-Z2*DP)53,12,12
   53 DO 54 I=1,3
      CMOVE(I)=TEMP(8)*TI(I)
   54 TE(I)=TE(I)+CMOVE(I)
      GO TO 18
   55 CSD(IS)=DABS(TEMP(7)/COS1(IS)+S(IS)+TAU(IS))
      TEMP(8)=S(IS)
      IF(CSD(IS)-Z5*DP)101,102,102
  101 S(IS)=CSD(IS)
      GO TO 152
  102 S(IS)=Z5*DP
  152 IF(S(IS)-DABS(TEMP(7)))153,52,52
  153 S(IS)=DABS(TEMP(7))
      GOTO52
       END
**** SOURCE FILE : M0011486.W01   ***
*
C
      SUBROUTINE CLDAT(ARG1,ARG2,ARG3,ARG4)
C
C   PURPOSE: TO CONTROL AND STORE CLDAT PARAMETERS AND INDICATORS.
C
C     ICLTAB   (1,X)  INDEX OF THE CLDAT SECTION.
C     ICLTAB   (2,X)  NUMBER OF POINTS IN THE CLDAT SECTION.
C     ICLTAB   (3,X)  FORM OF STORAGE ON EXFILE (TP,TA,TV,...).
C     ICLTAB   (4,X)  FIRST EXFILE BLOCK  OF THE CLDAT SECTION.
C     ICLTAB   (5,X)  FIRST EXFILE RECORD OF THE CLDAT SECTION.
C     CLDFG           FLAG TRUE = A CLDAT-SECTION IS OPENED, COUNTING
C                     OF THE POINTS IN ATAPE.
C     ICLCNT          POINTER TO THE LAST ICLTAB ENTRY.
C     ICLINE          ICLTAB INDEX.
C     ICLIDX          ICLTAB INDEX.
C
C     ICLCOD = ICLTAB   (3,X)    ;   ICLBLK = ICLTAB   (4,X)
C     ICLRCD = ICLTAB   (5,X)
C
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'IFXCOR.INC'
C
      INCLUDE 'CLDT.INC'
C
      DIMENSION CLREC(14),NARG(8)
      INTEGER   ARG1,ARG2,ARG3,ARG4,START,CLWRD
      DIMENSION ARG1(*),ARG2(*),ARG3(*),ARG4(*),NPTVCT(2,9),NCLR(2)
      EQUIVALENCE (NCLR(1),CLR)
      INTEGER BCDF
      LOGICAL FIRST
      SAVE FIRST,START,CLWRD,NORM,NOMO
C
      DATA ICLDM/100/
C
      DATA FIRST/.TRUE./
C
C
      IF (FIRST) THEN
        START = BCDF('STAR')
        CLWRD = BCDF('CLDA')
        NORM  = BCDF('NORM')
        NOMO  = BCDF('NOMO')
        FIRST = .FALSE.
      ENDIF
      DO 2 I=1,9
      NPTVCT(1,I)=BCDF(PNTVCT(I)(1:4))
    2 CONTINUE
      IF(ARG2(1).NE.CLWRD)GOTO 10
      ITYP=ARG4(1)
      IF(ITYP.EQ.NORM)GOTO 75
      IF(ITYP.NE.START.AND.ITYP.NE.NOMO)GOTO 5
      GOTO 100
C
C CLDAT/TP,TA,TV,...ETC.
C
    5 ICLCOD=1
      J=ITYP
      GOTO 85
C
   10 IF(ARG1(1).NE.1)GOTO 80
      NCLR(1)=ARG2(1)
      NCLR(2)=ARG2(2)
      J=ARG4(1)
      IF(ITYP.NE.START) GOTO 50
C
C CLDAT/START,IDX,.........
C
      ICLIDX=CLR
      DO 20 ICLINE=1,ICLCNT
      IF(ICLTAB(1,ICLINE).NE.ICLIDX)GOTO 20
C WARNING DIAGNOSTIC 94
C MULTIPLE DEFINED CLDAT-SECTION. FORMER SECTION DELETED.
      CALL ERROR(94,'CLDAT   ')
      GOTO 40
   20 CONTINUE
C IS ICLTAB FILLED ?
      IF(ICLCNT.LT.ICLDM)GOTO 30
C ERROR DIAGNOSTIC 95
C ARRAY ICLTAB FILLED. USE A FORMER DEFINED INDEX OR REDIMENSION ARRAY.
      CALL ERROR(95,'CLDAT   ')
      GOTO 100
   30 ICLCNT=ICLCNT+1
      ICLINE =ICLCNT
   40 CLDFG=.TRUE.
      ICLCOD=1
      ICLTAB(1,ICLINE)=ICLIDX
      ICLTAB(2,ICLINE)=0
      ICLTAB(3,ICLINE)=ICLCOD
      ICLTAB(4,ICLINE)=ICLBLK+1
      ICLTAB(5,ICLINE)=ICLRCD+3
      NUMCNT=0
      IF(J.EQ.0)GOTO 100
      GOTO 85
C
C CLDAT/NOMORE,IDX
C
   50 II=CLR
C WARNING DIAGNOSTIC 94
C CLDAT INDEXES ARE DIFFERENT. FIRST INDEX REMAINS VALID.
   70 IF(II.NE.ICLIDX)CALL ERROR(94,'CLDAT   ')
      ICLTAB(2,ICLINE)=ICLTAB(2,ICLINE)+NUMCNT
      CLDFG=.FALSE.
C
C CLDAT/NORMAL
C
   75 ICLCOD=0
      GOTO 100
C
   80 IF(ICLCOD.EQ.0)GOTO 100
      J=ARG2(1)
   85 K=ARG4(1)
      DO 90 II=1,9
      IF(J.NE.NPTVCT(1,II).AND.K.NE.NPTVCT(1,II))GOTO 90
      IF(MOD(ICLCOD,IPTVEC(II)).NE.0)ICLCOD=ICLCOD*IPTVEC(II)
      IF(CLDFG)ICLTAB(3,ICLINE)=ICLCOD
   90 CONTINUE
C
C OUTPUT CLDAT COMMAND ON EXFILE
C
  100 CALL APT299(ARG1,ARG2,ARG3,ARG4)
C
      RETURN
      END
**** SOURCE FILE : M0011487.V03   ***
*
C
C.....FORTRAN SUBROUTINE     CLDATF
C
C PURPOSE      TO RETRIEVE THE U OR V COORDINATE OR THE PATCH NUMBER
C              OF THE PART OR DRIVE SURFACE OF A PREVIOUS CL DATA
C              FROM EXFILE AND STORE IT IN RESULT.
C
C LINKAGE      CALL CLDATF(RESULT,ARG1,ARG2,ARG3)
C
C ARGUMENTS    RESULT  REAL VARIABLE TO CONTAIN THE DESIRED SCALAR.
C              ARG1    REAL NUMBER OF CLDAT SECTION.
C              ARG2    INTEGER DESIRED SCALAR NAME.
C              ARG3    REAL NUMBER OF DESIRED POINT.
C
C SUBSIDIARIES TYPE                ENTRY
C              SUBROUTINE          ATAPER
C
      SUBROUTINE CLDATF(RESULT,ARG1,ARG2,ARG3)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      INTEGER ARG2
C
      INCLUDE 'TOTAL.INC'
C
      DIMENSION P(6),NARG2(6)
C
      LOGICAL FIRST
      INTEGER BCDF
      SAVE FIRST,NARG2
C
      DATA FIRST/.TRUE./
C
      IF (FIRST)THEN
        NARG2(1) = BCDF('UDS ')
        NARG2(2) = BCDF('VDS ')
        NARG2(3) = BCDF('PDS ')
        NARG2(4) = BCDF('UPS ')
        NARG2(5) = BCDF('VPS ')
        NARG2(6) = BCDF('PPS ')
        FIRST = .FALSE.
      ENDIF
C
      DO 10 II=1,6
      IF(NARG2(II).EQ.ARG2)GOTO 20
   10 CONTINUE
C
   15 CALL ERROR(93,'CLDATF  ')
      RESULT=0.D0
C
      RETURN
   20 ITYP =8+II/4
      ISCT =ARG1
      IPNT =ARG3
      CALL ATAPER(P,IPNT,ISCT,ITYP,IEE)
      IF(IEE.EQ.0)GOTO 30
      GOTO 15
   30 IF(II.GT.3)II=II-3
      RESULT=P(II)
   40 RETURN
      END
**** SOURCE FILE : M0000712.W02   ***
*
C.....FORTRAN SUBROUTINE             COMP3D...              3/1/68   GK
      SUBROUTINE COMP3D
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C
      INTEGER PPWORD(2),BCDF
      CHARACTER*8 PP1
      DATA PP1/'3DCALC  '/
C
      I3DFLG=1
      PPWORD(1) = BCDF(PP1(1:4))
      PPWORD(2) = BCDF(PP1(5:8))
C
      CALL APT299(0,PPWORD,0,0)
      RETURN
      END
C
C
C
      SUBROUTINE NDTEST
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C
      INTEGER PPWORD(2),BCDF
      CHARACTER*8 PP2
      DATA PP2/'2DCALC  '/
C
      I3DFLG=0
      PPWORD(1) = BCDF(PP2(1:4))
      PPWORD(2) = BCDF(PP2(5:8))
C
      CALL APT299(0,PPWORD,0,0)
      RETURN
      END
C
C
C
      SUBROUTINE GOUGCK(DONOFF)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
      INCLUDE 'RMFLGS.INC'
C
      INTEGER PPWORD(2),BCDF
      CHARACTER PP3*8,DON*2,TEST*2
      DATA PP3/'GOUGCK  '/,DON/'ON'/
C
      CALL HOLFRM(DONOFF,TEST,1,2,NWD)
      IF (TEST.EQ.DON) THEN
        IGOUG=1
        LGCHK=.TRUE.
      ELSE
        IGOUG=0
        LGCHK=.FALSE.
      ENDIF
           
      PPWORD(1) = BCDF(PP3(1:4))
      PPWORD(2) = BCDF(PP3(5:8))
C
      CALL APT299(1,PPWORD,2,DONOFF)
      RETURN
      END
**** SOURCE FILE : M0000878.V07   ***
*
C
C.....FORTRAN SUBROUTINE             CPLAN....              4/1/68   GK
C
      SUBROUTINE CPLAN
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
      COMMON/ADDCOM/ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),
     2            (ADDCOM(25),KDYNFL)
C
C
      INCLUDE 'BLANKCOM.INC'
C
C
      DATA ZLIT1 / .05D0/
C
C
      TEMP(20)=RC(IS)
C                  TEST IF CYLINDER IT SURF,PLANE IS SURF
C
      IF(IPL(IS))10,1010,10
 10   IF(IFL4(IS))20,30,20
 20   IT = IPS
      GO TO 50
 30   IT = IDS
 50   GO TO 3000
 1010 CALL CROSS (SN(1,IS),SNK(1,IS),TEMP)
 1020 CALL VNORM (TEMP,TEMP)
 1030 IF(IER) 1040,1050,1040
 10500TEMP1=TEMP(1)*(SP(1,IS)-SPK(1,IS)) +
     1      TEMP(2)*(SP(2,IS)-SPK(2,IS)) +
     2      TEMP(3)*(SP(3,IS)-SPK(3,IS))
 1060 TEM(1)=SPK(1,IS)+TEMP1*TEMP(1)
      TEM(2)=SPK(2,IS)+TEMP1*TEMP(2)
      TEM(3)=SPK(3,IS)+TEMP1*TEMP(3)
 1090 CALL CCURV(IS,SP(1,IS),TEM,TN(1,IS))
 1120 IF(IFL4(IS))1130,1140,1130
 1130 IT = IPS
      ITT = IDS
      GO TO 1150
 1040 RC(IS)=RC1*DSIGN(Z1,RC(IS))
      GO TO 1120
 1140 IT = IDS
      ITT = IPS
 1150 IF(DABS(SP(3,IT)-SPK(3,IT))-Z1EM3) 2,1,1
    2 TEM(1)=TI(1)
      TEM(2)=TI(2)
      TEM(3)=TI(3)
      GO TO 5
    1 CALL CROSS(SN(1,IT),SN(1,ITT),TEM)
      CALL VNORM(TEM,TEM)
      IF(IER)2,3,2
    3 IF(TI(1)*TEM(1)+TI(2)*TEM(2)+TI(3)*TEM(3)) 4,5,5
    4 TEM(1)=-TEM(1)
      TEM(2)=-TEM(2)
      TEM(3)=-TEM(3)
    5 ISIS=IS
      IS=IT
      TEMP(4)=S(IS)
      TEMP(1)=TP(1,IS)
      TEMP(2)=TP(2,IS)
      TEMP(3)=TP(3,IS)
      TP(1,IS)=TP(1,IS)  -ZLIT1*TEM(1)
      TP(2,IS)=TP(2,IS)-ZLIT1*TEM(2)
      TP(3,IS)=TP(3,IS)-ZLIT1*TEM(3)
      CALL DDST
      TEM(1)=TP(1,IS)+S(IS)*TN(1,IS)
      TEM(2)=TP(2,IS)+S(IS)*TN(2,IS)
      TEM(3)=TP(3,IS)+S(IS)*TN(3,IS)
      TP(1,IS)=TEMP(1)
      TP(2,IS)=TEMP(2)
      TP(3,IS)=TEMP(3)
      S(IS)=TEMP(4)
      IS=ISIS
 1200 PLNCS(IS) = TN(1,IT)*TN(1,IS)+TN(2,IT)*TN(2,IS)+TN(3,IT)*TN(3,IS)
 1210 IF(EPS2(IS)-DABS(PLNCS(IS))) 1220,1240,1240
 1220 IF (CPLFL(IS)) 1250,1230,1250
 1230 DPLAN(1,IS) = TN(1,ITT)
      DPLAN(2,IS) = TN(2,ITT)
      DPLAN(3,IS) = TN(3,ITT)
      GO TO 1250
 1240 CALL CROSS(TN(1,IS),TN(1,IT),DPLAN(1,IS))
 1250 IF (IPL(IT)) 1600,1260,1600
C        USE RC1   FOR PROPER UNITS/ IMPLEMENTATION
 1600  IF ( DABS(RC(IS))-RC1 ) 1610,1620,1620
 1610 TEMP(1) = TN(1,IT)
      TEMP(2) = TN(2,IT)
      TEMP(3) = TN(3,IT)
      GO TO 1380
 1620 CPTST(IS)=-Z1
      PLND(IS)=S(IS)
      CPLFL(IS)=-Z1
      PLNV(1,IS)= TN(1,IS)
      PLNV(2,IS)= TN(2,IS)
      PLNV(3,IS)= TN(3,IS)
 9998 JCPR = 0
 9999 RC(IS)=TEMP(20)
      IF(KDYNFL.NE.K0) CALL APT238(K31)
      RETURN
 1260 CALL CCURV(IT,SP(1,IT),TEM,SN(1,IT))
      IF (KDYNFL.NE.K0) CALL APT238(K34)
 1310  IF ( DABS(RC(IT))-RC1 ) 1320,1600,1600
 1320 IF (IPL(IS)) 1340,1330,1340
 1340 CC(1,IS)= CC(1,IT)
      CC(2,IS)= CC(2,IT)
      CC(3,IS)= CC(3,IT)
      TEMP(1) = TN(1,IS)
      TEMP(2) = TN(2,IS)
      TEMP(3) = TN(3,IS)
      GO TO 1380
 1330  IF ( DABS(RC(IS))-RC1 ) 1370,1340,1340
 1370 TEMP(1) = CC(1,IT)-CC(1,IS)
      TEMP(2) = CC(2,IT)-CC(2,IS)
      TEMP(3) = CC(3,IT)-CC(3,IS)
      CALL VNORM(TEMP,TEMP)
      IF(IER)1380,1380,1340
 1380 CALL CROSS(TEMP,DPLAN(1,IS),PLNV(1,IS))
      CALL VNORM (PLNV(1,IS),PLNV(1,IS))
 1390 IF(IER)1400,1410,1400
C
 1400 JCPR = 1
      GO TO 9999
C
C                  FIND EXTREME POINT ON TOOL IN DIRECTION OF TEMP
C
 1410 ISS = IS
      IGS = 1
      IS  = IGS
      ITS = IT
C
C                  IF TAXIS NORM IT SURF, THEN TP = TE
C
      IF(MANTAX-2)1460,1415,1417
 1415 IF(IT-IPS)1460,1418,1460
 1417 IF(IT-IDS)1460,1418,1460
 1418 TP(1,IS)  =TE(1)
      TP(2,IS)=TE(2)
      TP(3,IS)=TE(3)
      GO TO 1470
 1460 CONTINUE
C
      TV=TEMP(1)*TN(1,IT)+TEMP(2)*TN(2,IT)+TEMP(3)*TN(3,IT)
      TEM(1)=DSIGN(Z1,TV)
      SN(1,IS)  =-TEM(1)*TEMP(1)
      SN(2,IS)=-TEM(1)*TEMP(2)
      SN(3,IS)=-TEM(1)*TEMP(3)
C                  USE TLNORM TO ESTABLISH CORRECT TOOL POINT
C
      RC(IS) = RC1
      CC(1,IS)=TP(1,IT)-RC(IS)*SN(1,IS)
      CC(2,IS)=TP(2,IT)-RC(IS)*SN(2,IS)
      CC(3,IS)=TP(3,IT)-RC(IS)*SN(3,IS)
      JTN(IS) =Z0
      CALL U1COMP
C
      ITSEG(IS)=1
      ITLON(IS)=ITLON(ISS)
      IAFL(IS) =-1
      JTLFLG(IS)=JTLFLG(ISS)
      IPL(IS) = Z1
      CALL TLNORM (U1(1,IS))
C
C                  COMPUTE MOVE TO BRING THIS TP ON TO THE CPLAN
C
 1470 CONTINUE
      PLND(ISS) = PLNV(1,ISS)*(CC(1,ISS)-TP(1,IS))
     1           +PLNV(2,ISS)*(CC(2,ISS)-TP(2,IS))
     2           +PLNV(3,ISS)*(CC(3,ISS)-TP(3,IS))
C
C                  RETURN
C
      IS=ISS
      IT=ITS
 1510 CPLFL(IS)=1.0
 1520 CPTST(IS)=CPTST(IS)+CPLFL(IS)
 1530 IF(CPTST(IS))9998,1520,9998
C
C                  SPECIAL ROUTE FOR CYLINDER IT SURF + PLANE IS SURF
C                  COMPUTE CPLAN POISTION FROM CANONICAL FORMS
C
 3000 IF((ISFIDN(IT).GT.K4).OR.(ISFIDN(IT).LT.K3)) GO TO 1010
      IC=ICANON(IT)
      TEMP(7)=CANON(IC+3)
      TEMP(8)=CANON(IC+4)
      TEMP(9)=CANON(IC+5)
      CALL CROSS(TEMP(7),SN(1,IS),PLNV(1,IS))
      CALL VNORM(PLNV(1,IS),PLNV(1,IS))
C
      CC(1,IS)=CANON(IC)
      CC(2,IS)=CANON(IC+1)
      CC(3,IS)=CANON(IC+2)
      PLNCS(IS)=TN(1,IT)*TN(1,IS)+TN(2,IT)*TN(2,IS)+TN(3,IT)*TN(3,IS)
      TEMP(1) = TN(1,IS)
      TEMP(2) = TN(2,IS)
      TEMP(3) = TN(3,IS)
      GO TO 1410
       END
**** SOURCE FILE : M0000713.V09   ***
*
C.....FORTRAN SUBROUTINE  ....CUT            8/68                 PH,HG
C.....FORTRAN SUBROUTINE             CUT   ...              3/1/68   GK
      SUBROUTINE CUT
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
C
C
C
      CHARACTER*4 PPWORD
      CHARACTER*32 MESAGE
C...
      DIMENSION     MSGARY(10)
C
      INTEGER BCDF,IPPWRD(2)
C
      DATA  PPWORD /'CUT '/
      DATA  MESAGE /' ...LOCATION WHERE CUT RESUMES..'/
      IF(JHLDFG.EQ.0) GO TO 1
      ITABH(ITHCNT)=6
      ITHCNT=ITHCNT+1
      RETURN
C
    1 CONTINUE
C...  OUTPUT CUTTER CENTERS ON EXFILE
      IF(ICUT)20,20,10
C
C...     WRITE ON EXFILE A MESSAGE INDICATING START OF CUT SEQUENCE
   10 MSGARY(1)=10
      MSGARY(2)=32
      DO 15 I=1,8
      I4 =I*4
      MSGARY(I+2) = BCDF(MESAGE(I4-3:I4))
   15 CONTINUE
      IPPWRD(1) = BCDF(PPWORD)
      IPPWRD(2) = BCDF('    ')
      CALL APT299(1,IPPWRD,27,MSGARY)
      ICL=K3
      ICUT=0
      CALL APT233
   20 CONTINUE
      RETURN
       END
C
C
C
      SUBROUTINE CUTH
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
C
C
C
      CHARACTER*4 PPWORD
      CHARACTER*32 MESAGE
C...
      DIMENSION     MSGARY(10)
C
      INTEGER BCDF
C
      DATA  PPWORD /'CUT '/
      DATA  MESAGE /' ...LOCATION WHERE CUT RESUMES..'/
C
    1 CONTINUE
C...  OUTPUT CUTTER CENTERS ON EXFILE
      IF(ICUT)20,20,10
C
C...     WRITE ON EXFILE A MESSAGE INDICATING START OF CUT SEQUENCE
   10 MSGARY(1)=10
      MSGARY(2)=32
      DO 15 I=1,8
      I4 =I*4
      MSGARY(I+2) = BCDF(MESAGE(I4-3:I4))
   15 CONTINUE
      IPPWRD = BCDF(PPWORD)
      CALL APT299(1,IPPWRD,27,MSGARY)
      ICL=K3
      ICUT=0
      CALL APT233
   20 CONTINUE
      RETURN
       END
**** SOURCE FILE : M0000714.V04   ***
*
C
C.....FORTRAN SUBROUTINE             DDCYLN...              4/1/68   GK
      SUBROUTINE DDCYLN(SRFACE)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
C
      DIMENSION SRFACE(7)
      IER=K0
      IF(ISTRUP.EQ.5)GO TO 47
      TEM(1)=TN(1,IS)*SRFACE(4)+TN(2,IS)*SRFACE(5)+TN(3,IS)*SRFACE(6)
      A=TN(1,IS)*TN(1,IS)+TN(2,IS)*TN(2,IS)+TN(3,IS)*TN(3,IS)
      TEM(2)=TP(1,IS)-SRFACE(1)
      TEM(3)=TP(2,IS)-SRFACE(2)
      TEM(4)=TP(3,IS)-SRFACE(3)
      TEM(5)=TEM(2)*SRFACE(4)+TEM(3)*SRFACE(5)+TEM(4)*SRFACE(6)
      B=TN(1,IS)*TEM(2)+TN(2,IS)*TEM(3)+TN(3,IS)*TEM(4)
      C=TEM(2)*TEM(2)+TEM(3)*TEM(3)+TEM(4)*TEM(4)
      A=A-TEM(1)*TEM(1)
      B=B-TEM(1)*TEM(5)
C              CHOOSE WELL-CONDITIONED FORMULA
      IF(DABS(C).LT.Z1EM9) GO TO 42
      IF(TEM(5)*TEM(5)/C-.9)42,42,44
42    C=C-TEM(5)*TEM(5)-SRFACE(7)*SRFACE(7)
      GO TO 46
   44 CALL CROSS (SRFACE(4),TEM(2),TEM(6))
      C=TEM(6)*TEM(6)+TEM(7)*TEM(7)+TEM(8)*TEM(8)-SRFACE(7)*SRFACE(7)
46    CALL QUAD
      IF(IER.EQ.1)GO TO 1000
      IF(ISTRUP.EQ.4)GO TO 50
      SPL(1,IS)=SP(1,IS)
      SPL(2,IS)=SP(2,IS)
      SPL(3,IS)=SP(3,IS)
      SNL(1,IS)=SN(1,IS)
      SNL(2,IS)=SN(2,IS)
      SNL(3,IS)=SN(3,IS)
50    SP(1,IS)=TP(1,IS)+S(IS)*TN(1,IS)
      SP(2,IS)=TP(2,IS)+S(IS)*TN(2,IS)
      SP(3,IS)=TP(3,IS)+S(IS)*TN(3,IS)
47    TEM(1)=SP(1,IS)-SRFACE(1)
      TEM(2)=SP(2,IS)-SRFACE(2)
      TEM(3)=SP(3,IS)-SRFACE(3)
      TEM(4)=TEM(1)*SRFACE(4)+TEM(2)*SRFACE(5)+TEM(3)*SRFACE(6)
      TEM(1)=TEM(1)-TEM(4)*SRFACE(4)
      TEM(2)=TEM(2)-TEM(4)*SRFACE(5)
      TEM(3)=TEM(3)-TEM(4)*SRFACE(6)
      TEM(5)=TEM(1)*TEM(1)+TEM(2)*TEM(2)+TEM(3)*TEM(3)
      IF(TEM(5)) 3,3,4
3     IER=K1
      GO TO 1000
4     TEM(5)=DSQRT(TEM(5))
      SN(1,IS)=TEM(1)/TEM(5)
      SN(2,IS)=TEM(2)/TEM(5)
      SN(3,IS)=TEM(3)/TEM(5)
1000  CONTINUE
      RETURN
      END
**** SOURCE FILE : M0000884.ORG   ***
*
C.....FORTRAN SUBROUTINE             DDLIM ...              3/1/68   GK
      SUBROUTINE DDLIM
C
C
      RETURN
       END
**** SOURCE FILE : M0002828.V04   ***
*
C
C
      SUBROUTINE DDPARA(U,V)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
      INCLUDE 'TOTAL.INC'
C...  ALL REFERENCES TO TEMP HAVE BEEN CHANGED TO TEMP1, AS
C...  TEMP OCCURS IN FXCOR.INC
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
      EQUIVALENCE (TEMP1(11),DIF(1)), (TEMP1(13),DISP(1))
      EQUIVALENCE  (TEMP1(19),UU), (TEMP1(20),VV)
      DIMENSION DERU(3,4),DERV(3,4),DIF(2),P(3),DISP(3)
      DIMENSION US(25),VS(25),SPLL(3),SDIF(3),T1(3),T2(3)
      DIMENSION PDUM(3),PDUM1(3)
      LOGICAL CKDEF
      DIMENSION IFSTT(4) ,TEMP1(25)
      DATA IFSTT /4*0/
C
C  --------------------------------------------------------------~
C
      Z1EM4=0.00003
      IDEBUG = 0
      UU=U
      VV=V
      IS2=IS+2
      IP=IS/80
      IF ( JENT(IS).EQ.0) IFSTT(IP)=0
      IF (JENT(IS).EQ.1 .AND. IFSTT(IP).EQ.0 ) GO TO 4040
      MMODE=2
 4039 MODE=2
      GO TO 4090
 4040 MMODE=1
      IF(CKDEF(U)) CALL AERR(27004,'DDPARA  ')
      IF(CKDEF(V)) CALL AERR(27005,'DDPARA  ')
      IFSTT(IP) = 1
      IF ( ISTRUP.EQ.1 .AND. INDIR(IS).EQ.1) GO TO 4039
C------MODE=1 MEANS AN SNXP COMPUTATION IS BEING REQUESTED
C------ COMPUTE THE CLOSEST POINT ON THE TANGENT PLANE TO THE TOOL POINT
      MODE=1
 4090 CONTINUE
      TEM(1)=SN(1,IS)
      TEM(2)=SN(2,IS)
      TEM(3)=SN(3,IS)
      TEM(4)=SP(1,IS)
      TEM(5)=SP(2,IS)
      TEM(6)=SP(3,IS)
C------THE FOLLOWING LOOP ATTEMPTS BY AN ITERATIVE TECHNIQUE, TO
C------FIND THE SURFACE POINT SP AND SURFACE NORMAL SN WHERE THE
C------TOOL RAY TP,TN INTERSECTS THE SURFACE
      LCT=0
   10 CALL LCLS(UU,VV,SP(1,IS),DERU(1,IP),DERV(1,IP),MMODE)
C------THE ABOVE CALL INITIATES A LINKAGE OF A PROGRAMMER SUPPLIED
C------FORTRAN SUBROUTINE WHICH DEFINES THE CURRENT PARAMETRIC
C------SURFACE.  THE PARAMETER VALUES U,V,W ARE INITIALLY SUPPLIED
C------FROM THE PART PROGRAM TO GIVE THIS ALGORITHM A GOOD STARTUP
C------POINT  THE SURFACE PT AND NORMAL CORRESPONDING TO THESE
C------PARAMETER VALUES ARE RETURNED.  THEREAFTER, THE ROUTINE
C------MODIFIES THE U V PARAMETER VALUES UNTIL THEY GENERATE A GOOD
C------SURFACE POINT
      TEMP1(1) = SP(1,IS) - TP(1,IS)
      TEMP1(2) = SP(2,IS) - TP(2,IS)
      TEMP1(3) = SP(3,IS) - TP(3,IS)
   22 S(IS) = TEMP1(1)*SN(1,IS) + TEMP1(2)*SN(2,IS) + TEMP1(3)*SN(3,IS)
C------IF TOOL POINT AND SURF PT ARE CLOSE THEN MAKE NORMAL EXIT
      DTEMP = DSQRT( TEMP1(1)**2+TEMP1(2)**2+TEMP1(3)**2 )
      INORM = 1
       IF ( DTEMP .LT. Z1EM4 ) GO TO 40
C------ IF IMODE=1 CHECK FOR SUFACE NORMAL ALLIGNMENT WITH TOOL POINT
      ZANG=SN(1,IS)*TEMP1(1)+SN(2,IS)*TEMP1(2)+SN(3,IS)*TEMP1(3)
      XANG = DABS(ZANG)/DTEMP
      IF(MODE.EQ.1.AND.DABS(XANG-1.0).LT.Z1EM4) GO TO 40
      ANG = 1.0 - DABS(S(IS)/DTEMP)
      DEN = TN(1,IS)*SN(1,IS) + TN(2,IS)*SN(2,IS) + TN(3,IS)*SN(3,IS)
C------IF THE TOOL NORMAL AND SURFACE NORMAL ARE NEARLY PERPENDICULAR
C------THEN TAKE AN ABNORMAL EXIT
      INORM = 2
      IF ( MODE .EQ. 2 .AND. DABS(DEN) .LT. Z1EM4 ) GO TO 70
C------THE FIRST TIME THROUGH, COMPUTE THE INTERSECTION OF THE
C------TOOL RAY TP,TN AND THE STARTUP SURFACE PLANE
      IF ( DABS(DEN) .GT. 1.0D-6) S(IS)=S(IS)/DEN
C------IF THE SURFACE POINT IS CLOSE TO THE TOOL RAY, THEN EXIT NORMALLY
      DOT = TEMP1(1)*TN(1,IS) + TEMP1(2)*TN(2,IS) +TEMP1(3)*TN(3,IS)
      DO 6031 LL=1,3
 6031 PDUM(LL) = TEMP1(LL) - DOT*TN(LL,IS)
      DDUM = DSQRT( PDUM(1)**2 + PDUM(2)**2 + PDUM(3)**2)
      INORM = 4
      IF ( MODE .EQ. 2 .AND. DDUM .LT. Z1EM4 ) GO TO 40
      IF ( MODE .EQ. 1 ) GO TO 501
C------P IS THE POINT OF INTERSECTION OF TANGENT PLANE AND TOOL RAY
      P(1) = TP(1,IS) + S(IS)*TN(1,IS)
      P(2) = TP(2,IS) + S(IS)*TN(2,IS)
      P(3) = TP(3,IS) + S(IS)*TN(3,IS)
      GO TO 601
  501 CONTINUE
      P(1) = TP(1,IS) +  ZANG*SN(1,IS)
      P(2) = TP(2,IS) +  ZANG*SN(2,IS)
      P(3) = TP(3,IS) +  ZANG*SN(3,IS)
  601 CONTINUE
      DISP(1) = P(1) - SP(1,IS)
      DISP(2) = P(2) - SP(2,IS)
      DISP(3) = P(3) - SP(3,IS)
C------FIND A CHANGE DU,DV IN U,V SUCH THAT DU*DERU+DV*DERV=DISP
      DO 5014 L=1,6
 5014 TEMP1(L)=0
      DO 5015 L=1,3
      TEMP1(1) = TEMP1(1) + DERU(L,IP)*DERU(L,IP)
      TEMP1(2) = TEMP1(2) + DERU(L,IP)*DERV(L,IP)
      TEMP1(3) = TEMP1(3) + DERV(L,IP)*DERV(L,IP)
      TEMP1(5) = TEMP1(5) + DISP(L)  *DERU(L,IP)
 5015 TEMP1(6) = TEMP1(6) + DISP(L)  *DERV(L,IP)
      DO 5016 L=1,6
      IF ( DABS(TEMP1(L)) .LT. 1.0D-30) TEMP1(L)=0.0
 5016 CONTINUE
      TEMP1(4) = TEMP1(1)*TEMP1(3) - TEMP1(2)**2
      IF ( DABS(TEMP1(4)).LT. 1.0D-30 ) GO TO 40
      DIF(1) = ( TEMP1(3)*TEMP1(5) - TEMP1(2)*TEMP1(6) )/ TEMP1(4)
      DIF(2) = ( TEMP1(1)*TEMP1(6) - TEMP1(2)*TEMP1(5) )/ TEMP1(4)
      TU = UU + DIF(1)
      TV = VV + DIF(2)
      IF(MODE.EQ.3) GO TO 3041
C------SAVE THE CURRENT SURFACE NORMAL SINCE LCLS RESETS SN
      DO 6713 L=1,3
 6713 T1(L)=SN(L,IS)
      CALL LCLS(TU,TV,SPLL,PDUM,PDUM1,MMODE)
C------RESTORE THE OLD SURFACE NORMAL
      DO 6714 L=1,3
 6714 SN(L,IS)=T1(L)
C------AFTER THE FIRST PASS, USE THE LAST SURFACE POINT AND PARA-
C------BOLIC INTERPOLATION TO ESTIMATE BETTER U,V VALUES
 3100 CONTINUE
C------FIRST SETUP THE APPROXIMATING PARABOLA TO THE SURFACE
      DO 3040 L = 1,3
 3040 SDIF(L) = SPLL(L) - SP(L,IS)
      CALL VNORM(SDIF,SDIF)
      IF(VTEM.GT.1.0D-12) GO TO 3042
      IFSTT(IP)=3
      MODE=3
 3041 UU=TU
      VV=TV
      GO TO 10
 3042 CALL CROSS(SDIF,SN(1,IS),T1)
      CALL CROSS( T1, SN(1,IS), T2)
      CALL VNORM( T2, T2)
C------ T2 IS NOW THE PARABOLIC TANGENT VECTOR
      PX = SDIF(1)*T2(1) + SDIF(2)*T2(2) + SDIF(3)*T2(3)
      PY = SDIF(1)*SN(1,IS) + SDIF(2)*SN(2,IS) + SDIF(3)*SN(3,IS)
      PCURV = PY/(PX*PX)
C------ THE PARABOLA IS NOW R(S) = SP + S*T2 + S**2*PCURV*SN
      DO 3050 L=1,3
 3050 T1(L) = PCURV*SN(L,IS)
C------ NOW CALL FOR THE CLOSEST APPROACH BETWEEN THE PARABOLA AND
C------AND THE TOOL RAY
      CALL PARLND( TP(1,IS),TN(1,IS),SP(1,IS),T2,T1,S(IS),PDUM,
     1           SA,PDUM1,DDUM,MODE,IOP(IS),IFAIL )
      IF ( IFAIL .EQ. 1 ) GO TO 70
C------ IF THE TOOL RAY LIES CLOSE TO THE PARABOLA, THEN EXIT NORMALLY
C------ON RETURN, S(IS) IS THE DISTANCE ALONG THE TOOL NORMAL FROM
C------TP TO CLOSEST APPROACH TO THE PARABOLA.  SA IS THE PARAMETER
C------VALUE WHICH DEFINES THE POINT ON THE PARABOLA.  OTHER
C------VARIABLES RETURNED (PDUM,PDUM1,DDUM) ARE NOT NEEDED HERE
C------ FROM THIS CONSTRUCT AN ESTIMATED DISPLACEMENT VECTOR
      DO 3060 L = 1,3
      DISP(L) = SA*T2(L)
      IF ( DABS(DISP(L)) .LT. 1.0D-30 ) DISP(L)=0.0
 3060 CONTINUE
 4010 CONTINUE
C------IF DISP IS VERY SMALL, MAKE A NORMAL EXIT
      TEMP1(1) = DISP(1)**2 + DISP(2)**2 + DISP(3)**2
      TEMP1(1) = DSQRT(TEMP1(1))
      INORM = 5
      IF(TEMP1(1).LT.1.0D-06) GO TO 40
C------TEST FOR LOOP COUNTER EXCEEDED
      IF( LCT .GT. 24 ) GO TO 70
C------FIND A CHANGE DU,DV IN U,V SUCH THAT DU*DERU+DV*DERV=DISP
   85 DO 3070 L=1,6
 3070 TEMP1(L) = 0.
      DO 3080 L = 1,3
      TEMP1(1) = TEMP1(1) + DERU(L,IP)*DERU(L,IP)
      TEMP1(2) = TEMP1(2) + DERU(L,IP)*DERV(L,IP)
      TEMP1(3) = TEMP1(3) + DERV(L,IP)*DERV(L,IP)
      TEMP1(5) = TEMP1(5) + DISP(L)  *DERU(L,IP)
 3080 TEMP1(6) = TEMP1(6) + DISP(L)  *DERV(L,IP)
      DO 3085 L=1,6
      IF ( DABS(TEMP1(L)) .LT. 1.0D-30) TEMP1(L)=0.0
 3085 CONTINUE
      TEMP1(4) = TEMP1(1)*TEMP1(3) - TEMP1(2)**2
      IF ( DABS(TEMP1(4)).LT. 1.0D-30 ) GO TO 40
      DIF(1) = ( TEMP1(3)*TEMP1(5) - TEMP1(2)*TEMP1(6) )/ TEMP1(4)
      DIF(2) = ( TEMP1(1)*TEMP1(6) - TEMP1(2)*TEMP1(5) )/ TEMP1(4)
      UU = UU + DIF(1)
      VV = VV + DIF(2)
      LCT = LCT + 1
      US(LCT) = UU
      VS(LCT) = VV
C------INTRODUCE ARITHMETIC MEANS TO AVOID OSCILLATIONS
      IF ( LCT .LT. 9 ) GO TO 250
      UU = 0.
      VV = 0.
      DO 260 LL = 9, LCT
      UU = UU + US(LL)
  260 VV = VV + VS(LL)
      UU = UU/(LCT-8)
      VV = VV/(LCT-8)
  250 CONTINUE
      GO TO 10
C------        END OF U,V ITERATIVE LOOP LOGIC
   40 IF(MODE.NE.1) GO TO 4050
      IF ( DTEMP .LT. Z1EM4 ) GO TO 4050
      TN(1,IS)=SP(1,IS)-TP(1,IS)
      TN(2,IS)=SP(2,IS)-TP(2,IS)
      TN(3,IS)=SP(3,IS)-TP(3,IS)
      S(IS)=DSQRT(TN(1,IS)**2+TN(2,IS)**2+TN(3,IS)**2)
      CALL VNORM (TN(1,IS),TN(1,IS) )
 4050 CONTINUE
   55 SNL(1,IS) = TEM(1)
      SNL(2,IS) = TEM(2)
      SNL(3,IS) = TEM(3)
      SPL(1,IS) = TEM(4)
      SPL(2,IS) = TEM(5)
      SPL(3,IS) = TEM(6)
C------IF STARTUP IS FINISHED , LET U,V ASSUME THE LAST DEFINED
C------UU,VV VALUES
      U=UU
      V=VV
      IF(IOP(IS).NE.1.OR.S(IS).GE.0.0) GO TO 999
C------  ERROR EXIT FOLLOWS
   70 CONTINUE
C------ IF TOOL NORMAL DIDNOT INTERSECT SURFACE, TRY TO FIND AN SRP
      IF ( MODE .EQ. 2 ) GO TO 1740
      IER = 1
  999 CONTINUE
      JENTL=JENT(IS)
      RETURN
 1740 CONTINUE
      MODE = 1
      UU = U
      VV = V
      GO TO 4090
      END
**** SOURCE FILE : DDPARS00.ORG   ***
*
      SUBROUTINE DDPARS(PCANON)
*
*  * DDPARS *  VAX-11 FORTRAN 77 VERSION  29.8.86  E.MCLELLAN
*
*  PURPOSE     TO SET THE ADDRESSES OF THE PARAMETERS U AND V
*              IN THE ARGUMENT LIST FOR A CALL TO DDPARA AND
*              TO SERVE AS A DISPATCHER BETWEEN DDST AND DDPARA
*
*  CALLING SEQUENCE
*              CALL DDPARS(PCANON)
*  ARGUMENTS
*              PCANON   ARRAY CONTAINING THE CANONICAL FORM OF
*                      A PARAMTRIC SURFACE
*
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C
      INCLUDE 'LDEF.INC'
      INCLUDE 'BLANKCOM.INC'
C
C
      INTEGER XCANON
      EXTERNAL XCANON
C
      DIMENSION PCANON(10)
C
C
C.....PICK UP VIRTUAL ADDRESSES OF U AND V FROM PCANON ARRAY
C
      IU=INT(PCANON(2))
      IV=INT(PCANON(3))
C
C.....CONVERT TO ACTUAL ADDRESSES
C
      IF (CANFLG) IU=XCANON(IU)
      U=COM(IU)
      IF (CANFLG) IV=XCANON(IV)
      V=COM(IV)
C
C.....CALL DDPARA(U,V)
C
      CALL DDPARA(U,V)
C
      RETURN
      END
**** SOURCE FILE : M0000887.V04   ***
*
C
C.....FORTRAN SUBROUTINE             DDPLAN...              3/1/68   GK
      SUBROUTINE DDPLAN(SRFACE)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
C
      DIMENSION SRFACE(4)
      IER=K0
      IF(ISTRUP.EQ.5)GO TO 5
      S(IS)=SRFACE(4)
      TEM(1)=TN(1,IS)*SRFACE(1)+TN(2,IS)*SRFACE(2)+TN(3,IS)*SRFACE(3)
      S(IS)=S(IS)-(TP(1,IS)*SRFACE(1)+TP(2,IS)*SRFACE(2)+
     1TP(3,IS)*SRFACE(3))
      IF(DABS(TEM(1))-Z1EM7) 3,3,2
    2 S(IS)=S(IS)/TEM(1)
      ADUMY=IOP(IS)
      IF (IOP(IS).EQ.-1) GOTO 4
      IF(ADUMY*S(IS)) 3,4,4
    3 IER=K1
      RETURN
4     IF(ISTRUP.EQ.4)GO TO 6
      SPL(1,IS)=SP(1,IS)
      SPL(2,IS)=SP(2,IS)
      SPL(3,IS)=SP(3,IS)
      SNL(1,IS)=SN(1,IS)
      SNL(2,IS)=SN(2,IS)
      SNL(3,IS)=SN(3,IS)
6     SP(1,IS)=TP(1,IS)+S(IS)*TN(1,IS)
      SP(2,IS)=TP(2,IS)+S(IS)*TN(2,IS)
      SP(3,IS)=TP(3,IS)+S(IS)*TN(3,IS)
5     SN(1,IS)=SRFACE(1)
      SN(2,IS)=SRFACE(2)
      SN(3,IS)=SRFACE(3)
      RETURN
      END
**** SOURCE FILE : M0000888.V05   ***
*
C
C.....FORTRAN SUBROUTINE             DDQUAD...              3/1/68   GK
      SUBROUTINE DDQUAD(SRFACE)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
C
C
      DIMENSION SRFACE(10)
      IER=0
      IF(ISTRUP.EQ.5)GO TO 1015
      IF(JSW.EQ.5.OR.JSW.EQ.9)GO TO 5
      DO 1 I=1,10
    1 TEM(I)=SRFACE(I)
      A=Z2*(TEM(6)*TN(3,IS)*TN(1,IS)
     1     +TEM(7)*TN(1,IS)*TN(2,IS)
     2     +TEM(5)*TN(2,IS)*TN(3,IS))
     3     +TN(1,IS)**2*TEM(1)+TN(2,IS)**2*TEM(2)
     4     +TN(3,IS)**2*TEM(3)
      B=(TEM(1)*TN(1,IS)+TEM(7)*TN(2,IS)+TEM(6)*TN(3,IS))*TP(1,IS)
     1 +(TEM(7)*TN(1,IS)+TEM(2)*TN(2,IS)+TEM(5)*TN(3,IS))*TP(2,IS)
     2 +(TEM(6)*TN(1,IS)+TEM(5)*TN(2,IS)+TEM(3)*TN(3,IS))*TP(3,IS)
     3 +TN(1,IS)*TEM(8)+TN(2,IS)*TEM(9)+TN(3,IS)*TEM(10)
      C=Z2*(TEM(6)*TP(3,IS)*TP(1,IS)
     1  +TEM(7)*TP(1,IS)*TP(2,IS)
     2  +TEM(5)*TP(2,IS)*TP(3,IS)
     3  +TP(1,IS)*TEM(8)+TP(2,IS)*TEM(9)+TP(3,IS)*TEM(10))
     4  +TP(1,IS)**2*TEM(1)+TP(2,IS)**2*TEM(2)
     5  +TP(3,IS)**2*TEM(3)+TEM(4)
      GO TO 1000
5     A=TN(1,IS)*TN(1,IS)+TN(2,IS)*TN(2,IS)+TN(3,IS)*TN(3,IS)
      TEM(1)=TP(1,IS)-SRFACE(1)
      TEM(2)=TP(2,IS)-SRFACE(2)
      TEM(3)=TP(3,IS)-SRFACE(3)
      B=TEM(1)*TN(1,IS)+TEM(2)*TN(2,IS)+TEM(3)*TN(3,IS)
      E=TEM(1)*TEM(1)+TEM(2)*TEM(2)+TEM(3)*TEM(3)
      IF(JSW.EQ.9)GO TO 10
      C=E-SRFACE(4)*SRFACE(4)
      GO TO 1000
10    TEM(4)=SRFACE(7)*SRFACE(7)
      TEM(5)=A
      A=TN(1,IS)*SRFACE(4)+TN(2,IS)*SRFACE(5)+TN(3,IS)*SRFACE(6)
      D=TEM(1)*SRFACE(4)+TEM(2)*SRFACE(5)+TEM(3)*SRFACE(6)
      B=A*D-TEM(4)*B
      A=A*A-TEM(5)*TEM(4)
      C=D*D-TEM(4)*E
      CALL QUAD
      IF(IER)20,20,3000
20    CONTINUE
      IF((TEM(1)+S(IS)*TN(1,IS))*SRFACE(4)+(TEM(2)+S(IS)*TN(2,IS))*
     1SRFACE(5)+(TEM(3)+S(IS)*TN(3,IS))*SRFACE(6))25,25,1011
C
C     **SOLUTION INVALID**
C
25    IF(SURD)30,50,40
30    IF(IOP(IS))40,40,50
40    S(IS)=SURD
      SURD=Z0
      GO TO 20
50    IER=1
      GO TO 3000
1000  CALL QUAD
1010  IF(IER.EQ.1)GO TO 3000
1011  IF(ISTRUP.EQ.4)GO TO 1012
      SPL(1,IS)=SP(1,IS)
      SPL(2,IS)=SP(2,IS)
      SPL(3,IS)=SP(3,IS)
      SNL(1,IS)=SN(1,IS)
      SNL(2,IS)=SN(2,IS)
      SNL(3,IS)=SN(3,IS)
1012  SP(1,IS)=TP(1,IS)+S(IS)*TN(1,IS)
      SP(2,IS)=TP(2,IS)+S(IS)*TN(2,IS)
      SP(3,IS)=TP(3,IS)+S(IS)*TN(3,IS)
1015  IF(JSW.EQ.5.OR.JSW.EQ.9)GO TO 2000
      TEM(1)=SRFACE(1)*SP(1,IS)+SRFACE(7)*SP(2,IS)+
     1SRFACE(6)*SP(3,IS)+SRFACE(8)
      TEM(2)=SRFACE(7)*SP(1,IS)+SRFACE(2)*SP(2,IS)+
     1SRFACE(5)*SP(3,IS)+SRFACE(9)
      TEM(3)=SRFACE(6)*SP(1,IS)+SRFACE(5)*SP(2,IS)+
     1SRFACE(3)*SP(3,IS)+SRFACE(10)
      CALL VNORM(TEM,SN(1,IS))
      GO TO 3000
2000  SN(1,IS)=SP(1,IS)-SRFACE(1)
      SN(2,IS)=SP(2,IS)-SRFACE(2)
      SN(3,IS)=SP(3,IS)-SRFACE(3)
      CALL VNORM(SN(1,IS),SN(1,IS))
      IF(JSW.EQ.5)GO TO 3000
      IF(IER)2002,2002,2009
2009  IER=0
      SN(1,IS)=-SRFACE(4)
      SN(2,IS)=-SRFACE(5)
      SN(3,IS)=-SRFACE(6)
      GO TO 3000
2002  TEM(4)=SN(1,IS)*SRFACE(4)+SN(2,IS)*SRFACE(5)+SN(3,IS)*SRFACE(6)
      TEM(6)=DSQRT(Z1-TEM(4)*TEM(4))
      TEM(7)=DSQRT(Z1-SRFACE(7)*SRFACE(7))
      TEM(8)=TEM(4)*SRFACE(7)+TEM(6)*TEM(7)
      IF(TEM(8))3000,2005,2005
 2005 SN(1,IS)=(SRFACE(7)*SN(1,IS)-TEM(8)*SRFACE(4))/TEM(6)
      SN(2,IS)=(SRFACE(7)*SN(2,IS)-TEM(8)*SRFACE(5))/TEM(6)
      SN(3,IS)=(SRFACE(7)*SN(3,IS)-TEM(8)*SRFACE(6))/TEM(6)
3000  RETURN
      END
**** SOURCE FILE : M0000889.V07   ***
*
C.....FORTRAN SUBROUTINE  ....DDRLSR         8/68                 RN,PH
C...  FORTRAN SUBROUTINE               DDRLSR
C
C              FORTRAN SUBROUTINE DDRLSR
C
C PURPOSE      TO CALCULATE THE SCALAR S,GIVEN THE VECTORS TP AND TN,
C              SUCH THAT TP+S*TN IS A POINT ON THE RULED SURFACE AND
C              ALSO TO CALCULATE THE SURFACE NORMAL AT THAT POINT
C
C LINKAGE      CALL DDRLSR
C
C CALLS        VNORM,CROSS
C
C
      SUBROUTINE DDRLSR
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DOUBLE PRECISION LCANON
C
      INCLUDE 'TOTAL.INC'
C...  ALL REFERENCES TO ARRAY R HAVE BEEN CHANGED TO R0,
C...  BECAUSE R OCCURS IN DSHAR4.INC.
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
C
C
C              COMMON,DIMENSION AND EQUIVALENCE FOR RLDSR
C
      INCLUDE 'BLANKCOM.INC'
C
      DIMENSION LCANON(COMSIZ)
      EQUIVALENCE  (CANON(1),P(1),W(1),F(1),PP(1),
     /                      WP(1),VP(1),LCANON(1)),
     1            (CANON(18),R2(3),R3(6),R0(9),SL(12),ZN(15),ZLAMBD(16),
     2             DELTA(17),IFST(18))
      DIMENSION P(COMSIZ),W(COMSIZ),F(COMSIZ),PP(COMSIZ),WP(COMSIZ),
     1VP(COMSIZ),ZN(COMSIZ-3),SL(COMSIZ-6),R3(COMSIZ-12),R2(COMSIZ-15),
     2R0(COMSIZ-9),Q1(3),W1(3),V1(3),Q2(3),W2(3),V2(3),D(3),PO(3),DV(3),
     3         DVP(3),E(3),DC(3),DCP(3),SC(3),CP(3),X(3),FC(3),UT1(3),
     4T1(3),AA(3),BB(3),IFST(COMSIZ),DELTA(COMSIZ-1),ZLAMBD(COMSIZ-2)
     5   ,S1(3),SPLL(3),SNLL(3)
     6        ,SPLLL(3)
C              NOTE THIS SUBROUTINE HAS BEEN COPIED FORM THE APT SYSTEM
C                   CURRANT AS OF 9/1/67. NONE OF THE NAMES HAVE BEEN
C                   CHANGED TO PROTECT THE INNOCENT.
C...           (EXCEPT FOR R, AS MENTIONED WITH THE INCLUDE STATEMENTS)
      DIMENSION LCIC(12)
      DOUBLE PRECISION IFST
      COMMON/TRACFL/TRACFL
      LOGICAL TRACFL
C     INITIALIZE
C
      ILIM = IC+160
      ICSS = IC
      IOPS = IOP(IS)
      I=ICANON(IS)
      JSW1 = ISFIDN(IS)
      IOP(IS) = -1
      IGUESS = 0
      LOOP = 25
      EP2 = .00001
      DO 10 I = 1,3
      D(I) = TN(I,IS)
      PO(I) = TP(I,IS)
      SPLL(I)=SPL(I,IS)
      SNLL(I)=SNL(I,IS)
      SPLLL(I) = SP(I,IS)
      SPL(I,IS) = SP(I,IS)
      SNL(I,IS)=SN(I,IS)
 10   CONTINUE
C
C
C     COMPUTE VARIABLE SUBSCRIPTS
      DO 11 I=2,12
   11 LCIC(I)=LCANON(IC+I)+0.1
      LSD=IC+LCIC(2)+4
      LS1=IC+LCIC(3)
      LP=IC+LCIC(4)
      LW=IC+LCIC(5)
      LV=IC+LCIC(6)
      LS2=IC+LCIC(7)
C
      JSW2 = LCANON(LS1-1)
      JSW3 = LCANON(LS2-1)
      Q1(1) = P(LP)
      Q1(2) = P(LP+1)
      Q1(3) = P(LP+2)
      W1(1) = W(LW)   - Q1(1)
      W1(2) = W(LW+1) - Q1(2)
      W1(3) = W(LW+2) - Q1(3)
      CALL VNORM (W1,DV)
C
C     STORE LENGTH OF W1 IN EP5
C
      EP5 = VTEM
      V1(1) = F(LV)
      V1(2) = F(LV+1)
      V1(3) = F(LV+2)
C
C.... FIRST TIME. SET TN
      I=ICANON(IS)
      IF(IOPS.NE.2) GO TO 12
      D(1) = V1(1)
      D(2) = V1(2)
      D(3) = V1(3)
   12 ICSS2 = LCANON(ICSS+2) + 0.1
C
      IF (ICSS2.EQ.5) GOTO 20
      LPP=IC+LCIC(8)
      LWP=IC+LCIC(9)
      LVP=IC+LCIC(10)
      Q2(1) = PP(LPP)
      Q2(2) = PP(LPP+1)
      Q2(3) = PP(LPP+2)
      W2(1) = WP(LWP)   - Q2(1)
      W2(2)=WP(LWP+1)-Q2(2)
      W2(3) = WP(LWP+2) - Q2(3)
      CALL VNORM (W2,DVP)
      EP6 = VTEM
      V2(1) = VP(LVP)
      V2(2) = VP(LVP+1)
      V2(3) = VP(LVP+2)
      GO TO 30
   20 CP(1) = PP(LS2)
      CP(2) = PP(LS2+1)
      CP(3) = PP(LS2+2)
      DCP(1) = 0.
      DCP(2) = 0.
      DCP(3) = 0.
   30 IF(IFST(LSD).NE.0.) GO TO 220
      IFST(LSD)=1.0
   40 LOOP = 25
      IGUESS = IGUESS + 1
      ZLAMBD(LSD) = 0.5
      ISFIDN(IS) = JSW1
      IF(IGUESS.LE.8) GO TO 60
      IER = 1
   50 TP(1,IS) = PO(1)
      TP(2,IS) = PO(2)
      TP(3,IS) = PO(3)
      TN(1,IS) = D(1)
      TN(2,IS) = D(2)
      TN(3,IS) = D(3)
      ISFIDN(IS) = JSW1
      IOP(IS) = IOPS
      IF(IER.EQ.1) GO TO 53
      DO 52 I=1,3
      SP(I,IS) = TP(I,IS) + S(IS) * TN(I,IS)
   52 CONTINUE
      GO TO 55
   53 CONTINUE
      DO 54 I = 1,3
      SP(I,IS) =SPLLL(I)
      SN(I,IS) =SNL(I,IS)
      SPL(I,IS)=SPLL(I)
      SNL(I,IS)=SNLL(I)
   54 CONTINUE
   55 IC=ICANON(IS)
      RETURN
C
   60 GO TO (65,70,80,90,100,110,120,130),IGUESS
   65 IF(INDIR(IS).EQ.1) GO TO 68
      XDIS1=(PO(1)-P(LP))**2+(PO(2)-P(LP+1))**2+(PO(3)-P(LP+2))**2
      XDIS2=(PO(1)-W(LW))**2+(PO(2)-W(LW+1))**2+(PO(3)-W(LW+2))**2
      DELTA(LSD)=0.3
      IF(XDIS2.LT.XDIS1) DELTA(LSD)=0.7
      GO TO 140
   68 IGUESS=IGUESS+1
   70 DELTA(LSD) = .5
      GO TO 140
   80 DELTA(LSD) = .999
      GO TO 140
   90 DELTA(LSD) = .001
      GO TO 140
  100 DELTA(LSD) = .75
      GO TO 140
  110 DELTA(LSD) = .25
      GO TO 140
  120 DELTA(LSD) =-.2
      GO TO 140
  130 DELTA(LSD) = 1.2
C
  140 ICSS2=LCANON(ICSS+2)+0.1
      IF(ICSS2.EQ.5) GO TO 160
C
      DO 150 I = 1,3
      X(I) = Q2(I) + DELTA(LSD)*W2(I)
  150 BB(I) = DVP(I)
      TN(1,IS)=V2(1)
      TN(2,IS) = V2(2)
      TN(3,IS) = V2(3)
      EP = EP6
      IC = LS2
      ISFIDN(IS) = JSW3
      CALL CROSS (V2,DVP,SC)
      GO TO 180
C
  155 CP(1) = E(1)
      CP(2) = E(2)
      CP(3) = E(3)
      DCP(1) = DC(1)
      DCP(2) = DC(2)
      DCP(3) = DC(3)
C
C
  160 DO 170 I = 1,3
      X(I) = Q1(I) + DELTA(LSD)*W1(I)
  170 BB(I) = DV(I)
      EP = EP5
      TN(1,IS) = V1(1)
      TN(2,IS) = V1(2)
      TN(3,IS) = V1(3)
      IC = LS1
      ISFIDN(IS) = JSW2
      CALL CROSS (V1,DV,SC)
  180 CALL VNORM (SC,FC)
      SIGN1 = VTEM
      IF (IER.NE.0) GO TO 40
      TP(1,IS) = X(1)
      TP(2,IS) = X(2)
      TP(3,IS) = X(3)
      AA(1) = 0.
      A = 0.
      B = 0.
      C = 0.
C
      JSW = ISFIDN(IS)
      IV=ISTRUP
      ISTRUP=4
      GOTO(250,250,255,255,265,265,265,265,265,265,275,182,280,265),JSW
  250 CALL DDPLAN(CANON(IC))
       GO TO 182
  255 CALL DDCYLN(CANON(IC))
       GO TO 182
  265 CALL DDQUAD(CANON(IC))
       GO TO 182
 275  CALL DDTABC(CANON(IC-1))
       GO TO 182
  280 CALL POLCON(CANON(IC),2)
182   ISTRUP=IV
      IF(IER.GT.0)GO TO 40
      E(1) = TP(1,IS) + S(IS)*TN(1,IS)
      E(2) = TP(2,IS) + S(IS)*TN(2,IS)
      E(3) = TP(3,IS) + S(IS)*TN(3,IS)
      SP(1,IS) = E(1)
      SP(2,IS) = E(2)
      SP(3,IS) = E(3)
  184 CALL CROSS (FC,SN(1,IS),UT1)
      CALL VNORM (UT1,T1)
      DOT = T1(1)*BB(1) + T1(2)*BB(2) + T1(3)*BB(3)
      IF (DOT.GT.0.) GO TO 190
      SIG = -1.
      GO TO 200
  190 SIG = 1.
  200 CALL CROSS (T1,TN(1,IS),S1)
      CALL VNORM (S1,UT1)
      SIGN2 = VTEM
      DO 210 I = 1,3
  210 DC(I) = T1(I)*SIG*SIGN1*EP/SIGN2
      IF(IC.EQ.LS2) GOTO 155
C
C   RB AND R2 ARE PARTIAL DERIVATIVES WRT DELTA AND LAMBDA REGSPECTIVELY
C
      R3(LSD)   = DC(1) + ZLAMBD(LSD)*(DCP(1)-DC(1))
      R3(LSD+1) = DC(2) + ZLAMBD(LSD)*(DCP(2)-DC(2))
      R3(LSD+2) = DC(3) + ZLAMBD(LSD)*(DCP(3)-DC(3))
      R2(LSD)   = CP(1) - E(1)
      R2(LSD+1) = CP(2) - E(2)
      R2(LSD+2) = CP(3) - E(3)
      CALL VNORM (R3(LSD),ZN(LSD))
      IF (IER.GT.0) GO TO 40
      CALL VNORM (R2(LSD),SL(LSD))
      IF (IER.GT.0) GO TO 40
      CALL CROSS (ZN(LSD),SL(LSD),SC)
      CALL VNORM(SC,ZN(LSD))
C     ZN(LSD) CONTAINS THE SURFACE NORMAL
      IF (IER.GT.0) GO TO 40
C
C     R0(LSD) CONTAINS THE SURFACE POINT
C
      R0(LSD)   = E(1) + ZLAMBD(LSD)*R2(LSD)
      R0(LSD+1) = E(2) + ZLAMBD(LSD)*R2(LSD+1)
      R0(LSD+2) = E(3) + ZLAMBD(LSD)*R2(LSD+2)
      ILSD=LSD+2
C
C     TAKE DOT PRODUCT OF TOOL NORMAL AND SURFACE NORMAL
      IF(IOPS.NE.2) GO TO 220
      X(1)=R0(LSD)-PO(1)
      X(2)=R0(LSD+1)-PO(2)
      X(3)=R0(LSD+2)-PO(3)
      CALL VNORM(X,D)
      VNDIR(1,IS)=D(1)
      VNDIR(2,IS)=D(2)
      VNDIR(3,IS)=D(3)
      INDIR(IS)=1
C
  220 G = D(1)*ZN(LSD) + D(2)*ZN(LSD+1) + D(3)*ZN(LSD+2)
      IF (DABS(G).LT..01) GO TO 40
      X(1) = PO(1) - R0(LSD)
      X(2) = PO(2) - R0(LSD+1)
      X(3) = PO(3) - R0(LSD+2)
      XLL = -(X(1)*ZN(LSD)+X(2)*ZN(LSD+1)+X(3)*ZN(LSD+2))/G
      CALL VNORM(X,AA)
      X(1) = X(1) + XLL*D(1)
      X(2) = X(2) + XLL*D(2)
      X(3) = X(3) + XLL*D(3)
C
C     SUM IS THE DISTANCE BETWEEN THE POINT OF INTERSECTION OF TOOL
C         NORMAL WITH THE PLANE AND THE SURFACE POINT
C     SIGMA IS THE COSINE OF THE ANGLE BETWEEN TOOL NORMAL AND
C         NORMALIZED (TOOL POINT - SURFACE POINT)
C
      SUM = DABS(X(1)) + DABS(X(2)) + DABS(X(3))
      SIGMA = DABS(AA(1)*D(1) + AA(2)*D(2) + AA(3)*D(3))
C
C     DECLARE CONVERGENCE IF EITHER ANGLE OR DIST. LT. TEST QUANTITIES
C
      IF ((SIGMA.LT..99995).AND.(SUM.GT.EP2)) GO TO 230
      IER = 1
      IF ((IOPS.GT.0).AND.(XLL.LT.0.)) GO TO 50
      IER = 0
      S(IS) = XLL
      TEM(8) = ZN(LSD)
      TEM(9) = ZN(LSD+1)
      TEM(10)= ZN(LSD+2)
      SLX(1,IS) = SL(LSD)
      SLX(2,IS) = SL(LSD+1)
      SLX(3,IS) = SL(LSD+2)
      CALL VNORM(TEM(8),SN(1,IS))
      GO TO 50
C
C     UPDATE COUNTERS PICKUP NEW PARAMETERS IF COUNTERS EXHAUSTED
C
  230 LOOP = LOOP - 1
      IF (LOOP.LE.0) GO TO 40
C
C     ALPH AND BETA ARE LINEAR CORRECTIONS TO DELTA AND LAMBDA
C
      CSL = R3(LSD)**2 + R3(LSD+1)**2 + R3(LSD+2)**2
      CSM = R3(LSD)*R2(LSD)+R3(LSD+1)*R2(LSD+1)+R3(LSD+2)*R2(LSD+2)
      CSN = R2(LSD)**2 + R2(LSD+1)**2 + R2(LSD+2)**2
      SMA = R3(LSD)*X(1)+R3(LSD+1)*X(2)+R3(LSD+2)*X(3)
      SMB = R2(LSD)*X(1)+R2(LSD+1)*X(2)+R2(LSD+2)*X(3)
      DELT = CSL*CSN - CSM*CSM
      IF (DELT.LT..00001) GO TO 40
      ALPH = (SMA*CSN - SMB*CSM)/DELT
      BETA = (SMB*CSL - SMA*CSM)/DELT
      DELTA(LSD) = DELTA(LSD) + .8*ALPH
      ZLAMBD(LSD)= ZLAMBD(LSD) + .8*BETA
      GO TO 140
      END
**** SOURCE FILE : M0002893.V06   ***
*
      SUBROUTINE DDST
C
C              /-DDST FOR DIRECTED DISTANCE TO SURFACE
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
C
C...  21. ADDCOM BLOCK
      COMMON/ADDCOM/ ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),  (ADDCOM( 2),CLNGTH),
     1            (ADDCOM(23),IBTFLG),  (ADDCOM(24),JLIN),
     2            (ADDCOM(25),KDYNFL)
C
      INCLUDE 'BLANKCOM.INC'
C
C              /-ARRAY TO SAVE SP,SN DATA
      DIMENSION STEM(6)
C              /-J11 IS AN INDEX TO THE LOCATION OF LARGE DATA IN CANON
C              /-J11 MUST BE ON A DOUBLE WORD BOUNDARY PER APT094 REQS.
      INTEGER J11
      EQUIVALENCE (REAL8,J11)
C
      COMMON/IDDST/IDDST
C
      DATA ZERO,ONE/0.0D0,1.0D0/
C
C
      IDDST=1
      DO 100 I=1,3
      STEM(I)=SN(I,IS)
      STEM(I+3)=SP(I,IS)
  100 CONTINUE
      A=ZERO
      B=ZERO
      C=ZERO
C
C              /-IC IS THE INDEX TO THE INTERNAL CANON FORM OF SURF IS
      IC=ICANON(IS)
C              /-JSW IS THE SURFACE NUMERIC TYPE(1 THRU 30)
      JSW=ISFIDN(IS)
C             /-SET MODE TO FETCH LARGE DATA FROM EXTERNAL STORAGE.
      IFETCH=3
C
      GO TO ( 1, 1, 3, 3, 6,  6, 6, 6, 6, 6,
     X       11,12,13, 6,15, 99,99,99,99,99,
     X       99,99,99,99,99, 99,99,99,29,30), JSW
   99 CONTINUE
C              /-ERROR, JSW INDEX IS OUT OF RANGE
      IER=1
      GO TO 999
    1 CONTINUE
      CALL DDPLAN(CANON(IC))
      GO TO 1000
C
    3 CONTINUE
      CALL DDCYLN(CANON(IC))
      GO TO 1000
C
    6 CONTINUE
      CALL DDQUAD(CANON(IC))
      GO TO 1000
C
   11 CONTINUE
      CALL APT094(IFETCH,CANON(IC),J11)
      J11=J11-1
      CALL DDTABC(CANON(J11))
      GO TO 1000
C
   12 CONTINUE
      CALL APT094(IFETCH,CANON(IC),J11)
      IC=J11
      CALL DDRLSR
      GO TO 1000
C
   13 CONTINUE
      CALL POLCON(CANON(IC),2)
      GO TO 1000
C              /-
   15 CONTINUE
      CALL DDPARS(CANON(IC))
      GO TO 1000
C
   29 CONTINUE
      CALL APT094(IFETCH,CANON(IC),J11)
      CALL DDSSRF(CANON(J11))
      GO TO 1000
C
C             /-SYNTHETIC CURVE NOT NOW PROGRAMMED FOR ARELEM
   30 CONTINUE
      CALL AERR(26203,'DDST    ')
      GO TO 999
C
 1000 CONTINUE
C
      IF(KDYNFL.NE.0) CALL APT238(1)
C
C              /-EXIT POINT FOR DDST ROUTINE
C              /-RESTORE SURFACE DATA
      DO 700 I=1,3
      SN(I,IS)=STEM(I)
  700 SP(I,IS)=STEM(I+3)
C
C
  999 CONTINUE
      IDDST=0
      RETURN
      END
C
C
C
C
      SUBROUTINE AJUNDD
C
C              /-AJUNDD FOR DISTANCE AND LINEUP WITH SURFACE.
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
C
C...  21. ADDCOM BLOCK
      COMMON/ADDCOM/ ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),  (ADDCOM( 2),CLNGTH),
     1            (ADDCOM(23),IBTFLG),  (ADDCOM(24),JLIN),
     2            (ADDCOM(25),KDYNFL)
C
      INCLUDE 'BLANKCOM.INC'
C
C              /-ARRAY TO SAVE SP,SN DATA
      DIMENSION STEM(6)
C              /-J11 IS AN INDEX TO THE LOCATION OF LARGE DATA IN CANON
C              /-J11 MUST BE ON A DOUBLE WORD BOUNDARY PER APT094 REQS.
      INTEGER J11
      EQUIVALENCE (REAL8,J11)
C
      COMMON/IDDST/IDDST
C
      DATA ZERO,ONE/0.0D0,1.0D0/
C
C
C
C              /-GIVEN TP,TN FIND SP,SN,S ON SURFACE
C              /-SUCH THAT TP+S*TN=SP
C
      IDDST=2
      MDIC=0
C
  200 CONTINUE
C              /-IC IS THE INDEX TO THE INTERNAL CANON FORM OF SURF IS
      IC=ICANON(IS)
C              /-JSW IS THE SURFACE NUMERIC TYPE(1 THRU 30)
      JSW=ISFIDN(IS)
C             /-SET MODE TO FETCH LARGE DATA FROM EXTERNAL STORAGE.
      IFETCH=3
C
      GO TO ( 1, 1, 3, 3, 6,  6, 6, 6, 6, 6,
     X       11,12,13, 6,15, 99,99,99,99,99,
     X       99,99,99,99,99, 99,99,99,29,30), JSW
   99 CONTINUE
C              /-ERROR, JSW INDEX IS OUT OF RANGE
      IER=1
      GO TO 999
    1 CONTINUE
      CALL DDPLAN(CANON(IC))
      GO TO 1000
C
    3 CONTINUE
      CALL DDCYLN(CANON(IC))
      GO TO 1000
C
    6 CONTINUE
      CALL DDQUAD(CANON(IC))
      GO TO 1000
C
   11 CONTINUE
      CALL APT094(IFETCH,CANON(IC),J11)
      J11=J11-1
      CALL DDTABC(CANON(J11))
      GO TO 1000
C
   12 CONTINUE
      CALL APT094(IFETCH,CANON(IC),J11)
      IC=J11
      CALL DDRLSR
      GO TO 1000
C
   13 CONTINUE
      CALL POLCON(CANON(IC),2)
      GO TO 1000
C              /-
   15 CONTINUE
      CALL DDPARS(CANON(IC))
      GO TO 1000
C
   29 CONTINUE
      CALL APT094(IFETCH,CANON(IC),J11)
      CALL DDSSRF(CANON(J11))
      GO TO 1000
C
C             /-SYNTHETIC CURVE NOT NOW PROGRAMMED FOR ARELEM
   30 CONTINUE
      CALL AERR(26203,'AJUNDD  ')
      GO TO 999
C
 1000 CONTINUE
C
      IF(KDYNFL.NE.0) CALL APT238(1)
C
      IF(IER.EQ.0) GO TO 810
C              /-CALL RADAR TO GENERATE A NEW TP,TN FOR INTERSECTION
      CALL RADAR
C              /-RESTART IF RADAR HAS OBTAINED A GOOD TP,TN
      IF(IAERR.EQ.0) GO TO 200
C              /-OTHERWISE, TERMINATE WITH THIS IAERR SETTING.
      GO TO 999
C
  810 CONTINUE
      IF(KDYNFL.NE.0) CALL APT238(2)
C              /-RADAR EXHAUSTED ALL TRIES
      IF(IER.NE.0) CALL AERR(26204,'AJUNDD  ')
      IF(JTN(IS).EQ.0) GO TO 820
C              /-ADJUST Z EACH TIME FOR CS, SN,TN SHOULD LIE SAME WAY.
      CALL DOTF(W1,TN(1,IS),SN(1,IS))
      Z(IS)=ONE
      IF(W1.LT.ZERO) Z(IS)=-ONE
  820 CONTINUE
      DO 830 I=1,3
  830 SN(I,IS)=Z(IS)*SN(I,IS)
C
C
C              /-EXIT POINT
  999 CONTINUE
      IDDST=0
      RETURN
      END
**** SOURCE FILE : M0002926.W01   ***
*
C.....FORTRAN SUBROUTINE  ....DDTABC         8/68                    RN
C.....FORTRAN SUBROUTINE             DDTABC...              3/1/68   GK
      SUBROUTINE DDTABC(D)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
C...  ALL REFERENCES TO ARRAY R, HAVE BEEN CHANGED TO R0,
C...  BECAUSE R OCCURS IN DSHAR4.INC
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
      DIMENSION R0(9)
C
      EQUIVALENCE (TEM(1),H2),(TEM(2),G2),(TEM(3),SQ),(TEM(4),A1),
     1            (TEM(5),B1),(TEM(6),C1),(TEM(7),UP),(TEM(8),VP),
     2            (TEM(9),UN),(TEM(10),VN)
      DIMENSION X(3)
      EQUIVALENCE (PARAM(4),X(1)),(PARAM(1),SINN),(PARAM(2),COSS)
      EQUIVALENCE (SEG(3),ACF),(SEG(4),BCF),(SEG(5),CCF)
      DIMENSION D(*)
      DIMENSION IITBSG(4)
      DOUBLE PRECISION XA
      DATA IITBSG,ISQLS/5*0/
      DATA ICOUNT/0/
      DATA ZLIT1,ZLIT2,KLIT3/.2D0,1.D-20,14/
C
C...  DEFINITIONS OF ARITHMETIC STATEMENT FUNCTIONS
C
      CUBIC(XA)=((ACF*XA+BCF)*XA+CCF)*XA
      CUBC1(XA)=((ACF*XA+BCF)*XA+(CCF-SLOPE))*XA-VINT
C
C...  INITIALIZE DIRECTED DISTANCE
C
C
C
C
C...  TRANSFORM TOOL POINT AND TOOL NORMAL INTO U-V-W COORD. SYSTEM
C
      I=1
   10 R0(I)=D(I+2)
      I=I+1
      IF(I.LT.10) GO TO 10
C
C
      IER=0
      S(IS)=1.0D+38
      UP = R0(1)*TP(1,IS)+R0(2)*TP(2,IS)+R0(3)*TP(3,IS)
      VP = R0(4)*TP(1,IS)+R0(5)*TP(2,IS)+R0(6)*TP(3,IS)
      WP=R0(7)*TP(1,IS)+R0(8)*TP(2,IS)+R0(9)*TP(3,IS)
      UN = R0(1)*TN(1,IS)+R0(2)*TN(2,IS)+R0(3)*TN(3,IS)
      VN = R0(4)*TN(1,IS)+R0(5)*TN(2,IS)+R0(6)*TN(3,IS)
      UQ=DSQRT(UN**2+VN**2)
      IF(UQ.EQ.0.)GO TO 1002
      UN=UN/UQ
      VN=VN/UQ
C
C...  CHECK TO SEE IF TOOL NORMAL IS PARALLEL TO AXIS OF TABCYL
C
      IF(DABS(UN)+DABS(VN)-Z1EM6) 1002,1002,600
C
C...  SET INDEXES AND BEGIN EXAMINING TABCYL SEGMENTS
C
  600 NWDS=D(12)*7.0+6.0
      I = D(13)
      IIP=IS-1
      IF(JENT(IS).EQ.0.AND.ISQLS.EQ.ISEQNO) I=IITBSG(IIP)
  602 ICHECK = 0
      NMBSEG=D(12)
      NMBSEG=NMBSEG-K1
      DO 1001 L=1,NMBSEG
C
C...  STORE CANONICAL INFORMATION FOR SEGMENT IN SEG(K)
C
 2501 J = I
      DO 500 K=1,9
      SEG(K)=D(J)
  500 J=J+K1
      SEG(6)=SEG(6)*SEG(5)
      SEG(7)=SEG(7)*SEG(5)
      SEG(5)=-SEG(5)*(SEG(3)*SEG(5)+SEG(4))
C
C...  TRANSFORM POINTS AND VECTOR INTO U-V COORD. SYSTEM OF SEGMENT
C
      H2=SEG(8)-SEG(1)
      G2=SEG(9)-SEG(2)
      SQROOT=DSQRT(H2*H2+G2*G2)
      SINN=G2/SQROOT
      COSS=H2/SQROOT
      H2=UP-SEG(1)
      G2=VP-SEG(2)
      UPP=H2*COSS+G2*SINN
      VPP=-H2*SINN+G2*COSS
      UNN=UN*COSS+VN*SINN
      VNN=-UN*SINN+VN*COSS
C
C...  TEST FOR INTERSECTION OF DIRECTED LINE WITH RECTANGLE
C...  SURROUNDING TABCYL SEGMENT
C
      IF(Z1E6*DABS(UNN)-DABS(VNN)) 603,603,604
  603 SLOPE=Z1E6
      IF(UPP-SQROOT) 4410,4410,1000
 4410 IF(UPP) 1000,4411,4411
 4411 TEM(1)=UPP
      TEM(2)=SEG(6)
      GO TO 700
  604 SLOPE=VNN/UNN
      IF(DABS(SLOPE)-Z1EM6) 605,605,4419
  605 SLOPE=Z0
      IF(VPP-SEG(6))606,4419,1000
  606 IF(SEG(7)-VPP)4419,4419,1000
C
C...  U AND V COORDS. OF INTERSECTION WITH RECTANGLE ARE STORED
C...  IN TEM AND TEM(2)
C
 4419 TEM(1)=0.
      M=K7
      IF(UPP)4420,4420,4429
 4420 TEM(2)=VPP+SLOPE*(TEM(1)-UPP)
 4421 IF(SEG(7)-TEM(2))4426,4424,4432
 4426 IF(SEG(6)-TEM(2))4435,4424,4424
 4435 M=K6
 4432 TEM(1)=(SEG(M)-VPP)/SLOPE+UPP
C---  CII UPDATE TO ENABLE INTERSEC AT A TAB PT, NIU-APR/75
      IF(DABS(TEM(1)).LT.5.0D-17)TEM(1)=Z0
      IF(-TEM(1)) 4433,4425,1000
 4433 IF(TEM(1)-SQROOT) 4425,4425,1000
 4425 TEM(2)=SEG(M)
 4424 TEM(3)=DSQRT((TEM(1)-UPP)**2+(TEM(2)-VPP)**2)
C
C...  IF DIRECTED DISTANCE TO RECTANGLE IS LESS THAN DIR. DIST.
C...  TO CUBIC OF LAST SEGMENT,GO AHEAD AND CALC. DIR. DIST.
C...  TO CUBIC FOR THIS SEGMENT
C
      IF(TEM(3)-DABS(S(IS))) 4436,1000,1000
 4429 IF(UPP-SQROOT)4431,4430,4430
 4431 IF(SEG(7)-VPP)4434,700,4432
 4434 IF(VPP-SEG(6))700,700,4435
 4430 TEM(1)=SQROOT
      GO TO 4420
 4436 IF(IOP(IS)) 700,700,4437
 4437 IF(UNN*(UPP-TEM(1))+VNN*(VPP-TEM(2))) 700,700,1000
C
C...  CALC. DIRECTED DISTANCE TO CUBIC OF SEGMENT
C
C...  J IS SET TO KEEP A RECORD OF THE NUMBER OF INTERSECTIONS WITH
C...  THE CUBIC
C
  700 J=K1
      IF(Z1E6-SLOPE)607,607,609
C
C...  SOLVE DIRECTLY FOR INTERSECTION WITH VERTICAL LINE
C
  607 X(1)=UPP
      GO TO 48
  609 VINT=VPP-SLOPE*UPP
      IF(Z1EM6-DABS(VINT)) 612,618,618
C
C...  TEST FOR DEGENERATE CASES OF CUBIC
C
  612 IF(SEG(3))630,613,630
  613 IF(SEG(4))616,617,616
C
C...  DOES DIRECTED LINE CROSS U AXIS WITHIN SEGMENT
C
  614 IF(VINT*SLOPE)615,635,635
  615 IF (VINT/SLOPE+SQROOT) 635,635,5041
C
C...  DEGENERATE CUBIC ---- QUADRATIC EQUATION
C
  616 C1=-VINT
      A1=SEG(4)
      B1=SEG(5)-SLOPE
  622 J = 0
      GO TO 623
C
C...  DEGENERATE CUBIC ---- LINEAR EQUATION
C
  617 X(1)=-VINT/SLOPE
      GO TO 48
C
C...  FACTOR OUT THE ROOT,X=0,AND CREATE THE RESULTING QUADRATIC
C
  699 IF(B1.EQ.0.)GO TO 629
      X(2)=-C1/B1
      K=K2
      GO TO 629
  618 X(1)=0.
      K=K1
      C1=SEG(5)-SLOPE
      B1=SEG(4)
      IF(DABS(SEG(3)).LT.Z1EM9) GO TO 699
  643 A1=SEG(3)
C
C...  SOLVE THE QUADRATIC EQUATION FOR ROOTS
C
  623 SQ=B1**2-4.0*A1*C1
      IF(DABS(SQ)-Z1EM7) 624,624,625
  624 X(2)=-B1/(Z2*A1)
C
C...  K IS SET TO KEEP A RECORD OF THE NUMBER OF ROOTS
C...  OF THE QUADRATIC, 0=0 ROOTS, 2=1 ROOT, 3=2 ROOTS
C
      K=K2
      GO TO 629
  625 IF(SQ)621,621,627
  621 K=K0
      GO TO 629
  627 SQ=-B1-DSIGN(DSQRT(SQ),B1)
      X(2)=Z2*C1/SQ
      X(3)=  SQ/(Z2*A1)
      K=K3
  629 IF(J)614,631,631
C
C...  REJECT ROOTS NOT IN SEGMENT AND UPDATE RECORDS
C
  631 N=K1
  750 N=N+K1
      IF(N-K)751,751,752
  751 IF(X(N).LT.-1.D-5) GO TO 750
      IF(X(N).GT.1.D-5) GO TO 633
      GO TO 634
  633 IF((X(N)-SQROOT).GT.1.D-5) GO TO 750
  634 X(J+1)=X(N)
      J=J+K1
      GO TO 750
  752 IF(J)1000,1000,48
C
C...  TRUE CUBIC, PREPARE TO DETERMINE ROOT
C
C...  DIFFERENTIATE CUBIC AND SOLVE FOR MAX AND MIN POINTS
C
  630 J=-K1
  620 A1=Z3*SEG(3)
      B1=Z2*SEG(4)
      C1=SEG(5)-SLOPE
      GO TO 623
C
C...  ELIMINATE MAX AND MIN POINTS NOT IN THE SEGMENT
C
  635 N=K1
  753 N=N+K1
      IF(N-K)754,754,1000
  754 IF(X(N).GT.1.D-5) GO TO 637
      GO TO 753
  637 IF((X(N)-SQROOT).GT.1.D-5) GO TO 753
C
C...  LOOK FOR TANGENCY AND MULTIPLE INTERSECTION CASES
C
  638 TEM(1)=CUBC1(X(N))
      IF(DABS(TEM(1))-Z1EM5) 639,640,640
C
C...  TANGENCY
C
  639 X(1)=X(N)
      J=K1
      GO TO 48
  641 J=K1
  642 B1=SEG(3)*X(1)+SEG(4)
      C1=B1*X(1)+SEG(5)-SLOPE
      GO TO 643
C
C...  IS THERE A POSSIBLE MULTIPLE INTERSECTION
C
  640 IF(VINT*TEM(1)) 753,5041,5041
C
C...  CALCULATE VALUE OF X WHICH WILL ASSURE CONVERGENCE TO A ROOT
C
 5041 IF(K-K2)5090,5090,5050
 5090 X(1)=Z5EM1*SQROOT
      GO TO 5100
 5050 DO 5060 J=1,2
 5060 TEM(J)=CUBC1(X(J+1))
      IF(TEM(1)*TEM(2)) 5061,5062,5062
 5061 X(1)=(X(2)+X(3))*Z5EM1
      GO TO 5100
 5062 IF(DABS(TEM(1))-DABS(TEM(2))) 5063,5064,5064
 5063 X(1)=Z12EM1*X(3)-ZLIT1*X(2)
      GO TO 5100
 5064 X(1)=Z12EM1*X(2)-ZLIT1*X(3)
C
C...  ITERATE FOR ROOT OF CUBIC
C
 5100 X(1)=DMIN1(DMAX1(X(1),Z0),SQROOT)
      TEM(1)=Z3*SEG(3)
      TEM(2)=Z2*SEG(4)
      TEM(3)=SEG(5)-SLOPE
      DO 5200 M=1,100
      TEM(4)=(TEM(1)*X(1)+ TEM(2))*X(1)+TEM(3)
      IF(DABS(TEM(4))-ZLIT2) 4008,4009,4009
 4008 X(1)=X(1)+Z1EM6
      GO TO 5200
 4009 TEM(4)=CUBC1(X(1))/TEM(4)
C
C...  ACCEPT ROOT WHEN CORRECTION TERM IS LESS THAN .000001*X
C
      IF(DABS(TEM(4)).LT.Z1EM6*DABS(X(1))) GO TO 5300
 5110 X(1)=X(1)-TEM(4)
 5200 CONTINUE
      CALL AERR (-28801,'DDTABC  ')
      GO TO 1000
C
C...  IF THE ROOT IS WITHIN THE SEGMENT,
C...  FACTOR OUT THE ROOT X,FOUND BY ITERATION, AND SOLVE
C...  THE RESULTING QUADRATIC
C
 5300 IF(X(1)) 636,641,644
  636 J = 0
      GO TO 642
  644 IF(X(1)-SQROOT) 641,641,636
   48 DO 51 K=1,J
C
C...  USING U COORD. OF INTERSECTION POINT,SOLVE CUBIC FOR V COORD.
C
      PARAM(3)=CUBIC(X(K))
C
C...  CALCULATE DIR. DIST. TO CUBIC AND TEST AGAINST PRESENT VALUE
C
      TEM(1)=DSQRT((X(K)-UPP)**2+(PARAM(3)-VPP)**2)
      IF(TEM(1)-DABS(S(IS))) 49,51,51
   49 TEM(1)=DSIGN(TEM(1),(X(K)-UPP)     *UNN+(PARAM(3)-VPP)*VNN)
      IF(IOP(IS)) 52,52,50
   50 IF(TEM(1)) 51,52,52
   52 S(IS)=TEM(1)
C
C...  SAVE SUBSCRIPT OF U COORD. OF FIRST POINT OF SEGMENT
C
      ISEG=I
C
C...  SAVE U COORD. OF SURFACE POINT
C
      SAVPAR(4)=X(K)
C
C...  SAVE SINN AND COSS FOR SEGMENT AND V COORD. OF SURFACE POINT
C
      DO 53 N=1,3
   53 SAVPAR(N)=PARAM(N)
      SAVC=SEG(5)
   51 CONTINUE
      IF (SUBFLG) GO TO 9000
C
C...  SET INDEX TO LOOK AT NEXT SEGMENT OR FIRST SEGMENT
C
 1000 IF (ICHECK) 2010,2020,2000
 2000 I = I - K7
      GO TO 1001
 2010 I = I + K7
      GO TO 1001
 2020 I=I+K7*L*(K2*MOD(L,K2)-K1)
      IF(I.LT.KLIT3) GOTO 2030
      IF (I.LT.NWDS) GO TO 1001
      ICHECK = 1
      I=I-K7*L-K7
      GO TO 1001
 2030 ICHECK = -1
      I=I+K7*L+K7
 1001 CONTINUE
      IF(DABS(S(IS))-Z1E38) 9000,1002,1002
C
C...  CALCULATE SURFACE NORMAL IN U-V-W COORD. SYSTEM
C
 9000 AARG1=(Z3*D(ISEG+2)*SAVPAR(4)+Z2*D(ISEG+3))*SAVPAR(4)+SAVC
      AARG2 = DATAN(AARG1)
      TEM(3) = Z0 - DSIN(AARG2)
      TEM(5) =  DCOS(AARG2)
      TEM(4) = TEM(3)*SAVPAR(2)-TEM(5)*SAVPAR(1)
      TEM(5) = TEM(3)*SAVPAR(1)+TEM(5)*SAVPAR(2)
C
C...  TRANSFORM SURFACE POINT INTO U-V-W COORD. SYSTEM
C
      PARAM(1)=SAVPAR(4)*SAVPAR(2)-SAVPAR(3)*SAVPAR(1)+D(ISEG)
      PARAM(2)=SAVPAR(4)*SAVPAR(1)+SAVPAR(3)*SAVPAR(2)+D(ISEG+1)
C
C...  TRANSFORM SURFACE POINT AND NORMAL INTO X-Y-Z COORD. SYSTEM
C
      J=IS
      DO 9001 I = 1,3
      SPL(I,J)=SP(1,J)
      SNL(I,J)=SN(1,J)
      SP(I,J)=R0(I)*PARAM(1)+R0(I+3)*PARAM(2)+R0(I+6)*WP
      TEM(I+7)=R0(I)*TEM(4)+R0(I+3)*TEM(5)
      SN(I,J)=TEM(I+7)
 9001 CONTINUE
C
C...  SAVE SEGMENT INDEX
C
      D(13)=ISEG
      ISQLS=ISEQNO
      IITBSG(IIP)=ISEG
C
C...  CALCULATE 3D DIRECTED DISTANCE
C
      S(IS)=DSIGN(DSQRT((SP(1,IS)-TP(1,IS))**2+(SP(2,IS)-TP(2,IS))**2+
     1      (SP(3,IS)-TP(3,IS))**2),S(IS))
      ICOUNT = ICOUNT + 1
   29 CONTINUE
      RETURN
C
C...  UNABLE TO FIND DIRECTED DISTANCE
C
 1002 IER=K1
      GO TO 29
       END
**** SOURCE FILE : M0000893.W04   ***
*
C.....FORTRAN SUBROUTINE  ....DELTA          8/68                    HG
C.....FORTRAN SUBROUTINE              DELTA...              3/27/68  GK
      SUBROUTINE DELTA
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C...  21. ADDCOM BLOCK
C
      COMMON/ADDCOM/ ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),  (ADDCOM( 2),CLNGTH),
     1            (ADDCOM(23),IBTFLG),  (ADDCOM(24),JLIN)
C
      INCLUDE 'CGOUG.INC'
      INCLUDE 'CHANG.INC'
C
      DATA ZLIT1,ZLIT3/1.D-4,4.D0/
C
      AAP=RC(IPS)
      BAP=RC(IDS)
      STAU1=TAU(IPS)
      STAU2=TAU(IDS)
      KAP=IS
C        USE RC1   FOR PROPER UNITS/ IMPLEMENTATION
      DPE = 1.D10*RC1/4500.D0
      DPI=DP
      J=0
      IF(JLIN-1)101,601,101
  601 TAU(IPS)=0.4*TAU(IPS)
      TAU (IDS)=0.4*TAU(IDS)
C1.2      DO FOR PART SURFACE FIRST
  101 IS=IPS
  901 IF(IPL(IS)-1)501,500,501
  500 ZL=DSQRT((TE(1)-TEK(1))**2+(TE(2)-TEK(2))**2+(TE(3)-TEK(3))**2)
  570 DP = DPMAX
      GO TO 303
  501 IF(ISFTYP(IS)-3)503,502,503
  502 DO 504 I=1,3
      P1(I)=TE(I)
  504 P2(I)=TEK(I)
      GO TO 401
  503 IF(DABS(SN(1,IS)*TA(1)+SN(2,IS)*TA(2)+SN(3,IS)*TA(3))-ZLIT1) 506,
     1   506,505
  506 IF(DABS(SNK(1,IS)*TA(1)+SNK(2,IS)*TA(2)+SNK(3,IS)*TA(3))-ZLIT1)
     /     507,507,505
  507 DO 509 I=1,3
      P1(I) = TP(I,IS)
  509 P2(I) = TPK(I,IS)
      GO TO 401
  505 IU=ITSEG(IS)
      IV=ITSEGK(IS)
      IF(TLINC(IU))508,510,508
  510 IF(IU-IV)508,512,508
  512 IF(U1K(1,IS)*U1(1,IS)+U1K(2,IS)*U1(2,IS)+U1K(3,IS)*U1(3,IS)-.01)
     1     508,513,513
  513 DO 514 I=1,3
      P1(I)=TE (I)+RI(IU)*U1(I,IS)+TLHITE(IU)*TA (I)
  514 P2(I)=TEK(I)+RI(IV)*U1K(I,IS)+TLHITE(IV)*TAK(I)
  401 PROD1=0.
      PROD2=0.
      DO 102 I=1,3
      PROD1=PROD1+(P1(I)-TE(I))*TA(I)
  102 PROD2=PROD2+(P2(I)-TEK(I))*TAK(I)
      ZL=0.
      DO 105 K=1,3
      P1(K)=TE(K)+PROD1*TA(K)
      P2(K)=TEK(K)+PROD2*TAK(K)
  105 ZL=ZL+(P1(K)-P2(K))**2
      IF (J.EQ.0) THEN
C1.4      FIND RC=RADIUS OF CURVATURE ALONG NORMAL AT P1
        CALL CCURV(IS,P1,P2,SN(1,IS))
      ELSE
        CALL CCURV(IS,P1,P2,SNK(1,IS))
      ENDIF
C
C...                IF APPARANT PLANE,USE LARGE RADIUS OF CURVATURE
C
      IF (ISIGCR(IS)-1) 301,1301,301
 1301 RC(IS) = DSIGN(RC1,RC(IS))
  301 D1=2.*DABS(RC(IS))
      GO TO 115
  303 IF(IS-IPS)113,112,113
C1.7      STORE RESULTS IN D2A,ZL1, AND RETURN FOR LIKE CALC. FOR DS
  112 DPS=DP
      ZLS=ZL
      IS=IDS
      GOTO 901
C1.8        USE RESULTS OF SURFACE, PS OR DS, HAVING SMALLEST DP
  113 IF(DP-DPS) 516,516,114
C1.9      RESTORE PS RESULTS (MOST CONSERVATIVE AFTER ALL)
  114 DP=DPS
      ZL=ZLS
      GO TO 516
  115 ZL=DSQRT(ZL)
      DP=DSQRT(ZLIT3*TAU(IS)*DABS(D1-TAU(IS)))
      GO TO 303
C1.12     IF BEGINNING CUT VECTOR CANDIDATE BEING TESTED, STORE
C1.12    CURRENT RESULTS (BASED ON NORMALS AT TERMINUS OF CUT VECTOR)
C1.12    AND RETURN FOR CALCULATIONS BASED ON NORMALS AT ORIGIN OF
C1.12    CUT VECTOR
  516 IF(J12-1) 116,117,119
  116 DPE=DP
      ZL2=ZL
      J=1
      J12=1
      GO TO 101
C1.14     COMPARE CUT VECTOR LENGHTS BASED ON NORMALS AT ORIGIN AND
C1.14    TERMINUS OF CUT VECTOR.  IF BEGINNING CUT VECTOR CANDIDATE
C1.14    IS UNDER CONSIDERATION DPE IS TOO LARGE--TRANSFER TO C1.15
  117 J12=2
      IF(DP-DPE) 119,119,118
C1.15     RESTORE RESULTS BASED ON NORMALS AT TERMINUS
C1.15    OF CUT VECTOR CANDIDATE
  118 DP=DPE
      ZL=ZL2
C
C1.16     PRESERVE UNTRUNCATED DP FOR USE IN ANOTHER PROGRAM
  119 DPL=DP
C
C2.1      TRUNCATE DP SO AS TO LIE BETWEEN TAU AND DPMAX
      IF(DP-DPMAX)122,125,121
  122 IF(DP-TAU(IS))124,125,125
  124 DP=TAU(IS)
      GO TO 125
  121 DP=DPMAX
C
  125 IF(DP-ZL+TAU(IS))130,151,151
  155 IF(DP-.6*DPI+TAU(IS))129,127,127
C2.9      CUT VECTOR CANDIDATE MUCH TOO LONG.  REDUCE IT TO .6 OF ITS
C2.9     CURRENT VALUE, SUBMIT TO ONE MORE TEST AND EXIT FAILING
  129 DP=.6*DPI
      GO TO 127
  130 TEMP(1) = DP/ZL
      IF(TEMP(1) - .6) 310,340,320
  310 TEMP(1) = .6
  340 IF(DPI - DP) 350,360,360
  350 DP = DPI
  360 DP = TEMP(1)*DP
      GO TO 145
  320 IF(.9 - TEMP(1)) 330,340,340
  330 TEMP(1) = .9
      GO TO 340
C2.14     REJECT CUT VECTOR CANDIDATE
  145 JDR=1
C.... COULD BE ACCEPTED IF
C.... CUTTER HAS NOT MOVED SINCE LAST CALL TO CENTR
      IF (JTENEU.EQ.1) GOTO 160
C.... CUT VECTOR LENGTH .LT. TAU
      IF (DPI.LT.TAU(IS)) GOTO 160
C.... OR CUT VECTOR .LT. 5*TAU AND .LT. HALF LAST ACCEPTED CUT VECTOR
      IF ((DPI.LT.(5.D0*TAU(IS))).AND.(DPI.LT.(.5D0*DPL))) GOTO 160
  201 IS=KAP
      RC(IPS)=AAP
      RC(IDS)=BAP
      TAU(IPS)=STAU1
      TAU(IDS)=STAU2
      RETURN
C
C
C         TENTATIVELY ACCEPT CUT VECTOR (MUST PASS GOUGCK YET)
C2.16     CUT DP DOWN TO 2DPI IF IT EXCEEDS THIS NO.  THIS PREVENTS
C2.16    WILD FLUCUATIONS OF THE DP CAUSED BY RAPID CHANGE
C2.16    IN SURFACE CURVATURE ALSO PRESENTS POINT SPACING
C2.16    TO POST PROCESSOR ADAPTABLE TO FEED RATES.
  151 IF(DP-2.*DPI+TAU(IS))155,155,153
  153 DP=2.*DPI
C
C
  127 IF(IGOUG)160,160,157
  157 CALL GOUGE
C2.22     IF GOUGCK FAILS, REJECT CUT VECTOR AND REDUCE DP TO .75DP
      IF(JGR)159,160,159
  159 DP=.75*DPI
      GO TO 145
C
C2.23     ACCEPT CUT VECTOR CANDIDATE
  160 JDR=0
      GO TO 201
  508 ZL=(TP(1,IS)-TPK(1,IS))**2+(TP(2,IS)-TPK(2,IS))**2
     1   +(TP(3,IS)-TPK(3,IS))**2
      ZL =DSQRT (ZL)
      IF (J.EQ.0) THEN
        CALL CCURV(IS,SP(1,IS),SPK(1,IS),SN(1,IS))
      ELSE
        CALL CCURV(IS,SP(1,IS),SPK(1,IS),SNK(1,IS))
      ENDIF
C
C...                IF APPARANT PLANE, USE LARGE RADIUS OF CURVATURE
C
      IF (ISIGCR(IS)-1) 104,1104,104
 1104 RC(IS) = DSIGN(RC1,RC(IS))
  104 IF(RC(IS))106,107,107
  106 IF(JLIN-1)108,109,108
  108 RC(IS)=DABS(RC(IS)+TAU2(IS))-TH(IS)
  110 D1=2.*DABS(RC(IS))
      GO TO 120
  107 IF(JLIN-1)111,812,111
  111 RC(IS)=RC(IS)+TAU1(IS)+TH(IS)
      GO TO 110
  812 RC(IS)=DABS(RC(IS))+.5*(TAU1(IS)+TAU2(IS))+TH(IS)
      GO TO 110
  109 RC(IS)=DABS(RC(IS))+.5*(TAU1(IS)+TAU2(IS))-TH(IS)
      GO TO 110
  120 F=1.-(DABS(SK(1,IS)-S(IS)))/(1.8*TAU(IS))
      DP=DSQRT(ZLIT3*TAU(IS)*DABS(D1-TAU(IS)))
      DP=F*DP
      TEMP(4) = DSQRT((TE(1)-TEK(1))**2+(TE(2)-TEK(2))**2
     1          + (TE(3)-TEK(3))**2)
      GO TO 303
       END
**** SOURCE FILE : M0000894.V07   ***
*
C
C.....FORTRAN SUBROUTINES        DNTCUT & DNTCUH  ...       3/1/68   GK
C
      SUBROUTINE DNTCUT
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
      INTEGER IPPWRD(2),BCDF
      CHARACTER*8 PPWORD
C
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
C
      DATA  PPWORD /'DNTCUT'/
C
C
      IF(JHLDFG.EQ.0) GO TO 1
      ITABH(ITHCNT)=7
      ITHCNT=ITHCNT+1
      RETURN
C
    1 CONTINUE
C...  DONT OUTPUT CUTTER CENTERS ON CLTAPE
      IPPWRD(1)=BCDF(PPWORD(1:4))
      IPPWRD(2)=BCDF(PPWORD(5:8))
      CALL APT299(0,IPPWRD,0,0)
      ICUT=K1
      RETURN
       END
C
C
C
C
C.....FORTRAN SUBROUTINE        DNTCUH...                3/1/68   GK
C
      SUBROUTINE DNTCUH
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
      INTEGER IPPWRD(2),BCDF
      CHARACTER*8 PPWORD
C
C
      DATA  PPWORD /'DNTCUT'/
C
C
C...  DONT OUTPUT CUTTER CENTERS ON CLTAPE
      IPPWRD(1)=BCDF(PPWORD(1:4))
      IPPWRD(2)=BCDF(PPWORD(5:8))
      CALL APT299(0,IPPWRD,0,0)
      ICUT=K1
      RETURN
       END
**** SOURCE FILE : M0000904.V04   ***
*
C.....FORTRAN SUBROUTINE  ....FROM           8/68                 AR,PH
C
      SUBROUTINE FROM(POINT)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
C
C...  THE PRESENT TOOL POSITION IS (POINT)
      DIMENSION POINT(3)
      CHARACTER*4 HFROM
      DATA HFROM/'FROM'/
      IAERR=0
      IGOTO=0
      CALL TRANSM(TEK,POINT,2,3,0)
      DO 10 J = 1,3
   10 TE(J)=TEK(J)
      CALL APT202(POINT,2)
C...  SET RECORD TYPE CODE FOR CLTAPE WRITER
      MODFER=HFROM
      CALL APT233
      RETURN
       END
**** SOURCE FILE : M0000905.W01   ***
*
C.....FORTRAN SUBROUTINE             GAUSS...               4/1/68   GK
      SUBROUTINE GAUSS(VEC1,D1,VEC2,D2,VEC3,D3,PT,IR)
      IMPLICIT DOUBLE PRECISION(A-H), DOUBLE PRECISION(O-Z)
      DIMENSION A(12),ASAV(4),PT(3),VEC1(3),D1(1),VEC2(3),D2(1),VEC3(3),
     1          D3(1),C(3)
      DATA EPS/0.9999D0/,ONE/1.D0/,ZERO/0.D0/
                                             
C.... CHECK FOR ANY TWO INPUT VECTORS BEING PARALLEL
C
      CALL DOTF(ERG1,VEC1,VEC2)
      CALL DOTF(ERG2,VEC1,VEC3)
      CALL DOTF(ERG3,VEC2,VEC3)
      IF (ABS(ERG1).GT.EPS) THEN
        IR=12
        IF (ERG1.LT.ZERO) IR=-12
      ELSE IF (ABS(ERG2).GT.EPS) THEN
        IR=13
        IF (ERG2.LT.ZERO) IR=-13
      ELSE IF (ABS(ERG3).GT.EPS) THEN
        IR=23
        IF (ERG3.LT.ZERO) IR=-23
      ELSE
      DO 7 I = 1,3
      A(I) = VEC1(I)
      A(I+4) = VEC2(I)
    7 A(I+8) = VEC3(I)
      A(4) = D1(1)
      A(8) = D2(1)
      A(12) = D3(1)
      Q = 0.
      DO 2 I = 1,3
      C(I) =DABS(A(4*I-3))
      Q = Q + C(I)
    2 CONTINUE
      IF (Q) 2000,2000,3
    3 IF (C(2) - C(1)) 30,30,40
   30 IF (C(3) - C(1)) 70,70,50
   40 IF (C(3) - C(2)) 60,60,50
   50 JMAX = 3
      GO TO 65
   60 JMAX = 2
   65 K = 2**JMAX
      DO 66 I = 1,4
      M = I + K
      ASAV(I) = A(I)
      A(I) = A(M)
      A(M) = ASAV(I)
   66 CONTINUE
   70 COE5 =A(5)/A(1)
      COE9 =A(9)/A(1)
      DO 75 J = 2,4
      A(J+4) = A(J+4) - COE5*A(J)
      A(J+8) = A(J+8) - COE9*A(J)
   75 CONTINUE
      C(2) =DABS(A(6))
      C(3) =DABS(A(10))
      IF (C(2)+C(3)) 2000,2000,80
   80 IF (C(2)-C(3)) 90,100,100
   90 DO 95 J = 1,4
      ASAV(J) = A(J+4)
      A(J+4) = A(J+8)
      A(J+8) = ASAV(J)
   95 CONTINUE
  100 COE10 = A(10)/A(6)
      DO 105 J = 3,4
  105 A(J+8) = A(J+8) - A(J+4)*COE10
      IF (A(11)) 1050,2000,1050
 1050 PT(3) = A(12)/A(11)
      PT(2) = (A(8)-A(7)*PT(3))/A(6)
      PT(1) = (A(4)-A(3)*PT(3)-A(2)*PT(2))/A(1)
      GO TO 2010
 2000 IR = 1
      GO TO 2020
 2010 IR = 0
      ENDIF
 2020 RETURN
      END
**** SOURCE FILE : M0002768.V08   ***
*
C...  FORTRAN SUBROUTINE     GO2
      SUBROUTINE GO2(HMOD,ADRESS)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      CHARACTER*2 HGO
      DIMENSION ADRESS(*)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      COMMON/ADDCOM/ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),
     2            (ADDCOM(25),KDYNFL)
C
C
C
C
      INCLUDE 'BLANKCOM.INC'
C
      DIMENSION CANSAV(4)
C
      DATA  HGO /'GO'/
      DATA ZLIT1,ZLIT2,KLIT3/.0001D0,.9999D0,21/
C
      ICNSAV=K0
      ZL=Z1
C
C                 SET IAFL FLAG
C
      NUMDIM = 0
      JCS = .FALSE.
      IF(IGOTO.EQ.K0)GO TO 1
      IF(ISRCH.NE.K0)GO TO 9600
  502 CALL AERR (20202,'GO2     ')
      GO TO 9100
    1 IF(ICSCNT-K1)1101,1101,1102
 1102 CALL AERR (20203,'GO2     ')
      GO TO 9100
 1101 ISTRUP=K1
      DP=-1.0
      JENT(IPS) = K1
      JENT(IDS) = K1
      IS=IDS
      CALL APT234 (HMOD,ADRESS)
      IF(IAERR)503,503,9100
  503 TEK(1) = TE(1)
      TEK(2)=TE(2)
      TEK(3)=TE(3)
      XDIR = K1
      IF (KDYNFL.NE.K0) CALL APT238(41)
 1000 IF(INOPS)6,6,2
    2 IF(ICSCNT)3,3,1020
    3 NGOSRF=K1
      GO TO 7
 1020 CALL AERR (20204,'GO2     ')
      GO TO 9100
    6 NGOSRF=ICSCNT+K2
    7 MODFER=HGO
      CALL APT235
      IF(IAERR.GT.K0)GO TO 9100
      IF(INOPS.NE.K1)GO TO 1610
      DO 1605 I=1,4
 1605 CANSAV(I)=CANON(I)
      ICNSAV=K1
 1610 CALL APT240(NUMDIM)
      ID=0
 1070 IA = K1
      IB=K1
      TEM1=Z0
 1080 ID=ID+K1
 1090 IF(NGOSRF-ID)1300,1100,1100
 1100 IF(ID-K2)1110,1120,1130
 1110 IS = IDS
      GO TO 1140
 1120 IS = IPS
      GO TO 1140
 1130 IS = ICS
1140  IF(INDIR(IS).EQ.0.AND.ISFIDN(IS).NE.12)GO TO 1160
 1150 IA=IA+K1
      IF (KDYNFL.NE.K0) CALL APT238(42)
      GO TO 1080
 1160 CONTINUE
      IF (KDYNFL.NE.K0) CALL APT238(43)
 1161 IF(ISVFL(IS))9000,1180,1170
 1170 TI(1) = SFVCT(1,IS)
      TI(2) = SFVCT(2,IS)
      TI(3) = SFVCT(3,IS)
      IF(IS.EQ.ICS) GO TO 1173
      ISSTO=IS
      IS=ICS+1
        CALL SVCOPY(ISSTO,IS)
        CALL ISVCPY(ISSTO,IS)
 1173 TN(1,IS)=SFVCT(1,IS)
      TN(2,IS) = SFVCT(2,IS)
      TN(3,IS) = SFVCT(3,IS)
      J20(IS)=0
      J23(IS)=K1
      DP=0.0
      ISTRUP=2
      CALL CHECK
      IF(IAERR)9100,100,9100
  100 IF(IS.EQ.ICS) GO TO 1175
        CALL SVCOPY(IS,ISSTO)
        CALL ISVCPY(IS,ISSTO)
      IS=ISSTO
      IF(TEM3)1240,1210,1240
 1175 IF(CSD(IS)) 1239,1210,1239
 1180 IF (IS.EQ.IPS) GO TO 1181
      IF(INDIR(IDS).EQ.1) GO TO 1182
      IF(INDIR(ICS).EQ.1) GO TO 1183
      TN(1,IS)=Z1
      TN(2,IS)=Z0
      TN(3,IS)=Z0
      GO TO 1190
 1181 TN(1,IS)=-TA(1)
      TN(2,IS)=-TA(2)
      TN(3,IS)=-TA(3)
      GO TO 1190
 1182 K=IDS
      GO TO 1184
 1183 K=ICS
 1184 TN(1,IS)=VNDIR(1,K)
      TN(2,IS)=VNDIR(2,K)
      TN(3,IS)=VNDIR(3,K)
 1190 IOPSET(IS)=0
      JENT(IS)=K1
      JTN(IS)=0
      JU1(IS)=K1
      JIOPS(IS)=0
      JMINR=K1
 1200 CALL AMIND
      JMINR=K0
      IF(IAERR)9100,1210,9100
 1210 TEM3=DABS(S(IS))
      IF (KDYNFL.NE.K0) CALL APT238(K44)
      GO TO 1240
 1239 TEM3=CSD(IS)
 1240 IF(TEM1  -DABS(S(IS))) 1250,1250,1260
 1250 TEM1=DABS(S(IS))
 1260 GO TO (1080,1310,1270), IB
 1270 IB=K2
      GO TO 1500
 1300 ID=0
      IB=K2
 1310 IA=IA-K1
 1320 IF (IA) 9000,2000,1330
 1330 ID=ID+K1
 1340 IF(NGOSRF-ID)9000,1350,1350
 1350 IF(ID-K2)1360,1370,1380
 1360 IS = IDS
      GO TO 1390
 1370 IS = IPS
      GO TO 1390
 1380 IS = ICS
 1390 IF(INDIR(IS)) 9000,1391,1400
 1391 IF(ISFIDN(IS).NE.12) GO TO 1330
      VNDIR(1,IS)=Z0
      VNDIR(2,IS)=Z0
      VNDIR(3,IS)=Z0
 1400 DO 1420 K=1,3
      TP(  K,IS  )=TE(K)+Z5EM1*CUTDAT(7)*TA(K)+TH(IS)*VNDIR(K,IS)
 1420 TN( K,IS   )=VNDIR(K,IS)
      IOP(IS)=K1
      IF(ISFIDN(IS).EQ.12.AND.INDIR(IS).EQ.0) IOP(IS)=K2
      CALL DDST
      IOP(IS)=K1
      IF(IER)1410,1430,1410
 1410 IB=K3
      GO TO 1160
 1430 TEM2=S(IS)
      IF(ISFTYP(IS)-K3)1445,1440,1445
 1445 TEM2=TEM2-CUTDAT(1)
 1440 ISSV=IS
      DO 1431 I=1,3
C          CHECK FOR ALL SURFACE
      IF(I.EQ.1) IS=IDS
      IF(I.EQ.2) IS=IPS
      IF(I.EQ.3.AND.ICSCNT.EQ.0) GO TO 1431
      IF(I.EQ.3) IS=ICS
C    IF ALREADY CHECKED SKIP
 1435 IF(IS.EQ.ISSV) GO TO 1431
      TEMP(1)=TN(1,IS)
      TEMP(2)=TN(2,IS)
      TEMP(3)=TN(3,IS)
      TEMP(7)=TP(1,IS)
      TEMP(8)=TP(2,IS)
      TEMP(9)=TP(3,IS)
      DO 1436 K=1,3
      TP(K,IS)=TE(K)+Z5EM1*CUTDAT(7)*TA(K)+TH(IS)*VNDIR(K,ISSV)
 1436 TN(K,IS)=VNDIR(K,ISSV)
      IOP(IS)=K1
      CALL DDST
      IF(IER.EQ.1) GO TO 1438
      TEM3=S(IS)
      IF(ISFTYP(IS).NE.K3) TEM3=TEM3-CUTDAT(1)
      IF(TEM3.LT.0.00000001) GO TO 1438
      IF(TEM3.LT.TEM2) TEM2=TEM3
 1438 TN(1,IS)=TEMP(1)
      TN(2,IS)=TEMP(2)
      TN(3,IS)=TEMP(3)
      TP(1,IS)=TEMP(7)
      TP(2,IS)=TEMP(8)
      TP(3,IS)=TEMP(9)
 1431 CONTINUE
      IS=ISSV
      TEMP(5)=TEM2-TAU(IS)
      TE(1)=TE(1)+TEMP(5)*VNDIR(1,IS)
      TE(2)=TE(2)+TEMP(5)*VNDIR(2,IS)
      TE(3)=TE(3)+TEMP(5)*VNDIR(3,IS)
      IF(INDIR(ICS).EQ.1.OR.ISVFL(ICS).EQ.1.OR.ICSCNT.EQ.0) GO TO 1160
      JENT(ICS)=1
      JMINR=1
      ISSSV=IS
      IS=ICS
      CALL AMIND
      JMINR=0
      IS=ISSSV
      GOTO 1160
 1500 IF(TEM3-TEM1)1510,1510,1520
C              USE SMALLEST MINIMUM DIST WHICH IS
C              GREATER THAN TWO TOLERANCES
 1510 TEM2 = TEM1
      DO 1501 III = IPS,ICS,LSV
      IF(ISVFL(III).EQ.0) GO TO 1501
      IF (CSD(III) - Z2*TAU(IS)) 1501,1501,1502
 1502 TEM2 = DMIN1 (TEM2,CSD(III))
 1501 CONTINUE
      GO TO 1440
 1511 TEM2 = TEM1
      GO TO 1440
 1520 IF (TEM3-Z10) 1530,1511,1511
 1530 TEM2=TEM3
      GO TO 1440
 2000 IF(NGOSRF-K2)2010,3000,3120
 2010 IF (INDIR(IDS)) 9000,2030,2020
 2020 DIR(1) = VNDIR(1,IDS)
      DIR(2) = VNDIR(2,IDS)
      DIR(3) = VNDIR(3,IDS)
      GO TO 2040
 2030 DIR(1) = TN(1,IDS)
      DIR(2) = TN(2,IDS)
      DIR(3) = TN(3,IDS)
 2040 IF ( DABS(DIR(3))-ZLIT1) 2050,2050,2060
 2050 PLNV(1,ICS) = DIR(2)
      PLNV(2,ICS) = -DIR(1)
      PLNV(3,ICS) = Z0
      GO TO 2090
 2060 IF ( DABS(DIR(2))-ZLIT1) 2070,2070,2080
 2070 PLNV(1,ICS) = DIR(3)
      PLNV(2,ICS) = Z0
      PLNV(3,ICS) = -DIR(1)
      GO TO 2090
 2080 IF(DABS(DIR(1))-ZLIT1) 2085,2085,2087
 2085 PLNV(1,ICS) = Z0
      PLNV(2,ICS) = DIR(3)
      PLNV(3,ICS) = -DIR(2)
      GO TO 2090
 2087 IF (DABS(DIR(2))-DABS(DIR(3))) 2070,2070,2050
 2090 CALL VNORM (PLNV(1,ICS),PLNV(1,ICS))
      CALL CROSS(DIR(1),PLNV(1,ICS),PLNV(1,IPS))
      CALL VNORM (PLNV(1,IPS),PLNV(1,IPS))
 2110 PLND(IPS)=PLNV(1,IPS)*TEK(1)+PLNV(2,IPS)*TEK(2)+PLNV(3,IPS)*TEK(3)
      PLND(ICS)=PLNV(1,ICS)*TEK(1)+PLNV(2,ICS)*TEK(2)+PLNV(3,ICS)*TEK(3)
 2120 ICANON(IPS)=K1
      ISFIDN(IPS)=K2
      ISFTYP(IPS)=K3
      ITLON(IPS)=0
      CANON(1)=PLNV(1,IPS)
      CANON(2)=PLNV(2,IPS)
      CANON(3)=PLNV(3,IPS)
      CANON(4)=PLND(IPS)
      IPL(IPS)=K1
      IUNFL(IPS)=K1
      JENT(IPS)=K1
      JTN(IPS)=0
      IOPSET(IPS)=0
      JU1(IPS)=K1
      JIOPS(IPS)=0
      TN(1,IPS)=PLNV(1,IPS)
      TN(2,IPS)=PLNV(2,IPS)
      TN(3,IPS)=PLNV(3,IPS)
      PAST(IPS)=Z1
      GO TO 3110
 3000 IF (INDIR(IDS)) 9000,3030,3010
 3010 IF (INDIR(IPS)) 9000,3050,3020
 3020 J50(ICS)=0
      J51(ICS)=0
      IS=ICS
      CALL CENTR
      IF(IAERR)9100,101,9100
  101 IF (JCR) 3152,9999,3152
 3030 IF (INDIR(IPS)) 9000,3020,3040
 3040 IS = IPS
      GO TO 3060
 3050 IS = IDS
 3060 DIR(1) = VNDIR(1,IS)
      DIR(2) = VNDIR(2,IS)
      DIR(3) = VNDIR(3,IS)
      IF(DABS(TN(1,IPS)*TN(1,IDS)+TN(2,IPS)*TN(2,IDS)+TN(3,IPS)*
     C TN(3,IDS)).GT.ZLIT1) GO TO 3020
      CALL CROSS(TN(1,IPS),TN(1,IDS),PLNV(1,ICS))
      CALL VNORM(PLNV(1,ICS),PLNV(1,ICS))
      IF (IER) 3020,3065,3020
 3065 CALL CROSS(PLNV(1,ICS),DIR,PLNV(1,ICS))
      CALL VNORM(PLNV(1,ICS),PLNV(1,ICS))
      IF(IER) 3020,3070,3020
 3070 CALL CROSS(PLNV(1,ICS),DIR,PLNV(1,ICS))
 3080 CALL VNORM (PLNV(1,ICS),PLNV(1,ICS))
 3090 IF(IER)3020,4100,3020
 4100 IF(IPL(IPS))4107,4105,4107
 4105 IF(IPL(IDS))4108,3020,4108
 4107 K=IPS
      GO TO 4109
 4108 K=IDS
 4109 IC=ICANON(K)
      IF(DABS(PLNV(1,ICS)*CANON(IC)+PLNV(2,ICS)*CANON(IC+1)+
     1PLNV(3,ICS)*CANON(IC+2))-ZLIT2)3100,3100,3020
 3100 PLND(ICS)=PLNV(1,ICS)*TEK(1)+PLNV(2,ICS)*TEK(2)+PLNV(3,ICS)*TEK(3)
 3110 ICANON(ICS) = KLIT3
      ISFIDN(ICS)=K1
      CANON(21)=PLNV(1,ICS)
      CANON(22)=PLNV(2,ICS)
      CANON(23)=PLNV(3,ICS)
      CANON(24)=PLND(ICS)
      ISFTYP(ICS)=K3
      ITLON(ICS)=0
      IUNFL(ICS)=K1
      IPL(ICS)=K1
      JENT(ICS)=K1
      JTN(ICS)=0
      IOPSET(ICS)=0
      JU1(ICS)=K1
      TN(1,ICS)=PLNV(1,ICS)
      TN(2,ICS)=PLNV(2,ICS)
      TN(3,ICS)=PLNV(3,ICS)
      JIOPS(ICS)=0
      PAST(ICS)=Z1
      IAFL(ICS)=KM1
      ICSCNT=K1
 3120 J50(ICS)=K1
      J51(ICS)=K1
 3130 IS=ICS
 3140 CALL CENTR
      IF(IAERR)9100,102,9100
  102 IF (JCR-K1) 3141,9999,3141
 3141 IF (NUMSUR-K3) 3020,3150,3150
C         TRY MOVING TO PS AND DS FIRST
 3150 IF (XDIR) 3152,3152,3151
 3151 XDIR = KM1
      J50(IS) = 0
      J51(IS) = 0
      IS = ICS
      CALL CENTR
      IF(JCR) 3152,1070,3152
 3152 CALL AERR (20205,'GO2     ')
      GO TO 9100
 9000 CALL AERR (20206,'GO2     ')
      GO TO 9100
 9999 ICL=K3
      CALL ATAPE
      IF(IAERR)9100,103,9100
  103 IF (KDYNFL.NE.K0) CALL APT238(45)
      GO TO 9500
 9100 CALL APT236
      GO TO 9900
 9500 CALL APT236
      ISTRUP=0
      IF(ISFTYP(IPS).NE.K2) GO TO 9550
      ISFTYP(IPS)=K1
      PAST(IPS)=Z1
 9550 IF (ISFTYP(IDS).NE.K2) GO TO 9600
      ISFTYP(IDS)=K1
      PAST(IDS)=Z1
 9600 CONTINUE
      DO 4112 K = 1,3
      TEMP(K) = TE(K) - TEK(K)
      TPK(K,IPS) = TP(K,IPS)
      SPK(K,IPS) = SP(K,IPS)
      U1K(K,IPS) = U1(K,IPS)
      SNK(K,IPS) = SN(K,IPS)
 4112 CONTINUE
      SK(1,IPS) = S(IPS)
C
 9900 IF(ICNSAV.NE.K1)GO TO 9990
      DO 9910 I=1,4
 9910 CANON(I)=CANSAV(I)
 9990 RETURN
      END
**** SOURCE FILE : M0002750.V06   ***
*
C
C.....FORTRAN SUBROUTINE             GODLTA...              3/1/68   GK
      SUBROUTINE GODLTA(VECTOR,DECMAL)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C     25.   COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM / IAERFG
C
C     23. DSNAME BLOCK
C
      COMMON/DSNAME/DSNAME,NAMSUB
C
      DIMENSION TASAV(3)
      DIMENSION VEC(3)
      INTEGER ITEMP(2),BCDF
      EQUIVALENCE (ATEMP,ITEMP(1))
C
C...  CUTTER POSITION IS ADVANCED BY THE VECTOR, OR IS MOVED
C...  (DECMAL) INCHES ALONG THE TOOL AXIS
      DIMENSION VECTOR(3)
      CHARACTER*6 HGDLTA
      CHARACTER*4 HGOTO
      DATA HGDLTA,HGOTO/'GODLTA','GOTO'/
      IF(IAERR.NE.0)GO TO 1000
      IF(JDS)CALL APT201(0,'NOCS    ')
      IF(IGOTO)1,1,2
    2 IF(ISRCH)3,3,1000
    3 IAERFG=1
      CALL AERR(21301,'GODLTA  ')
      IAERR=0
      GO TO 1000
    1 CALL TRANSM(VEC,VECTOR,3,3,0)
      DO 10 J = 1,3
      TEK(J)=TE(J)
C...  EITHER DECMAL OR THE VECTOR COMPONENTS WILL BE ZERO
   10 TE(J) = VEC(J) + DECMAL*TA(J)
C...  SET RECORD TYPE CODE FOR CLTAPE WRITER
   50 MODFER=HGDLTA
      DO 55 J=1,3
      TASAV(J)=TA(J)
   55 TA(J)=0.0
      CALL APT233
      DO 60 J=1,3
      TA(J)=TASAV(J)
   60 TE(J)=TEK(J)+TE(J)
      MODFER=HGOTO
      ITEMP(1)=BCDF('NONA')
      ITEMP(2)=BCDF('ME  ')
      DSNAME=ATEMP
      CALL APT233
 1000 CONTINUE
      RETURN
       END
**** SOURCE FILE : M0000913.V05   ***
*
C.....FORTRAN SUBROUTINE  ....GOTO           8/68                 AR,PH
C
      SUBROUTINE GOTO(POINT)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
C
      DIMENSION POINT(3)
      CHARACTER*4 HGOTO
      DATA HGOTO/'GOTO'/
      IF(JDS) CALL APT201(0,'NOCS    ')
      IAERR=0
      DO 10 J=1,3
   10 TEK(J) = TE(J)
      CALL TRANSM(TE,POINT,2,3,0)
      CALL APT202(POINT,2)
C...  SET RECORD TYPE CODE FOR CLTAPE WRITER
      MODFER = HGOTO
      CALL APT233
      IGOTO=0
      RETURN
       END
**** SOURCE FILE : M0002775.V06   ***
*
C
C...  FORTRAN SUBROUTINE               GOTOPN    3/69      SR
C
C PURPOSE      TO POSITION THE TOOL AS INDICATED BY A
C              PATERN MOTION STATEMENT
C
C LINKAGE      CALL GOTOPN(PAT,IARG1,IARG2,IARG3,IARG4,OMTLST,AVDLST)
C
C ARGUMENTS    PAT     ARRAY CONTAINING THE I.C.F. OF THE PATERN
C              IARG1   INTEGER 1 IF INVERS APPLIES, OTHERWISE 0
C              IARG2   INTEGER 1 IF ZIGZAG APPLIES, OTHERWISE 0
C              IARG3   INTEGER INDICATING TYPE (OMIT, RETAIN) AND
C                      NUMBER OF 2-ELEMENT ENTRIES IN OMTLST
C                      IARG3=0       NEITHER OMIT NOR RETAIN MODIFIER
C                                    USED
C                      0)IARG3)1000  OMTLST CONTAINS POINTS TO BE
C                                    OMITTED AND
C                                    IARG3=NUMBER OF ENTRIES
C                      1000)IARG3    OMTLST CONTAINS POINTS TO BE
C                                    RETAINED AND
C                                    1000-IARG3=NUMBER OF ENTRIES
C              IARG4   INTEGER INDICATING NUMBER OF 3-ELEMENT
C                      ENTRIES IN AVDLST
C              OMTLST  ARRAY CONTAINING FIRST AND LAST POINT OF
C                      EACH OMIT OR RETAIN SEQUENCE
C              AVDLST  ARRAY CONTAINING THE OFFSET AND THE FIRST
C                      AND LAST POINT OF EACH AVOID SEQUENCE
C
C SUBSIDIARIES TYPE                ENTRY
C              LOGICAL FUNCTION    CKDEF
C              SUBROUTINE          APT094
C              SUBROUTINE          APT202
C              SUBROUTINE          APT233
C              SUBROUTINE          APT299
C              SUBROUTINE          ERROR
C              SUBROUTINE          NPAT
C
      SUBROUTINE GOTOPN(PAT,IARG1,IARG2,IARG3,IARG4,OMTLST,AVDLST)
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
      INCLUDE 'BLANKCOM.INC'
C
      DOUBLE PRECISION OMTLST
      DIMENSION PAT(2),           OMTLST(2,49),AVDLST(3,34),RES(3)
C
      CHARACTER*4 HGOTO
      CHARACTER*5 HCYCLE
      CHARACTER*2 HON
      CHARACTER*6 HNOMOR
      LOGICAL CKDEF
      DATA HGOTO /'GOTO'/, HCYCLE /'CYCLE'/, HON /'ON'/,
     1 HNOMOR /'NOMORE'/
C
C          MOVE THE EXTERNAL CANONICAL FORM TO BCANON
C
      IF(CKDEF(PAT))GO TO 999
      CALL APT094(2,PAT,BCANON)
      IF(CKDEF(PAT))GO TO 999
C
C          DETERMINE NUMBER OF POINTS IN PATERN
C
      N=BCANON(4)+Z1EM5
C
C          IF ZIGZAG IS TO APPLY, PATERN MUST BE GRID
C
      ISVA2=IARG2
      IF(ISVA2.EQ.K0)GO TO 10
      IF(BCANON(2).EQ.Z3)GO TO 5
      CALL ERROR(45,'GOTOPN  ')
      ISVA2=K0
      GO TO 10
C
C          DETERMINE NUMBER OF POINTS IN FIRST SIDE OF GRID PATERN
C
    5 NPAT1=BCANON(7)+Z1EM5
C
C          IF OMTLST HAS ENTRIES, PUT THEM IN ORDER
C
   10 ISVA3=IARG3
      IF(ISVA3.LT.1000)GO TO 11
      ISVA3=-(ISVA3-1000)
   11 IF(ISVA3)12,20,14
   12 IPARG3=-ISVA3
      GO TO 16
   14 IPARG3=ISVA3
   16 DO 18 I=1,IPARG3
      IF(OMTLST(1,I).LE.OMTLST(2,I))GO TO 18
      TMPSAV=OMTLST(1,I)
      OMTLST(1,I)=OMTLST(2,I)
      OMTLST(2,I)=TMPSAV
   18 CONTINUE
C
C          CHECK FOR AVOID
C
   20 IF(IARG4.EQ.K0)GO TO 70
C
C          PUT AVDLST ENTRIES IN ORDER
C
      DO 60 I=1,IARG4
      IF(AVDLST(2,I).LT.AVDLST(3,I))GO TO 40
      IF(AVDLST(3,I).EQ.Z0)GO TO 22
C
C          REVERSE ORDER
C
      TMPSAV=AVDLST(2,I)
      AVDLST(2,I)=AVDLST(3,I)
      AVDLST(3,I)=TMPSAV
      GO TO 40
C
C          INSERT AS END POINT THE NEXT NON-OMITTED POINT
C
   22 AVDLST(3,I)=AVDLST(2,I)+Z1
      PT=N
      IF(ISVA3)24,60,32
   24 DO 26 J=1,IPARG3
      IF((AVDLST(3,I).GE.OMTLST(1,J)).AND.(AVDLST(3,I).LE.OMTLST(2,J)))
     1 GO TO 46
   26 CONTINUE
      IF(AVDLST(3,I).GE.PT)GO TO 1000
      AVDLST(3,I)=AVDLST(3,I)+Z1
      GO TO 24
   32 DO 36 J=1,IPARG3
      IF((AVDLST(3,I).GE.OMTLST(1,J)).AND.(AVDLST(3,I).LE.OMTLST(2,J)))
     1 GO TO 38
   36 CONTINUE
      GO TO 54
   38 IF(AVDLST(3,I).GE.PT)GO TO 1000
      AVDLST(3,I)=AVDLST(3,I)+Z1
      GO TO 32
C
C          CHECK FOR OMITTED FIRST OR END POINT IN AVOID STRING
C
   40 IF(ISVA3)42,60,50
   42 DO 44 J=1,IPARG3
      IF((AVDLST(3,I).GE.OMTLST(1,J)).AND.(AVDLST(3,I).LE.OMTLST(2,J)))
     1 GO TO 46
   44 CONTINUE
      GO TO 1000
   46 DO 48 J=1,IPARG3
      IF((AVDLST(2,I).GE.OMTLST(1,J)).AND.(AVDLST(2,I).LE.OMTLST(2,J)))
     1 GO TO 60
   48 CONTINUE
      GO TO 1000
   50 DO 52 J=1,IPARG3
      IF((AVDLST(3,I).GE.OMTLST(1,J)).AND.(AVDLST(3,I).LE.OMTLST(2,J)))
     1 GO TO 1000
   52 CONTINUE
   54 DO 58 J=1,IPARG3
      IF((AVDLST(2,I).GE.OMTLST(1,J)).AND.(AVDLST(2,I).LE.OMTLST(2,J)))
     1 GO TO 1000
   58 CONTINUE
   60 CONTINUE
C
   70 IAERR=0
      CALL APT202(PAT,2)
      MODFER=HGOTO
C
C          INITIALIZE FOR AVOID
C
      IAVTYP=K1
      AVDEND=Z0
      JSAV=K0
C
C
  100 DO 900 I=1,N
      NO=I
C
C          CHECK FOR INVERSE
C
      IF(IARG1.EQ.K0)GO TO 105
      NO=N-I+K1
C
C          CHECK FOR ZIGZAG
C
  105 IF(ISVA2.EQ.K0)GO TO 110
      NCOL=(NO-K1)/NPAT1
      NCOLMD=MOD(NCOL,K2)
      IF(((NCOLMD.EQ.K1).AND.(IARG1.EQ.K0)).OR.((NCOLMD.EQ.K0).AND.
     /  (IARG1.EQ.K1))) NO=NPAT1*(K2*NCOL+K1)-NO+K1
  110 PT=NO
C
C          CHECK FOR OMIT OR RETAIN
C
      IF(ISVA3)140,160,120
C
C          OMIT
C
  120 DO 124 J=1,IPARG3
      IF((PT.GE.OMTLST(1,J)).AND.(PT.LE.OMTLST(2,J)))GO TO 900
  124 CONTINUE
      GO TO 160
C
C          RETAIN
C
  140 DO 144 J=1,IPARG3
      IF((PT.GE.OMTLST(1,J)).AND.(PT.LE.OMTLST(2,J)))GO TO 160
  144 CONTINUE
      GO TO 900
C
C          CHECK FOR AVOID
C
  160 IF(IARG4.EQ.K0)GO TO 200
C
C          AVOID
C
      IF(AVDEND.NE.Z0)GO TO 170
C
C          LOOK FOR FIRST POINT
C
      DO 164 J=1,IARG4
      IF(PT.NE.AVDLST(2,J))GO TO 163
      AVDEND=AVDLST(3,J)
  162 JSAV=J
      AVDUP=AVDLST(1,J)
      AVDDN=AVDLST(1,J)
      IAVTYP=K2
      GO TO 200
  163 IF(PT.NE.AVDLST(3,J))GO TO 164
      AVDEND=AVDLST(2,J)
      GO TO 162
  164 CONTINUE
      GO TO 200
C
C          LOOK FOR END POINT
C
  170 IF(PT.EQ.AVDEND)GO TO 180
      IAVTYP=K3
      GO TO 200
C
C          IS THIS END POINT A FIRST POINT OF NEXT STRING
C
  180 DO 184 J=1,IARG4
      IF(PT.NE.AVDLST(2,J))GO TO 183
      IF(J.EQ.JSAV)GO TO 184
      AVDEND=AVDLST(3,J)
  182 AVDUP=AVDLST(1,J)
      IAVTYP=K3
      GO TO 200
  183 IF((PT.NE.AVDLST(3,J)).OR.(J.EQ.JSAV))GO TO 184
      AVDEND=AVDLST(2,J)
      GO TO 182
  184 CONTINUE
      JSAV=K0
      AVDEND=Z0
      IAVTYP=K4
C
C          CALL NPAT TO DETERMINE COORDINATES OF POINT
C
  200 CALL NPAT(RES,NO)
C
C          BRANCH ON IAVTYP
C             1-AVOID DOES NOT APPLY     2-FIRST POINT IN AVOID STRING
C             3-INTERMEDIATE POINT       4-END POINT
C
      GO TO(240,240,220,210),IAVTYP
  210 IAVTYP=K1
  220 DO 224 J=1,3
      TEK(J)=TE(J)
  224 TE(J)=RES(J)
      TE(3)=TE(3)+AVDDN
      CALL APT233
      CALL APT299(K1,HCYCLE,K2,HON)
      AVDDN=AVDUP
  240 DO 244 J=1,3
      TEK(J)=TE(J)
  244 TE(J)=RES(J)
      CALL APT233
      IF(IAVTYP.EQ.K1)GO TO 900
      CALL APT299(K1,HCYCLE,K2,HNOMOR)
      DO 250 J=1,3
      TEK(J)=TE(J)
  250 TE(J)=RES(J)
      TE(3)=TE(3)+AVDUP
      CALL APT233
  900 CONTINUE
C
      IGOTO=0
C
  999 RETURN
C
C          OMIT HAS BEEN APPLIED (OR RETAIN HAS NOT BEEN APPLIED)
C             TO A FIRST OR AN END POINT OF AN AVOID STRING
C
 1000 CALL ERROR(46,'GOTOPN  ')
      GO TO 999
C
      END
**** SOURCE FILE : M0000916.V01   ***
*
C
C.....FORTRAN SUBROUTINE ...GOUGE          SUPPLIED BY VW  6/88
C
C                         MODIFIED FOR SSV..  E.MCLELLAN
C
      SUBROUTINE GOUGE
C     VERSION K1 VOM 8.6.86
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
C
      DIMENSION TPSAV(3),TNSAV(3),SPSAV(3),SNSAV(3),U1SAV(3),VTSAV(3)
      DIMENSION HILF(3)
C
      INCLUDE 'CGOUG.INC'
C
      COMMON /MODESS/MODESS,MSSCHK,MSSARL
C
      DATA ZERO /0.D0/
C
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C+++
C+++  KORR  6-GOUGE -2
C+++
      DURCH = RI(6)
C     INITIALISIERUNG
      JGR = 0
      IFLG = GFLG
C     IF (IABS(IFLG) .GT. 1) STOP ' BETRAG VON GFLG GROESSER 1 '
      IF (IFLG.GE.0) THEN
C
      GFLG = ZERO
      IS = IPS
C
C     WRITE(6,1006) (TE(I), I=1,3)
C     WRITE(6,1007) (TP(I,IS), I=1,3)
C
C      PRINT *, 'GOUGE1:STORE DATA(FLIPMX,RCSAV,TPSAV,....'
C+++
C+++  KORR  6-GOUGE -2 ENDE
C+++
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
      FLIPMX = FLIPCK
      FLIPAB = DABS(FLIPCK)
      RCSAV = RC(IS)
      SSAV = S(IS)
      ITSAV = ITSEG(IS)
      DO 2900 I=1,3
      TPSAV(I) = TP(I,IS)
      TNSAV(I) = TN(I,IS)
      SPSAV(I) = SP(I,IS)
      SNSAV(I) = SN(I,IS)
      U1SAV(I) = U1(I,IS)
      VTSAV(I) = VT(I,IS)
 2900 CONTINUE
C
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C+++
C+++  KORR  6-GOUGE -3
C+++
CKEINE PRUEFUNG WENN DP SCHON KLEIN
C---  IF (DP .LT. 0.5D0)  GOTO 106
      IF (DP .LT. 2.0D0)  GOTO 106
C
C
      CALL DOTF(ZAHL, TI, TALT)
C--T--WRITE(6,1003) ZAHL
C      PRINT *, 'GOUGE1 AUFRUF AJUNDD'
      DO 100 I=1,3
      TP(I,IS) = TE(I) + DURCH           * TI(I)
  100 CONTINUE
C--T--WRITE(6,1008) (TP(I,IS), I=1,3)
      MODESS = 11
      CALL AJUNDD
      MODESS = 0
C     VERLETZUNG DER OBERFLAECHE
      DO 101 I=1,3
      HILF(I) = SP(I,IS) - TP(I,IS)
  101 CONTINUE
      CALL DOTF(SHILF, HILF, HILF)
      SHILF = DSQRT(SHILF)
      CALL DOTF(HILF1, HILF, SN(1,IS))
      IF (HILF1 .GT. 0) SHILF = -SHILF
      IF (SHILF .GT. 0) GOTO 103
C---  IF (DABS(SHILF) .LT. 2.0D0*TAU(IS) ) GOTO 106
C   WARNUNG AUSGEBEN
      IF (DABS(SHILF) .LT.10.0D0*TAU(IS) ) GOTO 106
C--T--WRITE(6,7015)(TE(I),I=1,3)
 7015 FORMAT(' *** WARNUNG : TE = ', 3(D12.5, 2X),' TOOL SCHNEIDET '
     1,'FLAECHE')
      GOTO 106
C
C --- RESTORE DATA
C
  103 CONTINUE
C     KEIN LOOK AHEAD, WENN DP NICHT GROSS GENUG
      IF (DABS(SHILF) .GT. 2.0*TAU(IS)) GOTO 106
      IF (DP .LT. 2.0D0)  GOTO 106
C      PRINT *, 'GOUGE1 AUFRUF AJUNDD MIT LOOK AHEAD'
      DO 104 I=1,3
      TP(I,IS) = TE(I) +( DP+DURCH) * TI(I)
  104 CONTINUE
C--T--WRITE(6,1008) (TP(I,IS), I=1,3)
      MODESS = 11
      CALL AJUNDD
      MODESS = 0
C     VERLETZUNG DER OBERFLAECHE
      DO 105 I=1,3
      HILF(I) = SP(I,IS) - TP(I,IS)
  105 CONTINUE
      CALL DOTF(SHILF, HILF, HILF)
      SHILF = DSQRT(SHILF)
      CALL DOTF(HILF1, HILF, SN(1,IS))
      IF (HILF1 .GT. 0) SHILF = -SHILF
      IF (SHILF .GT. 0) GOTO 106
      IF (DABS(SHILF) .LT. 1.5D1*TAU(IS) ) GOTO 106
C--   IF (DABS(SHILF) .LT. 2.5D1*TAU(IS) ) GOTO 106
C ZUSAETZLICHES KRITERIUM
      GFLG  = 1.D0
      JGR = -1
C+++
C+++  KORR  6-GOUGE -3 ENDE
C+++
C++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
C
  106 CONTINUE
C      PRINT *, 'GOUGE1 RESTORE DATA , GFLG = ', GFLG
      RC(IS) = RCSAV
      S(IS) = SSAV
      ITSEG(IS) = ITSAV
      DO 2910 I=1,3
      TP(I,IS) = TPSAV(I)
      TN(I,IS) = TNSAV(I)
      SP(I,IS) = SPSAV(I)
      SN(I,IS) = SNSAV(I)
      U1(I,IS) = U1SAV(I)
      VT(I,IS) = VTSAV(I)
 2910 CONTINUE
C
      ELSE
        GFLG = ZERO
      ENDIF
C
 1000 FORMAT(' GOUGE1 : IGOUG = ', I1)
 1001 FORMAT(' GOUGE1 : IS = ',I3, ' IPS = ', I3, ' IDS = ',I3
     1      ,' RC(IPS) = ', D12.5, ' RC(IDS) = ', D12.5 )
 1002 FORMAT(' GOUGE1 : TI  = ', 3(D12.5),/
     1       ' GOUGE1: TIK = ', 3(D12.5),/
     2       ' GOUGE1: GFLG= ',   D12.5)
 1003 FORMAT(' GOUGE1: TI . TIK =', D12.5)
 1004 FORMAT(' GOUGE1: HALBER C.DURCHMESSER:TLLDAT,CUTDAT)',2(D12.5),2X)
 1006 FORMAT(' GOUGE1: TE =', 3(D12.5,2X))
 1007 FORMAT(' GOUGE1: TP =', 3(D12.5,2X))
 1008 FORMAT(' GOUGE1: TPNEU =', 3(D12.5,2X))
      END
**** SOURCE FILE : M0002754.V09   ***
*
C
C.....FORTRAN SUBROUTINE             INDIRP...              3/1/68   GK
      SUBROUTINE INDIRP(SRFC,PNT)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      CHARACTER*8 TEST
      INTEGER IHDS(2),BCDF
      EQUIVALENCE(IHDS,VALHDS)
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
      COMMON /HSAVE/ SAVEH(50)
      EQUIVALENCE (SAVEH(32),SRFACE),(SAVEH(33),POINT(1))
C
C     25. COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM/ IAERFG,NPCTPT,PCTPTS,PCTPLN,ERRPTS
      DIMENSION PCTPTS(3,20),PCTPLN(4),ERRPTS(3,3)
C
C...  NEW DIRECTION OF MOTION IS FROM PRESENT TOOL POSITION TO POINT
C...  STORE DIRECTION VECTORS FOR DS,PS,CS AS REQUIRED
      DIMENSION POINT(3)
      DIMENSION PNT(3)
C
      SRFACE=SRFC
C
      CALL TRANSM(POINT,PNT,2,3,0)
      IF(JHLDFG.EQ.0) GO TO 501
      ITABH(ITHCNT)=12
      ITHCNT=ITHCNT+1
      RETURN
C
  501 CONTINUE
C
      IF(IGOTO)1,1,2
    2 IF(ISRCH)40,40,1000
    1 TEMP(1)=SRFACE
    3 K=IDS
      CALL HOLFRM(TEMP(1),TEST,1,8,NWD)
      IF(HDS.EQ.TEST) GO TO 5
      K=IPS
      IF(HPS.EQ.TEST) GO TO 5
      K=ICS
      IF(HCS.NE.TEST) GO TO 50
    5 DO 10 I=1,3
      VNDIR(I,K)=POINT(I)-TE(I)
   10 CONTINUE
      CALL VNORM(VNDIR(1,K),VNDIR(1,K))
      IF(IER)25,25,20
   20 IAERFG=1
      CALL AERR(20901,'INDIRP  ')
      GO TO 45
   25 INDIR(K)=K1
C...  IF DS,TELL AMIND VNDIR IS ALREADY THE FORWARD DIRECTION
      IF(HDS.NE.TEST) GO TO 1000
   30 DO 35 I=1,3
      TI(I)=VNDIR(I,K)
      TEK(I)=TE(I)-TI(I)
   35 CONTINUE
 1000 CONTINUE
      RETURN
C...  DIRECTION OF MOTION GIVEN WITHOUT A STARTING POINT GIVEN
   40 IAERFG=1
      CALL AERR(20902,'INDIRP  ')
   45 IAERR=0
      GO TO 1000
C...  WARNING-CANNOT DETERMINE SURFACE TYPE. DS ASSUMED
   50 CALL AERR(-20903,'INDIRP  ')
      IHDS(1) = BCDF(HDS(1:4))
      IHDS(2) = BCDF(HDS(5:8))
      TEMP(1)=VALHDS
      GO TO 3
       END
C
C
C
      SUBROUTINE INDRPH(SRFC,PNT)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      CHARACTER*8 TEST
      INTEGER IHDS(2),BCDF
      EQUIVALENCE(IHDS,VALHDS)
      COMMON /HSAVE/ SAVEH(50)
      EQUIVALENCE (SAVEH(32),SRFACE),(SAVEH(33),POINT(1))
C
C     25. COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM/ IAERFG,NPCTPT,PCTPTS,PCTPLN,ERRPTS
      DIMENSION PCTPTS(3,20),PCTPLN(4),ERRPTS(3,3)
C
C...  NEW DIRECTION OF MOTION IS FROM PRESENT TOOL POSITION TO POINT
C...  STORE DIRECTION VECTORS FOR DS,PS,CS AS REQUIRED
      DIMENSION POINT(3)
      DIMENSION PNT(3)
C
C
C
      IF(IGOTO)1,1,2
    2 IF(ISRCH)40,40,1000
    1 TEMP(1)=SRFACE
    3 K=IDS
      CALL HOLFRM(TEMP(1),TEST,1,8,NWD)
      IF(HDS.EQ.TEST) GO TO 5
      K=IPS
      IF(HPS.EQ.TEST) GO TO 5
      K=ICS
      IF(HCS.NE.TEST) GO TO 50
    5 DO 10 I=1,3
      VNDIR(I,K)=POINT(I)-TE(I)
   10 CONTINUE
      CALL VNORM(VNDIR(1,K),VNDIR(1,K))
      IF(IER)25,25,20
   20 IAERFG=1
      CALL AERR(20901,'INDRPH  ')
      GO TO 45
   25 INDIR(K)=K1
C...  IF DS,TELL AMIND VNDIR IS ALREADY THE FORWARD DIRECTION
      IF(HDS.NE.TEST) GO TO 1000
   30 DO 35 I=1,3
      TI(I)=VNDIR(I,K)
      TEK(I)=TE(I)-TI(I)
   35 CONTINUE
 1000 CONTINUE
      RETURN
C...  DIRECTION OF MOTION GIVEN WITHOUT A STARTING POINT GIVEN
   40 IAERFG=1
      CALL AERR(20902,'INDRPH  ')
   45 IAERR=0
      GO TO 1000
C...  WARNING-CANNOT DETERMINE SURFACE TYPE. DS ASSUMED
   50 CALL AERR(-20903,'INDRPH  ')
      IHDS(1) = BCDF(HDS(1:4))
      IHDS(2) = BCDF(HDS(5:8))
      TEMP(1)=VALHDS
      GO TO 3
       END
**** SOURCE FILE : M0002758.V07   ***
*
C
C.....FORTRAN SUBROUTINE             INDIRV...              3/1/68   GK
      SUBROUTINE INDIRV(SRFC,VCT)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C...  25. COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM/ IAERFG
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
      COMMON /HSAVE/ SAVEH(50)
      EQUIVALENCE (SAVEH(28),SRFACE),(SAVEH(29),VECTOR(1))
      DIMENSION VCT(3)
C
      CHARACTER*8 TEST
      INTEGER IHDS(2),BCDF
      EQUIVALENCE (IHDS,VALHDS)
C
C
C
C...  NEW DIRECTION OF MOTION IS ALONG VECTOR
C...  STORE DIRECTION VECTORS FOR DS,PS,CS AS REQUIRED
      DIMENSION VECTOR(3)
      SRFACE=SRFC
C
      CALL TRANSM(VECTOR,VCT,3,3,0)
      IF(JHLDFG.EQ.0) GO TO 501
      ITABH(ITHCNT)=11
      ITHCNT=ITHCNT+1
      RETURN
  501 CONTINUE
      IF(IGOTO)1,1,2
    2 IF(ISRCH)40,40,1000
    1 TEMP(1)=SRFACE
    3 K=IDS
      CALL HOLFRM(TEMP(1),TEST,1,8,NWD)
      IF(HDS.EQ.TEST) GO TO 5
      K=IPS
      IF(HPS.EQ.TEST) GO TO 5
      K=ICS
      IF(HCS.NE.TEST) GO TO 50
    5 DO 10 I=1,3
      VNDIR(I,K)=VECTOR(I)
   10 CONTINUE
      CALL VNORM(VNDIR(1,K),VNDIR(1,K))
      IF(IER)25,25,20
   20 IAERFG=1
      CALL AERR(21001,'INDIRV  ')
      GO TO 45
   25 INDIR(K)=K1
C...  IF DS,TELL AMIND VNDIR IS ALREADY THE FORWARD DIRECTION
      IF(HDS.NE.TEST) GO TO 1000
   30 DO 35 I=1,3
      TI(I)=VNDIR(I,K)
      TEK(I)=TE(I)-TI(I)
   35 CONTINUE
 1000 CONTINUE
      RETURN
   40 IAERFG=1
      CALL AERR(21002,'INDIRV  ')
   45 IAERR=0
      GO TO 1000
   50 CALL AERR(-21003,'INDIRV  ')
      IHDS(1) = BCDF(HDS(1:4))
      IHDS(2) = BCDF(HDS(5:8))
      TEMP(1)=VALHDS
      GO TO 3
       END
C
C
C
      SUBROUTINE INDRVH(SRFC,VCT)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C...  25. COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM/ IAERFG
      COMMON /HSAVE/ SAVEH(50)
      EQUIVALENCE (SAVEH(28),SRFACE),(SAVEH(29),VECTOR(1))
      DIMENSION VCT(3)
C
      CHARACTER*8 TEST
      INTEGER IHDS(2),BCDF
      EQUIVALENCE (IHDS,VALHDS)
C
C
C
C...  NEW DIRECTION OF MOTION IS ALONG VECTOR
C...  STORE DIRECTION VECTORS FOR DS,PS,CS AS REQUIRED
      DIMENSION VECTOR(3)
C
      IF(IGOTO)1,1,2
    2 IF(ISRCH)40,40,1000
    1 TEMP(1)=SRFACE
    3 K=IDS
      CALL HOLFRM(TEMP(1),TEST,1,8,NWD)
      IF(HDS.EQ.TEST) GO TO 5
      K=IPS
      IF(HPS.EQ.TEST) GO TO 5
      K=ICS
      IF(HCS.NE.TEST) GO TO 50
    5 DO 10 I=1,3
      VNDIR(I,K)=VECTOR(I)
   10 CONTINUE
      CALL VNORM(VNDIR(1,K),VNDIR(1,K))
      IF(IER)25,25,20
   20 IAERFG=1
      CALL AERR(21001,'INDRVH  ')
      GO TO 45
   25 INDIR(K)=K1
C...  IF DS,TELL AMIND VNDIR IS ALREADY THE FORWARD DIRECTION
      IF(HDS.NE.TEST) GO TO 1000
   30 DO 35 I=1,3
      TI(I)=VNDIR(I,K)
      TEK(I)=TE(I)-TI(I)
   35 CONTINUE
 1000 CONTINUE
      RETURN
   40 IAERFG=1
      CALL AERR(21002,'INDRHV  ')
   45 IAERR=0
      GO TO 1000
   50 CALL AERR(-21003,'INDRVH  ')
      IHDS(1) = BCDF(HDS(1:4))
      IHDS(2) = BCDF(HDS(5:8))
      TEMP(1)=VALHDS
      GO TO 3
       END
**** SOURCE FILE : ISVCPY00.ORG   ***
*
      SUBROUTINE ISVCPY(I,J)
C
      INCLUDE 'ISV.INC'
C
      IAFL(J) = IAFL(I)
      ICANON(J) = ICANON(I)
      INDEX(J) = INDEX(I)
      INDIR(J) = INDIR(I)
      IOP(J) = IOP(I)
      IOPSET(J) = IOPSET(I)
      IPL(J) = IPL(I)
      ISFIDN(J) = ISFIDN(I)
      ISFTYP(J) = ISFTYP(I)
      ISIGCR(J) = ISIGCR(I)
      ISVFL(J) = ISVFL(I)
      ITLON(J) = ITLON(I)
      ITSEG(J) = ITSEG(I)
      IUNFL(J) = IUNFL(I)
      JENT(J) = JENT(I)
      JIOPS(J) = JIOPS(I)
      JTLFLG(J) = JTLFLG(I)
      JTN(J) = JTN(I)
      JU1(J) = JU1(I)
      LIMFL(J) = LIMFL(I)
      ITSEGK(J) = ITSEGK(I)
C
      RETURN
      END
**** SOURCE FILE : M0002840.V05   ***
*
CCCCCCCCC
C....    FORTRAN SUBROUTINE ....  LCLS             RC  4/70
C
      SUBROUTINE LCLS(U,V,SSP,DDERU,DDERV,MMODE)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C...CALLS TO PARCHK & FCN HAVE BEEN COMMENTED OUT AS THE PARSRF
C....FACILITY IS NOT PROVIDED.   24/9/86.   E.MCLELLAN.
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
      INCLUDE 'BLANKCOM.INC'
C
      DIMENSION SSP(3),DDERU(3),DDERV(3),R2(3),R3(3)
      DATA DD/0.0D0/
C
C  --------------------------------------------------------------~
C
      IF(MMODE.NE.1) GO TO 5
C      CALL PARCHK(CANON(IC),KER)
      IF(KER.EQ.1) CALL AERR(27003,'LCLS    ')
    5 CONTINUE
C------MM=1  DERIV CASE.  MM=0  NODER CASE.
 4000 MM=CANON(IC+3)
      IF(MM.EQ.0) GO TO 10
C      CALL FCN (CANON(IC),U,V,SSP,DDERU,DDERV,W1,W2,W3,W4,W5,W6)
      IF(MMODE.EQ.1) GO TO 1000
 2000 CONTINUE
      GO TO 60
C
   10 DINCX=0.0001
C------COMPUTE THE SURFACE POINT
C      CALL FCN (CANON(IC),U,V,SSP,DDERU,DDERV,W1,W2,W3,W4,W5,W6)
      IF(MMODE.EQ.1) GO TO 1000
 3000 CONTINUE
C------COMPUTE THE PARTIAL DERIVATIVE WITH RESPECT TO U
      U4=U+DINCX
C      CALL FCN (CANON(IC),U4,V,R3,DDERU,DDERV,W1,W2,W3,W4,W5,W6)
      U2=U-DINCX
C      CALL FCN (CANON(IC),U2,V,R2,DDERU,DDERV,W1,W2,W3,W4,W5,W6)
      DO 20 I=1,3
   20 DDERU(I)=(R3(I)-R2(I))/(2*DINCX)
C------COMPUTE THE PARTIAL WITH RESPECT TO V
      V1=V+DINCX
C      CALL FCN (CANON(IC),U,V1,R3,DDERV,DDERV,W1,W2,W3,W4,W5,W6)
      V2=V-DINCX
C      CALL FCN (CANON(IC),U,V2,R2,DDERV,DDERV,W1,W2,W3,W4,W5,W6)
      DO 30 I=1,3
   30 DDERV(I)=(R3(I)-R2(I))/(2*DINCX)
C
   60 CALL CROSS(DDERU(1),DDERV(1),SN(1,IS))
      CALL VNORM(SN(1,IS),SN(1,IS))
      IF(IER.EQ.1) CALL AERR(27002,'LCLS    ')
      RETURN
 1000 KKK=1
      IF(DDERU(1).EQ.DD.AND.DDERU(2).EQ.DD.AND.DDERU(3).EQ.DD.AND.
     C   DDERV(1).EQ.DD.AND.DDERV(2).EQ.DD.AND.DDERV(3).EQ.DD) KKK=0
      IF(MM.EQ.1.AND.KKK.EQ.1) GO TO 2000
      IF(MM.EQ.0.AND.KKK.EQ.0) GO TO 3000
      CALL AERR(-27001,'LCLS    ')
      CANON(IC+3)=KKK
      GO TO 4000
      END
**** SOURCE FILE : M0001137.V05   ***
*
 
 
 
C
C
C.....FORTRAN SUBROUTINES          MAXDP & MAXDPH            4/1/68   GK
C
C
      SUBROUTINE MAXDP(DCML,ELNGTH)
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
      INCLUDE 'FXCOR.INC'
C
C...  21. ADDCOM BLOCK
C
      COMMON/ADDCOM/ ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),  (ADDCOM( 2),CLNGTH),
     1            (ADDCOM(23),IBTFLG),  (ADDCOM(24),JLIN)
C
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
      COMMON /HSAVE/ SAVEH(50)
      EQUIVALENCE (SAVEH(26),DECMAL),(SAVEH(27),ELNGH)
C
      COMMON/MODESS/MODESS,MSSCHK,MSSARL
C
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
      CHARACTER*8 PPWORD
      INTEGER IPPWRD(2),BCDF
      DATA  PPWORD /'MAXDP '/
C
      DATA Z2,Z3,Z4,SMAL/2.D0,3.D0,4.D0,1.D-12/
C
      DECMAL=DCML
      ELNGH=ELNGTH
      IF(JHLDFG.EQ.0) GO TO 1
C             /-IF JHLDFG IS NOT ZERO, ARELEM IS SEARCHING FOR A CHECK
C             /-SURFACE.  INTERVENING COMMANDS NOT TO BE EXECUTED YET.
      ITABH(ITHCNT)=10
      ITHCNT=ITHCNT+1
      RETURN
            
    1 CONTINUE
C
C             /-SPECIAL FLAG FOR SS ARELEM MODE AND DEBUGGING LEVEL PRIN
C             /-MAXDP/-K,L WHERE -K IS -2 OR LESS AND IBUG=L
      IF(DECMAL.GT.-Z2) GO TO 200
C             /-SET SWITCH FOR SS SPECIAL ARELEM(ON FOR-2, OFF FOR -3)
      IF(DABS(DECMAL+Z2).LT.SMAL) MSSARL=1
      IF(DABS(DECMAL+Z3).LT.SMAL) MSSARL=0
C             /-SET VALUE OF IBUG FROM SECOND ARGUMENT IF DECMAL=-4
      IF(DABS(DECMAL+Z4).LT.SMAL) IBUG=ELNGH
C             /-OMIT WRITING A MAXDP RECORD FOR THESE CASES
      GO TO 100
C
  200 CONTINUE
      IPPWRD(1)=BCDF(PPWORD(1:4))
      IPPWRD(2)=BCDF(PPWORD(5:8))
C...  USE THIS MAXIMUM STEP IN ALL ARITHMETIC CALCULATIONS
      IF (ELNGH) 30,30,10
   10 ELMAX = ELNGH
      KK=2
   20 DPMAX = DECMAL
      GO TO 70
C
   30 KK=1
      IF (DECMAL) 50,40,20
   40 JLIN=0
      GO TO 70
C
C...     THE COMMAND MAXDP/-1 IS NOT IMPLEMENTED
   50 IF (DECMAL+1.) 60,70,40
   60 IF(DECMAL+1.1.GT.0.0) JLIN=1
C
   70 CALL APT299(KK,IPPWRD,1,DECMAL)
      IF (KK .EQ. 1) GO TO 100
      CALL APT299(1,ELNGH,0,0)
C
  100 RETURN
      END
C
C
C
C
C
C
C.....FORTRAN SUBROUTINE            MAXDPH...               4/1/68   GK
C
      SUBROUTINE MAXDPH(DCML,ELNGTH)
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
C
C...  21. ADDCOM BLOCK
C
      COMMON/ADDCOM/ ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),  (ADDCOM( 2),CLNGTH),
     1            (ADDCOM(23),IBTFLG),  (ADDCOM(24),JLIN)
C
      COMMON /HSAVE/ SAVEH(50)
      EQUIVALENCE (SAVEH(26),DECMAL),(SAVEH(27),ELNGH)
C
      COMMON/MODESS/MODESS,MSSCHK,MSSARL
C
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
      CHARACTER*8 PPWORD
      INTEGER IPPWRD(2),BCDF
      DATA  PPWORD /'MAXDP '/
C
      DATA Z2,Z3,Z4,SMAL/2.D0,3.D0,4.D0,1.D-12/
C
C
C             /-SPECIAL FLAG FOR SS ARELEM MODE AND DEBUGGING LEVEL PRIN
C             /-MAXDP/-K,L WHERE -K IS -2 OR LESS AND IBUG=L
      IF(DECMAL.GT.-Z2) GO TO 200
C             /-SET SWITCH FOR SS SPECIAL ARELEM(ON FOR-2, OFF FOR -3)
      IF(DABS(DECMAL+Z2).LT.SMAL) MSSARL=1
      IF(DABS(DECMAL+Z3).LT.SMAL) MSSARL=0
C             /-SET VALUE OF IBUG FROM SECOND ARGUMENT IF DECMAL=-4
      IF(DABS(DECMAL+Z4).LT.SMAL) IBUG=ELNGH
C             /-OMIT WRITING A MAXDP RECORD FOR THESE CASES
      GO TO 100
C
  200 CONTINUE
      IPPWRD(1)=BCDF(PPWORD(1:4))
      IPPWRD(2)=BCDF(PPWORD(5:8))
C...  USE THIS MAXIMUM STEP IN ALL ARITHMETIC CALCULATIONS
      IF (ELNGH) 30,30,10
   10 ELMAX = ELNGH
      KK=2
   20 DPMAX = DECMAL
      GO TO 70
C
   30 KK=1
      IF (DECMAL) 50,40,20
   40 JLIN=0
      GO TO 70
C
C...     THE COMMAND MAXDP/-1 IS NOT IMPLEMENTED
   50 IF (DECMAL+1.) 60,70,40
   60 IF(DECMAL+1.1.GT.0.0) JLIN=1
C
   70 CALL APT299(KK,IPPWRD,1,DECMAL)
      IF (KK .EQ. 1) GO TO 100
      CALL APT299(1,ELNGH,0,0)
C
  100 RETURN
      END
**** SOURCE FILE : M0001497.V03   ***
*
C.....FORTRAN SUBROUTINE                MULTAX...            8/1/68  AR
      SUBROUTINE MULTAX(DONOFF)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'IFXCOR.INC'
C
C
      CHARACTER DOFF*4,TEST*4
      INTEGER BCDF,PPWORD(2)
      DATA  DOFF/'OFF '/
C
C
C...  ALL CUTTER CENTERS WILL BE OUTPUT WITH TOOL AXIS VECTORS
C IF DONOFF .NE. 'OFF'
      PPWORD(1) = BCDF('MULT')
      PPWORD(2) = BCDF('AX  ')
C
      CALL APT299(1,PPWORD,2,DONOFF)
      MULOUT=1
      CALL HOLFRM(DONOFF,TEST,1,4,NWD)
      IF(TEST.EQ.DOFF) MULOUT=0
      RETURN
       END
**** SOURCE FILE : M0000937.V02   ***
*
C.....FORTRAN SUBROUTINE             NOPS....               4/1/68   GK
      SUBROUTINE NOPS
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
      IF(IAERR.NE.0)GO TO 10
C...  NO PS IS TO BE USED FOR THE STARTUP
      INOPS=K1
      IAUTPS = 0
      JENT(IPS) = K1
   10 RETURN
       END
**** SOURCE FILE : M0000940.V04   ***
*
C.....FORTRAN SUBROUTINE             NUMPTS...              3/1/68   GK
      SUBROUTINE NUMPTS(XNUMBR)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'IFXCOR.INC'
C
      INTEGER IPPWRD(2),BCDF
      CHARACTER*8 PPWORD
      DATA  PPWORD /'NUMPTS'/
C
C
C
C...  USE THIS AS THE MAXIMUM NUMBER OF CUTTER CENTERS ON ONE
C...  ELEMENTARY CUT SEQUENCE
      IPPWRD(1)=BCDF(PPWORD(1:4))
      IPPWRD(2)=BCDF(PPWORD(5:8))
      CALL APT299(1,IPPWRD,1,XNUMBR)
      NMPNTS=XNUMBR
      RETURN
       END
**** SOURCE FILE : M0000647.V01   ***
*
C
      SUBROUTINE PARLND(P,R,A,B,C,T,S,MODE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C-- MODULAR   PURPOSE IS TO COMPUTE THE CLOSEST APPROACH BETWEEN A
C--  PARABOLA IN SPACE AND A SPACE POINT, LINE OR HALF RAY.
C--  INPUT' POINT P AND TOOL RAY R( BOTH VECTORS)
C--          VECTOR COEFFICIENTS OF PARABOLA A,B AND C (EQUATION IS
C--            ( A+ B*S +C*S**2 )
C--          CONTROL VARIABLE  IS MODE.  =-1 MEANS SHORTEST
C--          DISTANCE FROM FULL LINE,  =0 MEANS SHORTEST DISTANCE
C--          FROM POINT AND =1 MEANS SHORTEST DISTANCE FROM HALF LINE.
C--
C--  OUTPUT'  NUMBERS T(FOR LINE) AND S(FOR PARABOLA) WHICH GENERATE THE
C--           SOLUTION POINTS ON THE TOOL RAY(P+T*R) AND CURVE(A+
C--           B*S+C*S**2) RESPECTIVELY.
      DIMENSION P(3),R(3),A(3),B(3),C(3),Z(3)
      D1=A(1)-P(1)
      D2=A(2)-P(2)
      D3=A(3)-P(3)
      DB=D1*B(1)+D2*B(2)+D3*B(3)
      BSQ=B(1)*B(1)+B(2)*B(2)+B(3)*B(3)
      DC=D1*C(1)+D2*C(2)+D3*C(3)
      BC=B(1)*C(1)+B(2)*C(2)+B(3)*C(3)
      CSQ=C(1)*C(1)+C(2)*C(2)+C(3)*C(3)
      DSQ=D1*D1+D2*D2+D3*D3
      X1=DB
      X2=BSQ+DC+DC
      X3=3.0*BC
      X4=CSQ+CSQ
      IF(MODE) 20,30,20
   20 RSQ=R(1)*R(1)+R(2)*R(2)+R(3)*R(3)
      BR=B(1)*R(1)+B(2)*R(2)+B(3)*R(3)
      CR=C(1)*R(1)+C(2)*R(2)+C(3)*R(3)
      DR=D1*R(1)+D2*R(2)+D3*R(3)
      X1=X1-DR*BR/RSQ
      X2=X2-(BR*BR+2.0*DR*CR)/RSQ
      X3=X3-3.0*BR*CR/RSQ
      X4=X4-2.0*CR*CR/RSQ
   30 CONTINUE
      CALL GCUBIC(X4,X3,X2,X1,Z,NZ)
      IF(NZ.GT.1) GO TO 40
      S=Z(1)
      T=0
      IF(MODE.EQ.0) RETURN
      T=(DR+S*(BR+S*CR))/RSQ
      RETURN
   40 IF(MODE) 100,200,100
  100 DST=99999999.0
      DO 110 I=1,NZ
      SCUR=Z(I)
      TCUR=(DR+SCUR*(BR+SCUR*CR))/RSQ
      IF(TCUR.LT.0.0.AND.MODE.EQ.1) GO TO 110
C-----X1=DSQ+SCUR*(DB+DB+SCUR*(DC+DC+BSQ+SCUR*(BC+BC+SCUR*CSQ)))
C-----X2=DR+SCUR*(BR+SCUR*CR)
C-----TEMP=X1-TCUR*(X2+X2-TCUR*RSQ)
      TEMP=1.0-SCUR
      TEMP=DABS(TEMP)
C------  DISRCIMINATE AGAINST A NEGATIVE SCUR
      IF(SCUR.LT.0) TEMP=10*TEMP
      IF(TEMP.GT.DST) GO TO 110
      DST=TEMP
      S=SCUR
      T=TCUR
  110 CONTINUE
      RETURN
  200 DST=9999999.0
      DO 210 I=1,NZ
      SCUR=Z(I)
      TEMP=DSQ+SCUR*(DB+DB+SCUR*(DC+DC+BSQ+SCUR*(BC+BC+SCUR*CSQ)))
      IF(TEMP.GT.DST) GO TO 210
      DST=TEMP
      S=SCUR
  210 CONTINUE
      T=0
      RETURN
      END
**** SOURCE FILE : M0002852.V04   ***
*
C.....FORTRAN SUBROUTINE  ....PLANE          8/68                    PH
C.....FORTRAN SUBROUTINE             PLANE....              4/1/68   GK
      SUBROUTINE PLANE
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C...  21. ADDCOM BLOCK
C
      COMMON/ADDCOM/ ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM( 1),ELMAX ),  (ADDCOM( 2),CLNGTH),
     1            (ADDCOM(23),IBTFLG),  (ADDCOM(24),JLIN)
C
C
C
      DATA ZLIT1/3.5D0/
C
      J = IDS
      IF (IFL4(IS)) 3,4,3
    3 J = IPS
    4 DO 41 I = 1,3
      TP(I,J) = TP(I,J) + CMOVE(I)
      SP(I,J) = SP(I,J) + CMOVE(I)
   41 CONTINUE
    9 CALL CHECK
      IF(IAERR)16,91,16
   91 IF(JCKR)1,14,1
    1 CALL CENTR
      IF(IAERR)16,92,16
   92 IF(JCR)2,10,11
    2 CALL AERR(-24401,'PLANE   ')
      ISFTYP(IS) = 99
      GO TO 15
   12 J21(IS)=K1
      JPR = -K2
      TE(1)=TEL(1)
      TE(2)=TEL(2)
      TE(3)=TEL(3)
      S(IS)=Z3*DP
      IF (ICSCNT - K1) 16,16,30
   30 STCK(IS)=Z1E6
      DP=DPMAX
      S(IS)=ZLIT1*DP
      CSD(IS)=Z11EM1*DP
      GO TO 16
   10 CALL AERR (24402,'PLANE   ')
      GO TO 16
   11 IF((TE(1)-TEK(1))*TI(1)+(TE(2)-TEK(2))*TI(2)+(TE(3)-TEK(3)
     1)*TI(3))12,13,13
   13 IF(JCR-K1)21,20,21
   21 JPR=KM1
      GO TO 16
   20 JPR=K1
      GO TO 16
   14 NUMPT1=NUMPT1-K1
      CLNGTH = CLNGTH + DPMAX
      IF (ELMAX - CLNGTH) 19,19,18
   19 CALL AERR(24404,'PLANE   ')
   18 IF (NUMPT1 - K1) 15,17,15
   15 JPR=0
   16 CONTINUE
      RETURN
   17 CALL AERR (24403,'PLANE   ')
      GO TO 16
       END
**** SOURCE FILE : M0002779.V09   ***
*
C
C
C.....FORTRAN SUBROUTINE           POCKET        2/69      SR,RL
      SUBROUTINE POCKET(RADF,OFSC,OFSF,FRONE,FRTWO,FRTHRE,
     C   OVRD,PTYP,NCOR,CRR)
      IMPLICIT DOUBLE PRECISION (A-H), DOUBLE PRECISION (O-Z)
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR5.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C...            SYSTEM I/O FILE NAMES
C
      INCLUDE 'SYMFIL.INC'
C
      INCLUDE 'BLANKCOM.INC'
C
      DOUBLE PRECISION SRF(4)
      EQUIVALENCE (COM(1),SRF(1))
C
C...  DIMENSION FOR POCKET
      DIMENSION XI(3,22),Q(3,21),U(3,21),W(3,20),BL(20),QQ(63),WW(60),
     1XIPRIM(3,21),VPRIM(3,20),UPRIM(3,20),T(3),WD(3),Y(3),PTINT(3),
     2CTEMP(3,20),CROSTO(3),UCRSTO(3),TCRSTO(3),KTAB(20),COR(3,20)
      DIMENSION CRR(3,20)
      EQUIVALENCE (Q(1,1),QQ(1)),(W(1,1),WW(1))
      DIMENSION KCLDAT(10)
      DIMENSION E(3),F(3)
      INTEGER BCDF,IPOCKT(2),IFDRT(2)
      LOGICAL FIRST
      SAVE FIRST,KCLDAT,IPOCKT,IFDRT
      EQUIVALENCE (HPOCKT,IPOCKT(1)),(HFDRT,IFDRT(1))
      INTEGER Z4E
      PARAMETER (Z4E=1308622848)
      LOGICAL SR1,SR2,SR3,SR4,SR5
      LOGICAL CKDEF
      LOGICAL  FPTFLG
      LOGICAL  FPFLG
      DATA KCLDAT /0,0,Z4E,0,Z4E,2,
     C   Z4E,1,0,0/
      DATA FIRST/.TRUE./
      DATA Z5EM4, Z5EM3, Z1EM4 / 5.D-4, 5.D-3, 1.D-4 /
C
      CALL TAPOP(POFILE,-1)
      RADEFF=RADF
      OFSETC=OFSC
      OFSETF=OFSF
      OVRIDE=OVRD
      PTTYPE=PTYP
      NC=NCOR
      IF (FIRST)THEN
        KCLDAT(1) = BCDF('CLDA')
        KCLDAT(2) = BCDF('TA  ')
        KCLDAT(9) = BCDF('GOTO')
        KCLDAT(10) = BCDF('    ')
        IPOCKT(1) = BCDF('POCK')
        IPOCKT(2) = BCDF('ET  ')
        IFDRT(1) = BCDF('FEDR')
        IFDRT(2) = BCDF('AT  ')
        FIRST =.FALSE.
      ENDIF
C...WRITE POCKET HEADER RECORD
      CALL APT299(K0,HPOCKT,K0,K0)
      NCORIG=NC
      CUTRAD=CUTDAT(1)
      SR1=.FALSE.
      SR2=.FALSE.
      SR3=.FALSE.
      SR4=.FALSE.
      SR5=.FALSE.
      NWD=1
      DO 4 I=1,NCOR
      IF(CKDEF(CRR(1,I))) GO TO 5
    4 CONTINUE
      GO TO 4002
C   AN INPUT POINT IS UNDEFINED
    5 CALL ERROR(3506)
      GO TO 993
 4002 IF(PTTYPE.LT.1.1) GO TO 4003
      PTTYPE = PTTYPE - 2.0
      DO 4001 I=1,NCOR
      TEMPD = TA(1)*SRF(1)+TA(2)*SRF(2)+TA(3)*SRF(3)
      RMDA = SRF(4)-(CRR(1,I)*SRF(1)+CRR(2,I)*SRF(2)+CRR(3,I)*SRF(3))
      IF(DABS(TEMPD).LT.Z1EM4) GO TO 50
      RMDA = RMDA/TEMPD
      COR(1,I) = CRR(1,I)+RMDA*TA(1)
      COR(2,I) = CRR(2,I) + RMDA*TA(2)
      COR(3,I) = CRR(3,I) + RMDA*TA(3)
 4001 CONTINUE
      GO TO 6
 4003 DO 4004 I=1,NCOR
      COR(1,I) = CRR(1,I)
      COR(2,I) = CRR(2,I)
 4004 COR(3,I) = CRR(3,I)
    6 IF(RADEFF) 1903,1903,2903
 1903 RADEFF = Z5EM1*OFSETC*CUTRAD
 2903 KALC = K0
      MOVE = K1
      INIT = K1
      DELDST=Z0
      GO TO 1904
  904 NC=NCUTBK
      PTTYPE=Z0
 1904 DO 905 J=1,NC
      DO 905 I=1,3
  905 XI(I,J+1)=COR(I,J)
      DO 906 I=1,3
      XI(I,1)=COR(I,NC)
  906 XI(I,NC+2)=COR(I,1)
      NPLUS1=NC+1
      NLESS1=NC-1
      DO 908 J=1,NPLUS1
      ADDEM1=Z0
      DO 907 I=1,3
      Q(I,J)=XI(I,J+1)-XI(I,J)
  907 ADDEM1=(Q(I,J))**2+ADDEM1
      DO 908 I=1,3
  908 U(I,J)=Q(I,J)/DSQRT(ADDEM1)
      IF(INIT)9907,9907,1907
 1907 CONTINUE
      DO 2906 J=1,NC
      DO 1906 I=1,3
      IF(DABS(XI(I,J)-COR(I,J))-Z5EM4)1906,1906,2906
 1906 CONTINUE
      CALL AERR(3501,'POCKET  ')
 2906 CONTINUE
      DO 4906 J=1,NC
      DO 3906 I=1,3
      IF(DABS(U(I,J+1)-U(I,J))-Z5EM4)3906,3906,4906
 3906 CONTINUE
      CALL AERR(3502,'POCKET  ')
 4906 CONTINUE
      ICRSTO=K1
      DO 6907 J=1,NC
      CROSTO(1)=-U(1,J)
      CROSTO(2)=-U(2,J)
      CROSTO(3)=-U(3,J)
      CALL CROSS(CROSTO ,U(1,J+1),CROSTO)
      CALL VNORM(CROSTO,UCRSTO)
      IF(ICRSTO) 4907,4907,2907
 2907 DO 3907 I=1,3
 3907 TCRSTO(I)=UCRSTO(I)
      ICRSTO=K0
      GO TO 6907
 4907 DO 5907 I=1,3
      IF(DABS(UCRSTO(I)-TCRSTO(I))-Z5EM4)5907,5907,7907
 5907 CONTINUE
 6907 CONTINUE
C...  ADJUST POCKET VERTICES IF POCKET BOTTOM IS CANTED
C      WITH RESPECT TO TOOL AXIS AND VERTICIES DESCRIBE ACTUAL
C     POCKET BOUNDARIES.
      X1=DABS(TA(1)*TCRSTO(1)+TA(2)*TCRSTO(2)
     1  +TA(3)*TCRSTO(3))
      IF(X1-.2D0)50,50,55
   50 CALL AERR(3507,'POCKET  ')
   55 IF(X1-.9999D0)65,60,60
   60 INIT=-K1
   65 IF(INIT)9907,60,70
   70 IF(PTTYPE)50,60,75
  75  INIT=K0
      PTTYPE=Z0
      DO 200 J=1,NC
      ADDEM1 = TA(1)*U(1,J)+TA(2)*U(2,J)+TA(3)*U(3,J)
      ADDEM2 =     TA(1)*U(1,J+1)+    TA(2)*U(2,J+1)+    TA(3)*U(3,J+1)
      DO 100 I=1,3
      QQ(I)=U(I,J)-TA(I)*ADDEM1
  100 WW(I)=U(I,J+1)-TA(I)*ADDEM2
      CALL VNORM(QQ,QQ)
      CALL VNORM(WW,WW)
      T(1)=WW(1)-QQ(1)
      T(2)=WW(2)-QQ(2)
      T(3)=WW(3)-QQ(3)
      CALL VNORM(T,T)
      ALPHA=DSQRT(CUTRAD**2/(1.-(T(1)*WW(1)+T(2)*WW(2)+T(3)*WW(3))**2))
      Y(1) = ALPHA*T(1)
      Y(2) = ALPHA*T(2)
      Y(3) = ALPHA*T(3)
      ALPHA = Y(1)*TCRSTO(1)+Y(2)*TCRSTO(2)+Y(3)*TCRSTO(3)
      DO 200 I=1,3
  200 COR(I,J)=COR(I,J)+Y(I)-ALPHA*TA(I)/X1
      GO TO 1904
 7907 DO 5906 I=1,3
      IF(DABS(DABS(UCRSTO(I))-DABS(TCRSTO(I)))-Z5EM4)5906,5906,6906
 5906 CONTINUE
      CALL AERR(3504,'POCKET  ')
 6906 CALL AERR(3503,'POCKET  ')
 9907 IF(OVRIDE) 909,1908,909
 1908 SPHIO2=Z1
      DO 4908 J=1,NC
      ADDEM1=Z0
      DO 2908 I=1,3
 2908 ADDEM1=-U(I,J)*U(I,J+1)+ADDEM1
      DUMMY=DSQRT((Z1-ADDEM1)/Z2)
      IF(DUMMY-SPHIO2) 3908,4908,4908
 3908 SPHIO2=DUMMY
 4908 CONTINUE
      DUMMY=RADEFF/CUTRAD*(Z1+SPHIO2)
      IF(OFSETC-DUMMY) 6908,6908,5908
 5908 OFSETC=DUMMY
 6908 IF(OFSETF-DUMMY) 8908,8908,7908
 7908 OFSETF=DUMMY
 8908 IF(.NOT.SR5) GO TO 909
      SR5 = .FALSE.
 9908 OFCSTO=OFSETC
      OFFSTO=OFSETF
      DUMMY=Z2*RADEFF/CUTRAD*SPHIO2
      IF(OFSETC-DUMMY) 4909,4909,2909
 2909 OFSETC=DUMMY
      IF(OFSETF-DUMMY) 4909,4909,3909
 3909 OFSETF=DUMMY
 4909 SR5=.TRUE.
  909 DO 911  J=1,NC
      DO 1909 I=1,3
 1909 W(I,J)=U(I,J+1)-U(I,J)
      ADDEM1=Z0
      ADDEM2=Z0
      DO 910 I=1,3
      ADDEM1=W(I,J)*U(I,J+1)+ADDEM1
  910 ADDEM2=W(I,J)*W(I,J)+ADDEM2
  911 BL(J)=DSQRT(ADDEM2-ADDEM1**2)
      DIST=PTTYPE*CUTRAD
      GO TO 4915
  912 MOVE=K2
      GO TO 1913
  913 MOVE=K3
 1913 DELDST=Z5EM1*OFSETF*CUTRAD
      GO TO 2914
  914 MOVE=K4
 1914 DELDST=Z5EM1*OFSETC*CUTRAD
 2914 DIST=DIST+DELDST
  915 IF(KALC) 1915,1915,2915
 1915 KALC=K1
      GO TO 3915
 2915 KALC=K0
C     EXIT IF ZERO DIAM. CUTTER
 3915  IF(CUTRAD) 987,987,3916
 3916 IF (.NOT. SR5) GO TO 4915
 5915 OFSETC=OFCSTO
      OFSETF=OFFSTO
 4915 DO 916 J=1,NC
      DO 916 I=1,3
  916 XIPRIM(I,J)=COR(I,J)+DIST/BL(J)*W(I,J)
      DO 917 I=1,3
  917 XIPRIM(I,NC+1)=XIPRIM(I,1)
      DO 919 J=1,NC
      ADDEM1=Z0
      DO 918 I=1,3
      VPRIM(I,J)=XIPRIM(I,J+1)-XIPRIM(I,J)
  918 ADDEM1=(VPRIM(I,J))**2+ADDEM1
      DO 919 I=1,3
  919 UPRIM(I,J)=VPRIM(I,J)/DSQRT(ADDEM1)
C     COLLAPSE TESTS
  920 DO 7260 J=1,NC
      KTAB(J) = K0
      DO 7260 I=1,3
      IF(DABS(U(I,J+1)-UPRIM(I,J))-Z5EM3)7260,7260,7250
 7250 KTAB(J) = K1
 7260 CONTINUE
 7270 NCUTBK = NC
      KUTBAC = K0
      KOLAPS = K0
      PHITMP=Z1
      DO 942 J=1,NC
      IF(KTAB(J)) 921,921,934
  921 IF (.NOT. SR2 )  GO TO 927
      SR2 = .FALSE.
  922  IF (KUTBAC-J+1)924,923,924
  923 JSAVE=J
      KOLAPS=K0
      GO TO 942
  924 INTER=K1
      KONE=J-KOLAPS-1
      KTWO=J
      GO TO 1940
  925 DO 926 I=1,3
      JDUMMY=J-KUTBAC
  926 CTEMP(I,JDUMMY)=PTINT(I)
      KOLAPS=K0
      GO TO 929
  927 DO 928 I=1,3
      JDUMMY=J-KUTBAC
  928 CTEMP(I,JDUMMY)=XIPRIM(I,J)
  929 IF(J-NC) 942,930,930
  930 IF ( .NOT. SR3 )  GO TO 942
      SR3 = .FALSE.
  931 INTER=K2
      KONE = J
      KTWO = JSAVE
      GO TO 1940
  932 DO 933 I=1,3
  933 CTEMP(I,1)=PTINT(I)
      GO TO 942
  934 NCUTBK=NCUTBK-1
      KUTBAC=KUTBAC+1
      KOLAPS=KOLAPS+1
      SR2=.TRUE.
      IF(J-1) 935,935,936
  935 SR3=.TRUE.
      GO TO 942
  936 IF(J-NC) 942,1936,1936
 1936 IF(MOVE.EQ.1.AND.NCUTBK.LE.2) CALL AERR(3510,'POCKET  ')
      IF(NCUTBK-2) 2936,2936,937
 2936 MOVE=K5
      IF(KALC) 3936,3936,982
  937 IF ( .NOT. SR3 )  GO TO 940
      SR3 = .FALSE.
  938 KTWO = JSAVE
  939 INTER=K2
      KONE = J-KOLAPS
      GO TO 1940
  940 KTWO=K1
      GO TO 939
C...  CALCULATE INTERSECTION OF NON-COLLAPSING SIDES
 1940  ITEST=K1
       KT1=KONE
       KT2=KTWO
 2040  COSVA=  UPRIM(1,KT1)*UPRIM(1,KT2) +
     1         UPRIM(2,KT1)*UPRIM(2,KT2) +
     2         UPRIM(3,KT1)*UPRIM(3,KT2)
      ADDEM2=DSQRT(DABS((Z1+COSVA)/Z2))
      IF(ADDEM2-PHITMP) 2060,2080,2080
 2060 PHITMP = ADDEM2
 2080 SIN2VA=Z1-COSVA**2
      IF(SIN2VA-Z1EM4) 2140,2140,2340
C...  SIDES ARE NEARLY PARALLEL - TAKE AVERAGE OF TWO VERTICES
 2140 DO 2240 L=1,3
 2240 PTINT(L)=(XIPRIM(L,KONE+1)+ XIPRIM(L,KTWO))/Z2
      GO TO 8941
C...  SIDES INTERSECT - COMPUTE INTERSECTION
 2340 ALPHA=Z0
      DO 2440 L=1,3
 2440 ALPHA = ALPHA + (XIPRIM(L,KT2)-XIPRIM(L,KT1))*
     1                (UPRIM(L,KT1)-UPRIM(L,KT2)*COSVA)
      ALPHA = ALPHA/SIN2VA
      ADDEM1=Z0
      DO 2540 L=1,3
 2540 ADDEM1 = ADDEM1 + (XIPRIM(L,KT1+1)-XIPRIM(L,KT1))**2
      ADDEM1 = DSQRT(ADDEM1)
      GO TO (2640,2740,3040,3340,3540,3840), ITEST
 2640 IF(ALPHA) 2650,2140,3140
 2650 KT1 = KT1-K1
      IF(KT1) 2680,2680,2660
 2660 IF(KTAB(KT1)) 2670,2670,2650
 2670 ITEST = K2
      GO TO 2040
 2680 KT1 = NC
 2690 IF(KTAB(KT1)) 2670,2670,2700
 2700 KT1 = KT1-K1
      IF(KT1-KT2) 2140,2140,2690
 2740 IF(ALPHA) 2140,2140,2840
 2840 IF(ALPHA-ADDEM1) 2940,2940,2140
 2940 KT2 = KT1
      KT1 = KTWO
      ITEST=K3
      GO TO 2340
 3040 IF(ALPHA) 2140,2140,3050
 3050 IF(ALPHA-ADDEM1) 3060,3060,2140
C...  SIDE OUTSIDE POLYGON-PLACE SIDE IN COLLAPSE CONDITION
 3060 KTAB(KONE) = K1
      GO TO 3870
 3140 IF(ALPHA-ADDEM1) 3240,2140,2140
 3240 KT1 = KTWO
      KT2 = KONE
      ITEST = K4
      GO TO 2340
 3340 IF(ALPHA) 2140,2140,3350
 3350 IF(ALPHA-ADDEM1) 5940,5940,3440
 3440 KT1 = KT2
      KT2 = KTWO
 3450 KT2 = KT2+K1
      IF(KT2-NC) 3460,3460,3480
 3460 IF(KTAB(KT2)) 3470,3470,3450
 3470 ITEST = K5
      GO TO 2040
 3480 KT2 = K1
 3490 IF(KTAB(KT2)) 3470,3470,3510
 3510 KT2 = KT2+K1
      IF(KT2-KT1-K1) 3490,2140,2140
 3540 IF(ALPHA) 2140,2140,3640
 3640 IF(ALPHA-ADDEM1) 3740,3740,2140
 3740 KT1 = KT2
      KT2 = KONE
      ITEST = K6
      GO TO 2340
 3840 IF(ALPHA) 2140,2140,3850
 3850 IF(ALPHA-ADDEM1) 3860,3860,2140
C...  SIDE OUTSIDE POLYGON-PLACE SIDE IN COLLAPSE CONDITION
 3860 KTAB(KTWO) = K1
 3870 SR2 = .FALSE.
 3880 SR3 = .FALSE.
      GO TO 7270
 5940 DO 6040 L=1,3
 6040 PTINT(L) = XIPRIM(L,KT1)+ALPHA*UPRIM(L,KT1)
 8941 GO TO (925,932),INTER
  942 CONTINUE
      IF(NC-NCUTBK) 944,944,1942
 1942 IF(KALC) 8942,2942,8942
 2942 IF(OVRIDE) 3942,5942,3942
 8942 IF(OVRIDE) 3942,9941,3942
 9941 SR5=.TRUE.
 3942 DO 4942 J=1,NCUTBK
      DO 4942 I=1,3
 4942 COR(I,J)=CTEMP(I,J)
      GO TO 904
 5942 IF ( .NOT. SR5 ) GO TO 6942
      SR5 = .FALSE.
  943 IF ( .NOT. SR4 )  GO TO 6942
      SR4 = .FALSE.
      GO TO 3942
 6942 IF(PHITMP-SPHIO2) 7942,3942,3942
 7942 SPHIO2=PHITMP
      DUMMY=RADEFF/CUTRAD*(Z1+SPHIO2)
      IF(OFSETC-DUMMY) 2943,2943,9942
 9942 OFCSTO=DUMMY
      IF(OFSETF-DUMMY) 3943,3943,1943
 1943 OFFSTO=DUMMY
      GO TO 4943
 2943 OFCSTO=OFSETC
 3943 OFFSTO=OFSETF
 4943 DUMMY=Z2*RADEFF/CUTRAD*SPHIO2
      IF(OFSETC-DUMMY) 3942,3942,5943
 5943 OFSETC=DUMMY
      IF(OFSETF-DUMMY) 7943,7943,6943
 6943 OFSETF=DUMMY
 7943 SR5=.TRUE.
      SR4=.TRUE.
      DIST=DIST-DELDST
      KALC=K1
      GO TO (2915,1913,1913,1914,1914),MOVE
  944 IF(KALC) 946,945,946
  945 SR1=.FALSE.
      SR2=.FALSE.
      SR3=.FALSE.
      SR4=.FALSE.
      SR5=.FALSE.
C     COVERAGE TESTS
  946 RTEST=Z2*RADEFF
      KOVER=K2
      GO TO 949
  947 RTEST=RADEFF
      KOVER=K1
  949 DO 968 J=1,NC
      DO 965 L=2,NLESS1
      K=J+L
      IF(K-NC) 951,951,950
  950 K=K-NC
  951 GO TO (952,954),KOVER
  952 DO 953 I=1,3
  953 Y(I)=XIPRIM(I,K)-XIPRIM(I,J+1)
  954 DO 955 I=1,3
  955 T(I)=XIPRIM(I,K)-XIPRIM(I,J)
      ADDEM1=Z0
      ADDEM2=Z0
      DO 956 I=1,3
      ADDEM1=T(I)*UPRIM(I,J)+ADDEM1
  956 ADDEM2=T(I)*T(I)+ADDEM2
      DCOV=DSQRT(ADDEM2-ADDEM1**2)
      IF(DCOV-RTEST) 957,957,968
  957 GO TO (958,965),KOVER
  958 ADDEM1=Z0
      DO 959 I=1,3
  959 ADDEM1=Y(I)*(-UPRIM(I,J))+ADDEM1
      IF(ADDEM1) 960,965,962
  960 ADDEM1=Z0
      DO 961 I=1,3
  961 ADDEM1=Y(I)*Y(I)+ADDEM1
      ADDEM2=DSQRT(ADDEM1)
      IF(ADDEM2-RTEST) 965,965,968
  962 ADDEM1=Z0
      DO 963 I=1,3
  963 ADDEM1=T(I)*UPRIM(I,J)+ADDEM1
      IF(ADDEM1) 964,965,965
  964 ADDEM1=DSQRT(ADDEM2)
      IF(ADDEM1-RTEST) 965,965,968
  965 CONTINUE
      MOVE=K5
      GO TO (969,967),KOVER
  967 IF(KALC) 980,980,947
  968 CONTINUE
      GO TO (980,1968),KOVER
 1968 IF(KALC) 980,980,982
  969 ADDEM1=Z0
      ADDEM2=Z0
      DO 970 I=1,3
      ADDEM1=(XIPRIM(I,J)-XIPRIM(I,1))**2+ADDEM1
  970 ADDEM2=(XIPRIM(I,J+1)-XIPRIM(I,1))**2+ADDEM2
      IF(DSQRT(DABS(ADDEM1))-DSQRT(DABS(ADDEM2))) 971,971,974
  971 DO 972 I=1,3
      WD(I)=XIPRIM(I,J)
  972 XIPRIM(I,1)=XIPRIM(I,J+1)
  973 J=K2
      NUM=K2
      GO TO 985
  974 DO 975 I=1,3
      WD(I)=XIPRIM(I,J+1)
  975 XIPRIM(I,1)=XIPRIM(I,J)
      GO TO 973
 3936 DO 4937 J=1,NC
      DO 4936 I=1,3
 4936 XIPRIM(I,J)=CTEMP(I,J)
 4937 CONTINUE
  980 NUM=NPLUS1
      J=K1
      GO TO 983
  981 J=NUM-1
      NUM=J
      IF(J) 982,982,983
  982 GO TO (912,913,914,1914,987),MOVE
  983 DO 984 I=1,3
  984 WD(I)=XIPRIM(I,J)
  985 NWD=0
      CALL AWRITE(POFILE,NWD,WD,6,IR)
 2986 NWD=NWD+1
      NWDMAX = NWD
      GO TO 981
C........INVERT ORDER OF POINTS ON FILE AND OUTPUT TO EXFILE
C       INSERTING PROPER FEEDRATES
C
C
C...POCKET MUST GENERATE AT LEAST 3 POINTS
  987 IF(NWD.LT.K3) CALL AERR(3510,'POCKET  ')
      CALL RECORD (ISEQNO)
C...SET FINAL POINT INDICATOR FOR CLDATA RECORD WRITER
      ICL = K3
C...SET PLUNGE FEEDRATE
      FEEDRT = FRONE
C...SET FIRST POINT FLAG TRUE
      FPTFLG = .TRUE.
C
      FPFLG = .FALSE.
      IF(NWDMAX.EQ.NCORIG+K2) FPFLG = .TRUE.
C...  WRITE A FEEDRATE RECORD ON EXFILE
  992 CALL APT299(K1,HFDRT,K1,FEEDRT)
      KCLDAT(4)=ISEQNO
      NR=0
      CALL EWRITE(EXFILE,NR,KCLDAT,10,IR)
C
C...WAS LAST POINT PROCESSED....
  993 IF(NWD.LE.K1) GO TO 9999
C.... NO
C...WILL FINISH PASS BE COMPLETED WITH NEXT POINT...
      IF(NWD.EQ.K2) GO TO 996
C.... NO
C...SKIP NEXT TEST IF FINISH PASS STARTED
      IF (FPFLG) GO TO 998
C...IS IT TIME FOR FINISH PASS...
      IF (NWD.EQ. (NCORIG+K2))GO TO 995
C.... NO
C...WILLCLEANOUT PASS BE COMPLETED WITH NEXT POINT...
  998 IF(NWD.EQ.(NCORIG+K3))GO TO 996
C.... NO
C...PRODUCE NEXT POINT
  994 IF(NWD.EQ.NWDMAX) GO TO 997
C
  997 NWD = NWD - 1
      CALL AREAD(POFILE,NWD,TE,6,IR)
      CALL ATAPE
C
C...SET INTERMEDIATE POINT INDICATOR FOR ATAPE (CLDATA RECORD WRITER)
      ICL = K2
C...CHECK FIRST POINT FLAG
      IF (.NOT.FPTFLG) GO TO 993
C...FLAG TRUE ...SET FALSE , AND PREPARE FOR POCKET CLEANOUT
      FPTFLG = .FALSE.
      FEEDRT = FRTWO
      IF(NWD.LE.K2)          GO TO 995
      IF(NWD.GT.(NCORIG+K1)) GO TO 992
C...SET FINAL FEEDRATE
  995 FEEDRT = FRTHRE
      FPFLG = .TRUE.
      GO TO 992
C...SET FINAL POINT INDICATOR FOR ATAPE
  996 ICL = K3
      GO TO 994
 9999 CONTINUE
      RETURN
       END
**** SOURCE FILE : M0000948.ORG   ***
*
C.....FORTRAN SUBROUTINE             POLCON...              3/1/68   GK
      SUBROUTINE POLCON(SRFACE,NUMBER)
      RETURN
       END
**** SOURCE FILE : M0000950.V03   ***
*
C.....FORTRAN SUBROUTINE             PSIS.....              3/1/68   GK
      SUBROUTINE PSIS   (HMOD,ADRESS)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      DIMENSION ADRESS(*)
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
C
C...  ESTABLISHES PART SURFACE PARAMETERS
      IPSDEF=0
      IS=IPS
      CALL APT234(HMOD,ADRESS)
      RETURN
       END
**** SOURCE FILE : M0000955.V02   ***
*
C.....FORTRAN SUBROUTINE             QUAD.....              4/1/68   GK
      SUBROUTINE QUAD
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
C
C   S(IS) IS PRIMARY ROOT IF EXTANT.  SURD IS SECONDARY IF EXTANT.
      SURD=Z0
      IF(DABS(A).GT.Z1EM7) GO TO 100
      IF(DABS(B).GT.Z1EM7) GO TO 30
   20 IER=K1
      GO TO 999
C   EQUATION IS LINEAR
   30 S(IS)=-Z5EM1*C/B
   40 IF(DABS(S(IS))-Z1EM7) 70,70,50
 50   IF(IOP(IS))60,80,60
   60 IF(S(IS))130,130,80
   70 S(IS)=Z0
   80 IER=0
  999 CONTINUE
      RETURN
C   EQUATION IS QUADRATIC
  100 SURD=B*B-A*C
      IF(DABS(SURD).GT.Z1EM7) GO TO 110
C   ROOTS ARE EQUAL
      SURD=-B/A
      S(IS)=SURD
      GO TO 40
  110 IF(SURD)20,20,120
C   ROOTS ARE REAL, UNEQUAL.
  120 SURD=-B-DSIGN(DSQRT(SURD),B)
      S(IS)=C/SURD
      SURD=SURD/A
C   THUS SURD ABSOLUTELY LARGER THAN S(IS)
      GO TO 40
 130  IF(SURD)135,135,140
 135  IF(IOP(IS))80,80,20
C   LEAST POSITIVE ROOT REQUIRED.  S(IS) NEG, SURD POS, SO EXCHANGE.
  140 HOLD=SURD
      SURD=S(IS)
      S(IS)=HOLD
      GO TO 80
       END
**** SOURCE FILE : M0002894.V04   ***
*
C.....FORTRAN SUBROUTINE           RADAR           AR       5/1/68
      SUBROUTINE RADAR
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
C
      INCLUDE 'BLANKCOM.INC'
C
      DIMENSION CRDR(3),AXIS1(3),AXIS2(3),AXIS3(3)
      DIMENSION RADANG(5)
      DATA RADANG/.5255D0, .1309D0, 1.0472D0, 1.5707D0, .7854D0/
CC                 30 DEGS   7.5       60       90         45 DEGS
C
      DATA KN/9/
      DATA ZERO,ONE,ZLIT1/0.0D0,1.0D0,0.8D0/
C
C              /-PURPOSE OF RADAR IS TO MAKE ADDITIONAL TP,TN TO PIERCE
C              /-SURFACE AFTER ONE CANDIDATE TP,TN FAILED.
  100 CONTINUE
C              /-MDIC IS THE COUNT OF RADAR TRIES WITHOUT SUCCESS
      MDIC=MDIC+1
      IF(MDIC.EQ.KN) GO TO 130
      IF(MDIC.GT.KN) GO TO 200
C             /-MDIC IS LES THAN KN, PRELIMINARY RESTART ATTEMPTS.
C              /-FIRST ATTEMPT IS TO MOVE TP TOWARD LAST GOOD SP
C              /-IF JENT IS 1 AND IAMDCT 0 NO SP IS AVAILABLE
      IF(IAMDCT.LT.JENT(IS)) GO TO 130
C              /-TP LIES ONE HALF OF THE WAY BETWEEN TP AND SP
      DO 125 I=1,3
      TP(I,IS)=TP(I,IS)+0.6*(SP(I,IS)-TP(I,IS))
  125 CONTINUE
      GO TO 999
C
C              /-CONSTRUCT SURFACE NORMAL THRU EXT TP POINT AND USE THIS
C              /-NORMAL FOR A NEW TN IF POSSIBLE
  130 CONTINUE
      MDIC=KN
      IF(IUNFL(IS).LE.0) GO TO 100
      DO 134 I=1,3
      SP(I,IS)=TP(I,IS)
  134 CONTINUE
C              /-CALL DIRECTED DISTANCE ROUTINE FOR SURF WITH UNIT NORMA
C              /- THRU EXTERIOR POINT CAPABILITY
      IC=ICANON(IS)
      JSW=ISFIDN(IS)
      ISTSAV=ISTRUP
C             /-SET ISTRUP TO 5 FOR SPECIAL CALCULATION IN DD ROUTINES
      ISTRUP=5
      GO TO(1,1,3,3,6, 6,6,6,6,6, 139,139,139,6,139),JSW
C
  139 CONTINUE
      ISTRUP=ISTSAV
      IF(IER.GT.0) GO TO 100
C              /-USE SN FOR NEW TN
      W1=ONE
      IF(JTN(IS).EQ.0) W1=-ONE
      DO 140 I=1,3
      TN(I,IS)=W1*SN(I,IS)
  140 CONTINUE
      GO TO 999
C
    1 CALL DDPLAN(CANON(IC))
      GO TO 139
    3 CALL DDCYLN(CANON(IC))
      GO TO 139
    6 CALL DDQUAD(CANON(IC))
      GO TO 139
C
C              /-SEARCH PATTERN - SEND TOOL RAYS IN CONICAL LAYERS
C              /-AROUND LAST GOOD TN.
  200 CONTINUE
      IF(MDIC.LE.KN+28) GO TO 210
C              /-RADAR FAILED IN KN+28 TRIES SO TERMINATE
      CALL AERR(26803,'RADAR   ')
      GO TO 999
C
  210 CONTINUE
      JMDIC=MDIC-KN
      IF(JMDIC.NE.1) GO TO 220
C              /-SET UP BASE SYSTEM OF ORTHONORMAL VECTORS
C              /-FIRST DETERMINE IF TN CAN BE USED
      CALL VNORM(TN(1,IS),TN(1,IS))
      IF(IER.LE.0) GO TO 230
C              /-NO GOOD TOOL NORMAL, RADAR TERMINATES
      CALL AERR(26802,'RADAR   ')
      GO TO 999
C
  230 CONTINUE
C              /-CONSTRUCT COORDINATE SYSTEM AROUND TN
      DO 231 I=1,3
      AXIS1(I)=TN(I,IS)
  231 AXIS2(I)=ZERO
      W1=DABS(AXIS1(1))
      IF(W1.LT.ZLIT1) AXIS2(1)=ONE
      IF(W1.GE.ZLIT1) AXIS2(2)=ONE
      CALL CROSS(AXIS1,AXIS2,AXIS2)
      CALL VNORM(AXIS2,AXIS2)
      CALL CROSS(AXIS1,AXIS2,AXIS3)
C
  220 CONTINUE
C              /-INDEX TO CONICAL ANGLE AROUND TN
      ILAYER=(JMDIC-1)/8+1
C              /-DETERMINE MULTIPLE OF SWIVEL ANGLE WITHIN THIS CONE
      ISWIV=JMDIC-(ILAYER-1)*8-1
      ASWIV=ISWIV*RADANG(5)
      CRDR(1)=DCOS(RADANG(ILAYER))
      W1=DSIN(RADANG(ILAYER))
      CRDR(2)=DCOS(ASWIV)*W1
      CRDR(3)=DSIN(ASWIV)*W1
C              /-DETERMINE TN WITHIN CONICAL LAYER
      DO 240 I=1,3
      TN(I,IS)=CRDR(1)*AXIS1(I)+CRDR(2)*AXIS2(I)+CRDR(3)*AXIS3(I)
  240 CONTINUE
C
      CALL VNORM(TN(1,IS),TN(1,IS))
      IF(IER.GT.0) GO TO 100
C
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0002864.V06   ***
*
C
C.....FORTRAN SUBROUTINE             SRFVCT...              3/1/68   GK
      SUBROUTINE SRFVCT(SRFACE,VECTOR)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'HOLRTH.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C     25. COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM/ IAERFG,NPCTPT,PCTPTS,PCTPLN,ERRPTS
      DIMENSION PCTPTS(3,20),PCTPLN(4),ERRPTS(3,3)
C
      CHARACTER*8 TEST
      INTEGER IHDS(2),BCDF
      EQUIVALENCE (IHDS,VALHDS)
C
C...  NEW DIRECTION OF MOTION IS ALONG VECTOR
C...  STORE DIRECTION VECTORS FOR DS,PS,CS AS REQUIRED
      DIMENSION VECTOR(3)
      TEMP(1)=SRFACE
    3 K=IDS
      CALL HOLFRM(TEMP(1),TEST,1,8,NWD)
      IF(HDS.EQ.TEST) GO TO 5
      K=IPS
      IF(HPS.EQ.TEST) GO TO 5
      K=ICS
      IF(HCS.NE.TEST) GO TO 50
    5 DO 10 I=1,3
      SFVCT(1,K)=VECTOR(I)
   10 CONTINUE
      CALL TRANSM (SFVCT(1,K),VECTOR,3,3,0)
      CALL VNORM(SFVCT(1,K),SFVCT(1,K))
      IF(IER)30,30,20
   30 ISVFL(K)=K1
 1000 CONTINUE
      RETURN
   20 IAERFG=1
      CALL AERR(21101,'SRFVCT  ')
      IAERR=0
      GO TO 1000
   50 CALL AERR(-21102,'SRFVCT  ')
      IHDS(1) = BCDF(HDS(1:4))
      IHDS(2) = BCDF(HDS(5:8))
      TEMP(1)=VALHDS
      GO TO 3
       END
**** SOURCE FILE : SVCOPY00.ORG   ***
*
      SUBROUTINE SVCOPY(I,J)
C
      INCLUDE 'SV.INC'
C
      DO 10 K=1,3
      CC(K,J) = CC(K,I)
      PLNV(K,J) = PLNV(K,I)
      SFVCT(K,J) = SFVCT(K,I)
      SLX(K,J) = SLX(K,I)
      SN(K,J) = SN(K,I)
      SNK(K,J) = SNK(K,I)
      SNL(K,J) = SNL(K,I)
      SP(K,J) = SP(K,I)
      SPK(K,J) = SPK(K,I)
      SPL(K,J) = SPL(K,I)
      TN(K,J) = TN(K,I)
      TOOLHT(K,J) = TOOLHT(K,I)
      TP(K,J) = TP(K,I)
      TPK(K,J) = TPK(K,I)
      U1(K,J) = U1(K,I)
      VNDIR(K,J) = VNDIR(K,I)
      VT(K,J) = VT(K,I)
      U1K(K,J) = U1K(K,I)
      SK(K,J) = SK(K,I)
10      CONTINUE
                
      EPS1(J) = EPS1(I)
      EPS2(J) = EPS2(I)
      EPS3(J) = EPS3(I)
      EPS4(J) = EPS4(I)
      EPS6(J) = EPS6(I)
      EPS8(J) = EPS8(I)
      PAST(J) = PAST(I)
      PLND(J) = PLND(I)
      RC(J) = RC(I)
      S(J) = S(I)
      SAVE(J) = SAVE(I)
      TAU(J) = TAU(I)
      TAU1(J) = TAU1(I)
      TAU2(J) = TAU2(I)
      TH(J) = TH(I)
      TOOLWD(J) = TOOLWD(I)
      Z(J) = Z(I)
      VARBLE(J) = VARBLE(I)
C
      RETURN
      END
         
**** SOURCE FILE : M0002868.W01   ***
*
C.....FORTRAN SUBROUTINES      THICK & THICKH                 8/68   PH
C.....FORTRAN SUBROUTINES      THICK & THICKH               4/1/68   GK
C
      SUBROUTINE THICK(NMBR,THK)
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
      INCLUDE 'ZNUMBR.INC'
C
      CHARACTER*8 PPWORD
      INTEGER IPPWRD(2),BCDF
      DATA  PPWORD /'THICK '/
C
      COMMON/HOLD/JHLDFG,ITHCNT,ITABH(100)
      COMMON/HSAVE/SAVEH(50)
      EQUIVALENCE(SAVEH(36),NUMBER),(SAVEH(37),THKNES(1))
      DIMENSION THK(4)
C
C
C...  APPLY THE SPECIFIED DECIMAL NUMBERS AS THICKNESSES TO THE
C...  PART,DRIVE AND CHECK SURFACES RESPECTIVELY
      DIMENSION THKNES(4)
      NUMBER=NMBR
      DO 500 I=1,4
  500 THKNES(I)=THK(I)
      IF(JHLDFG.EQ.0) GO TO 501
      ITABH(ITHCNT)=13
      ITHCNT=ITHCNT+1
      RETURN
C
  501 CONTINUE
      IF(NUMBER.GT.NUMSFS) GO TO 40
    5 IS=IPS
      DO 30 I=K1,NUMSFS
      IF(I .LE. NUMBER)GO TO 6
C     IF I IS GREATER THAN NUMBER, THEN STUFF REMAINING SURFACES WITH
C     LAST THICK VALUE    IE   THKNES(NUMBER)
      TH(IS)=THKNES(NUMBER)
      GO TO 7
    6 TH(IS)=THKNES(I)
    7 IF(IS-ICS)10,20,20
   10 IS=IS+LSV
      GO TO 30
   20 IS=IS+LSV1
   30 CONTINUE
      JENT(IDS) = K1
      JENT(IPS) = K1
      GO TO 42
C
   40 CALL AERR(-22701,'THICK   ')
      NUMBER=NUMSFS
      GO TO 5
C
C...     OUTPUT PART PROGRAM COMMAND ON EXFILE
   42 IPPWRD(1)=BCDF(PPWORD(1:4))
      IPPWRD(2)=BCDF(PPWORD(5:8))
      CALL APT299(NUMBER,IPPWRD,1,THKNES(1))
      IF (NUMBER .LE. 1) GO TO 60
      KK=1
      DO 50  J=2,NUMBER,2
        IF (J .NE. NUMBER) THEN
          CALL APT299(1,THKNES(J),1,THKNES(J+1))
        ELSE
          CALL APT299(1,THKNES(J),0,Z0)
        ENDIF
   50 CONTINUE
C
   60 RETURN
      END
C
C
C
C
C.....FORTRAN SUBROUTINE  ....THICKH          8/68                    PH
C.....FORTRAN SUBROUTINE             THICKH....              4/1/68   GK
C
      SUBROUTINE THICKH
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
      INCLUDE 'ZNUMBR.INC'
C
      CHARACTER*8 PPWORD
      INTEGER IPPWRD(2),BCDF
      DATA  PPWORD /'THICK '/
C
      COMMON/HSAVE/SAVEH(50)
      EQUIVALENCE(SAVEH(36),NUMBER),(SAVEH(37),THKNES(1))
      DIMENSION THK(4)
C
C
C...  APPLY THE SPECIFIED DECIMAL NUMBERS AS THICKNESSES TO THE
C...  PART,DRIVE AND CHECK SURFACES RESPECTIVELY
      DIMENSION THKNES(4)
C
      IF(NUMBER.GT.NUMSFS) GO TO 40
    5 IS=IPS
      DO 30 I=K1,NUMSFS
      IF(I .LE. NUMBER)GO TO 6
C     IF I IS GREATER THAN NUMBER, THEN STUFF REMAINING SURFACES WITH
C     LAST THICK VALUE    IE   THKNES(NUMBER)
      TH(IS)=THKNES(NUMBER)
      GO TO 7
    6 TH(IS)=THKNES(I)
    7 IF(IS-ICS)10,20,20
   10 IS=IS+LSV
      GO TO 30
   20 IS=IS+LSV1
   30 CONTINUE
      JENT(IDS) = K1
      JENT(IPS) = K1
      GO TO 42
C
   40 CALL AERR(-22701,'THICKH  ')
      NUMBER=NUMSFS
      GO TO 5
C
C...     OUTPUT PART PROGRAM COMMAND ON EXFILE
   42 IPPWRD(1)=BCDF(PPWORD(1:4))
      IPPWRD(2)=BCDF(PPWORD(5:8))
      CALL APT299(NUMBER,IPPWRD,1,THKNES(1))
      IF (NUMBER .LE. 1) GO TO 60
      KK=1
      DO 50  J=2,NUMBER,2
        IF (J .NE. NUMBER) THEN
          CALL APT299(1,THKNES(J),1,THKNES(J+1))
        ELSE
          CALL APT299(1,THKNES(J),0,Z0)
        ENDIF
   50 CONTINUE
C
   60 RETURN
      END
**** SOURCE FILE : M0000733.W01   ***
*
C
C.....FORTRAN SUBROUTINE             TINKR....              4/1/68   GK
      SUBROUTINE TINKR
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
      DATA ZLIT1/.999999D0/
C
C...  NOTE- IN THIS PROGRAM BOTH ITL AND ITT ARE PROGRAM VARIABLES
C           AND DO NOT APPEAR IN COMMON
      JTR = 1
      IPS = IPS
      IDS = IDS
C...     MULTAX = 1 - FIXED TA, MULTAX = 2 - PS CONTROL, MULTAX = 3
C...     DS CONTROL.
      ITL  = IDS
      ITT = IPS
      IF (MANTAX - 2) 350,10,20
   10 ITL  = IPS
      ITT = IDS
C...     NUMAX = 0 - 4-AXIS, NUMAX = 1 - 5-AXIS, NUMAX = 2 -
C...     RULED SURFACE, NUMAX = 3 - NEW SURFACE, NUMAX = 4 -
C...     PIVOT POINT
   20 I = NUMAX + 1
      GO TO (230,30,270,40,320),I
   30 AX4(1)= TN(1,ITT)
      AX4(2)= TN(2,ITT)
      AX4(3)= TN(3,ITT)
C...     AX4 IS NORMAL TO SECONDARY SURFACE.
C...     TEMP(7) IS NORMAL TO PLANE OF AX4 AND TN(ITL).
   40 CALL CROSS(AX4,TN(1,ITL),TEMP(7))
      CALL VNORM(TEMP(7),TEMP(7))
      IF (IER) 50,60,50
C...     NORMALS COINCIDE - LET TEMP(7) = TI
   50 TEMP(7) = TI(1)
      TEMP(8) = TI(2)
      TEMP(9) = TI(3)
C...     TEMP IS X-AXIS OF PLANE OF NEW TOOL AXIS.
   60 CALL CROSS (TN(1,ITL),TEMP(7),TEMP)
      CALL VNORM (TEMP,TEMP)
      IF (IER) 340,70,340
C...     TEMP(10),TEMP(11) ARE SIN AND COS OF LEAD-LAG ANGLE
   70 TEMP(10)=DSIN(ALP)
      TEMP(11)=DCOS(ALP)
      IF (TEMP(7)*TI(1) +TEMP(8)*TI(2) +TEMP(9)*TI(3)) 80,90,90
   80 TEMP(10) = -TEMP(10)
C...     ROTATE PLANE OF CALCULATION - TEMP(4) IS Y-AXIS OF TA PLANE
   90 DO 100 I=1,3
  100 TEMP(I+3) = TEMP(10)*TEMP(I+6) + TEMP(11) *TN(I,ITL)
      CALL VNORM (TEMP(4),TEMP(4))
C
C     COMPUTE NEW TA W/O ANY MODIFICATIONS = T7
C
  105 DO 110 I = 1, 3
  110 TEMP(I+6)= - SAGL * TEMP(I) - CAGL * TEMP(I+3)
      CALL VNORM(TEMP(7),TEMP(7))
      IF(IER) 340, 120, 340
C
C     DOT NEW TA AND OLD TA = T12
C
  120 TEMP(12)=TEMP(7)*TA(1) + TEMP(8)*TA(2) + TEMP(9)*TA(3)
C
C     IF DOT .LT. 0 REVERSE NEW TA
C
      IF(TEMP(12)) 121, 125, 125
  121 TEMP(7) = - TEMP(7)
      TEMP(8) = - TEMP(8)
      TEMP(9) = - TEMP(9)
      TEMP(12) = - TEMP(12)
C
C6    IF DOT .GT. .999995 SET JTKF = 1 + RETURN
C
  125 IF(TEMP(12)-ZLIT1) 135,130,130
  130 JTKF = 1
      GO TO 350
C
  135 IF(JCNT1 + JCNT3 - 45) 136,136,138
  136 KDB = KDB + 1
      TDB = KDB
      DO 137 I = 1,3
      TEMP(12) = TA(I)
      TA(I)=(TDB*TEMP(I+6)+TA(I))/(TDB+1.0)
  137 TEMP(I+6) = TEMP(12)
      CALL VNORM(TA,TA)
      GO TO 140
  138 DO 1385 I = 1, 3
      TEMP(12) = TA(I)
      TA(I) = TEMP(I+6)
 1385 TEMP(I+6) = TEMP(12)
 1388 KDB = 0
  140 JTR = 0
  145 IF (NUMAX-4) 150,350,150
C...     ROTATE TOOL ABOUT CONTACT POINT OF CONTROLLING SURFACE
C...     DETERMINE INITIAL ORIENTATION OF TE TO TA.
C...     TEMP(4) IS PERP. TO PLANE OF OLD TA,TE,AND TP(ITL)
  150 TEMP(1) = TE(1) - TP(1,ITL) + TH(ITL)*TN(1,ITL)
      TEMP(2) = TE(2) - TP(2,ITL) + TH(ITL)*TN(2,ITL)
      TEMP(3) = TE(3) - TP(3,ITL) + TH(ITL)*TN(3,ITL)
      CALL CROSS (TEMP(7),TEMP,TEMP(4))
      CALL VNORM (TEMP(4),TEMP(4))
      IF (IER) 350,160,350
C
C...     TEMP IS PERP. TO NEW TA IN PLANE OF TN(ITL)
  160 CALL CROSS (TN(1,ITL),TA,TEMP)
      CALL CROSS (TA,TEMP,TEMP)
  170 CALL VNORM (TEMP,TEMP)
      IF (IER) 180,190,180
  180 CALL CROSS (TEMP(7),TEMP(4),TEMP)
      CALL VNORM ( TEMP , TEMP )
C...     CALCULATE VECTOR IN PLANE OF TA AND TEMP WHICH WILL BE
C...     FROM TP(ITL) TO NEW TE. RA, HI ARE COORDINATES OF RING.
  190 DO 200 I=1,3
  200 TEMP(I+9) = RA*TEMP(I) - HI*TA(I)
C...     TEMP(13) IS PERP. TO PLANE OF NEW TA,TP(ITL), AND NEW TE.
C...     ORIENTATION OF TEMP(4) AND TEMP(13) MUST BE SAME.
      CALL CROSS (TA,TEMP(10),TEMP(13))
      TEMP(14)=TEMP(4)*TEMP(13)+TEMP(5)*TEMP(14)+TEMP(6)*TEMP(15)
      IF (TEMP(14)) 210,220,220
  210 DO 215 I = 1, 3
  215 TEMP(I+9) = - (RA*TEMP(I) + HI*TA(I))
  220 TE(1)=TEMP(10)+TP(1,ITL)
      TE(2) = TEMP(11) +TP(2,ITL)
      TE(3) = TEMP(12) +TP(3,ITL)
      GO TO 350
C
C...     4-AXIS CASE - TA MUST LIE IN PLANE PERP. TO AX4
C        TEMP IS X-AXIS OF PLANE OF NEW TA.
  230 CALL CROSS (TN(1,ITL),AX4,TEMP)
      CALL VNORM (TEMP,TEMP)
      IF (IER) 350,240,350
C...     TEMP MUST BE IN DIRECTION OF TN(ITT).
  240 TEMP(10)= TN(1,ITT)*TEMP(1) +TN(2,ITT)*TEMP(2) +TN(3,ITT)*TEMP(3)
      IF (TEMP(10)) 250,260,260
  250 TEMP(1)=-TEMP(1)
      TEMP(2) =-TEMP(2)
      TEMP(3) =-TEMP(3)
C...     TEMP(4) IS X-AXIS IN PLANE OF NEW TA.
  260 CALL CROSS (AX4,TEMP,TEMP(4))
      CALL VNORM (TEMP(4),TEMP(4))
      IF (IER) 340,105,340
C...     RULED SURFACE.
C        TA WILL BE PARALLEL TO RULING.
  270 DO 280 I = 1, 3
  280 TEMP(I+6) = SLX(I,ITL)
      GO TO 120
C...     PIVOT POINT - AXIS WILL PASS THRU POINT AX4, ROTATE AROUND TE.
  320 DO 330 I=1,3
      TEMP(I+6) =TA(I)
  330 TA(I) = AX4(I) - TE(I)
      CALL VNORM(TA,TA)
      IF (IER) 335,120,335
  335 DO 336 I=1,3
  336 TA(I) = TEMP(I+6)
      GO TO 350
  340 JTR = -1
  350 CONTINUE
      RETURN
       END
**** SOURCE FILE : M0002872.W01   ***
*
C.....FORTRAN SUBROUTINE  ....TLAXIS         8/68                    PH
C
      SUBROUTINE TLAXIS(NUMBER,NPRD,PARAM)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      INCLUDE 'GLFLGS.INC'
C
C...   COMMON BLOCK FOR AERR INFORMATION
C
      COMMON/AERCOM/IAERFG
C
C...  COMMON FOR >PLOTFT/GOLOFT<
C
      DIMENSION IPLGO(26),COSAL(10),SINAL(10),CUTY(10),CUTX(10),CUTL(10)
      DIMENSION ICSEG(10),NLIOCI(10)
      DIMENSION VTA(3)
C
      COMMON/PLGOL/IPLGO,JCSEG,NCSEG,ICSEG,NLIOCI,
     +             COSAL,SINAL,CUTY,CUTX,CUTL,VTA
C
      DIMENSION PARAM(9)
      CHARACTER*6 TEST,DS,HLAG
      DATA DS/'DS    '/,HLAG/'LAG   '/
C
C...     IF MULTAX HAS NOT BEEN SPECIFIED ISSUE WARNING DIAGNOSTIC
      IF (MULOUT .NE. 1) CALL AERR(-22300,'TLAXIS  ')
C
      JTLFLG(IPS)=0
      JTLFLG(IDS)=0
      IPRD=NPRD/100
      NPRD=NPRD-IPRD*100
      IAUTAG=0
      MOTDIR=0
      IF (NPRD.NE.9) RINGFG=.FALSE.
      IP2=2
    1 IF (NPRD.LT.5) IP2=IP2-1
C            1   2   3   4  5  6  7  8  9 10 11  12  13  14  15
      GOTO(201,202,203,204,72,15,50,20,10,75,30,212,213,214,215,
C           16  17  18  19  20  21  22
     *     216,217,218,218,220,220,222),NPRD
C
C     **TLAXIS/1**
C
   10 IF (PARAM(1).NE.Z1)GOTO 150
      MANTAX=K1
      GO TO 140
C
C     **TLAXIS/NORMPS**
C
15    MANTAX=K2
      GAMMA=K0
      GO TO 28
C
C     **TLAXIS/NORMDS**
C
20    MANTAX=K3
      GAMMA=PI
C     **SET VALUES FOR NUMAX,RA & HI FOR TLAXIS/NORMPS & TLAXIS/NORMDS**
28    NUMAX=K1
      ALP=Z0
      RA=Z0
      HI=Z0
      GO TO 110
C
C     **TLAXIS/PARLEL,1 OR TLAXIS/PARLEL,2 **
C
30    IF(PARAM(2).LE.Z0.OR.PARAM(2).GT.Z2)GO TO 150
      GAMMA=Z0
  31  II=7
C     **IF BETA IS GREATER THAN 0,SET RA&HI AT UPPER LINE SEGMENT**
      IF(CUTDAT(6).GT.Z1EM7)GO TO 40
C     **SET RA&HI AT INTERSECTION OF UPPER&LOWER LINE SEGMENTS**
      II=6
C     **IF CORNER RADIUS IS GREATER THAN 0,RA=XH&HI=YH**
      IF(CUTDAT(2).GT.Z0)II=5
C     **IF BETA IS NEGATIVE,SET RA&HI AT EXTREMITY OF CORNER CIRCLE**
      IF(CUTDAT(6).LT.Z0)GO TO 45
40    RA=RI(II)
      HI=TLHITE(II)
      GO TO 48
45    RA=CUTDAT(3)+CUTDAT(2)
      HI=CUTDAT(4)
48    MANTAX=K3
      IF(PARAM(2).EQ.Z1)MANTAX=K2
      NUMAX=IP2
      IF (NUMBER.EQ.9)GOTO 96
      ALP=Z0
      AX4(1)=Z0
      AX4(2)=Z0
      AX4(3)=Z0
      GO TO 110
C
C     **TLAXIS/V OR TLAXIS/I,J,K**
C
50    MANTAX=K1
      CALL TRANSM(TA,PARAM,3,3,0)
      CALL VNORM(TA,TA)
      GO TO 140
C
C     **TLAXIS/A,B,RA,HI **
C     **TLAXIS/PARLEL,1,RA,HI OR TLAXIS/PARLEL,2,RA,HI**
C     **TLAXIS/A,B,RA,HI,GAMMA,I,J,K**
C     **TLAXIS/A,B,RA,HI,GAMMA,I,J,K,ALPHA**
C
72    IF(PARAM(1).EQ.Z0.OR.PARAM(1).GE.4.0)GO TO 150
      IF(PARAM(2).GT.K4)GO TO 150
      GO TO 80
   75 IF(PARAM(2).GE.Z3) GO TO 150
   76 PARAM(1)=PARAM(2)+Z1
C...
   80 IF (NUMBER .GE. 9) GOTO 95
      DO 90 I=NUMBER,8
90    PARAM(I+1)=Z0
   95 CONTINUE
100   MANTAX=PARAM(1)
      NUMAX=IP2
      RA=PARAM(3)
      HI=PARAM(4)
      GAMMA=DEGRAD*PARAM(5)
   96 ALP=-DEGRAD*PARAM(9)
      AX4(1)=PARAM(6)
      AX4(2)=PARAM(7)
      AX4(3)=PARAM(8)
      RINGFG=.TRUE.
      IF (SQRT(AX4(1)*AX4(1)+AX4(2)*AX4(2)+AX4(3)*AX4(3)).GT.1.D-10)
     *          CALL VNORM(AX4,AX4)
C
C     **EXIT ROUTES**
C
110   TLHITE(8)=HI
      RI(8)=RA
      SAGL=DSIN(GAMMA)
      CAGL=DCOS(GAMMA)
      IF(MANTAX-K2)140,120,130
120   JTLFLG(IPS)=K1
      GO TO 140
130   JTLFLG(IDS)=K1
140   RETURN
C
C     **ERROR-INVALID TLAXIS FORMAT**
C
  150 IAERFG=1
      CALL AERR(22301,'TLAXIS  ')
      RETURN
C       NO CUTTER DEFINED TO COMPUTE DISC RADIUS RA OR DISC HIGHT HI.
  160 IAERFG=1
      CALL AERR(22219,'TLAXIS  ')
      RETURN
C
C      NEW TLAXIS FORMATS INSTALLED AT 10.12.84
C
C 201 **TLAXIS/ATANGL,PS,GAMMA,RADIUS,RA,HIGHT,HI**
C 212 **TLAXIS/PARLEL,DS,RADIUS,RA,HIGHT,HI**
C
  201 PARAM(5)=180.D0-PARAM(5)
  212 PARAM(1)=Z1
      CALL HOLFRM(PARAM(2),TEST,1,6,NWD)
      IF(TEST.EQ.DS)PARAM(1)=Z2
      PARAM(2)=PARAM(1)
      GOTO 76
C
C 204 **TLAXIS/ATANGL,DS,GAMMA**
C 215 **TLAXIS/PARLEL,PS OR TLAXIS/PARLEL,DS **
C
  204 GAMMA=(180.D0-PARAM(5))*DEGRAD
  215 PARAM(1)=Z1
      CALL HOLFRM(PARAM(2),TEST,1,6,NWD)
      IF(TEST.EQ.DS)PARAM(1)=Z2
      PARAM(2)=PARAM(1)
      GOTO 31
C
C 202 **TLAXIS/ATANGL,DS,GAMMA,RADIUS,RA**
C 213 **TLAXIS/PARLEL,PS,RADIUS,RA**
C
  202 PARAM(5)=180.D0-PARAM(5)
  213 PARAM(4)=Z0
      IF(NCSEG.EQ.0)GOTO 160
      DO 313 I=1,NCSEG
      IF(NLIOCI(I).EQ.1)GOTO 311
      IF(CUTL(I).EQ.0.D0)GOTO 313
C           COMPUTATION OF SEGMENT AND RADIUS ON CIRCLE
      SERA=CUTX(I)+CUTL(I)*SINAL(I)
      IF(SERA.LT.PARAM(3))GOTO 313
C           COMPUTATION OF HI
      PARAM(4)=CUTY(I)-SQRT(CUTL(I)*CUTL(I)-(PARAM(3)-CUTX(I))**2)
      GOTO 212
C           COMPUTATION OF SEGMENT AND RADIUS ON LINE
  311 SERA=CUTX(I)+CUTL(I)*COSAL(I)
      IF(SERA.LT.PARAM(3))GOTO 313
C           COMPUTATION OF HI
      IF(DABS(COSAL(I)).LT.1.D-8)GOTO 312
      PARAM(4)=CUTY(I)+(PARAM(3)-CUTX(I))*SINAL(I)/COSAL(I)
      GOTO 212
  312 PARAM(4)=CUTY(I)+CUTL(I)
      GOTO 212
  313 CONTINUE
      PARAM(4)=CUTY(NCSEG)
      GOTO 212
C
C 203 **TLAXIS/ATANGL,DS,GAMMA,HIGHT,HI**
C 214 **TLAXIS/PARLEL,PS,HIGHT,HI**
C
  203 PARAM(5)=180.D0-PARAM(5)
  214 PARAM(3)=Z0
      IF(NCSEG.EQ.0)GOTO 160
      DO 315 I=1,NCSEG
      IF(NLIOCI(I).EQ.1)GOTO 314
      IF(CUTL(I).EQ.0.D0)GOTO 315
C           COMPUTATION OF SEGMENT AND HEIGHT ON CIRCLE
      SEHI=CUTY(I)-CUTL(I)*COSAL(I)
      IF(SEHI.LT.PARAM(4))GOTO 315
C           COMPUTATION OF RA
      PARAM(3)=SQRT(CUTL(I)*CUTL(I)-(PARAM(4)-CUTY(I))**2)+CUTX(I)
      GOTO 212
C           COMPUTATION OF SEGMENT AND HEIGHT ON LINE
  314 SEHI=CUTY(I)+CUTL(I)*SINAL(I)
      IF(SEHI.LT.PARAM(4))GOTO 315
C           COMPUTATION OF RA
      IF(ABS(SINAL(I)).LT.1.D-8)GOTO 316
      PARAM(3)=CUTX(I)+(PARAM(4)-CUTY(I))*COSAL(I)/SINAL(I)
      GOTO 212
  316 PARAM(3)=CUTX(I)+CUTL(I)
      GOTO 212
  315 CONTINUE
      PARAM(3)=CUTX(NCSEG)
      GOTO 212
C                                     LAG
C 216 **TLAXIS/ATANGL,........,CUTANG,LEAD,ALPHA
C 217 **TLAXIS/ATANGL,........,CUTANG,ALPHA
C
  216 CALL HOLFRM(PARAM(NUMBER-1),TEST,1,6,NWD)
      IF(TEST.EQ.HLAG)PARAM(NUMBER)=-PARAM(NUMBER)
  217 PARAM(9)=PARAM(NUMBER)
      DO 317 I=6,8
  317 PARAM(I)=Z0
      NUMBER=9
      GOTO 331
C                                     LAG
C 218 **TLAXIS/ATANGL,........,CUTANG,LEAD,AUTO
C 219 **TLAXIS/ATANGL,........,CUTANG,AUTO
C
  218 IAUTAG=1
      CALL HOLFRM(PARAM(NUMBER-1),TEST,1,6,NWD)
      IF(TEST.EQ.HLAG)IAUTAG=-1
      GOTO 330
C                                     LINE
C 220 **TLAXIS/ATANGL,........,PARLEL,PLANE
C 221 **TLAXIS/ATANGL,........,PERPTO,VECTOR
C
  220 NUMBER=9
      PARAM(9)=Z0
      IP2=IP2-1
      GOTO 331
C
C 222 **TLAXIS/ATANGL,........,MOTDIR
C
  222 MOTDIR=1
      IP2=IP2-1
C
  330 NUMBER=5
  331 NPRD=IPRD
      GOTO 1
C
      END
**** SOURCE FILE : M0000971.V03   ***
*
C
C...FORTRAN SUBROUTINES TLLFT,TLRGT,TLON,TLONPS,TLOFPS... 5/9/72
C
C
      SUBROUTINE TLLFT
C
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
C
C.... TOOL IS LEFT OF DS
C
      I = 1
      J = 1
      K = 1
      L = IDS
C
C
      MOTMOD = I
      ISFTYP(L) = J
      IF(ITLON(L).EQ.K) GO TO 10
      ITLON(L) = K
      JENT(L) = 1
   10 RETURN
      END
C
C
C
C
C
      SUBROUTINE TLRGT
C
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
C
C
C.... TOOL IS RIGHT OF DS
C
      I = 2
      J = 1
      K = 1
      L = IDS
C
C
      MOTMOD = I
      ISFTYP(L) = J
      IF(ITLON(L).EQ.K) GO TO 10
      ITLON(L) = K
      JENT(L) = 1
   10 RETURN
      END
C
C
C
C
C
      SUBROUTINE TLON
C
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
C
C
C.... TOOL END IS ON DS
C
      I = 3
      J = 3
      K = 0
      L = IDS
C
C
      MOTMOD = I
      ISFTYP(L) = J
      IF(ITLON(L).EQ.K) GO TO 10
      ITLON(L) = K
      JENT(L) = 1
   10 RETURN
      END
C
C
C
C
C
      SUBROUTINE TLONPS
C
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
C
C
C.... TOOL END IS ON PS
C
      J = 3
      K = 0
      L = IPS
C
C
      ISFTYP(L) = J
      IF(ITLON(L).EQ.K) GO TO 10
      ITLON(L) = K
      JENT(L) = 1
   10 RETURN
      END
C
C
C
C
C
      SUBROUTINE TLOFPS
C
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
C
C
C.... TOOL IS TANGENT TO PS
C
      J = 1
      K = 1
      L = IPS
C
C
      ISFTYP(L) = J
      IF(ITLON(L).EQ.K) GO TO 10
      ITLON(L) = K
      JENT(L) = 1
   10 RETURN
      END
C
C
C
C
**** SOURCE FILE : M0002898.W06   ***
*
C.....FORTRAN SUBROUTINE  ....TLNORM         8/68                 PH,HG
C..... FORTRAN SUBROUTINE            TLNORM...              4/8/68   GK
      SUBROUTINE TLNORM(U1VAR)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'DSHAR4.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ZNUMBR.INC'
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'CHEKFL.INC'
C
      DIMENSION U1VAR(3),TNOLD(3),TPOLD(3),SNOLD(3),SPOLD(3)
C
      COMMON/MODESS/MODESS,MSSCHK,MSSARL
C
      DIMENSION TPSPDF(3)
C
      DATA ZBIG/1.D30/,Z4/4.D0/,Z3EM4/3.D-4/,Z5EM3/5.D-3/,Z5EM4/5.D-4/
      DATA Z700,Z9999,Z995,ZBIG2/700.D0,0.9999D0,.995D0,1.D20/
      DATA ZERO,ONE/0.0D0,1.0D0/
C
C-----------------------------------------------------------
C             /-JFIND IS -1 WHEN AT LEAST ONE TOOL SEG HAS LINED UP
C             /-WITH THE CENTER OF CURVATURE
C             /-IBB=-1 FOR 1ST PASS THRU TLNORM, =0 ON SECOND PASS
      JFIND=1
      IBB=-1
  805 CONTINUE
C              /-IT IS TOOL SEGMENT INDEX  =1 AT TIP,2,3,4 ETC
C              /-IT=7 IS LAST SEGMENT, =8 IS DISC. IBEGIN IS FIRST
C              /-SIGNIFICANT TOOL SEGMENT.
      IT=IBEGIN
      DO 12 I=1,3
   12 UVEC(I)=U1VAR(I)
C
      IF(MSSCHK.EQ.1) GO TO 3029
C-----------------------------------------------------------
C              /-TEST FOR ROUTE
C
C              /-ITLON IS 0 IF TOOL ON SURF, 1 OTHERWISE
      IF(ITLON(IS).EQ.0) GO TO 1
C              /-IAFL=-1, GENERAL SURF, 0 PLANE PERP TO TA, 1 CYL LL TA
C              /-JTLFLG=0 FOR NORMAL CUTTER, =1 FOR DISC TYPE.
C
      IW=IAFL(IS)+JTLFLG(IS)
C              /-IAFL,JTLFLG = 0,1,  1,1,  OR 1,0
      IF(IW.GT.0) GO TO 401
C              /-IAFL,JTLFLG = -1,1, 0,0
      IF(IW.EQ.0) GO TO 404
C              /-IAFL=-1,JTLFLG=0
      IF(IPT1.NE.0) GO TO 84
      GO TO 1
C
C              /-TA LL TO SURFACE ELEMENT
C
  401 CONTINUE
      DO 402 I=1,3
      TP(I,IS)=TE(I)+TOOLWD(IS)*UVEC(I)+TOOLHT(I,IS)
      TN(I,IS)=UVEC(I)
  402 CONTINUE
C              /-TP,TN FOUND, RETURN TO CALLING PROGRAM
      GO TO 9999
C              /-CASE OF POINT CUTTER
    1 CONTINUE
C              /-TEMP(1) IS +OR-1 TO SELECT CUTTER SIDE
C              /-TEMP(2) IS 0 OR 1
      TEMP(2)=ZERO
      DO 21 I=1,3
   21 TP(I,IS)=TE(I)
      ITSEG(IS)=1
      GO TO 408
C
C-----------------------------------------------------------
C
C              /-TLON, POINT TOOL, 5-AXIS RING ROUTES
  404 CONTINUE
      IF(RI(8).EQ.ZERO) GO TO 406
      TEMP(1)=-ONE
      TEMP(2)=ONE
      GO TO 407
  406 CONTINUE
      TEMP(2)=ZERO
  407 CONTINUE
      DO 405 I=1,3
  405 TP(I,IS)=TE(I)+TLHITE(8)*TA(I)+TEMP(1)*RI(8)*UVEC(I)
      ITSEG(IS)=8
  408 CONTINUE
      DO 2 I=1,3
      TN(I,IS)=CC(I,IS)-TP(I,IS)
    2 CONTINUE
C              /-LL MAY BE 3,4 OR 5
      LL=TEMP(1)*TEMP(2)+Z4
      CALL VNORM(TN(1,IS),TN(1,IS))
      IF(IER.EQ.0) GO TO 8
C**** ERROR EXIT, TN CANNOT BE FOUND
    3 CONTINUE
      IF(TEMP(2).GT.ZERO) GO TO 410
      CALL AERR(26601,'TLNORM  ')
      GO TO 9999
C
  410 TEMP(LL)=-ONE
C
  417 CONTINUE
      IF(TEMP(1).GE.ZERO) GO TO 418
      DO 503 I=1,3
      TEMP(I+5)=TN(I,IS)
  503 TEMP(I+8)=TP(I,IS)
      TEMP(1)=ONE
      GO TO 407
C
  418 CONTINUE
      IF(TEMP(5).GE.TEMP(3)) GO TO 505
C              /-TEMP(5) IS LT TEMP(3)
      DO 506 I=1,3
      TN(I,IS)=TEMP(I+5)
      TP(I,IS)=TEMP(I+8)
  506 CONTINUE
  505 CONTINUE
C              /-JTLFLG NE 1 MEANS IGNORE DISC CUTTER
      IF(JTLFLG(IS).NE.1) GO TO 9999
      IF(IPL(IS).NE.1) GO TO 9999
C              /-PLANAR SURFACE CASE
      CALL DOTF(W1,TA,SN(1,IS))
      IF(DABS(W1).LT.Z995) GO TO 9999
C              /-SN AND TA ARE CLOSE, LOOK FURTHER
      IF(JTN(IS).GT.0) GO TO 9999
C              /-SURFACE IS DS OR PS, CONTINUE
      GO TO 413
C
    8 CONTINUE
      IF(TEMP(2).GT.ZERO) GO TO 412
C              /-TEMP(2) IS LE ZERO
      IF(JTN(IS).GT.0) GO TO 414
  413 CONTINUE
C              /-JTN(IS) IS ZERO, NORMAL PS OR DS SURFACE
      CALL DOTF(W1,SN(1,IS),TN(1,IS))
C              /- WHEN TN AND SN ARE OPPOSED, FINISH
      IF(W1.LE.ZERO) GO TO 9999
C              /-ELSE CHECK FURTHER
      GO TO 340
  414 CONTINUE
C              /-JTN NOT ZERO, CHECK SURFACE, TN CONTROL
      CALL DOTF(W1,TN(1,IS),TNL(1,IS))
C              /-LAST TWO TNS ALIGNED, THEN QUIT
      IF(W1.GT.ZERO) GO TO 9999
      IF(W1.LT.ZERO) GO TO 340
C              /-CHECK FURTHER IF TN PERPEN TO TNL
      CALL DOTF(W1,TN(1,IS),SN(1,IS))
      IF(W1.GE.ZERO) GO TO 9999
  340 CONTINUE
C              /-REVERSE TN AND THEN TERMINATE
      DO 341 I=1,3
      TN(I,IS)=-TN(I,IS)
  341 CONTINUE
      GO TO 9999
C
  412 CONTINUE
      CALL DOTF(W1,TN(1,IS),UVEC)
      IF(TEMP(1)*W1.GE.ZERO) GO TO 502
C              /-REVERSE TN
      DO 501 I=1,3
      TN(I,IS)=-TN(I,IS)
  501 CONTINUE
  502 CONTINUE
      IF(JTN(IS).LE.0) CALL DOTF(W1,TN(1,IS),SN(1,IS))
      IF(JTN(IS).LE.0) TEMP(LL)=-W1
      IF(JTN(IS).GT.0) CALL DOTF(TEMP(LL),TN(1,IS),TNL(1,IS))
      GO TO 417
C-----------------------------------------------------------
C
C              /-START NORMAL ROUTE. SPECIAL PATH FOR END TOOL
C
   84 CONTINUE
      TCONT(8)=-ONE
      NNN=1
      IF(JTN(IS).EQ.0) IT=ITSEG(IS)
C.... CONSIDER PRECEDING AS WELL AS CURRENT AND FOLLOWING TOOL SEGMENTS
      IF (IT.GE.4) IT=IT-2
      CENDIS=ZBIG
      WFL1=ZERO
      IT=IT-NNN
C
C              /-INCREMENT TOOL SEGMENT, TRY AGAIN
 2000 CONTINUE
      IT=IT+NNN
C              /-TCONT=0 MEANS SEGMENT INSIGNIFICANT
      IF(TCONT(IT).EQ.ZERO) GO TO 2000
C              /-TCONT=-1 MEANS ALL SEGS OF TOOL DONE, SELECT TN.
      IF(TCONT(IT).GE.ZERO) GO TO 700
C
C              /-END OF TOOL.  ONLY ONE POSSIBLE TN.
C
      IF(JFIND.LE.0) GO TO 9999
      TEMP(1)=2*JTN(IS)-1
      DO 8223 I=1,3
      TN(I,IS)=TEMP(1)*SN(I,IS)
 8223 CONTINUE
      CALL DOTF(COM1,TA,TN(1,IS))
      COM1=-COM1
      COM4=DSQRT(ONE-COM1**2)
      IF(COM4.LE.Z1EM3.AND.COM1.GE.ZERO) GO TO 605
      IF(COM4.LT.Z1EM3.AND.COM1.LT.ZERO) GO TO 604
      TANGL=COM1/COM4
      IT=IBEGIN
  704 CONTINUE
C              /-TCONT LT ZERO MEANS THIS IS LAST TOOL SEGMENT
      IF(TCONT(IT).LT.ZERO) GO TO 3
C              /-TCONT GT ZERO MEANS THIS IS ORDINARY TOOL SEGMENT
      IF(TCONT(IT).GT.ZERO) GO TO 706
C              /-TCONT EQ ZERO MEANS INSIGNIFICANT TOOL SEGMENT
  705 CONTINUE
      IT=IT+1
      GO TO 704
  706 CONTINUE
      IF(TLINC(IT).NE.ZERO) GO TO 705
      IF(TANGL.LT.TANHI(IT)) GO TO 705
      DO 709 I=1,3
  709 TP(I,IS)=TE(I)+TLHITE(IT)*TA(I)+RI(IT)*UVEC(I)+CORRAD(IT)*TN(I,IS)
      GO TO 9999
C
  700 CONTINUE
C              /-CONTINUE SEARCH
      DO 15 I=1,3
      REFPNT(I)=TE(I)+RI(IT)*UVEC(I)+TLHITE(IT)*TA(I)
      OGLE(I)=CC(I,IS)-REFPNT(I)
   15 CONTINUE
      CALL VNORM(OGLE,U2)
C              /-IF OGLE, CANDIDATE TN, IS SMALL, TRY NXT SEG
      IF(IER.GT.0) GO TO 2000
C              /-IF SURFACE IS PLANAR, USE NORMAL RATHER THAN CC
      IF(IPL(IS).LT.1) GO TO 155
      DO 153 I=1,3
      OGLE(I)=-RC(IS)*SN(I,IS)
      U2(I)=-DSIGN(ONE,RC(IS))*SN(I,IS)
  153 CONTINUE
C
  155 CONTINUE
      IF(TLINC(IT).EQ.ZERO) GO TO 16
      CORRAD(IT)=ZERO
      DO 41 I=1,3
      U2(I)=COSL(IT)*UVEC(I)+SINL(IT)*TA(I)
   41 CORRAD(IT)=CORRAD(IT)+OGLE(I)*U2(I)
C              /-IF CORNER RADIUS IS SMALL, GO TO NEXT SEG
      IF(CORRAD(IT).LT.-Z3EM4) GO TO 2000
C              /-OTHERWISE, GO TO PLANE CALC
C              /-IF SURF IS A PLANE, TN MUST BE LL TO TOOL SEG
   43 CONTINUE
      IF(IPL(IS).LE.0) GO TO 643
      IF(CORRAD(IT).GE.Z5EM3) GO TO 2000
      CORRAD(IT)=ZERO
      GO TO 44
  643 CONTINUE
      IF(CORRAD(IT).GE.UMAX(IT)+Z5EM4) GO TO 2000
   44 CONTINUE
C              /-COSL IS HORIZONTAL AND SINL VERTICAL COMP OF LINEAR SEG
      DO 45 I=1,3
   45 ZLNORM(I)=SINL(IT)*UVEC(I)-COSL(IT)*TA(I)
      GO TO 31
C
   16 CONTINUE
      CALL DOTF(COM1,OGLE,TA)
      CALL DOTF(COM4,OGLE,OGLE)
      COM4=COM4-COM1**2
      TEMP(1)=ONE
      IF(IT.EQ.7) TEMP(1)=-ONE
      TANGL=TEMP(1)*ZBIG
      IF(COM4.GT.ZERO) GO TO 19
      DO 50 I=1,3
   50 U2(I)=-TEMP(1)*TA(I)
      ITRY=1
      GO TO 25
C
   19 CONTINUE
      COM4=DSQRT(COM4)
      TANGL=-ZBIG
      IF(COM1.LT.Z700*COM4) TANGL=-COM1/COM4
      CALL DOTF(W1,UVEC,OGLE)
      ITRY=0
 1900 CONTINUE
      IF(W1.GE.ZERO) GO TO 25
C              /-REVERSE SIDE OF CUTTER
      TANGL=-TANGL
      DO 24 I=1,3
   24 U2(I)=-U2(I)
C-----------------------------------------------------------
C              /-RESUME NORMAL PATH. COMPUTE ZLPNT,ZLNORM
C
   25 CONTINUE
C              /- TANHI.LT.TANGL.LT.TANLO IS CRITERIA FOR VALID TN
      IF ((TANLO(IT).GE.TANGL).AND.(TANHI(IT).LE.TANGL)) THEN
        DO 30 I=1,3
          ZLNORM(I)=U2(I)
   30   CONTINUE
      ELSE
        IF (TANLO(IT).LT.TANGL) THEN
C              /-TN CONTROL, SEARCH BACKWARDS ON TOOL
          IF(JTN(IS).NE.0) NNN=-1
        ENDIF
C
        IF (ITRY.EQ.1) GOTO 2000
        IF ((ICHEKF.NE.1).AND.(ABS(W1).GT.0.05D0)) GOTO 2000
        IF (ABS(W1).GT.10.D0) GOTO 2000
        ITRY=1
        W1=-W1
        GOTO 1900
      ENDIF
C
   31 CONTINUE
      DO 32 I=1,3
   32 ZLPNT(I)=REFPNT(I)+CORRAD(IT)*U2(I)
      IF(JTN(IS).LE.0) GO TO 237
C
C
C              /-NORMAL PATH. TN CONTROL
C
      CALL DOTF(W1,TNL(1,IS),ZLNORM)
C             /-TN.TNL POSITIVE, ACCEPT CURRENT TP,TN - RETURN
      IF(W1.GE.ZERO) GO TO 9998
      IF (IBB.LT.0) THEN
        W11=W1
      ELSE
        IF (W11.GT.W1) THEN
          GOTO 8021
        ELSE
          IF (W1.GT.-0.08D0) THEN
            CALL ERROR(-26002,'TLNORM')
            GO TO 9998
          ENDIF
        ENDIF
      ENDIF
      CALL DOTF(AM,ZLNORM,TA)
      IF(DABS(AM).LE.Z9999) GO TO 802
      IF(JTN(IS).EQ.0) GO TO 603
      DO 601 I=1,3
  601 TN(I,IS)=-ZLNORM(I)
      IF(AM.GT.ZERO) GO TO 605
C              /-AM IS LE ZERO
      GO TO 604
C
  802 CONTINUE
C             /-IBB =0 MEANS 2ND TIME THRU TLNORM, SO FAIL HERE.
      IF(IBB.GE.0) GO TO 804
C             /-RESTART MODE, SWITCH TO OTHER SIDE CUTTER, THEN RESTART
 8021 IBB=0
      ITSEG(IS)=IBEGIN
      DO 803 I=1,3
  803 U1VAR(I)=-U1VAR(I)
C             /-BRANCH BACK TO START OF TLNORM, BEGIN AGAIN
      GO TO 805
  804 CONTINUE
C*****
      CALL AERR(26602,'TLNORM  ')
  603 CONTINUE
C             /-SET REFERENCE TP AT TOP OF TOOL
      IF(IT.EQ.7) GO TO 605
  604 CONTINUE
      IT=7
      ITSEG(IS)=7
      DO 3604 I=1,3
 3604 TP(I,IS)=TE(I)+TLHITE(IT)*TA(I)+RI(IT)*U1(I,IS)
      GO TO 9999
C
  605 CONTINUE
      ITSEG(IS)=IBEGIN
      DO 3603 I=1,3
 3603 TP(I,IS)=TE(I)
      GO TO 9999
C              /-SELECT CORRECT TN FROM MULTIPLE TN'S.
C              /-TEMPORARILY REPLACE TP,TN WITH NEW TP,TN CANDIDATE
  237 CONTINUE
      DO 34 I=1,3
      SNOLD(I)=SN(I,IS)
      SPOLD(I)=SP(I,IS)
      TNOLD(I)=TN(I,IS)
      TPOLD(I)=TP(I,IS)
      TN(I,IS)=ZLNORM(I)
      TP(I,IS)=ZLPNT(I)
   34 CONTINUE
      IF(IS.EQ.1) GO TO 7003
      IF(ISFIDN(IS).EQ.29.OR.ISFIDN(IS).EQ.30) GO TO 7003
C              /-
      CALL DDST
C              /-
      IF(IER.EQ.0) GO TO 7004
 7003 S(IS)=ZBIG2
 7004 CONTINUE
      DO 4029 I=1,3
      SN(I,IS)=SNOLD(I)
      SP(I,IS)=SPOLD(I)
      TN(I,IS)=TNOLD(I)
      TP(I,IS)=TPOLD(I)
 4029 CONTINUE
      S(IS)=DABS(S(IS))
C
      IF(CENDIS.LT.S(IS)) GO TO 2000
C.... SELECT TN WHOS DIRECTION COINCIDES BEST WITH LAST SN
C.... IE. WHOSE ABS VALUE OF TN.SN IS MAXIMAL
      CALL DOTF(WFL2,SN(1,IS),ZLNORM)
      IF (ABS(WFL2).LE.ABS(WFL1)) GOTO 2000
      WFL1=WFL2
C              /-NEW DISTANCE TO SURFACE LESS, SET JFIND TO SEARCH TOOL
C             /-SET JFIND TO -1 TO SHOW A VALID DIST HAS BEEN FOUND
      JFIND=-1
      CENDIS=S(IS)
C
C              /-UPDATE TP,TN AND EXIT IF JFIND =1.
 9998 CONTINUE
      ITSEG(IS)=IT
      DO 9222 I=1,3
      TP(I,IS)=ZLPNT(I)
      TN(I,IS)=ZLNORM(I)
 9222 CONTINUE
C             /-JFIND -1, SO CONTINUE SEARCHING FOR BETTER TOOL SEG
      IF(JFIND.LT.0) GO TO 2000
C****
 9999 CONTINUE
      RETURN
C************************************************************
C-----------------------------------------------------------
C
 3029 CONTINUE
C--------  SPECIAL TREATMENT OF A BALL CUTTER BY SSURF
C              /-RADIUS OF BALL EQUALS HALF DIAMETER OF TOOL
      RRR=CUTDAT(2)
C              /-TOOL ON OR POINT TOOL MEANS RRR IS ZERO
      IF(ITLON(IS)*IPT1.EQ.0) RRR=ZERO
C              /-ISFTYP 1=TO, 2=PAST, 3=ON, 4=TANTO 8=PSTAN
      IF(ISFTYP(IS).EQ.3) RRR=ZERO
C              /-GENERATE POINT AT CENTER OF BALL OR TIP OF TOOL
      DO 3030 I=1,3
      TP(I,IS)=TE(I)+RRR*TA(I)
 3030 SPL(I,IS)=SP(I,IS)
C             /-BRANCH TO DD ROUTINE TO ESTABLISH TOOL/SURF RELATION
      MODESS=21
      CALL AJUNDD
      MODESS=0
C
C             /-COMPUTE RELEVANT POINT ON TOOL SURFACE
      W1=ONE
      IF(JTN(IS).EQ.0) W1=-W1
C             /-MODIFY TN FOR TN CONTROL SO THAT TN.TI IS POSITIVE
      IF(JTN(IS).EQ.0) GO TO 3032
C             /-MEASURE THE ANGLE BETWEEN TN AND TI
      CALL DOTF(W2,SN(1,IS),TI)
      W2=W2*W1*PAST(IS)
      IF(W2.GE.ZERO) GO TO 3032
C             /-ALTER THE SIGN OF Z AND SN TO MAKE TN.TI.PAST POSITIVE
      Z(IS)=-Z(IS)
      DO 3034 I=1,3
      SN(I,IS)=-SN(I,IS)
 3034 CONTINUE
 3032 CONTINUE
      DO 3033 I=1,3
      TN(I,IS)=W1*SN(I,IS)
      TP(I,IS)=TP(I,IS)+RRR*TN(I,IS)
      TPSPDF(I)=SP(I,IS)-(TP(I,IS)+TH(IS)*TN(I,IS))
 3033 CONTINUE
C             /-DISTANCE MEASURED FROM RELEVANT TP TO SP IN TN DIRECTION
      CALL DOTF(S(IS),TPSPDF,TN(1,IS))
      CALL CCURV(IS,SP(1,IS),SPL(1,IS),SN(1,IS))
      ITSEG(IS)=4
      IF(DABS(RRR).LT.Z5EM4) ITSEG(IS)=1
      CALL DOTF(W1,TN(1,IS),TA)
      DO 3035 I=1,3
 3035 U1VAR(I)=TN(I,IS)-W1*TA(I)
      CALL VNORM(U1VAR,U1VAR)
      IER=0
      RETURN
      END
**** SOURCE FILE : M0000735.W01   ***
*
C.....FORTRAN SUBROUTINES  TOLER,INTOL,OUTTOL,TOLERH,INTOLH, & OUTTOH
C
C
C.....FORTRAN SUBROUTINE             TOLER....              3/1/68   GK
      SUBROUTINE TOLER(NMBR,TLRNS)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
      COMMON /HSAVE/ SAVEH(50)
      DIMENSION TOLRNS(4)
      EQUIVALENCE  (SAVEH( 1),TOLRNS(1)),(SAVEH(5),NUMBER)
      DIMENSION TLRNS(4)
      CHARACTER*6 PPWORD
      DIMENSION PPWORD(3),ITHVAL(3),IPPWRD(2)
      INTEGER BCDF
C
      DATA PPWORD/'INTOL ','OUTTOL','TOLER '/
      DATA ITHVAL/  8     ,  9     ,  4     /
C
      ICASE=3
C
      DO 5 I=1,4
    5 TOLRNS(I)=TLRNS(I)
      NUMBER=NMBR
      IF(JHLDFG.EQ.0) GO TO 300
      ITABH(ITHCNT)=ITHVAL(ICASE)
      ITHCNT=ITHCNT+1
  999 RETURN
C
C
C---    OUTTOL, MAX DEVIATION ZERO ON SIDE AWAY FROM CUTTER
  300 CONTINUE
      DO 350 I=1,NUMSFS
      TAU2(I)=Z0
  350 CONTINUE
C
      CALL APT232(NUMBER,TOLRNS,TAU1,Z1)
C
C---    OUTPUT PART PROGRAM COMMAND ON EXFILE
C
      IPPWRD(1)=BCDF(PPWORD(ICASE)(1:4))
      IPPWRD(2)=BCDF(PPWORD(ICASE)(5:6))
      CALL APT299(NUMBER,IPPWRD,1,TOLRNS(1))
      IF(NUMBER.LE.1) GO TO 999
      DO 30 J=2,NUMBER,2
       IF(J.NE.NUMBER) THEN
         CALL APT299(1,TOLRNS(J),1,TOLRNS(J+1))
       ELSE
         CALL APT299(1,TOLRNS(J),0,Z0)
       ENDIF
   30 CONTINUE
      GO TO 999
      END
C
C
C
C
C.....FORTRAN SUBROUTINE  ....INTOL          8/68                    PH
C.....FORTRAN SUBROUTINE             INTOL....              3/1/68   GK
      SUBROUTINE INTOL(NMBR,TLRNS)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
      COMMON /HSAVE/ SAVEH(50)
      DIMENSION TOLRNS(4)
      EQUIVALENCE  (SAVEH( 1),TOLRNS(1)),(SAVEH(5),NUMBER)
      DIMENSION TLRNS(4)
      CHARACTER*6 PPWORD
      DIMENSION PPWORD(3),ITHVAL(3),IPPWRD(2)
      INTEGER BCDF
C
      DATA PPWORD/'INTOL ','OUTTOL','TOLER '/
      DATA ITHVAL/  8     ,  9     ,  4     /
C
C
      ICASE=1
C
      DO 5 I=1,4
    5 TOLRNS(I)=TLRNS(I)
      NUMBER=NMBR
      IF(JHLDFG.EQ.0) GO TO 100
      ITABH(ITHCNT)=ITHVAL(ICASE)
      ITHCNT=ITHCNT+1
  999 RETURN
C
C
C---    INTOL, MAX DEVIATION SPECFD ON SIDE OF SURF AWAY FROM CUTTER
  100 CONTINUE
      IF(IBTFLG.GE.0) GO TO 110
      IBTFLG=0
      TAU1(1)=Z0
  110 CALL APT232(NUMBER,TOLRNS,TAU2,-Z1)
C---    OUTPUT PART PROGRAM COMMAND ON EXFILE
C
  400 CONTINUE
      IPPWRD(1)=BCDF(PPWORD(ICASE)(1:4))
      IPPWRD(2)=BCDF(PPWORD(ICASE)(5:6))
      CALL APT299(NUMBER,IPPWRD,1,TOLRNS(1))
      IF(NUMBER.LE.1) GO TO 999
      DO 30 J=2,NUMBER,2
       IF(J.NE.NUMBER) THEN
         CALL APT299(1,TOLRNS(J),1,TOLRNS(J+1))
       ELSE
         CALL APT299(1,TOLRNS(J),0,Z0)
       ENDIF
   30 CONTINUE
      GO TO 999
      END
C
C
C
C
C.....FORTRAN SUBROUTINE  ....OUTTOL         8/68                    PH
C.....FORTRAN SUBROUTINE            OUTTOL....              3/1/68   GK
      SUBROUTINE OUTTOL(NMBR,TLRNS)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
      COMMON /HSAVE/ SAVEH(50)
      DIMENSION TOLRNS(4)
      EQUIVALENCE  (SAVEH( 1),TOLRNS(1)),(SAVEH(5),NUMBER)
      DIMENSION TLRNS(4)
      CHARACTER*6 PPWORD
      DIMENSION PPWORD(3),ITHVAL(3),IPPWRD(2)
      INTEGER BCDF
C
      DATA PPWORD/'INTOL ','OUTTOL','TOLER '/
      DATA ITHVAL/  8     ,  9     ,  4     /
C
C
C
      ICASE=2
C
      DO 5 I=1,4
    5 TOLRNS(I)=TLRNS(I)
      NUMBER=NMBR
      IF(JHLDFG.EQ.0) GO TO 200
      ITABH(ITHCNT)=ITHVAL(ICASE)
      ITHCNT=ITHCNT+1
  999 RETURN
C
C
C---    OUTTOL, MAXDEVIATION SPECIFD ON CUTTER SIDE OF SURFACE
  200 CONTINUE
      IF(IBTFLG.LT.0) IBTFLG=0
  210 CONTINUE
      CALL APT232(NUMBER,TOLRNS,TAU1,Z1)
C
      IPPWRD(1)=BCDF(PPWORD(ICASE)(1:4))
      IPPWRD(2)=BCDF(PPWORD(ICASE)(5:6))
      CALL APT299(NUMBER,IPPWRD,1,TOLRNS(1))
      IF(NUMBER.LE.1) GO TO 999
      DO 30 J=2,NUMBER,2
       IF(J.NE.NUMBER) THEN
         CALL APT299(1,TOLRNS(J),1,TOLRNS(J+1))
       ELSE
         CALL APT299(1,TOLRNS(J),0,Z0)
       ENDIF
   30 CONTINUE
      GO TO 999
      END
C
C
C
C
C.....FORTRAN SUBROUTINE  ....TOLERH         8/68                    PH
C.....FORTRAN SUBROUTINE             TOLERH....             3/1/68   GK
      SUBROUTINE TOLERH(NMBR,TLRNS)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      COMMON /HSAVE/ SAVEH(50)
      DIMENSION TOLRNS(4)
      EQUIVALENCE  (SAVEH( 1),TOLRNS(1)),(SAVEH(5),NUMBER)
      CHARACTER*6 PPWORD
      DIMENSION PPWORD(3),IPPWRD(2)
      INTEGER BCDF
C
      DATA PPWORD/'INTOL ','OUTTOL','TOLER '/
C
C
C
      ICASE=3
C
C
C
C---    OUTTOL, MAX DEVIATION ZERO ON SIDE AWAY FROM CUTTER
      DO 350 I=1,NUMSFS
      TAU2(I)=Z0
  350 CONTINUE
C
      CALL APT232(NUMBER,TOLRNS,TAU1,Z1)
C
      IPPWRD(1)=BCDF(PPWORD(ICASE)(1:4))
      IPPWRD(2)=BCDF(PPWORD(ICASE)(5:6))
      CALL APT299(NUMBER,IPPWRD,1,TOLRNS(1))
      IF(NUMBER.LE.1) GO TO 999
      DO 30 J=2,NUMBER,2
       IF(J.NE.NUMBER) THEN
         CALL APT299(1,TOLRNS(J),1,TOLRNS(J+1))
       ELSE
         CALL APT299(1,TOLRNS(J),0,Z0)
       ENDIF
   30 CONTINUE
  999 RETURN
      END
C
C
C
C
C.....FORTRAN SUBROUTINE  ....INTOLH         8/68                    PH
C.....FORTRAN SUBROUTINE             INTOLH...              3/1/68   GK
      SUBROUTINE INTOLH(NMBR,TLRNS)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      COMMON /HSAVE/ SAVEH(50)
      DIMENSION TOLRNS(4)
      EQUIVALENCE  (SAVEH( 1),TOLRNS(1)),(SAVEH(5),NUMBER)
      CHARACTER*6 PPWORD
      DIMENSION PPWORD(3),IPPWRD(2)
      INTEGER BCDF
C
      DATA PPWORD/'INTOL ','OUTTOL','TOLER '/
C
C
C
      ICASE=1
C
C
C---    INTOL, MAX DEVIATION SPECFD ON SIDE OF SURF AWAY FROM CUTTER
  100 CONTINUE
      IF(IBTFLG.GE.0) GO TO 110
      IBTFLG=0
      TAU1(1)=Z0
  110 CALL APT232(NUMBER,TOLRNS,TAU2,-Z1)
C---    OUTPUT PART PROGRAM COMMAND ON EXFILE
C
  400 CONTINUE
      IPPWRD(1)=BCDF(PPWORD(ICASE)(1:4))
      IPPWRD(2)=BCDF(PPWORD(ICASE)(5:6))
      CALL APT299(NUMBER,IPPWRD,1,TOLRNS(1))
      IF(NUMBER.LE.1) GO TO 999
      DO 30 J=2,NUMBER,2
       IF(J.NE.NUMBER) THEN
         CALL APT299(1,TOLRNS(J),1,TOLRNS(J+1))
       ELSE
         CALL APT299(1,TOLRNS(J),0,Z0)
       ENDIF
   30 CONTINUE
  999 RETURN
      END
C
C
C
C
C.....FORTRAN SUBROUTINE  ....OUTTOH         8/68                    PH
C.....FORTRAN SUBROUTINE            OUTTOH....              3/1/68   GK
      SUBROUTINE OUTTOH(NMBR,TLRNS)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
      COMMON /HSAVE/ SAVEH(50)
      DIMENSION TOLRNS(4)
      EQUIVALENCE  (SAVEH( 1),TOLRNS(1)),(SAVEH(5),NUMBER)
      CHARACTER*6 PPWORD
      DIMENSION PPWORD(3),IPPWRD(2)
      INTEGER BCDF
C
      DATA PPWORD/'INTOL ','OUTTOL','TOLER '/
C
C
C
      ICASE=2
C
C---    OUTTOL, MAXDEVIATION SPECIFD ON CUTTER SIDE OF SURFACE
  200 CONTINUE
      IF(IBTFLG.LT.0) IBTFLG=0
  210 CONTINUE
      CALL APT232(NUMBER,TOLRNS,TAU1,Z1)
C
      IPPWRD(1)=BCDF(PPWORD(ICASE)(1:4))
      IPPWRD(2)=BCDF(PPWORD(ICASE)(5:6))
      CALL APT299(NUMBER,IPPWRD,1,TOLRNS(1))
      IF(NUMBER.LE.1) GO TO 999
      DO 30 J=2,NUMBER,2
       IF(J.NE.NUMBER) THEN
         CALL APT299(1,TOLRNS(J),1,TOLRNS(J+1))
       ELSE
         CALL APT299(1,TOLRNS(J),0,Z0)
       ENDIF
   30 CONTINUE
  999 RETURN
      END
