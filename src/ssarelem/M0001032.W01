*
      SUBROUTINE APRIX(DU,DV,DT,SPV,TP,TN,MODE,ILEV,IRR,IDEBUG)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---      PURPOSE IS TO COMPUTE INTERSECTION BETWEEN SURFACE
C---      DIFFERENTIAL FORM AND EXTERNAL TOOL RAY.
C--- INPUT U,V   FOR REFERENCE ONLY, CURRENT SURFACE PARAMETRIC COORDS.
C--- INPUT SPV   SURFACE POINT SPV 1-3, SPV-U 5-7, SPV-V 9-11,
C---             SPV-UU 13-15, SPV-UV 17-19, SPV-VV 21-23,
C---             SPV- SPU-U X SPV-V 25-27, SPV UNIT NORMAL 29-31
C--- INPUT TP    CURRENT EXTERIOR (TOOL) POINT
C--- INPUT TN    IF MODE.NE.0, TN IS THE TOOL RAY VECTOR
C--- INPUT MODE  IF MODE.EQ.0, COMPUTE CLOSEST POINT TO TP.
C---       MODE  IF MODE.NE.0 COMPUTE CLOSEST POINT(INTERSECTION) WITH
C--              TOOL RAY FROM POINT TP IN DIRECTION TN.
C--- INPUT ILEV  CONTROLS WHICH PHASES OF APRIX ARE USED
C---       ILEV.LE.1 MEANS QUIT AFTER PHASE 1.
C---       ILEV.EQ.2 MEANS DO BOTH PHASE 1 AND PHASE 2
C---       ILEV.GE.3 MEANS USE DU,DV AS INPUT AND GO TO PHASE 2.
C--- OUTPUT DU,DV SUGGESTED CHANGE IN U,V TO PROVIDE ANSWER
C--- OUTPUT DT    IF MODE.NE.0, DT IS THE SCALAR TP+DT*TN FOR RAY INTERS
C--- OUTPUT IRR  ERROR CODE.  IF IRR.EQ.0, THEN NO ERROR OCCURRED.
C--- OUTPUT IDEBUG IF NOT ZERO, THEN PRINT DEBUGGING OUTPUT
C
      DIMENSION SPV(32),TP(3),TN(3)
      DIMENSION DIF(3),AU(3),AV(3),AT(3),AC(3)
      DIMENSION VEC(3),VECU(3),VECV(3)
      CHARACTER*20 BADMSG
C
      DATA ZERO,ONE,TWO,VSMAL/0.0D0,1.0D0,2.0D0,1.0D-20/
C---      ERGOOD IS THE FACTOR FOR IMPROVEMENT IN ERROR WHICH IS
C---      NECESSARY TO CONTINUE WITH THE SECOND ORDER ITERATION.
      DATA ERGOOD/0.8D0/
C---      MAXIMUM NUMBER OF SECOND ORDER ITERATIONS ALLOWED
      DATA MXCT/15/,ERCHK/0.05D0/,DISCK/0.0008D0/
C---      ERCHK2 IS A MORE LIBERAL ACCEPTANCE CRITERIA FOR
C---      SECOND ORDER ITERATION ERROR THAN ERCHK.
      DATA ERCHK2/0.15D0/
      DATA BIG0,BIG/1.0D+13,1.0D+19/
C
C
      IF(IDEBUG.EQ.0) GO TO 5
      CALL BAD(-1,0,' ',0)
      BADMSG=' ENTRY TO APRIX'
      CALL CPRINT(BADMSG)
      CALL BAD(1,0,'ILEV',ILEV)
      CALL BAD(1,0,'MODE',MODE)
      CALL BAD(1,1,'DU  ',DU)
      CALL BAD(-1,1,'DV  ',DV)
    5 CONTINUE
C
      IRR=0
      DO 10 I=1,3
      DIF(I)=TP(I)-SPV(I)
   10 CONTINUE
C
      IF(ILEV.GE.3) GO TO 200
C---      DETERMINE DU,DV,DT SO THAT
C---  (SPV+DU*SPV-U +DV*SPV-V - TP -DT*TN) **2 = MINIMUM.
C
      CALL DOTV(AU(1),SPV(5),SPV(5))
      CALL DOTV(AU(2),SPV(5),SPV(9))
      AV(1)=AU(2)
      CALL DOTV(AV(2),SPV(9),SPV(9))
      CALL DOTV(AC(1),DIF,SPV(5))
      CALL DOTV(AC(2),DIF,SPV(9))
C---      CONTINUE WITH FURTHER COEFFICIENT CALCULATION IF MODE.NE.0
      IF(MODE.NE.0) GO TO 50
C---       FIRST COMPLETE 3X3 COEFFICIENTS
      AU(3)=ZERO
      AV(3)=ZERO
      DO 20 I=1,3
   20 AT(I)=ZERO
      AC(3)=ZERO
C---      FIND CLOSEST POINT BETWEEN TP AND SPV+DU*SPU+DV*SPV.
      DISC=AU(1)*AV(2)-AU(2)**2
      IRR=1
      IF(DABS(DISC).LT.VSMAL) GO TO 1000
      DU=(AC(1)*AV(2)-AC(2)*AV(1))/DISC
      DV=(AU(1)*AC(2)-AU(2)*AC(1))/DISC
      DT=ZERO
      GO TO 100
C
   50 CONTINUE
C---      CALCULATE 3 X 3 COEFFICIENTS FOR SPV+DU*SPU+DV*SPV-TP-DT*TN=MI
      CALL DOTV(AU(3),SPV(5),TN)
      CALL DOTV(AV(3),SPV(9),TN)
      AT(1)=-AU(3)
      AT(2)=-AV(3)
      CALL DOTV(AT(3),TN,TN)
      AT(3)=-AT(3)
      CALL DOTV(AC(3),DIF,TN)
C
      DISC=DET3(AU,AV,AT)
      IRR=2
      IF(DABS(DISC).LT.VSMAL) GO TO 1000
C
      DU=DET3(AC,AV,AT)/DISC
      DV=DET3(AU,AC,AT)/DISC
      DT=DET3(AU,AV,AC)/DISC
C
  100 CONTINUE
C
      IF(IDEBUG.EQ.0) GO TO 110
      CALL BAD(1,1,'DU  ',DU)
      CALL BAD(1,1,'DV  ',DV)
      CALL BAD(1,1,'DT  ',DT)
      CALL BAD(1,1,'DISC',DISC)
      CALL BAD(-1,0,' ',0)
      BADMSG=' EXIT FROM APRIX'
      CALL CPRINT(BADMSG)
  110 CONTINUE
C---      IF DU,DV, OR DT ARE TOO LARGE, TEHN AVOID 2ND ORDER CALCULATIO
C---      AVOID A POSSIBLE OVERFLOW CONDITION
      IF(DABS(DU)+DABS(DV)+DABS(DT).GT.BIG0) GO TO 2000
C
C
      IF(ILEV.LE.1) GO TO 2000
C
  200 CONTINUE
C---      BEGIN SECOND PHASE OF APRIX ALGORITHM
C
C---      FOLLOW 1ST ORDER SOLN WITH 2ND ORDER NEWTON RAPHSON ITERATION
C---   (SP+DU*SPU+DV*SPV+DU**2*SPUU/2+DU*DV*SPUV+DV**2*SPVV-TP-DT*TN)**2
C---    SHOULD BE REPETITIVELY EVALUATED TO REACH A MINIMUM.
C---    ABOVE EXPRESSION IS CALLED W(DU,DV,DT)=VEC(DU,DV,DT)**2
C
      EU=DU
      EV=DV
      ET=DT
      ICT=0
C
  210 CONTINUE
C---      COMPUTE COEFFICIENTS FOR EFFICIENCY
      EUSQ=EU**2/TWO
      EUV=EU*EV
      EVSQ=EV**2/TWO
C
      ICT=ICT+1
      IF(ICT.LE.MXCT) GO TO 300
C---      MXCT EXCEEDED, ERROR IF ILEV IS GE 3
      IRR=3
      IF(ILEV.GE.3) GO TO 1000
C---      MXCT EXCEEDED, ACCEPT LINEAR ESTIMATE
      EU=DU
      EV=DV
      ET=DT
      GO TO 400
C
  300 CONTINUE
C---      EVALUATE VEC-U,VEC-V, VEC-UU ETC.
      DO 310 I=1,3
      VEC(I)=-DIF(I)+EU*SPV(4+I)+EV*SPV(8+I)+EUSQ*SPV(12+I)
     X       +EUV*SPV(16+I)+EVSQ*SPV(20+I)-ET*TN(I)
      VECU(I)=SPV(4+I)+EU*SPV(12+I)+EV*SPV(16+I)
      VECV(I)=SPV(8+I)+EU*SPV(16+I)+EV*SPV(20+I)
C---      VECUU=SPV(12+I)=SPUU
C---      VECUV=SPV(16+I)=SPUV
C---      VECVV=SPV(20+I)=SPVV
C---      VECTU=VECTV=VECTT=0
  310 CONTINUE
C
C---      W(DU,DV,DT)=VEC(DU,DV,DT)**2
C---      COMPUTE ALL 2ND ORDER PARTIALS OF W FROM VEC AND VEC PARTIALS
C
      DO 320 I=1,3
      AU(I)=ZERO
      AV(I)=ZERO
      AT(I)=ZERO
      AC(I)=ZERO
  320 CONTINUE
C
      CALL DOTV(WVAL,VEC,VEC)
      WVAL=DSQRT(WVAL)
      IF(IDEBUG.EQ.0) GO TO 322
      CALL BAD(1,1,'DIST',WVAL)
      CALL BAD(-3,1,'TPSP',VEC)
  322 CONTINUE
      CALL DOTV(AC(1),VEC,VECU)
      CALL DOTV(AC(2),VEC,VECV)
      AC(1)=-AC(1)
      AC(2)=-AC(2)
      CALL DOTV(TEMP,VECU,VECU)
      CALL DOTV(AU(1),VEC,SPV(13))
      AU(1)=AU(1)+TEMP
      CALL DOTV(TEMP,VECU,VECV)
      CALL DOTV(AU(2),VEC,SPV(17))
      AU(2)=AU(2)+TEMP
      AV(1)=AU(2)
      CALL DOTV(TEMP,VECV,VECV)
      CALL DOTV(AV(2),VEC,SPV(21))
      AV(2)=AV(2)+TEMP
C---      TERMINATE 2ND ORDER ALGORITHM IF ANY COEFFICIENT IS LARGE
      IF(DABS(AC(1)).GT.BIG) GO TO 2000
      IF(DABS(AC(2)).GT.BIG) GO TO 2000
C---      COEFFICIENTS ARE COMPLETE FOR 2X2 CASE, I.E. MODE.EQ.0
      IF(MODE.NE.0) GO TO 330
C
      DISC=AU(1)*AV(2)-AU(2)**2
C---      IF DISC IS TOO SMALL ACCEPT FIRST ORDER ANSWER
      IF(DISC.LT.DISCK) GO TO 410
      FU=(AC(1)*AV(2)-AC(2)*AV(1))/DISC
      FV=(AU(1)*AC(2)-AU(2)*AC(1))/DISC
      FT=ZERO
      GO TO 360
C---      COMPLETE COEFFICIENT CALCULATION FOR 3X3 CASE
  330 CONTINUE
      CALL DOTV(AC(3),VEC,TN)
C---      TERMINATE SECOND ORDER PROCESS IF COEFFICIENT IS TOO LARGE
      IF(DABS(AC(3)).GT.BIG) GO TO 2000
      CALL DOTV(AU(3),TN,VECU)
      AU(3)=-AU(3)
      CALL DOTV(AV(3),TN,VECV)
      AV(3)=-AV(3)
      AT(1)=AU(3)
      AT(2)=AV(3)
      CALL DOTV(AT(3),TN,TN)
C---      NOW USE NEWTON RAPHSON FORMULA TO ALTER EU,EV,ET TO MIN W.
C---      EQUATIONS TAKE THE FORM
C---      WU(NXT)=0-WU(NOW)=FU*WUU+FV*WUV+FT*WUT
C---      WV(NXT)=0-WV(NOW)=FU*WUV+FV*WVV+FT*WVT
C---      WT(NXT)=0-WT(NOW)=FU*WUT+FV*WVT+FT*WTT
C---      THEN EU=EU+FU, EV=EV+FV, ET=ET+FT.
C
      DISC=DET3(AU,AV,AT)
C---      IF DISC IS SMALL, THEN ACCEPT LAST GOOD DU,DV,DT
      IF(DISC.LT.DISCK) GO TO 410
      FU=DET3(AC,AV,AT)/DISC
      FV=DET3(AU,AC,AT)/DISC
      FT=DET3(AU,AV,AC)/DISC
C
  360 CONTINUE
C---      COMPARE CURRENT FU,FV,FT AND LAST EU,EV,ET
C---      IF CHANGE IS SMALL, THEN QUIT
      TEMP=DABS(EU)+DABS(EV)+DABS(ET)
      IF ((ICT.EQ.1).AND.(ILEV.GE.3)) TEMP=ONE
      IF(TEMP.LT.VSMAL) GO TO 400
C
      ERRAT=(DABS(FU)+DABS(FV)+DABS(FT))/TEMP
      EU=EU+FU
      EV=EV+FV
      ET=ET+FT
C
      IF(IDEBUG.EQ.0) GO TO 370
      CALL BAD(1,1,'EU  ',EU)
      CALL BAD(1,1,'EV  ',EV)
      CALL BAD(1,1,'ET  ',ET)
      CALL BAD(1,1,'ERAT',ERRAT)
      CALL BAD(-1,0,'ICT ',ICT)
      CALL BAD(1,1,'DISC',DISC)
      CALL BAD(-3,1,'AC  ',AC)
  370 CONTINUE
      IF (ILEV.GT.3) GOTO 400
      IF(ERRAT.LT.ERCHK) GO TO 400
C---      CHECK FOR DEFINITE REDUCTION OF ERROR, OTHERWISE QUIT
      IF(ICT.EQ.3) ERRLAS=ERRAT
      IF(ICT.LT.4) GO TO 210
      IF(ERRAT/ERRLAS.GT.ERGOOD) GO TO 2000
      ERRLAS=ERRAT
C---      NOT CLOSE ENOUGH, SO SAVE FU,FV,FT AND REPEAT N-R ITERATION
      GO TO 210
C
  410 CONTINUE
C---      DECIDE WHETHER TO ACCEPT SECOND ORDER ITERATION
      IF(ICT.LT.2.OR.ERRAT.GT.ERCHK2) GO TO 2000
  400 CONTINUE
      DU=EU
      DV=EV
      DT=ET
 2000 CONTINUE
      IRR=0
C
      GO TO 9999
C
 1000 CONTINUE
C---      ERROR EXIT
C
 9999 CONTINUE
C
      IF(IDEBUG.EQ.0) GO TO 2010
      CALL BAD(1,0,'IRR ',IRR)
      CALL BAD(1,1,'DU  ',DU)
      CALL BAD(1,1,'DV  ',DV)
      CALL BAD(1,1,'DT  ',DT)
      CALL BAD(-1,1,'DISC',DISC)
 2010 CONTINUE
C
      RETURN
      END
