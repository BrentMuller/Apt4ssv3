**** SOURCE FILE : M0004316.W03   ***
*
      SUBROUTINE DDSSRF(SS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------ BEGIN SCULPTURED SURFACE TOOL RAY INTERSECTION ALGORITHM
      DIMENSION SS(*)
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
C
C
      COMMON/MODESS/MODESS,MSSCHK,MSSARL
C
      COMMON/IDDST/IDDST
C
      COMMON/IBUGG/IBUG,I1,I2
C
      COMMON/SSARLM/B(64,4),U(4),V(4),ITOP(6,4,4),IFLAG(4,4),IPNUM(4),
     X              ISEQLS,NLAST,MCAT,
     X              IDDLAS(4),JENLAS(4),LODFLG(4),
     X              NCALMX,NCMX
C
      INCLUDE 'CHEKFL.INC'
C
      DIMENSION DIF(3)
C
      DIMENSION SPSAV(3),DSAV(3)
C
      DATA ZERO,ONE,SMAL/0.D0,1.D0,1.D-12/
      DATA Z5EM1/0.5D0/,ZM5EM1/-0.5D0/
C
      IAERR=0
      LOD63=0
      IDEBUG=0
      IDEBUX=0
      IF(IBUG.EQ.1.OR.IBUG.EQ.2) IDEBUG=1
      IF(IBUG.EQ.2) IDEBUX=1
C
C
      NLAST=NLAST+1
      IP=IS-1
C             /-SAVE UV,PATCH NUMBER IN CASE OF TROUBLE
      USAVE=U(IP)
      VSAVE=V(IP)
      IPSAVE=IPNUM(IP)
C             /-SAVE OLD SP VALUE
      DO 8 I=1,3
    8 SPSAV(I)=SP(I,IS)
      IF(ISEQLS.EQ.ISEQNO) GO TO 20
C             /-RESET INITIALIZING DATA FOR ALL SURFACES FOR NEW STATEME
      DO 30 I=1,4
   30 LODFLG(I)=1
   20 CONTINUE
      IF(JENT(IS).EQ.1.AND.JENLAS(IP).EQ.0) LODFLG(IP)=1
C             /-SET COUNT OF NUMBER OR RETRY-S WITHIN DDSSRF
      KRETRY=0
C
C             /-NLAST RECORDS TOTAL NUMBER OF CALLS TO DDSSRF
C             /-NCALMX IS NUMBER OF CALLS SINCE LAST CUT VECTOR
C             /-NCMX IS MAX NUMBER OF CALLS ALLOWED FOR ONE CUT VECTOR
C             /-ICLCUR IS NUMBER OF CURRENT CL POINT IN CUT RECORD
C             /-MCAT IS LAST VALUE OF ICLCUR ON EXIT FROM DDSSRF
      ICLCUR=NMPNTS-NUMPT1+1
      IF(ICLCUR.NE.MCAT) NCALMX=0
C             /-RESET NUMBER OF CALLS FOR NEW DS
      IF(JENLAS(IP).EQ.0.AND.JENT(IS).EQ.1) NCALMX=0
      NCALMX=NCALMX+1
      IF(NCALMX.GT.NCMX) IAERR=25403
      IF(IAERR.NE.0) GO TO 999
C
      IF(IDEBUG.LE.0) GO TO 40
      CALL BAD(-1,0,'DSRF',NLAST)
      CALL BAD(1,0,'ISEQ',ISEQNO)
      CALL BAD(1,0,'CLPT',ICLCUR)
      CALL BAD(1,0,'MODS',MODESS)
      CALL BAD(1,0,'MSCK',MSSCHK)
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(-1,0,'DDST',IDDST)
      CALL BAD(1,0,'JTN ',JTN(IS))
      CALL BAD(1,0,'MDIC',MDIC)
      CALL BAD(1,0,'INDR',INDIR(IS))
      CALL BAD(-3,1,'TE  ',TE (1))
      CALL BAD(3,1,'TP  ',TP(1,IS))
      CALL BAD(-3,1,'TN  ',TN(1,IS))
   40 CONTINUE
C
C             /-SET MODE FOR DD CALCULATION- USE SNXP WITH MODE=0,
C             /-OR ELSE USE DDST WITH MODE=-1
C             /-FOR VERY FIRST ENTRY USE MODE=0
      MODE=-1
      IF(MDIC.GT.0) GO TO 50
      IF(INDIR(IS).EQ.1.AND.ISTRUP.NE.0.AND.JENT(IS).EQ.1) GO TO 50
      IF(MSSCHK.EQ.0.AND.MODESS.NE.11) GO TO 50
C             /-SET MODE TO SNXP IF ABOVE CONDITIONS DO NOT EXIST
      MODE=0
   50 CONTINUE
C
C             /-INITIAL PHASE, SCAN SURFACE FOR BEST CANDIDATE
C             /-THIS IS USED FOR ERROR RESTART OR INITIAL PROCESSING
C             /-LOAD INITIAL PATCH IF DDST MODE OR MODE HAS CHANGED
      IF(IDDLAS(IP).NE.IDDST) GO TO 63
C             /-DO NOT LOAD IF LODFLG IS ZERO AND MDIC IS ZERO
      IF(LODFLG(IP).EQ.0.AND.MDIC.EQ.0) GO TO 60
   63 CONTINUE
C             /-LOAD A PATCH DURING ERROR PROCESSING OR INITIAL PROCESSI
C
      CALL LODINT(SS,B(1,IP),U(IP),V(IP),TP(1,IS),TN(1,IS),
     X            IFLAG(1,IP),ITOP(1,1,IP),IPNUM(IP),MODE)
      IF(IDEBUG.LE.0) GO TO 66
      CALL BAD(1,0,'LODI',MODE)
      CALL BAD(1,1,'UIP ',U(IP))
      CALL BAD(-1,1,'VIP ',V(IP))
   66 CONTINUE
C
C             /-TRUNCATE INITIAL U,V TO LIE INSIDE PATCH BOUNDARY
      CALL SQRCUT(Z5EM1,Z5EM1,U(IP),V(IP),UU,VV,ICKBN)
      U(IP)=Z5EM1+.9999D0*(UU-Z5EM1)
      V(IP)=Z5EM1+.9999D0*(VV-Z5EM1)
   80 CONTINUE
      LODFLG(IP)=0
      IF(IDEBUG.LE.0) GO TO 70
      CALL BAD(1,0,'LINT',IPNUM(IP))
      CALL BAD(1,0,'ICKB',ICKBN)
      CALL BAD(1,1,'UU  ',UU)
      CALL BAD(-1,1,'VV  ',VV)
   70 CONTINUE
C
   60 CONTINUE
C
C             /-CALL THE MAIN ALGORITHM FOR DETERMINING THE RELATION
C             /-BETWEEN THE SURFACE AND EXTERIOR POINT OR TOOL RAY
C...CALL PCHPRC.  LAST PARAMETER .FALSE. FOR NO GEOMETRIC CONSTRUCTION
C
      CALL PCHPRC( SS,B(1,IP),U(IP),V(IP),
     1         TP(1,IS),TN(1,IS),UA,VA,
     2         SP(1,IS),SN(1,IS),SLX(1,IS),
     3         IFLAG(1,IP),ITOP(1,1,IP),IPNUM(IP),
     4         MODE,IDEBUX,IRR,.FALSE.)
C
      IF(IDEBUG.LE.0) GO TO 100
      CALL BAD(1,0,'PCHP',IRR)
      CALL BAD(1,0,'MODE',MODE)
      CALL BAD(1,0,'PCNO',IPNUM(IP))
      CALL BAD(1,1,'UA  ',UA)
      CALL BAD(-1,1,'VA  ',VA)
      CALL BAD(3,1,'SP  ',SP(1,IS))
      CALL BAD(-3,1,'SN  ',SN(1,IS))
  100 CONTINUE
C
      IF(IRR.NE.0) GO TO 800
C
C
      IF ( (ICHEKF.NE.1).OR.(LOD63.EQ.1)) THEN
        CONTINUE
      ELSE
        LOD63=1
        DO 109 I=1,3
          DIF(I) = SP(I,IS) - TP(I,IS)
  109   CONTINUE
        CALL DOTF(DCK,TI,DIF)
        IF (DCK.LT.ZM5EM1) GOTO 63
      ENDIF
C             /-CHECK FURTHER TO SEE WHETHER U,V ARE VALID
      NOPATC=SS(4)
      IRR=0
      IF(IPNUM(IP).LT.1.OR.IPNUM(IP).GT.NOPATC) GO TO 70
C---  DOUBLE CHECK TO SEE IF UA,VA ARE ON A LEGAL EXTENSION
      IUR=2
      IF(UA.LT.ZERO) IUR=1
      IF(UA.GT.ONE) IUR=3
      IVR=2
      IF(VA.LT.ZERO) IVR=1
      IF(VA.GT.ONE) IVR=3
      ISQNO=IUR+3*(IVR-1)
C---  IF UA,VA ARE INSIDE THE PATCH BOUNDS ITS O.K.
      IF(ISEQNO.EQ.5.AND.IP.EQ.K1) IPCHN=0
      IF(ISQNO.EQ.5) GO TO 230
      IF(MOD(ISQNO,2).NE.0) GO TO 240
C---  UA,VA IS ON EXT DIRECTLY OPPOSITE A BOUNDARY
      IB1  =ISQNO/2
C---  CHECK IF A PATCH IS HOOKED TO THIS BOUNDARY
      IF(ITOP(2,IB1  ,IP).EQ.0) GO TO 230
      IRR=2
      GO TO 230
  240 CONTINUE
C---  UA,VA ARE ON A CORNER EXTENSION, CHECK TWO BOUNDARIES
      IB1=1
      IB2=2
      IF(ISQNO.EQ.7) IB1=4
      IF(ISQNO.EQ.3) IB2=3
      IF(ISQNO.EQ.9) IB1=4
      IF(ISQNO.EQ.9) IB2=3
C---  IB1,IB2 ARE THE BOUNDARIES, CHECK IF EITHER HAS A PATCH
      IF(ITOP(2,IB1,IP).EQ.0.AND.ITOP(2,IB2,IP).EQ.0) GO TO 230
      IRR=3
  230 CONTINUE
C
      IF(IRR.EQ.0.OR.IDEBUG.LE.0) GO TO 885
      CALL RECORD(II)
      CALL BAD(1,0,'ISEQ',II)
      CALL BAD(1,0,'IRR ',IRR)
      CALL BAD(1,0,'IPNM',IPNUM(IP))
      CALL BAD(1,1,'U   ',U(IP))
      CALL BAD(-1,1,'V   ',V(IP))
      CALL BAD(1,0,'ISQN',ISQNO)
      CALL BAD(1,1,'UA  ',UA)
      CALL BAD(-1,1,'VA  ',VA)
      DO 825 LL=1,4
      CALL BAD(1,0,'ITOP',ITOP(2,LL,IP))
  825 CONTINUE
      CALL BAD(-1,0,' ',0)
  885 CONTINUE
C             /-QUIT IF IRR IS  NOT ZERO NOW
      IF(IRR.NE.0) GO TO 800
      IER=0
C             /-SET TN ONLY IF MODE=0 AND MODESS.NE.11(Z DETERMINATION)
      IF(MODE.NE.0) GO TO 310
      W1=ONE
      IF(JTN(IS).EQ.0) W1=-ONE
      W1=W1*Z(IS)
      DO 320 I=1,3
      TN(I,IS)=W1*SN(I,IS)
  320 CONTINUE
  310 CONTINUE
      DO 300 I=1,3
      TEMP(I)=SP(I,IS)-TP(I,IS)
  300 CONTINUE
C             /-MODIFY TN FOR CASE OF MODESS.EQ.11
      IF(MODESS.NE.11) GO TO 330
      CALL DOTF(W1,TN(1,IS),TEMP)
      IF(W1.GE.ZERO) GO TO 330
C             /-REVERSE TN TO POINT TOWARD SP
      DO 360 I=1,3
      TN(I,IS)=-TN(I,IS)
  360 CONTINUE
  330 CONTINUE
      CALL DOTF(S(IS),TEMP(1),TEMP(1))
      S(IS)=DSQRT(S(IS))
      CALL DOTF(W1,TEMP,TN(1,IS))
      S(IS)=DSIGN(ONE,W1)*S(IS)
C
      U(IP)=UA
      V(IP)=VA
C             /-SET THE VALUE OF THE LAST SURFACE POINT
      IEQUAL=1
      DO 410 I=1,3
      W1=SP(I,IS)-SPSAV(I)
      IF(DABS(W1).GT.SMAL) IEQUAL=0
  410 CONTINUE
C             /-IF SPSAV IS DIFFERENT AND MODESS.NE.11, SET SPL=SPSAV
      IF(IEQUAL.EQ.1.OR.MODESS.EQ.11) GO TO 420
      DO 430 I=1,3
  430 SPL(I,IS)=SPSAV(I)
      GO TO 999
  420 CONTINUE
      DO 440 I=1,3
  440 SPL(I,IS)=SPSAV(I)
C
      GO TO 999
C
C             /-ERROR PROCESSING
  800 CONTINUE
      KRETRY=KRETRY+1
      IF(KRETRY.EQ.1) GO TO 340
C.... ACCEPT SURFACE POINT
C.... IF DISTANCE BETWEEN CUTTER AND SP IS LARGE (DIST.GE.10)
C.... AND DISTANCE TO PATCH BOUNDARY IS SMALL (UVDIST.LE.0.05)
      IF ((DIST.GE.10.D0).AND.(UVDIST.LE.0.05D0)) THEN
        IRR=0
        GOTO 885
      ENDIF
      IF(KRETRY.EQ.2) GO TO 350
      GO TO 355
C             /-RELOAD INITIAL DATA AND RETRY
  340 CONTINUE
      U(IP)=USAVE
      V(IP)=VSAVE
      IPNUM(IP)=IPSAVE
C             /-BRANCH BACK TO LOAD INITIAL PATCH
      LODFLG(IP)=1-LODFLG(IP)
      IF (MODE.NE.0.OR.MODES.NE.11) GO TO 50
C     IF MODE=0, RETRY WITH NEW TE,TP
      DO 345 I=1,3
  345 DSAV(I)=TE(I)-TP(I,IS)
      CALL DOTV (W1,DSAV,DSAV)
      W1=DSQRT(W1)
      IF(DABS(W1).LT.SMAL) GO TO 355
      DO 346 I=1,3
      DSAV(I) =DSAV(I)/W1
  346 CONTINUE
      W1=0.5D0*W1
      DO 347 I=1,3
      TE(I)=TE(I)+W1*DSAV(I)
  347 TP(I,IS)=TP(I,IS)+W1*DSAV(I)
      GO TO 50
C
  350 CONTINUE
      IER=IRR
      IF(MODE.EQ.0) GO TO 355
      IER=0
      IF(IDDST.EQ.1) GO TO 999
      IER=0
      MODE=0
      MDIC=1
      GO TO 63
C
  355 CONTINUE
C             /- FATAL ERROR IN SNXP MODE
C                IF IBUG=1 OR 2, DO AGAIN TO GET DYDMP-LIST
      IF (IBUG.LE.0) GO TO 356
      IDEBUG=1
      IDEBUX=1
      GO TO 50
  356 IAERR=25402
      GO TO 999
  999 CONTINUE
      IF(IDEBUG.GT.0) CALL BAD(1,0,'IER ',IER)
      IF(IDEBUG.GT.0) CALL BAD(-1,0,'AERR',IAERR)
      MCAT=ICLCUR
      ISEQLS=ISEQNO
      IDDLAS(IP)=IDDST
      JENLAS(IP)=JENT(IS)
      IF(IAERR.NE.0)IBUG=0
      IF (IAERR.NE.0) IAER1=IAERR
      IF(IAERR.NE.0) CALL AERR(IAER1,'DDSSRF  ')
      RETURN
      END
**** SOURCE FILE : M0001032.W01   ***
*
      SUBROUTINE APRIX(DU,DV,DT,SPV,TP,TN,MODE,ILEV,IRR,IDEBUG)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---      PURPOSE IS TO COMPUTE INTERSECTION BETWEEN SURFACE
C---      DIFFERENTIAL FORM AND EXTERNAL TOOL RAY.
C--- INPUT U,V   FOR REFERENCE ONLY, CURRENT SURFACE PARAMETRIC COORDS.
C--- INPUT SPV   SURFACE POINT SPV 1-3, SPV-U 5-7, SPV-V 9-11,
C---             SPV-UU 13-15, SPV-UV 17-19, SPV-VV 21-23,
C---             SPV- SPU-U X SPV-V 25-27, SPV UNIT NORMAL 29-31
C--- INPUT TP    CURRENT EXTERIOR (TOOL) POINT
C--- INPUT TN    IF MODE.NE.0, TN IS THE TOOL RAY VECTOR
C--- INPUT MODE  IF MODE.EQ.0, COMPUTE CLOSEST POINT TO TP.
C---       MODE  IF MODE.NE.0 COMPUTE CLOSEST POINT(INTERSECTION) WITH
C--              TOOL RAY FROM POINT TP IN DIRECTION TN.
C--- INPUT ILEV  CONTROLS WHICH PHASES OF APRIX ARE USED
C---       ILEV.LE.1 MEANS QUIT AFTER PHASE 1.
C---       ILEV.EQ.2 MEANS DO BOTH PHASE 1 AND PHASE 2
C---       ILEV.GE.3 MEANS USE DU,DV AS INPUT AND GO TO PHASE 2.
C--- OUTPUT DU,DV SUGGESTED CHANGE IN U,V TO PROVIDE ANSWER
C--- OUTPUT DT    IF MODE.NE.0, DT IS THE SCALAR TP+DT*TN FOR RAY INTERS
C--- OUTPUT IRR  ERROR CODE.  IF IRR.EQ.0, THEN NO ERROR OCCURRED.
C--- OUTPUT IDEBUG IF NOT ZERO, THEN PRINT DEBUGGING OUTPUT
C
      DIMENSION SPV(32),TP(3),TN(3)
      DIMENSION DIF(3),AU(3),AV(3),AT(3),AC(3)
      DIMENSION VEC(3),VECU(3),VECV(3)
      CHARACTER*20 BADMSG
C
      DATA ZERO,ONE,TWO,VSMAL/0.0D0,1.0D0,2.0D0,1.0D-20/
C---      ERGOOD IS THE FACTOR FOR IMPROVEMENT IN ERROR WHICH IS
C---      NECESSARY TO CONTINUE WITH THE SECOND ORDER ITERATION.
      DATA ERGOOD/0.8D0/
C---      MAXIMUM NUMBER OF SECOND ORDER ITERATIONS ALLOWED
      DATA MXCT/15/,ERCHK/0.05D0/,DISCK/0.0008D0/
C---      ERCHK2 IS A MORE LIBERAL ACCEPTANCE CRITERIA FOR
C---      SECOND ORDER ITERATION ERROR THAN ERCHK.
      DATA ERCHK2/0.15D0/
      DATA BIG0,BIG/1.0D+13,1.0D+19/
C
C
      IF(IDEBUG.EQ.0) GO TO 5
      CALL BAD(-1,0,' ',0)
      BADMSG=' ENTRY TO APRIX'
      CALL CPRINT(BADMSG)
      CALL BAD(1,0,'ILEV',ILEV)
      CALL BAD(1,0,'MODE',MODE)
      CALL BAD(1,1,'DU  ',DU)
      CALL BAD(-1,1,'DV  ',DV)
    5 CONTINUE
C
      IRR=0
      DO 10 I=1,3
      DIF(I)=TP(I)-SPV(I)
   10 CONTINUE
C
      IF(ILEV.GE.3) GO TO 200
C---      DETERMINE DU,DV,DT SO THAT
C---  (SPV+DU*SPV-U +DV*SPV-V - TP -DT*TN) **2 = MINIMUM.
C
      CALL DOTV(AU(1),SPV(5),SPV(5))
      CALL DOTV(AU(2),SPV(5),SPV(9))
      AV(1)=AU(2)
      CALL DOTV(AV(2),SPV(9),SPV(9))
      CALL DOTV(AC(1),DIF,SPV(5))
      CALL DOTV(AC(2),DIF,SPV(9))
C---      CONTINUE WITH FURTHER COEFFICIENT CALCULATION IF MODE.NE.0
      IF(MODE.NE.0) GO TO 50
C---       FIRST COMPLETE 3X3 COEFFICIENTS
      AU(3)=ZERO
      AV(3)=ZERO
      DO 20 I=1,3
   20 AT(I)=ZERO
      AC(3)=ZERO
C---      FIND CLOSEST POINT BETWEEN TP AND SPV+DU*SPU+DV*SPV.
      DISC=AU(1)*AV(2)-AU(2)**2
      IRR=1
      IF(DABS(DISC).LT.VSMAL) GO TO 1000
      DU=(AC(1)*AV(2)-AC(2)*AV(1))/DISC
      DV=(AU(1)*AC(2)-AU(2)*AC(1))/DISC
      DT=ZERO
      GO TO 100
C
   50 CONTINUE
C---      CALCULATE 3 X 3 COEFFICIENTS FOR SPV+DU*SPU+DV*SPV-TP-DT*TN=MI
      CALL DOTV(AU(3),SPV(5),TN)
      CALL DOTV(AV(3),SPV(9),TN)
      AT(1)=-AU(3)
      AT(2)=-AV(3)
      CALL DOTV(AT(3),TN,TN)
      AT(3)=-AT(3)
      CALL DOTV(AC(3),DIF,TN)
C
      DISC=DET3(AU,AV,AT)
      IRR=2
      IF(DABS(DISC).LT.VSMAL) GO TO 1000
C
      DU=DET3(AC,AV,AT)/DISC
      DV=DET3(AU,AC,AT)/DISC
      DT=DET3(AU,AV,AC)/DISC
C
  100 CONTINUE
C
      IF(IDEBUG.EQ.0) GO TO 110
      CALL BAD(1,1,'DU  ',DU)
      CALL BAD(1,1,'DV  ',DV)
      CALL BAD(1,1,'DT  ',DT)
      CALL BAD(1,1,'DISC',DISC)
      CALL BAD(-1,0,' ',0)
      BADMSG=' EXIT FROM APRIX'
      CALL CPRINT(BADMSG)
  110 CONTINUE
C---      IF DU,DV, OR DT ARE TOO LARGE, TEHN AVOID 2ND ORDER CALCULATIO
C---      AVOID A POSSIBLE OVERFLOW CONDITION
      IF(DABS(DU)+DABS(DV)+DABS(DT).GT.BIG0) GO TO 2000
C
C
      IF(ILEV.LE.1) GO TO 2000
C
  200 CONTINUE
C---      BEGIN SECOND PHASE OF APRIX ALGORITHM
C
C---      FOLLOW 1ST ORDER SOLN WITH 2ND ORDER NEWTON RAPHSON ITERATION
C---   (SP+DU*SPU+DV*SPV+DU**2*SPUU/2+DU*DV*SPUV+DV**2*SPVV-TP-DT*TN)**2
C---    SHOULD BE REPETITIVELY EVALUATED TO REACH A MINIMUM.
C---    ABOVE EXPRESSION IS CALLED W(DU,DV,DT)=VEC(DU,DV,DT)**2
C
      EU=DU
      EV=DV
      ET=DT
      ICT=0
C
  210 CONTINUE
C---      COMPUTE COEFFICIENTS FOR EFFICIENCY
      EUSQ=EU**2/TWO
      EUV=EU*EV
      EVSQ=EV**2/TWO
C
      ICT=ICT+1
      IF(ICT.LE.MXCT) GO TO 300
C---      MXCT EXCEEDED, ERROR IF ILEV IS GE 3
      IRR=3
      IF(ILEV.GE.3) GO TO 1000
C---      MXCT EXCEEDED, ACCEPT LINEAR ESTIMATE
      EU=DU
      EV=DV
      ET=DT
      GO TO 400
C
  300 CONTINUE
C---      EVALUATE VEC-U,VEC-V, VEC-UU ETC.
      DO 310 I=1,3
      VEC(I)=-DIF(I)+EU*SPV(4+I)+EV*SPV(8+I)+EUSQ*SPV(12+I)
     X       +EUV*SPV(16+I)+EVSQ*SPV(20+I)-ET*TN(I)
      VECU(I)=SPV(4+I)+EU*SPV(12+I)+EV*SPV(16+I)
      VECV(I)=SPV(8+I)+EU*SPV(16+I)+EV*SPV(20+I)
C---      VECUU=SPV(12+I)=SPUU
C---      VECUV=SPV(16+I)=SPUV
C---      VECVV=SPV(20+I)=SPVV
C---      VECTU=VECTV=VECTT=0
  310 CONTINUE
C
C---      W(DU,DV,DT)=VEC(DU,DV,DT)**2
C---      COMPUTE ALL 2ND ORDER PARTIALS OF W FROM VEC AND VEC PARTIALS
C
      DO 320 I=1,3
      AU(I)=ZERO
      AV(I)=ZERO
      AT(I)=ZERO
      AC(I)=ZERO
  320 CONTINUE
C
      CALL DOTV(WVAL,VEC,VEC)
      WVAL=DSQRT(WVAL)
      IF(IDEBUG.EQ.0) GO TO 322
      CALL BAD(1,1,'DIST',WVAL)
      CALL BAD(-3,1,'TPSP',VEC)
  322 CONTINUE
      CALL DOTV(AC(1),VEC,VECU)
      CALL DOTV(AC(2),VEC,VECV)
      AC(1)=-AC(1)
      AC(2)=-AC(2)
      CALL DOTV(TEMP,VECU,VECU)
      CALL DOTV(AU(1),VEC,SPV(13))
      AU(1)=AU(1)+TEMP
      CALL DOTV(TEMP,VECU,VECV)
      CALL DOTV(AU(2),VEC,SPV(17))
      AU(2)=AU(2)+TEMP
      AV(1)=AU(2)
      CALL DOTV(TEMP,VECV,VECV)
      CALL DOTV(AV(2),VEC,SPV(21))
      AV(2)=AV(2)+TEMP
C---      TERMINATE 2ND ORDER ALGORITHM IF ANY COEFFICIENT IS LARGE
      IF(DABS(AC(1)).GT.BIG) GO TO 2000
      IF(DABS(AC(2)).GT.BIG) GO TO 2000
C---      COEFFICIENTS ARE COMPLETE FOR 2X2 CASE, I.E. MODE.EQ.0
      IF(MODE.NE.0) GO TO 330
C
      DISC=AU(1)*AV(2)-AU(2)**2
C---      IF DISC IS TOO SMALL ACCEPT FIRST ORDER ANSWER
      IF(DISC.LT.DISCK) GO TO 410
      FU=(AC(1)*AV(2)-AC(2)*AV(1))/DISC
      FV=(AU(1)*AC(2)-AU(2)*AC(1))/DISC
      FT=ZERO
      GO TO 360
C---      COMPLETE COEFFICIENT CALCULATION FOR 3X3 CASE
  330 CONTINUE
      CALL DOTV(AC(3),VEC,TN)
C---      TERMINATE SECOND ORDER PROCESS IF COEFFICIENT IS TOO LARGE
      IF(DABS(AC(3)).GT.BIG) GO TO 2000
      CALL DOTV(AU(3),TN,VECU)
      AU(3)=-AU(3)
      CALL DOTV(AV(3),TN,VECV)
      AV(3)=-AV(3)
      AT(1)=AU(3)
      AT(2)=AV(3)
      CALL DOTV(AT(3),TN,TN)
C---      NOW USE NEWTON RAPHSON FORMULA TO ALTER EU,EV,ET TO MIN W.
C---      EQUATIONS TAKE THE FORM
C---      WU(NXT)=0-WU(NOW)=FU*WUU+FV*WUV+FT*WUT
C---      WV(NXT)=0-WV(NOW)=FU*WUV+FV*WVV+FT*WVT
C---      WT(NXT)=0-WT(NOW)=FU*WUT+FV*WVT+FT*WTT
C---      THEN EU=EU+FU, EV=EV+FV, ET=ET+FT.
C
      DISC=DET3(AU,AV,AT)
C---      IF DISC IS SMALL, THEN ACCEPT LAST GOOD DU,DV,DT
      IF(DISC.LT.DISCK) GO TO 410
      FU=DET3(AC,AV,AT)/DISC
      FV=DET3(AU,AC,AT)/DISC
      FT=DET3(AU,AV,AC)/DISC
C
  360 CONTINUE
C---      COMPARE CURRENT FU,FV,FT AND LAST EU,EV,ET
C---      IF CHANGE IS SMALL, THEN QUIT
      TEMP=DABS(EU)+DABS(EV)+DABS(ET)
      IF ((ICT.EQ.1).AND.(ILEV.GE.3)) TEMP=ONE
      IF(TEMP.LT.VSMAL) GO TO 400
C
      ERRAT=(DABS(FU)+DABS(FV)+DABS(FT))/TEMP
      EU=EU+FU
      EV=EV+FV
      ET=ET+FT
C
      IF(IDEBUG.EQ.0) GO TO 370
      CALL BAD(1,1,'EU  ',EU)
      CALL BAD(1,1,'EV  ',EV)
      CALL BAD(1,1,'ET  ',ET)
      CALL BAD(1,1,'ERAT',ERRAT)
      CALL BAD(-1,0,'ICT ',ICT)
      CALL BAD(1,1,'DISC',DISC)
      CALL BAD(-3,1,'AC  ',AC)
  370 CONTINUE
      IF (ILEV.GT.3) GOTO 400
      IF(ERRAT.LT.ERCHK) GO TO 400
C---      CHECK FOR DEFINITE REDUCTION OF ERROR, OTHERWISE QUIT
      IF(ICT.EQ.3) ERRLAS=ERRAT
      IF(ICT.LT.4) GO TO 210
      IF(ERRAT/ERRLAS.GT.ERGOOD) GO TO 2000
      ERRLAS=ERRAT
C---      NOT CLOSE ENOUGH, SO SAVE FU,FV,FT AND REPEAT N-R ITERATION
      GO TO 210
C
  410 CONTINUE
C---      DECIDE WHETHER TO ACCEPT SECOND ORDER ITERATION
      IF(ICT.LT.2.OR.ERRAT.GT.ERCHK2) GO TO 2000
  400 CONTINUE
      DU=EU
      DV=EV
      DT=ET
 2000 CONTINUE
      IRR=0
C
      GO TO 9999
C
 1000 CONTINUE
C---      ERROR EXIT
C
 9999 CONTINUE
C
      IF(IDEBUG.EQ.0) GO TO 2010
      CALL BAD(1,0,'IRR ',IRR)
      CALL BAD(1,1,'DU  ',DU)
      CALL BAD(1,1,'DV  ',DV)
      CALL BAD(1,1,'DT  ',DT)
      CALL BAD(-1,1,'DISC',DISC)
 2010 CONTINUE
C
      RETURN
      END
**** SOURCE FILE : M0001047.V02   ***
*
      SUBROUTINE BONCHK(SS,B,U,V,IFLAG,ITOP,INUM,ICKBN,IDEBUG)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------ THIS PROGRAM CHECKS FOR A VALID BOUNDARY TRANSITION
C------ IF THE TRANSITION IS VALID, THE ROUTINE REPLACES THE
C------ CURRENT PATCH WITH A NEW ONE
C------ SS IS THE SCULPTURE SURFACE CANON ARRAY
C------ B,IFLAG,ITOP IS THE DEFINING DATA FOR THE CURRENT PATCH
C------ INUM IS THE NUMBER OF THE CURRENT PATCH RELATIVE TO SS
C------ ICKBN IS THE NUMBER OF THE BOUNDARY TO BE CHECKED
C------ U,V SHOULD BE PARAMETRIC COORDINATES ON THIS BOUNDARY
C------ IF THE TRANSITION IS VALID, ALL DATA EXCEPT SS SHOULD
C------ BE REPLACED ON TERMINATION OF THIS PROGRAM.
C------      FIRST CHECK TO SEE IF ANY PATCH AT ALL LIES ACROSS
C------      THIS BOUNDARY.
      DIMENSION B(64),IFLAG(4),ITOP(6,4)
      DIMENSION BT(64),IFLAGT(4),ITOPT(6,4)
      DIMENSION SS(*)
      DIMENSION SPV(4),CV(16),C(16)
      DATA SMAL,ONE,ZERO/1.0D-4,1.0D0,0.0D0/
C
      NP=ITOP(1,ICKBN)
      IF(ITOP(2,ICKBN).EQ.0) RETURN
C------ OTHERWISE CHECK EACH PATCH IN THE LIST
      DO 10 I=1,NP
      NCUR=ITOP(I+1,ICKBN)
      CALL LODPCH(SS,BT,IFLAGT,ITOPT,NCUR,3)
C------ CHECK THE TOPOLOGY TABLE OF NCUR FOR A MATCH WITH INUM
      DO 20 L=1,4
      NPT=ITOPT(1,L)
      IF(NPT.EQ.0) GO TO 20
      DO 30 K=1,NPT
      IF(ITOPT(K+1,L).EQ.INUM) GO TO 40
   30 CONTINUE
      GO TO 20
C------ IT IS CLEAR THAT PATCH NCUR S LTH BOUNDARY DOES LIE ON
C------ PATCH INUM S ICKBN-TH BOUNDARY.  THEREFORE, MAY A DETAILED
C------ COMPUTATION IF A CROSSOVER OCCURS AT U,V
C------ SPV IS COMPUTED AS THE CROSSOVER SPACE POINT
C------ IN CASE OF A MESH SURFACE, SKIP MOST OF THE TRANSFER LOGIC
   40 CONTINUE
      NMESH=SS(5)
      T=U
      IF((ICKBN-1)*(ICKBN-4).NE.0) T=V
C------ THEREFORE GENERATE THE NEW ACTIVE PATCH DATA
      INUM=NCUR
      DO 200 KK=1,64
      B(KK)=BT(KK)
  200 CONTINUE
      DO 210 KK=1,4
      IFLAG(KK)=IFLAGT(KK)
      ITOP(1,KK)=ITOPT(1,KK)
      NPT=ITOP(1,KK)
      DO 210 JJ=2,6
      ITOP(JJ,KK)=ITOPT(JJ,KK)
  210 CONTINUE
      ICKBN=L
      IF((ICKBN-1)*(4-ICKBN).GT.0) GO TO 220
      V=ZERO
      IF(ICKBN.EQ.4) V=ONE
      U=T
      GO TO 230
  220 U=ZERO
      IF(ICKBN.EQ.3) U=ONE
      V=T
  230 RETURN
   20 CONTINUE
   10 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001064.V02   ***
*
      FUNCTION DET3(A,B,C)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(*),B(*),C(*)
C           /-COMPUTE DETERMINANT FROM ROW VECTORS A,B AND C
      DET3=A(1)*(B(2)*C(3)-B(3)*C(2))
     X    -A(2)*(B(1)*C(3)-B(3)*C(1))
     X    +A(3)*(B(1)*C(2)-B(2)*C(1))
      RETURN
      END
**** SOURCE FILE : M0000640.W01   ***
*
C
C
      SUBROUTINE LODINT(SS,B,UST,VST,TP,TN,IFLAG,ITOP,IPNUM,MODE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C--------PROGRAM PERFORMS GLOBAL SEARCH OF PATCH STRUCTURE
C--------AND LOADS AN INITIAL PATCH BASED ON DISTANCE
C--------AS RETURNED BY PUVLOC
      DIMENSION SS(*)
      DIMENSION B(64),IFLAG(4),ITOP(6,4)
      DIMENSION TP(3),TN(3)
      HALF=0.5D0
      D=1.0D10
      IPNUM=1
      NPCHS=SS(4)
      IF (NPCHS.NE.1) THEN
      DO 20 I=1,NPCHS
      CALL LODPCH(SS,B,IFLAG,ITOP,I,1)
C.... TAKE 'CENTRE POINT' OF PATCH FOR START OF SEARCH
      UT=HALF
      VT=HALF
      CALL PUVLOC(B,TP,TN,UT,VT,DT,MODE,IFLAG)
      IF(DT.GT.D) GO TO 20
      IPNUM=I
      UST=UT
      VST=VT
      D=DT
   20 CONTINUE
      ELSE
C.... SPECIAL TREATMENT FOR SINGLE PATCH SURFACES
C.... CONSIDER 9 START POINTS
        CALL LODPCH(SS,B,IFLAG,ITOP,1,1)
        ISTEP=2
        JSTEP=2
        DO 210 I=1,ISTEP+1
          DO 200 J=1,JSTEP+1
            UT=I-1
            UT=UT/DBLE(ISTEP)
            VT=J-1
            VT=VT/DBLE(JSTEP)
            CALL PUVLOC(B,TP,TN,UT,VT,DT,MODE,IFLAG)
            IF (DT.LT.D) THEN
              IPNUM=1
              UST=UT
              VST=VT
              D=DT
            ENDIF
  200     CONTINUE
  210   CONTINUE
      ENDIF
      CALL LODPCH(SS,B,IFLAG,ITOP,IPNUM,3)
      END
**** SOURCE FILE : M0004323.W03   ***
*
      SUBROUTINE PCHPRC(SS,B,UST,VST,TP,TN,UA,VA,SP,SN,SLX,
     1 IFLAG,ITOP,IPNUM,MODE,IDEBUG,IRR,LGEOM)
C------ THIS PROGRAM ACCEPTS A CURRENT PATCH B AND U,V VALUES.
C------ IT MUST DETERMINE A LINEUP WITH AN INPUT TOOL POINT AND
C------  TOOL NORMAL .  IF THE LINEUP IS NOT ON THE CURRENT
C------ PATCH THEN THE LOGIC FREELY EXCHANGES PATCHES UNTIL AN ANSWER
C------ IS FOUND.  NO MORE THAN TEN PATCH EXCHANGES ARE ALLOWED.
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION SS(*),DAF(3),DELT(3)
      DIMENSION B(64),IFLAG(4),ITOP(6,4)
      DIMENSION SLX(3),DIF(3)
      DIMENSION SP(32),SN(3),TP(3),TN(3),SPV(32)
      DIMENSION UCHG(8),VCHG(8)
      LOGICAL LGEOM
      CHARACTER*20 BADMSG
C
      INCLUDE 'CSTART.INC'
C
      DATA ZERO,ONE,HALF/0.0D0,1.0D0,0.5D0/
      DATA FLCK0,FLCK1,FLCK2/0.99998D0,0.999992D0,0.9990D0/
      DATA SMAL,VSMAL/1.0D-10,1.0D-20/,BIG/1.0D10/
      DATA UVCHG/0.0005D0/
      DATA UCHG/0.0D0,3*1.0D0,0.0D0,3*-1.0D0/
      DATA VCHG/2*1.0D0,0.0D0,3*-1.0D0,0.0D0,1.0D0/
C---      NITS IS THE NUMBER OR ITERATIONS ALLOWED ON 1 SURFACE
C---      MEXCHG IS THE NUMBER OF PATCH EXCHANGES ALLOWED
      DATA NITS/30/,MEXCHG/10/
C---      STEPMX IS A MAXIMUM STEP WITHIN THE PARAMETRIC UNIT SQUARE
C---      STEPLN IS THE REDUCTION OF STEP SIZE IF IT IS TOO LARGE.
      DATA STEPMX/0.64D0/,STEPLN/0.7D0/,R125/0.125D0/,R875/0.875D0/
C---
C---
C---
C---
      KRETRY=0
      UA=UST
      VA=VST
      ULAST=HALF
      VLAST=HALF
      DRMAX = 0.0D0
      IPNST=IPNUM
    1 IEXCNT = 0
      KINPAT = 0
C
      DO 1000 K=1,NITS
C
      IF (KRETRY.EQ.5) GO TO 8
      IF(KRETRY.EQ.0)  GO TO 8
      IF(IPNUM.NE.IPMAX) GO TO 8
      IF(DABS(UA-UMAX).GT.0.01D0)  GO TO 8
      IF(DABS(VA-VMAX).GT.0.01D0)  GO TO 8
      GO TO 1400
    8 KINPAT=KINPAT+1
      IF(IDEBUG.EQ.0) GO TO 9
      CALL BAD(-1,0,' ',0)
      BADMSG=' PCHPRC LOOP'
      CALL CPRINT(BADMSG)
      CALL BAD(1,0,'PNUM',IPNUM)
      CALL BAD(1,1,'UA  ',UA)
      CALL BAD(1,1,'VA  ',VA)
      CALL BAD(-1,0,'KNPT',KINPAT)
    9 CONTINUE
C
C------EVALUATE THE SURFACE DIFFERENTIAL ELEMENTS AT UA,VA
C------PLACE THE ELEMENTS IN ARRAY SPV
C
      CALL CNSURF(UA,VA,B,SPV,IFLAG,1)
      IF(IDEBUG.EQ.0) GO TO 10
      CALL BAD(3,1,'SP  ',SPV)
      CALL BAD(-3,1,'SPN ',SPV(29))
      CALL BAD(3,1,'SPU ',SPV(5))
      CALL BAD(-3,1,'SP-V',SPV(9))
      CALL BAD(3,1,'SPUU',SPV(13))
      CALL BAD(-3,1,'SPVV',SPV(21))
      CALL BAD(-3,1,'SPUV',SPV(17))
   10 CONTINUE
C
C
C------BEFORE SEEKING A NEW UV PAIR, CHECK THE ACCURACY OF THE
C------PRESENT SURFACE POINT,NORMAL
C------ ERROR COMPUTATIONS DEPEND ON THE VARIABLE MODE
C------ MODE=-1, POSITIVE DDST. =0 SNXP OR CLOSEST POINT. =1
C------ DDST IN EITHER DIRECTION ALONG TOOL RAY.
      DO 20 I=1,3
   20 DIF(I)=TP(I)-SPV(I)
      CALL DOTF(D,DIF,DIF)
      D=DSQRT(D)
C---      IF D IS TOO SMALL, THEN SET IT TO A LARGER VALUE
      D=DMAX1(D,VSMAL)
      DO 25 I=1,3
      DAF(I)=DIF(I)/D
   25 CONTINUE
C
      IF(MODE.NE.0) GO TO 30
C---      COMPUTE ANGLE BETWEEN DIF AND SURFACE NORMAL
      CALL DOTF(DR,DAF,SPV(29))
      GO TO 35
C
   30 CONTINUE
C---      COMPUTE ANGLE BETWEEN DIF AND TOOL RAY
      CALL DOTF(DR,DAF,TN)
C---      NORMALIZE ANGLE BY DIVIDING BY LENGTH OF DIF
   35 CONTINUE
      DR=DABS(DR)
C
      IF(IDEBUG.EQ.0) GO TO 41
      CALL BAD(1,1,'ERR*',DR)
      CALL BAD(1,1,'DIST',D)
      CALL BAD(-3,1,'SPTP',DIF)
   41 CONTINUE
C
C---      IF THE RAY IS AT RIGHT ANGLES TO THE SURFACE, QUIT NOW.
      IF(DR.LT.SMAL.AND.MODE.NE.0) GO TO 9999
C---      ACCEPTANCE CRITERIA, ANGULAR LINEUP BETTER THAN FLIPCK
      IF(MODE.EQ.0.AND.DR.GT.FLCK0) GO TO 2000
      IF(MODE.NE.0.AND.DR.GT.FLCK2) GO TO 2000
      IF(DR.LT.SMAL) GO TO 63
      IF(DR.LT.DRMAX) GO TO 60
      DMAX=D
      DRMAX = DR
      UMAX = UA
      VMAX = VA
      IPMAX = IPNUM
C
C------ ALL INDICATIONS ARE THAT U,V SHOULD BE R MODIFIED
   60 CONTINUE
      CU = ZERO
      CV = ZERO
      DT=ZERO
      ILEV = 3
      IF (KRETRY.LT.5) ILEV=2
      CALL APRIX(CU,CV,DT,SPV,TP,TN,MODE,ILEV,IR,IDEBUG)
C---      IF IR.NE.0, THEN ARBITRARILY ALTER CU,CV SLIGHTLY
  640 IF(IR.EQ.0) GO TO 65
   63 DM=ZERO
      CT=0.025D0
      DO 649 IZ=1,2
      DO 648 J=1,8
      DHU=UA+CT*UCHG(J)
      DHV=VA+CT*UCHG(J)
      CALL CNSURF(DHU,DHV,B,SPV,IFLAG,1)
      DO 641 I=1,3
  641 DIF(I)=TP(I)-SPV(I)
      CALL DOTF(D,DIF,DIF)
      D=DSQRT(D)
      D=DMAX1(D,VSMAL)
      DO 642 I=1,3
  642 DAF(I)=DIF(I)/D
      IF(MODE.NE.0)  GO TO 643
      CALL DOTF(DT,DAF,SPV(29))
      GO TO 644
  643 CALL DOTF(DT,DAF,TN)
  644 DT=DABS(DT)
      IF(DT.LE.DM)  GO TO 648
      JMAX=J
      CTM=CT
      DM=DT
  648 CONTINUE
      CT=0.075D0
  649 CONTINUE
      IF(IDEBUG.NE.0) CALL BAD(1,1,'ERRT',DM)
      IF(IDEBUG.NE.0) THEN
        CALL BAD(-1,0,' ',0)
        BADMSG=' AFTER UV CHANGE'
        CALL CPRINT(BADMSG)
      ENDIF
      IF(1.1D0*DT.LT.DRMAX.OR.DT.LT.SMAL)  GO TO 1400
      CU=UCHG(JMAX)*CTM
      CV=VCHG(JMAX)*CTM
   65 CONTINUE
C
      U1=UA+CU
      V1=VA+CV
C
      IF(IDEBUG.EQ.0) GO TO 42
      CALL BAD(1,1,'UNXT',U1)
      CALL BAD(1,1,'VNXT',V1)
      CALL BAD(1,1,'UCHG',CU)
      CALL BAD(-1,1,'VCHG',CV)
   42 CONTINUE
C
C------ SQRCUT DETERMINES IF A BOUNDARY IS BEING CROSSED.  IF IT IS,
C------ IT WILL THEN DETERMINE IF AN EXCHANGE SHOULD BE CONSIDERED
C------ ON THE BOUNDARY ICKBN.
C
      CALL SQRCUT(UA,VA,U1,V1,U,V,ICKBN)
C---      SAVE THE NUMBER OF THE CURRENT PATCH
      IPSAVE=IPNUM
      IF(IDEBUG.EQ.0) GO TO 43
      CALL BAD(1,1,'UCUT',U)
      CALL BAD(1,1,'VCUT',V)
      CALL BAD(1,0,'ICKB',ICKBN)
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER SQRCUT'
      CALL CPRINT(BADMSG)
   43 CONTINUE
C---      RESTRICT A PARAMETER CHANGE WITHIN THE UNIT SQUARE
      IF(KINPAT.LE.1) GO TO 130
      IF(DABS(ULAST-HALF).GT.HALF) GO TO 130
      IF(DABS(VLAST-HALF).GT.HALF) GO TO 130
      IF(DABS(U-HALF).GT.HALF) GO TO 130
      IF(DABS(V-HALF).GT.HALF) GO TO 130
C---      BOTH POINTS ARE WITHIN THE UNIT SQUARE, SO CHECK FOR LENGTH
      STEP=(U-ULAST)**2+(V-VLAST)**2
      IF(STEP.LT.STEPMX) GO TO 130
C---      MODIFY STEP LENGTH TO AVOID TRAVERSING COMPLETE PATCH
      U=ULAST+STEPLN*(U-ULAST)
      V=VLAST+STEPLN*(V-VLAST)
      ICKBN=0
      IF(IDEBUG.EQ.0) GO TO 130
      CALL BAD(1,1,'ULIM',U)
      CALL BAD(-1,1,'VLIM',V)
  130 CONTINUE
C
C------ BONCHK WILL SEARCH BOUNDARY ICKBN AND IF ANOTHER PATCH IS
C------ FOUND, WILL EXCHANGE THE CURRENT PATCH VALUES.
C
      IF(ICKBN.EQ.0) GO TO 110
C---
      CALL BONCHK(SS,B,U,V,IFLAG,ITOP,IPNUM,ICKBN,IDEBUG)
      IF(IPSAVE.NE.IPNUM) GO TO 1300
      GO TO 110
C---      A PATCH EXCHANGE OCCURRED SO INCREMENT THE EXCHANGE COUNT
 1300 IEXCNT=IEXCNT+1
C---      RESET COUNTER FOR ITERATIONS ON THIS PATCH TO ZERO
      KINPAT=0
C
      IF(IDEBUG.EQ.0) GO TO 120
      CALL BAD(1,1,'UNEW',U)
      CALL BAD(1,1,'VNEW',V)
      CALL BAD(1,0,'PNUM',IPNUM)
      CALL BAD(1,0,'EXCT',IEXCNT)
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER BONCHK'
      CALL CPRINT(BADMSG)
  120 CONTINUE
C
      UA=U
      VA=V
  110 CONTINUE
      IF(IEXCNT.GT.MEXCHG) GO TO 1400
C
 1100 ULAST=UA
      VLAST=VA
      UA=U
      VA=V
 1000 CONTINUE
C---      ACCEPT A LESSER TOLERANCE, IF NECESSARY.
 1400 IF(DRMAX.GT.FLCK2) GO TO 1500
      IF(DR.GT.FLCK2) GO TO 2000
 1410 KRETRY=KRETRY+1
      IF (KRETRY.GT.4) THEN
        IF (KRETRY.GT.5) GOTO 9999
        UA=UMAX
        VA=VMAX
        IPNUM=IPMAX
        CALL LODPCH(SS,B,IFLAG,ITOP,IPNUM,3)
      ELSE
        UA=UST
        VA=VST
        IF(KRETRY.EQ.1)  VA=-HALF
        IF(KRETRY.EQ.2)  UA=-HALF
        IF(KRETRY.EQ.3)  UA=1.5D0
        IF(KRETRY.EQ.4)  VA=1.5D0
        IPNUM=IPNST
        CALL LODPCH(SS,B,IFLAG,ITOP,IPNUM,3)
        CALL SQRCUT(UST,VST,UA,VA,U,V,ICKBN)
        IF(ICKBN.EQ.0) GO TO 1410
        CALL BONCHK(SS,B,U,V,IFLAG,ITOP,IPNUM,ICKBN,IDEBUG)
        UA=U
        VA=V
        IF(KRETRY.EQ.1)  VA=VA-HALF
        IF(KRETRY.EQ.2)  UA=UA-HALF
        IF(KRETRY.EQ.3)  UA=UA+HALF
        IF(KRETRY.EQ.4)  VA=VA+HALF
      ENDIF
      IF(IDEBUG.EQ.0)  GO TO 1
      CALL BAD(1,1,'UA  ',UA)
      CALL BAD(1,1,'VA  ',VA)
      CALL BAD(1,0,'PNUM',IPNUM)
      CALL BAD(-1,0,'RETY',KRETRY)
      GO TO 1
C---      ERROR, ROUTINE FAILED TO DETERMINE SURFACE PT WITHIN TOLERANCE
 9999 CONTINUE
C.... FOR MODE=0 (CALC. SP WITH MINIMUM DISTANCE TO TE)
C.... AND (DMAX.GT.10) AND (DRMAX.GT.0.8) TAKE BEST SOLUTION
      IF (((MODE.EQ.0).AND.(DMAX.GT.10.D0)).AND.(DRMAX.GT.0.8D0))
     +   GO TO 1500
      IRR=7001
      GO TO 3000
C
C --- THE BEST LINE-UP IS ACCEPTED WITH A LESSER TOLERANCE
C
 1500 IPNUM = IPMAX
      CALL LODPCH(SS,B,IFLAG,ITOP,IPNUM,3)
      UA = UMAX
      VA = VMAX
      CALL CNSURF(UA,VA,B,SPV,IFLAG,1)
C
 2000 IRR=0
      IF(NITS.NE.20) GO TO 2003
      NITS = 30
      GO TO 1
 2003 CONTINUE
C
      IF (UA.LT.ZERO) THEN
        UDIST=-UA
        UBOND=ZERO
      ELSE
        IF (UA.LE.ONE) THEN
          UDIST=ZERO
          UBOND=UA
        ELSE
          UDIST=UA-ONE
          UBOND=ONE
        ENDIF
      ENDIF
C
      IF (VA.LT.ZERO) THEN
        VDIST=-VA
        VBOND=ZERO
      ELSE
        IF (VA.LE.ONE) THEN
          VDIST=ZERO
          VBOND=VA
        ELSE
          VDIST=VA-ONE
          VBOND=ONE
        ENDIF
      ENDIF
C
      UVDIST=UDIST + VDIST
C
      DIST=D
C
      IF (UVDIST.GE.0.1D0) THEN
        CALL LODPCH(SS,B,IFLAG,ITOP,IPNUM,3)
        CALL CNSURF(UBOND,VBOND,B,SPBOND,IFLAG,1)
      ENDIF
C
      DO 2005 I=1,3
      SP(I)=SPV(I)
      SN(I)=SPV(I+28)
 2005 CONTINUE
C
C---  LGEOM=.TRUE. SIGNIFIES A SPECIAL CALL FOR GEOMETRIC CONSTRUCTION
      IF (LGEOM) THEN
        DO 2001 II=4,32
        SP(II)=SPV(II)
 2001   CONTINUE
      END IF
C---      SLX VECTOR IS SET IN THE DIRECTION OF THE CRSSPL VECTOR
C---      THIS IS FOR SPECIAL ARELEM TOOL AXIS PRORATING.
      CALL VNORM(SPV(9),SLX)
C
C
 3000 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001084.W02   ***
*
      SUBROUTINE PUVLOC(BMAT,TP,TN,UST,VST,DIST,MODE,IFLAG)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C---      PURPOSE IS TO DETERMINE STARTUP U,V VALUES AND APPROXIMATE
C---      DISTANCE OF A PATCH FROM A TOOL RAY OR POINT.
C---      SPECIAL ENTRY POINT PUVINT IS TO INITIALIZE PUV PARAMETERS
C---      ENTRY PUVLOC PARAMETERS
C---      INPUT TP   INPUT TOOL POINT
C---      INPUT TN   INPUT TOOL RAY VECTOR(SHOULD BE UNITIZED)
C---      INPUT MODE  =0 MEANS FIND CLOSEST POINT ON PATCH TO TP ONLY
C---                  =1 MEANS FIND CLOSEST POINT TO POSITIVE TOOL RAY
C---                  =-1 MEANS FIND CLOSEST POINT TO TOOL SPACE LINE.
C---      INPUT ILEV  =1 MEANS USE FIRST ORDER DERIVATIVES ONLY
C---                  =2 MEANS USE SECOND ORDER DERIVATIVES AS WELL
C---      INPUT NITS  NUMBER OF ITERATIONS TO DETERMINE CLOSEST POINT
C---      INPUT IFREE =0 MEANS NOT FREE - THAT IS KEEP SOLUTION WITHIN
C---                  UNIT SUARE. =1 MEANS OBTAIN SOLUTION ANYWHERE.
C
C---      INPUT BMAT COONS MATRIX COEFFICIENTS OR ELSE TYPE OF GENCUR
C---            SURFACE
C---      INPUT IFLAG FLAGS FOR TYPE OF COORDINATE MATRIX OR LOCATION
C---            OF GENCUR DEFINING CURVES
C---      OUTPUT UST,VST COMPUTED ROUGH LOCATION OF CLOSEST PATCH POINT
C---      OUTPUT DIST COMPUTED DISTANCE BETWEEN PATCH AND POINT OR RAY.
C
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
C
      INCLUDE 'CHEKFL.INC'
C
      DIMENSION BMAT(64),TP(3),TN(3),IFLAG(4)
      DIMENSION DIF(3),SPV(32)
      CHARACTER*20 BADMSG
C
      DATA ONE,HALF,BIG/1.0D0,0.5D0,1.0D+6/
      DATA PLO,PHI/0.005D0,0.995D0/
      DATA ILEV,NITS,IFREE/1,1,0/
      DATA IDEBUG/0/
C
C---      MAIN ENTRY POINT FOR PUVLOC
C
      DO 10 I=1,NITS
C---      EVALUATE SURFACE POINT AND DERIVATIVES AT UST,VST
      CALL CNSURF(UST,VST,BMAT,SPV,IFLAG,1)
C
C---      CALL APRIX TO COMPUTE A CLOSER LINEUP
      CALL APRIX(DU,DV,DIST,SPV,TP,TN,MODE,ILEV,IRR,IDEBUG)
C---      IF AN ERROR OCCURRED THEN USE CURRENT SURFACE POINT
      IF(IRR.NE.0) GO TO 60
C---      IF IFREE IS 0, THEN INSURE PARAMETERS ARE IN UNIT SQUARE
      UST=UST+DU
      VST=VST+DV
      IF(IFREE.EQ.1) GO TO 10
C---      SELECT UST,VST IN UNIT SQUARE CLOSEST TO ESTIMATED UST,VST
      UST=DMAX1(UST,PLO)
      UST=DMIN1(UST,PHI)
      VST=DMAX1(VST,PLO)
      VST=DMIN1(VST,PHI)
C
   10 CONTINUE
C
C---      NOW REEVALUATE SURFACE AT NEW UST,VST COORDINATES
      CALL CNSURF(UST,VST,BMAT,SPV,IFLAG,0)
C
C---      ITERATION COMPLETE, NOW COMPUTE EFFECTIVE DISTANCE
   60 CONTINUE
C---      COMPUTE DIFFERENCE BETWEEN EFFECTIVE POINT AND TP
      DO 90 J=1,3
   90 DIF(J)=SPV(J)-TP(J)
C
      IF(MODE.NE.0) GO TO 120
C---      CASE OF CLOSEST POINT, MODE=0
      CALL DOTV(DIST,DIF,DIF)
      DIST=DSQRT(DIST)
C
      CALL DOTV(D1,DIF,TN)
      CALL DOTV(D2,SPV(29),TN)
      IF ((D1.LT.ZERO).AND.(ICHEKF.EQ.1)) DIST=ABS(DIST)*BIG
      GO TO 190
C
  120 CONTINUE
C---      MODE=1 OR -1
      CALL DOTV(D1,DIF,TN)
      IF(MODE.GT.0) GO TO 140
C---      MODE=-1
C---      DISTANCE IS NORMAL DISTANCE FROM CALCULATED POINT TO TOOL RAY
      CALL CROSS(DIF,TN,DIF)
      CALL DOTV(DIST,DIF,DIF)
      DIST=DSQRT(DIST)
      IF ((D1.LT.ZERO).AND.(ICHEKF.EQ.1)) DIST=ABS(DIST)*BIG
      GO TO 190
C
  140 CONTINUE
C---      MODE=1
      IF(D1.LT.ZERO) DIST=ABS(DIST)*BIG
C
  190 CONTINUE
C---      INCREASE DIST TO ADD A BIAS IN CASE AN ERROR OCCURRED EARLIER
      IF(IRR.GT.0) DIST=DIST*BIG
C---      CALCULATION OF UST,VST,DIST IS COMPLETE
C
  999 CONTINUE
C
      IF(IBUG.NE.2) GO TO 998
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER PUVLOC'
      CALL CPRINT(BADMSG)
      CALL BAD(1,1,'UST ',UST)
      CALL BAD(1,1,'VST ',VST)
      CALL BAD(-1,1,'DIST',DIST)
C
  998 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001095.V02   ***
*
      SUBROUTINE SQRCUT(U0,V0,U1,V1,U,V,ICKBN)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------INPUT IS AN OLD POINT U0,V0 IN UV SPACE AND A TRIAL
C------ NEW POINT U1,V1.  IF THESE TWO PTS ARE IN THE SAME
C------ SECTOR OF SPACE( UNIT SQUARE DIVIDES SPACE INTO NINE
C------ SECTORS) THEN U,V IS SET EQUAL TO U1,V1 AND NO
C------ BOUNDARY CHECKING IS REQUIRED( I.E. SET ICKBN=0).
C------ OTHERWISE U,V IS SET EQUAL TO THE CLOSEST
C------ BOUNDARY POINT TO U0,V0 WHICH LIES BETWEEN U0,V0 AND
C------ U1,V1.  IN ADDITION THE ROUTINE DETERMINES WHICH
C------  BOUNDARY OF THE PATCH SHOULD BE CHECKED.
C
      DIMENSION IBCHK(4,4)
C---      ARRAY WHICH RECORDS BOUNDARY TO CHECK IN MOVING FROM SECTOR
C---      J TO SECTOR I (IBCHK(I,J)).
      DATA IBCHK/ 2,3,0,0,  1,0,4,0,  0,1,0,4,  0,0,2,3/
C
      DATA ZERO,ONE,TWO/0.0D0,1.0D0,2.0D0/
      DATA VSMAL/1.0D-12/
C---      FUNCTION F GIVES SQUARE OF DISTANCE FROM (A,B) TO (C,D)
      F(A,B,C,D)=(C-A)**2+(D-B)**2
C---      FUNCTION G IS POSITIVE WHEN C IS OUTSIDE THE A,B INTERVAL
      G(A,B,C)=(A-C)*(B-C)
C
      ICKBN=0
      U=U1
      V=V1
      IU=2
      IF(U0.LT.ZERO)IU=1
      IF(U0.GT.ONE) IU=3
      IV=3
      IF(V0.LT.ZERO)IV=0
      IF(V0.GT.ONE) IV=6
      IC0=IU+IV
      IU=2
      IF(U1.LT.ZERO)IU=1
      IF(U1.GT.ONE) IU=3
      IV=3
      IF(V1.LT.ZERO)IV=0
      IF(V1.GT.ONE) IV=6
      IC1=IU+IV
      IF(IC0.EQ.IC1) GO TO 999
C
C------DETERMINE THE BOUNDARY INTERCEPT CLOSEST TO U0,V0
C---      EQN OF LINE IS (U0-U1)*V+(V1-V0)*U+(V0*U1-U0*V1)=0
C---      EQN OF LINE IS      A1*V+     A2*U+     A3      =0
      A1=U0-U1
      A2=V1-V0
      A3=V0*U1-V1*U0
C---      SET U,V AND DISTANCE D TO DEFAULT VALUES
      U=U1
      V=V1
      D=F(U0,V0,U1,V1)
C---      SET INITIAL VALUES FOR SECOND POINT BETWEEN P0 AND P1.
      D2=D
      U2=U
      V2=V
C
C---      LINE IS HORIZONTAL, SKIP INTERCEPT CALCULATION WITH U=0 OR U=1
      IF(DABS(A1).LT.VSMAL) GO TO 100
      UT=ZERO
      VT=-A3/A1
      DT=F(U0,V0,UT,VT)
      IF(G(U0,U1,UT).GE.ZERO.OR.DT.GT.D) GO TO 10
      D=DT
      U=UT
      V=VT
   10 CONTINUE
      UT=ONE
      VT=-(A2+A3)/A1
      DT=F(U0,V0,UT,VT)
      IF(G(U0,U1,UT).GE.ZERO.OR.DT.GE.D2) GO TO 100
C---      SAVE THE SECOND CLOSEST INTERCEPT TO UO,VO FIRST
      IF(DT.LT.D) GO TO 20
C---      U2,V2 IS NEW SECOND CLOSEST INTERCEPT ( DT.GT.D)
      IF(DT.EQ.D) GO TO 100
      U2=UT
      V2=VT
      D2=DT
      GO TO 100
   20 CONTINUE
C---      U2,V2 TAKES ON THE OLD U,V VALUE OF CLOSEST INTERCEPT
      U2=U
      V2=V
      D2=D
C---      CLOSEST INTERCEPT U,V IS NOW UT,VT
      U=UT
      V=VT
      D=DT
C---      LINE IS VERTICAL, SKIP INTERCEPT CALC WITH V=0 OR V=1.
  100 IF(DABS(A2).LT.VSMAL) GO TO 200
      VT=ZERO
      UT=-A3/A2
      DT=F(U0,V0,UT,VT)
      IF(G(V0,V1,VT).GE.ZERO.OR.DT.GE.D2) GO TO 110
C---      SAVE THE SECOND CLOSEST INTERCEPT TO UO,VO FIRST
      IF(DT.LT.D) GO TO 40
C---      U2,V2 IS NEW SECOND CLOSEST INTERCEPT ( DT.GT.D)
      IF(DT.EQ.D) GO TO 110
      U2=UT
      V2=VT
      D2=DT
      GO TO 110
   40 CONTINUE
C---      U2,V2 TAKES ON THE OLD U,V VALUE OF CLOSEST INTERCEPT
      U2=U
      V2=V
      D2=D
C---      CLOSEST INTERCEPT U,V IS NOW UT,VT
      U=UT
      V=VT
      D=DT
  110 VT=ONE
      UT=-(A1+A3)/A2
      DT=F(U0,V0,UT,VT)
      IF(G(V0,V1,VT).GE.ZERO.OR.DT.GE.D2) GO TO 200
C---      SAVE THE SECOND CLOSEST INTERCEPT TO UO,VO FIRST
      IF(DT.LT.D) GO TO 60
C---      U2,V2 IS NEW SECOND CLOSEST INTERCEPT ( DT.GT.D)
      IF(DT.EQ.D) GO TO 200
      U2=UT
      V2=VT
      D2=DT
      GO TO 200
   60 CONTINUE
C---      U2,V2 TAKES ON THE OLD U,V VALUE OF CLOSEST INTERCEPT
      U2=U
      V2=V
      D2=D
C---      CLOSEST INTERCEPT U,V IS NOW UT,VT
      U=UT
      V=VT
      D=DT
  200 CONTINUE
C---      DETERMINE UT,VT JUST INSIDE THE SECTOR BEYOND U,V
C---      ICKBN IS SET TO ZERO IF NO ADJACENT PATCH NEED BE CHECKED
C---      OTHERWISE ICKBN SHOULD POINT TO THE PATCH BOUNDARY (1,2,3,OR 4
C---      WHICH SHOULD BE CHECKED.
      ICKBN=0
C---      NEXT DETERMINE THE SECTOR WHICH THE PATH FROM U0,V0 TO U,V
C---      IS ENTERING.
      UT=(U+U2)/TWO
      VT=(V+V2)/TWO
      IF(G(ZERO,ONE,U0).NE.ZERO.AND.G(ZERO,ONE,V0).NE.ZERO) GO TO 210
C---      STARTING POINT IS ON BOUNDARY, SO CUT UT,VT BACK
      UT=(U0+U)/TWO
      VT=(V0+V)/TWO
  210 CONTINUE
C
      IU=2
      IF(UT.LT.ZERO) IU=1
      IF(UT.GT.ONE)  IU=3
      IV=3
      IF(VT.LT.ZERO) IV=0
      IF(VT.GT.ONE)  IV=6
C---      IC2 IS THE SECTOR NUMBER ( 1 THRU 9) WHICH IS BEING ENTERED.
      IC2=IU+IV
C---      IF THE CENTER SQUARE IS BEING ENTERED, THEN CHECK NO BOUNDARY
      IF(IC2.EQ.5) GO TO 999
      IF(MOD(IC2,2).EQ.0) GO TO 310
      IF(MOD(IC2,2).EQ.1) GO TO 320
C
  310 CONTINUE
C---      AN EVEN-NUMBERED SECTOR IS BEING ENTERED -- BOUNDARY CALCULATI
C---      IS STRAIGHT FORWARD.
      ICKBN=IC2/2
      GO TO 999
C
  320 CONTINUE
C---      AN ODD SECTOR IS BEING ENTERED, BOUNDARY DEPENDS ON BOTH POINT
C---      (I.E. ON SECTOR OF UT,VT AND ON SECTOR OF U0,V0)
      I1=IC2/3+1
      IF(MOD(IC0,2).NE.0) GO TO 999
      I2=IC0/2
      ICKBN=IBCHK(I1,I2)
      GO TO 999
C
  999 CONTINUE
      RETURN
      END
