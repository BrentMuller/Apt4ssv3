**** SOURCE FILE : M0006624.W03   ***
*
C
C              FORTRAN SUBROUTINE BOOLIF
C
C LINKAGE      SUBROUTINE  BOOLIF(PROD)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ARGCVT          SUBROUTINE    RECOG
C          SUBROUTINE    MACLBL          SUBROUTINE    INPUT
C          LOGICAL FCT.  IFTMP
C          INTEGER FCT.  MODE
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          INTEGER FCT.  GETTMP
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    RLSLIN
C          SUBROUTINE    LABELZ
C          SUBROUTINE    ALARM
C          SUBROUTINE    TWOARG
C
      SUBROUTINE  BOOLIF(PROD)
C
      IMPLICIT INTEGER (A-Z)
C
C              FUNCTION DECLARATION
      LOGICAL IFTMP
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE 'NAMETB.INC'
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),NUMBER(2),LABEL(2),IMPLAB(2),RELAT(2),AND(2)
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C IMPLAB:      (1)=CODE CLASS 23000,(2)=NAMTBL INDEX OF 'IMPLAB'
      EQUIVALENCE (IMPLAB(1),CODE(45))
C RELAT:       (1)=CODE CLASS 27000,(2)=NAMTBL INDEX OF 'RELAT '
      EQUIVALENCE (RELAT(1),CODE(53))
C AND:         (1)=CODE CLASS 29000,(2)=NAMTBL INDEX OF 'AND   '
      EQUIVALENCE (AND(1),CODE(57))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(501),META(50)
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C CONJMP:      CONTAINS COMMAND CODE (11) FOR CONJMP COMMAND
      EQUIVALENCE (CONJMP,IL(11))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C REAL:        MODE CODE (21) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C BOOL:        MODE CODE (23) FOR BOOLEAN
      EQUIVALENCE (BOOL,MODX(23))
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL FINMAC
      DIMENSION MACXX1(71)
C FINMAC:      TRUE IF SECOND FINAL PASS OF MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C WHCHMN:      EQUAL TO NUMBER OF CURRENT MACRO BEING PROCESSED
      EQUIVALENCE (WHCHMN,MACXX1(63))
C
C       27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION OPMOD(6)
C QUIDLR:      CONTAINS OPERAND TYPE CODE 5
      EQUIVALENCE (QUIDLR,OPMOD(6))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136)
C LOGIF:       NAMTBL POINTER TO EXECUTION SUBROUTINE RELAT
      EQUIVALENCE (LOGIF,SUBLST(104))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       43.    DO LOOP CONTROL VALUES
C
      COMMON/DOLOOP/DOLOOP
      LOGICAL IFFLAG
      DIMENSION DOLOOP(9)
C JUMPTO:      MARKER SET AFTER JUMPTO OR IF FOR LABEL CONTROL
      EQUIVALENCE (JUMPTO,DOLOOP(1))
C IFFLAG:      FLAG ON WHEN LOGICAL IF OCCURS
      EQUIVALENCE (IFFLAG,DOLOOP(9))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ESTACK,ERGSTK
      DIMENSION ERRPOS(302),ESTACK(100),ERGSTK(100)
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C ERGSTK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN ARGSTK
      EQUIVALENCE (ERGSTK(1),ERRPOS(203))
C*
      DIMENSION LGSTK(50)
      LOGICAL BOLFLG
      DATA KK/20000/,LASTMN/-1/
      external alarm
C**
      IF(PROD.GT.0)GOTO 5
      IF(LASTMN.NE.WHCHMN) GOTO 300
      IFFLAG=.FALSE.
      LASTMN=-1
      CALL LABELZ(LBL)
      JUMPTO=0
      GOTO 300
C
    5 IF(ARGTOP.EQ.0)BOLFLG=.FALSE.
      GOTO(10,20,50,70,70),PROD
C
C     PRODUKTION 34:  ALL $ VBL $ NOT
C
   10 K=STACK(1,TOP-1)
      IF(IFTMP(K))GOTO 310
      IF(MOD(NAMTBL(K),MODHLF).NE.BOOL)
     *CALL ALARM(1008,TOP-1,8,'BOOLIF  ')
      RSLT=GETTMP(BOOL)
      CALL CALLZZ(LOGIF)
      CALL ARGCVT(RSLT)
      CALL TWOARG(QUIDLR,7)
      CALL ARGCVT(K)
      CALL ARGCVT(K)
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=RSLT
      BOLFLG=.TRUE.
      STACK(1,TOP-2)=RSLT
      STACK(2,TOP-2)=META(NAMTBL(RSLT)/MODULO)
      STACK(1,TOP-1)=STACK(1,TOP)
      STACK(2,TOP-1)=STACK(2,TOP)
      ERGSTK(ARGTOP)=ESTACK(TOP-1)
      TOP=TOP-1
      GOTO 40
C
C     PRODUKTION 35: ALL $ VBL,TEMP,NUMBER $ RELAT $ VBL,TEMP,NUMBER
C
   20 DO 30 I=1,3,2
      J=MODE(STACK(1,TOP-I))
   30 IF(J.NE.REAL)CALL ALARM(1008,TOP-I,8,'BOOLIF  ')
      ART=NAMTBL(STACK(1,TOP-2))-RELAT(1)
      RSLT=GETTMP(BOOL)
      CALL CALLZZ(LOGIF)
      CALL ARGCVT(RSLT)
      CALL TWOARG(QUIDLR,ART)
      CALL ARGCVT(STACK(1,TOP-3))
      CALL ARGCVT(STACK(1,TOP-1))
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=RSLT
      BOLFLG=.TRUE.
      STACK(1,TOP-3)=RSLT
      STACK(2,TOP-3)=META(NAMTBL(RSLT)/MODULO)
      STACK(1,TOP-2)=STACK(1,TOP)
      STACK(2,TOP-2)=STACK(2,TOP)
      ERGSTK(ARGTOP)=ESTACK(TOP-2)
      TOP=TOP-2
   40 CALL RLSLIN
      GOTO 300
C
C     PRODUKTION 36:  ALL $ VBL,TEMP $ AND,OR $ VBL,TEMP
C
   50 IF(BOLFLG)GOTO 60
      K=STACK(1,TOP-1)
      IF(MOD(NAMTBL(K),MODHLF).NE.BOOL)
     *CALL ALARM(1008,TOP-1,8,'BOOLIF  ')
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=STACK(1,TOP-1)
      ERGSTK(ARGTOP)=ESTACK(TOP-1)
   60 BOLFLG=.FALSE.
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=STACK(1,TOP-2)
      ERGSTK(ARGTOP)=ESTACK(TOP-2)
      STACK(1,TOP-2)=STACK(1,TOP)
      STACK(2,TOP-2)=STACK(2,TOP)
      TOP=TOP-2
      GOTO 300
C
C     PRODUKTION 32:    ( $ VBL,TEMP,NUMBER $ ) $ IF $ LTERM
C     PRODUKTION 23,24: RTERM $ VBL,TEMP,NUMBER  $ = .......
C
   70 IF(BOLFLG)GOTO 80
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=STACK(1,TOP-1)
      ERGSTK(ARGTOP)=ESTACK(TOP-1)
      BOLFLG=.TRUE.
   80 RSLT=STACK(1,TOP-1)
      IF(ARGTOP.LE.1)GOTO 200
      ART=AND(1)/MODULO
      TP=0
      I=0
  100 RSLT=0
  110 I=I+2
      IF(I.GE.ARGTOP)GOTO 170
      K=ARGSTK(I)
      L=ARGSTK(I-1)
      IF(NAMTBL(K)/MODULO.EQ.ART)GOTO 130
      IF(.NOT.BOLFLG)GOTO 120
      TP=TP+1
      LGSTK(TP)=L
  120 BOLFLG=.TRUE.
      GOTO 100
C
C     HANDLING OF OTHER TEMPORARY RESULTS IN STACK
C
  130 J=ARGSTK(I+1)
      IF(RSLT.GT.0)GOTO 150
      IF(IFTMP(L))RSLT=L
      IF(RSLT.GT.0)GOTO 140
      IF(IFTMP(J))RSLT=J
      IF(RSLT.GT.0)GOTO 140
      RSLT=GETTMP(BOOL)
  140 TP=TP+1
      LGSTK(TP)=RSLT
      CALL CALLZZ(LOGIF)
      CALL ARGCVT(RSLT)
      CALL TWOARG(QUIDLR,9)
      CALL ARGCVT(J)
      CALL ARGCVT(L)
      GOTO 160
  150 CALL CALLZZ(LOGIF)
      CALL ARGCVT(RSLT)
      CALL TWOARG(QUIDLR,9)
      CALL ARGCVT(RSLT)
      CALL ARGCVT(J)
  160 CALL RLSLIN
      BOLFLG=.FALSE.
      GOTO 100
C
  170 IF(.NOT.BOLFLG)GOTO 180
      TP=TP+1
      LGSTK(TP)=ARGSTK(ARGTOP)
C
C    PROCESSING OF OR
C
  180 RSLT=LGSTK(1)
      IF(TP.EQ.2)GOTO 200
      K=RSLT
      IF(IFTMP(RSLT))GOTO 185
      RSLT=GETTMP(BOOL)
  185 DO 190 I=2,TP
      CALL CALLZZ(LOGIF)
      CALL ARGCVT(RSLT)
      CALL TWOARG(QUIDLR,8)
      CALL ARGCVT(K)
      CALL ARGCVT(LGSTK(I))
      CALL RLSLIN
  190 K=RSLT
C
C     WORKING UP OF IF(BOOL) LAB1,LAB1,LAB2
C
  200 IF (PROD.NE.5)GOTO 210
      STACK(1,TOP-1)=RSLT
      STACK(2,TOP-1)=META(NAMTBL(RSLT)/MODULO)
      GOTO 300
  210 CALL OPCODE(CONJMP)
      CALL ARGCVT(RSLT)
      L=WHCHMN
      IF(L.EQ.0)L=MSEQDM+3
      KK=KK+50000
      CALL MACLBL(KK,-L,JJ)
      NAMTBL(JJ)=JJ
      KK=KK+50000
      CALL MACLBL(KK,-L,K)
      IF((.NOT.FINMAC).AND.(WHCHMN.NE.0))GOTO 220
      NAMTBL(JJ)=LABEL(1)+WHCHMN
      NAMTBL(K)=LABEL(1)+WHCHMN
      GOTO 230
C
C     WORKING UP OF IF-LABELS
C
  220 NAMTBL(JJ)=IMPLAB(1)+WHCHMN
      NAMTBL(K)=IMPLAB(1)+WHCHMN
  230 CALL ONEARG(JJ)
      CALL ONEARG(JJ)
      CALL ONEARG(K)
      CALL RLSLIN
      CALL LABELZ(K)
      IF (IFFLAG)GOTO 290
      LBL=JJ
      LASTMN=WHCHMN
      IFFLAG=.TRUE.
  290 BOLFLG=.FALSE.
      TOP=0
  300 RETURN
C
  310 CALL ALARM(1007,TOP-1,8,'BOOLIF  ')
      TOP=-1
      GOTO 300
C
      END
