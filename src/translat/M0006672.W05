*
C
C              FORTRAN SUBROUTINE RECOG
C
C LINKAGE      SUBROUTINE  RECOG
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    LARGES          SUBROUTINE    START
C          SUBROUTINE    LCANON
C          SUBROUTINE    BINBCD
C          SUBROUTINE    MACLBL
C          SUBROUTINE    MACREC
C          LOGICAL FCT.  IFTMP
C          SUBROUTINE    MATCH
C          SUBROUTINE    MCXTRN
C          SUBROUTINE    INPUT
C          SUBROUTINE    ISSCOD
C          INTEGER FCT.  NAME
C          INTEGER FCT.  NUMB
C          SUBROUTINE    ONEARG
C          SUBROUTINE    OPCODE
C          INTEGER FCT.  GETTMP
C          SUBROUTINE    PATH
C          SUBROUTINE    CALLZZ
C          SUBROUTINE    PRO020
C          SUBROUTINE    PRO026
C          SUBROUTINE    PRO027
C          SUBROUTINE    PUTTMP
C          SUBROUTINE    ARGCVT
C          SUBROUTINE    RECOGN
C          SUBROUTINE    REPLAC
C          SUBROUTINE    RESRED
C          SUBROUTINE    RESRVZ
C          SUBROUTINE    RLSLIN
C          INTEGER FCT.  SEARCH
C          SUBROUTINE    LABELZ
C          SUBROUTINE    SETCHR
C          SUBROUTINE    SETMOD
C          SUBROUTINE    INPAT
C          SUBROUTINE    ARGGEN
C          SUBROUTINE    SSDEF
C          SUBROUTINE    SUBCOD
C          SUBROUTINE    ALARM
C          SUBROUTINE    TWOARG
C          SUBROUTINE    CONCAT
C          SUBROUTINE    BCDBIN
C          SUBROUTINE    LABCON
C          SUBROUTINE    LOOP
C          SUBROUTINE    BOOLIF
C          SUBROUTINE    KONAST
C          SUBROUTINE    VCTPRD
C          INTEGER FCT.  BCDF
C          SUBROUTINE    HOLFRM
C
      SUBROUTINE  RECOG
C
      IMPLICIT INTEGER (A-Z)
C
C              FUNCTION DECLARATION
      LOGICAL IFTMP
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE (NAMETB)
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C NUMBST:      NAMTBL INDEX OF BEGINNING OF NUMBER SECTION
C NUMBND:      NAMTBL INDEX OF END OF NUMBER SECTION
C
C        2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST
      DIMENSION STKLST(300),STACK(2,99),ARGSTK(99)
C TOP:         POINTER TO LAST STACK ENTRY
      EQUIVALENCE (TOP,STKLST(1))
C ARGTOP:      POINTER TO LAST ARGSTK ENTRY
      EQUIVALENCE (ARGTOP,STKLST(2))
C STACK:       WORKING STACK
      EQUIVALENCE (STACK(1,1),STKLST(4))
C ARGSTK:      ARGUMENT STACK
      EQUIVALENCE (ARGSTK(1),STKLST(202))
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),COMMA(2),RTERM(2),SLASH(2),MINUS(2),PLUS(2),
     *          ASTER(2),LETTER(2),QUOTE(2),NUMBER(2),GEOM(2),TEMP(2),F
     *          CN(2),PROCED(2),PERMID(2),LABEL(2),IMPLAB(2),LTERM(2),V
     *          BL(2),DBLAST(2),IDENT(2),MCLTRM(2),CANON(2),BIGGEO(2),L
     *          PAREN(2),RPAREN(2),DOT(2),KREUZ(2),RELAT(2),CONAST(2),N
     *          OT(2),CONGEO(2),CONPRO(2),DECMAL(2),DOLLAR(2)
C COMMA:       (1)=CODE CLASS  1000,(2)=NAMTBL INDEX OF ',     '
      EQUIVALENCE (COMMA(1),CODE(1))
C LPAREN:      (1)=CODE CLASS  2000,(2)=NAMTBL INDEX OF '(     '
      EQUIVALENCE (LPAREN(1),CODE(3))
C RPAREN:      (1)=CODE CLASS  3000,(2)=NAMTBL INDEX OF ')     '
      EQUIVALENCE (RPAREN(1),CODE(5))
C RTERM:       (1)=CODE CLASS  4000,(2)=NAMTBL INDEX OF 'RTERM '
      EQUIVALENCE (RTERM(1),CODE(7))
C SLASH:       (1)=CODE CLASS  5000,(2)=NAMTBL INDEX OF '/     '
      EQUIVALENCE (SLASH(1),CODE(9))
C MINUS:       (1)=CODE CLASS  6000,(2)=NAMTBL INDEX OF '-     '
      EQUIVALENCE (MINUS(1),CODE(11))
C PLUS:        (1)=CODE CLASS  7000,(2)=NAMTBL INDEX OF '+     '
      EQUIVALENCE (PLUS(1),CODE(13))
C ASTER:       (1)=CODE CLASS  9000,(2)=NAMTBL INDEX OF '*     '
      EQUIVALENCE (ASTER(1),CODE(17))
C LETTER:      (1)=CODE CLASS 11000,(2)=NAMTBL INDEX OF 'LETTER'
      EQUIVALENCE (LETTER(1),CODE(21))
C QUOTE:       (1)=CODE CLASS 12000,(2)=NAMTBL INDEX OF ''     '
      EQUIVALENCE (QUOTE(1),CODE(23))
C NUMBER:      (1)=CODE CLASS 14000,(2)=NAMTBL INDEX OF 'NUMBER'
      EQUIVALENCE (NUMBER(1),CODE(27))
C DOLLAR:      (1)=CODE CLASS 15000,(2)=NAMTBL INDEX OF '$     '
      EQUIVALENCE (DOLLAR(1),CODE(29))
C GEOM:        (1)=CODE CLASS 16000,(2)=NAMTBL INDEX OF 'GEOM  '
      EQUIVALENCE (GEOM(1),CODE(31))
C TEMP:        (1)=CODE CLASS 17000,(2)=NAMTBL INDEX OF 'TEMP  '
      EQUIVALENCE (TEMP(1),CODE(33))
C FCN:         (1)=CODE CLASS 18000,(2)=NAMTBL INDEX OF 'FCN   '
      EQUIVALENCE (FCN(1),CODE(35))
C PROCED:      (1)=CODE CLASS 19000,(2)=NAMTBL INDEX OF 'PROCED'
      EQUIVALENCE (PROCED(1),CODE(37))
C PERMID:      (1)=CODE CLASS 20000,(2)=NAMTBL INDEX OF 'PERMID'
      EQUIVALENCE (PERMID(1),CODE(39))
C DECMAL:      (1)=CODE CLASS 21000,(2)=NAMTBL INDEX OF '.     '
      EQUIVALENCE (DECMAL(1),CODE(41))
C LABEL:       (1)=CODE CLASS 22000,(2)=NAMTBL INDEX OF 'LABEL '
      EQUIVALENCE (LABEL(1),CODE(43))
C IMPLAB:      (1)=CODE CLASS 23000,(2)=NAMTBL INDEX OF 'IMPLAB'
      EQUIVALENCE (IMPLAB(1),CODE(45))
C LTERM:       (1)=CODE CLASS 24000,(2)=NAMTBL INDEX OF 'LTERM '
      EQUIVALENCE (LTERM(1),CODE(47))
C DOT:         (1)=CODE CLASS 25000,(2)=NAMTBL INDEX OF 'DOT   '
      EQUIVALENCE (DOT(1),CODE(49))
C KREUZ:       (1)=CODE CLASS 26000,(2)=NAMTBL INDEX OF 'KREUZ '
      EQUIVALENCE (KREUZ(1),CODE(51))
C RELAT:       (1)=CODE CLASS 27000,(2)=NAMTBL INDEX OF 'RELAT '
      EQUIVALENCE (RELAT(1),CODE(53))
C NOT:         (1)=CODE CLASS 28000,(2)=NAMTBL INDEX OF 'NOT   '
      EQUIVALENCE (NOT(1),CODE(55))
C VBL:         (1)=CODE CLASS 31000,(2)=NAMTBL INDEX OF 'VBL   '
      EQUIVALENCE (VBL(1),CODE(61))
C DBLAST:      (1)=CODE CLASS 32000,(2)=NAMTBL INDEX OF 'DBLAST'
      EQUIVALENCE (DBLAST(1),CODE(63))
C IDENT:       (1)=CODE CLASS 35000,(2)=NAMTBL INDEX OF 'IDENT '
      EQUIVALENCE (IDENT(1),CODE(69))
C MCLTRM:      (1)=CODE CLASS 38000,(2)=NAMTBL INDEX OF 'MCLTRM'
      EQUIVALENCE (MCLTRM(1),CODE(75))
C CONGEO:      (1)=CODE CLASS 39000,(2)=NAMTBL INDEX OF 'CONGEO'
      EQUIVALENCE (CONGEO(1),CODE(77))
C CONPRO:      (1)=CODE CLASS 40000,(2)=NAMTBL INDEX OF 'CONPRO'
      EQUIVALENCE (CONPRO(1),CODE(79))
C CANON:       (1)=CODE CLASS 42000,(2)=NAMTBL INDEX OF 'CANON '
      EQUIVALENCE (CANON(1),CODE(83))
C BIGGEO:      (1)=CODE CLASS 44000,(2)=DNAMTBL INDEX OF 'BIGGEO'
      EQUIVALENCE (BIGGEO(1),CODE(87))
C CONAST:      (1)=CODE CLASS 45000,(2)=NAMTBL INDEX OF 'CONAST'
      EQUIVALENCE (CONAST(1),CODE(89))
C
C        4.    PRODUCTION TABLE
C
      COMMON/SRCTBL/SRCTBL
      DIMENSION SRCTBL(1482),PRODTB(1430),META(50)
C BRKPNT:      END OF MACRO TEXT TRANSFER PRODUCTION IN PRODTB
      EQUIVALENCE (BRKPNT,SRCTBL(1))
C MBKPNT:      END OF CHARACTER CONCATENATION AND STRING PRODUCTION
      EQUIVALENCE (MBKPNT,SRCTBL(2))
C META:        CONTAINS INTERNAL BIT CODES FOR METALINGUISTIC CLASSES
      EQUIVALENCE (META(1),SRCTBL(3))
C PRODTB:      CONTAINS BASIC PRODUCTIONS
      EQUIVALENCE (PRODTB(1),SRCTBL(53))
C
C        5.    PROGRAM CONTROL FLAGS
C
      COMMON/FLAGS/FLAGS
      LOGICAL ENDFLG,NEWSTM
      DIMENSION FLAGS(4)
C ENDFLG:      TRUE WHEN SOURCE STATEMENT TOTALLY IN STACK
      EQUIVALENCE (ENDFLG,FLAGS(1))
C NEWSTM:      TRUE WHEN NEXT SOURCE STATEMENT REQUESTED FOR PROCESS
      EQUIVALENCE (NEWSTM,FLAGS(2))
C
C        6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C              LENGTH AND CURRENT NUMBER OF ACTIVE TEMPORARY STORAGE
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C        7.    STRING STORAGE AREA
C              POINTER TO THE LAST PROCESSED CHARACTER OF A STATEMENT
      COMMON/INPTR/CNT
C
C        8.    NAME TABLE POINTERS TO BCD LITERALS
C
      COMMON/BCDPTR/BCDPTR
      DIMENSION BCDPTR(7)
C DOTAC:       NAMTBL POINTER TO ALPHAMERIC LITERAL '.AC.'
      EQUIVALENCE (DOTAC,BCDPTR(1))
C
C        9.    NAME TABLE POINTERS TO NUMBERS
C
      COMMON/NUMPTR/NUMPTR
      DIMENSION NUMPTR(13)
C ZEROPT:      NAMTBL POINTER TO '0.    '
      EQUIVALENCE (ZEROPT,NUMPTR(2))
C ONEPT:       NAMTBL POINTER TO '1.    '
      EQUIVALENCE (ONEPT,NUMPTR(4))
C TENPT:       NAMTBL POINTER TO '10.   '
      EQUIVALENCE (TENPT,NUMPTR(13))
C
C       10.    TABLE STORAGE FOR GEOMETRIC FUNCTION PROCESSOR
C
      INCLUDE (GMTY)
C GEOLOC:      GEOMETRIC PRODUCTION STARTING INDEX IN GEOMTB
C PMIDTB:      INTERNAL BIT REPRESENTATIONS FOR EACH ELEMENT OF GEOMTB
C GEOMTB:      GEOMETRIC FORMAT PRODUCTIONS ARRANGED BY SURFACE TYPE
C
C       11.    SEQUENCE NUMBER STORAGE
C
      INCLUDE (SEQCOM)
C SEQNO:       INTERNALLY GENERATED STATEMENT NUMBER
C SEQNUM:      ALPHANUMERIC REPRESENTATION OF CURRRENT STATEMENT NUMBER
C
C       13.    NAMTBL POINTERS TO NEGATIVE NUMBERS
C              NAMTBL POINTER TO -1.
      COMMON/NEGPTR/NONEPT
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL INTERP
      DIMENSION PRT(7)
C INTERP:      NORMALLY TRUE,INDICATING INTERPRETIVE APPROACH DEFAULT
      EQUIVALENCE (INTERP,PRT(3))
C
C       15.    ARRAY LIMIT STORAGE
C
      COMMON/SBSCPT/SBSCPT
      DIMENSION SBSCPT(101),RANGE(100)
C RNGPT:       POINTER TO NEXT RANGE ENTRY
      EQUIVALENCE (RNGPT,SBSCPT(1))
C RANGE:       STORAGE FOR APT RESERVE STATEMENT INFORMATION
      EQUIVALENCE (RANGE(1),SBSCPT(2))
C
C       16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C FADD:        CONTAINS COMMAND CODE ( 1) FOR FADD COMMAND
      EQUIVALENCE (FADD,IL(1))
C FSUB:        CONTAINS COMMAND CODE ( 2) FOR FSUB COMMAND
      EQUIVALENCE (FSUB,IL(2))
C FMPY:        CONTAINS COMMAND CODE ( 3) FOR FMPY COMMAND
      EQUIVALENCE (FMPY,IL(3))
C FDIV:        CONTAINS COMMAND CODE ( 4) FOR FDIV COMMAND
      EQUIVALENCE (FDIV,IL(4))
C FEXP:        CONTAINS COMMAND CODE ( 5) FOR FEXP COMMAND
      EQUIVALENCE (FEXP,IL(5))
C SEQNCE:      CONTAINS COMMAND CODE ( 9) FOR SEQNCE COMMAND
      EQUIVALENCE (SEQNCE,IL(9))
C CONJMP:      CONTAINS COMMAND CODE (11) FOR CONJMP COMMAND
      EQUIVALENCE (CONJMP,IL(11))
C HOLDAT:      CONTAINS COMMAND CODE (21) FOR HOLDAT COMMAND
      EQUIVALENCE (HOLDAT,IL(21))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C TABCYL:      MODE CODE (11) FOR TABULATED CYLINDER
      EQUIVALENCE (TABCYL,MODX(11))
C POINT:       MODE CODE (19) FOR POINT
      EQUIVALENCE (POINT,MODX(19))
C VECTOR:      MODE CODE (20) FOR VECTOR
      EQUIVALENCE (VECTOR,MODX(20))
C REAL:        MODE CODE (21) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C BOOL:        MODE CODE (23) FOR BOOLEAN TYPE
      EQUIVALENCE (BOOL,MODX(23))
C SUBSCR:      MODE CODE (24) FOR SUBSCRIPT
      EQUIVALENCE (SUBSCR,MODX(24))
C STRING:      MODE CODE (25) FOR STRING
      EQUIVALENCE (STRING,MODX(25))
C PATERN:      MODE CODE (26) FOR PATTERN
      EQUIVALENCE (PATERN,MODX(26))
C BOUNDS:      MODE CODE (27) FOR BOUNDS
      EQUIVALENCE (BOUNDS,MODX(27))
C OBJECT:      MODE CODE (28) FOR OBJECT
      EQUIVALENCE (OBJECT,MODX(28))
C SSURF:       MODE CODE (29) FOR SCULPTURED SURFACE
      EQUIVALENCE (SSURF,MODX(29))
C SCURV:       MODE CODE (30) FOR SCULPTURED CURVE
      EQUIVALENCE (SCURV,MODX(30))
C
C       18.    STRING STORAGE AREA
C              STORAGE OF INTERNAL REPRESENTATION OF STRING OR SYMBOL
      COMMON/CHRX/CHR
      CHARACTER CHR*400
C FIRST 3 BYTES CONTAIN CHARACTER REPRESENTATION OF NUMBER OF
C CHARACTERS IN STRING, REMAINING BYTES CONTAIN STRING
C
C       22.    MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      LOGICAL MACLDD,ILHLT,MACRED,FINMAC,ENTRY,SHOULD
      DIMENSION MACXX1(71)
C MACLDD:      TRUE WHEN MACRO TEXT IS TO BE LOAD INTO MCBUFF TABLE
      EQUIVALENCE (MACLDD,MACXX1(7))
C ILHLT:       TRUE IF I.L. SHOULD NOT BE PLACED IN ILFILE
      EQUIVALENCE (ILHLT,MACXX1(14))
C TEXTST:      POINTER TP MCBUFF OF MACRO TEXT WORD BEING PROCESSED
      EQUIVALENCE (TEXTST,MACXX1(15))
C MACRED:      SET TRUE TO INDICATE INPUT FROM MCBUFF TABLE
      EQUIVALENCE (MACRED,MACXX1(18))
C INTMED:      0=NO -,-1=INTERMEDIATE-,+1=FINAL MACRO PROCESSING
      EQUIVALENCE (INTMED,MACXX1(22))
C MAJWRD:      CONTAINS ACTUAL MAJOR WORD
      EQUIVALENCE (MAJWRD,MACXX1(23))
C FINMAC:      TRUE IF SECOND FINAL PASS OF MACRO PROCESSING
      EQUIVALENCE (FINMAC,MACXX1(24))
C WAY:         INDICATES TYPE OF MACRO PROCESSING
      EQUIVALENCE (WAY,MACXX1(26))
C ENTRY:       FALSE ON FIRST ENTRY TO MATCH FOR A MACRO EXPRESSION
      EQUIVALENCE (ENTRY,MACXX1(40))
C MAJOR:       CURRENT CALL ASSIGNED VALUE IF MAYWRD IS MACRO VARIABLE
      EQUIVALENCE (MAJOR,MACXX1(44))
C WHCHMN:      EQUAL TO NUMBER OF CURRENT MACRO BEING PROCESSED
      EQUIVALENCE (WHCHMN,MACXX1(63))
C SHOULD:      MACRO INDICATOR. NORMALLY FALSE
      EQUIVALENCE (SHOULD,MACXX1(70))
C
C       28.    OPERAND MODIFIERS
C
      COMMON/SUBLST/SUBLST
      DIMENSION SUBLST(136)
C UNDEF:       NAMTBL POINTER TO EXECUTION SUBROUTINE UNDEF
      EQUIVALENCE (UNDEF,SUBLST(74))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C MODHLF:      NORMAL MODE CODE LIMIT 500
      EQUIVALENCE (MODHLF,MODULI(2))
C
C       36.    SYSTEM MACRO AND SEGMENT READ VARIABLES
C
      COMMON/MACSEG/MACSEG
      LOGICAL LMREND
      DIMENSION MACSEG(6)
C LMREND:      FLAG ON AFTER COMPLETION READING A SYSTEM MACRO
      EQUIVALENCE (LMREND,MACSEG(6))
C
C       37.    INCLUSIVE SUBSCRIPT VARIABLES
C
      COMMON/ISSCOM/ISSCOM
      LOGICAL ISSFL,ISSEND
      DIMENSION ISSCOM(9),ISSTRM(2)
C ISSA:        LOWEST SUBSCRIPT OF AN INCLUSIVE SUBSCRIPT STRING
      EQUIVALENCE (ISSA,ISSCOM(1))
C ISSB:        HIGHEST SUBSCRIPT OF AN INCLUSIVE SUBSCRIPT STRING
      EQUIVALENCE (ISSB,ISSCOM(2))
C ISSC:        INCREMENT OR DECREMENT FOR INCLUSIVE SUBSCRIPT STRING
      EQUIVALENCE (ISSC,ISSCOM(3))
C ISSVBL:      NAMTBL POINTER TO THE INCLUSIVE SUBSCRIPTED VARIABLE
      EQUIVALENCE (ISSVBL,ISSCOM(4))
C ISSFL:       TRUE DURING INCLUSIVE SUBSCRIPT PROCESSING
      EQUIVALENCE (ISSFL,ISSCOM(6))
C ISSEND:      END OF INCLUSIVE SUBSCRIPT PROCESSING
      EQUIVALENCE (ISSEND,ISSCOM(7))
C ISSTRM:      SAVES THE STACK TOP ITEMS DURING SUBSCRIPT PROCESSING
      EQUIVALENCE (ISSTRM(1),ISSCOM(8))
C
C       38.    COMMON BLOCK MACRO CALL STATEMENT
C              INDICATES A MACRO CALL BEING PROCESSED
      COMMON/CALFLG/ICALLF
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C
C       42.    COMMON BLOCK FOR CANON AND OBTAIN ARGUMENT STORAGE
C
      COMMON/CANSTR/CANSTR
      DIMENSION CANSTR(18)
C CANPTR:      POINTER TO LAST CANSTK ENTRY
      EQUIVALENCE (CANPTR,CANSTR(1))
C
C       43.    DO LOOP CONTROL VALUES
C
      COMMON/DOLOOP/DOLOOP
      LOGICAL DOFLAG,IFFLAG
      DIMENSION DOLOOP(9)
C JUMPTO:      MARKER SET AFTER JUMPTO OR IF FOR LABEL CONTROL
      EQUIVALENCE (JUMPTO,DOLOOP(1))
C RELDO:       CURRENTLY NESTED DO LOOPS
      EQUIVALENCE (RELDO,DOLOOP(3))
C DOJUMP:      VBL FOR COMPUTED GOTO AT LOOP PROCESSING
      EQUIVALENCE (DOJUMP,DOLOOP(6))
C DOFLAG:      FLAG IS ON DURING OPENED LOOP
      EQUIVALENCE (DOFLAG,DOLOOP(7))
C IFFLAG:      FLAG ON WHEN LOGICAL IF OCCURS
      EQUIVALENCE (IFFLAG,DOLOOP(9))
C
C       44.    ERROR POSITION TABLE
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS,ESTACK,ERGSTK
      LOGICAL NOWARN
      DIMENSION ERRPOS(302),ESTACK(100),ERGSTK(100)
C NOWARN:      FLAG TRUE IS SUPPRESSING OUTPUT OF WARNING NR. 50
      EQUIVALENCE (NOWARN,ERRPOS(1))
C ESTACK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN STACK
      EQUIVALENCE (ESTACK(1),ERRPOS(103))
C ERGSTK:      INPUT STATEMENT ERROR POSITION WHEN DETECTED IN ARGSTK
      EQUIVALENCE (ERGSTK(1),ERRPOS(203))
C
C       45.    NUMBER TABLE INDICES
C
      INCLUDE (NUMBLK)
C MNMBND:      LAST NAME TABLE ENTRY TO MACRO ASSIGNED NUMBER SECTION
C NUMIDX:      NAMTBL INDEX OF A NUMBER GIVEN IN THE CURRENT STATEMENT
C  NMBRS:      QUANTITY OF NUMBERS IN THE CURRENT STATEMENT
C LSTCHR:      LAST CHARACTER OF A NUMBER
C*
      CHARACTER IICHR*20
      DIMENSION ARGX(2),ICNUM(3)
      EQUIVALENCE(ARGX(1),ARG1),(ARGX(2),ARG2)
C      IMPLEMENTATION DEPENDENT  NAME $21T$1                       ..CD.
      CHARACTER*6  ICD21
      CHARACTER*6 BLK,ISEQ1,ON,OFF,ZERO*3,TRUE,FALSE
      LOGICAL OPDFLG
      INCLUDE (SDP)
      INTEGER BCDF
      EXTERNAL BCDF
      DATA LBKPNT/1/
      DATA BLK/'    '/,CLDATA/69/
      DATA  ISEQ1/' 1  '/,TRUE/'.TRUE.'/,FALSE/'.FALSE'/
      DATA STRCNT /0/,ON/'ON  '/,OFF/'OFF '/
      DATA ICD21/'$21T$1'/
      DATA ZERO/'  0'/
C**
      SEQNUM=ISEQ1
      MNMBND=NUMBST
      NUMIDX=NUMBST
C      PUT IMPLEMENTATION DEPENDENT NAME INTO NAMTBL              ..CD.
      I=NAME(ICD21)
      NAMTBL(I)=TEMP(1)+REAL
C      PUT FIRST ITEM IN CANONICAL FORM BLOCK 3.
      I=GETTMP(POINT)
C      GENERATE I.L. TO STORE -1.0 IN PERMANENT LOCATION.
C        (USE OF TEMPORARY CAN CAUSE INCORRECT I.L.)
C        STORE NAMTBL POINTER TO LOCATION OF -1.0 IN NONEPT.
      CALL MACLBL(ONEPT,0,NONEPT)
      NAMTBL(NONEPT)=VBL(1)+REAL
      CALL RESRVZ(NONEPT,REAL,TXXXX(1,REAL),1)
      CALL OPCODE(FSUB)
      CALL ARGCVT(NONEPT)
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ONEPT)
      CALL RLSLIN
C  GENERATE IL TO RESERVE LOCATION FOR .AC. IN CANONICAL FORM BLOCK
C  TO OVERCOME IMPEMENTATION DEPENDENCY OF USE OF AC
      CALL RESRVZ(DOTAC,REAL,TXXXX(1,REAL),1)
      GO TO 11
C
    1 IF(.NOT.NEWSTM) GO TO 20
C...  IF INTERP FALSE, TRANSLATION IS COMPLETE
      IF(.NOT.INTERP) RETURN
C
C... SET LARGE SURFACE ARGUMENT COUNT = 0
C
    3 BIGCNT = 0
      IBR=0
      IF (STACK(1,TOP) .NE. RTERM(2) ) GO TO 11
    5 IF (IFFLAG)CALL BOOLIF(0)
      OPDFLG=.FALSE.
      NUMIDX=MNMBND
      NMBRS=0
      IF (.NOT.DOFLAG)GOTO 6
      DOJUMP=3
      CALL LOOP
    6 IF(.NOT.ILHLT)GO TO 10
      IF(INTMED.NE.1)GO TO 11
   10 SEQNO=SEQNO+1
      CALL BINBCD(SEQNO,SEQNUM,TOP)
      IF(MACLDD.OR.ILHLT)GO TO 11
      CALL OPCODE(SEQNCE)
      CALL ONEARG(SEQNO)
      CALL RLSLIN
      IF(JUMPTO.NE.SEQNO)GOTO 11
      CALL BINBCD(SEQNO-1,SEQNUM,TOP)
      CALL ALARM(1009,0,4,'RECOG   ')
      CALL BINBCD(SEQNO,SEQNUM,TOP)
      JUMPTO=0
C...  NEW STATEMENT
C
   11 NEWSTM = .FALSE.
      TOP=1
      IF(.NOT.MACLDD) GO TO 12
      STACK(1,1) = MCLTRM(2)
      L = MCLTRM(1)/MODULO
      BKPT=MBKPNT
      GO TO  13
   12 STACK(1,1) = LTERM(2)
      L = LTERM(1)/MODULO
      BKPT=BRKPNT
C
      DO 15 I=1,30
   15 TXXXX(2,I) = 0
      ARGTOP = 0
      CANPTR=0
   13 STACK(2,1)=META(L)
      GO TO 2900
C...  FIND MATCHING PRODUCTION
   20 IF((.NOT.LMREND).AND.(.NOT.ISSFL).AND.(.NOT.ISSEND))GO TO 21
      LBKPNT=BKPT
      ISSEND=.FALSE.
      LMREND=.FALSE.
   21 IF(MACRED)LBKPNT=BKPT
   25 ERRP=TOP
      TOPT2=TOP*2
      I=SEARCH(STACK,TOPT2,PRODTB(LBKPNT),ERRP)
      LBKPNT=1
C
      IF(I.GT.50)GO TO 50
      GOTO ( 100, 200, 300, 400, 500, 600, 700, 800, 900,1000,
     1      1100,2950,1300,1450,1500,1600,1700,1800,1900,2000,
     2      2100,2200,2300,2400,2500,2600,2700,2800,2900,3000,
     3      3100,3200,3300,3400,3500,3600,3700,3700,3700,4000,
     4      5000,5000,5000,5000,5000,5000,5000,5000,5000,1200),I
   50 IF(I.LT.70)GO TO 5100
      J=I-70
      GOTO(7100,3500,2000,2000,7500,7500,7500,7800),J
      GO TO 5200
C
C          SET I TO G
  100 CALL SETMOD (TOP-1,GEOM)
      GOTO 220
C     IDENTIFIER TO PROCEDURE
  200 CALL SETMOD (TOP-1,PROCED)
  220 LBKPNT = BKPT
      GO TO 25
C...       GENERATE CODE FOR STRING
C
  300 CHR=ZERO//BLK
  310 CALL INPUT
      I=STACK(1,TOP)
      IF(I.EQ.QUOTE(2))GO TO 320
      I=-I
      CALL CONCAT(CHR,CNAMTB(I))
      TOP=TOP-1
      GO TO 310
  320 STRCNT=STRCNT+1
      CALL MACLBL(QUOTE(2),-STRCNT,I)
C              ENTER STRING NAME IN NAMTBL
C
C              ENTER STRING NAME IN STACK
C
      STACK(1,TOP-1) = I
      NAMTBL(I) = VBL(1)+STRING
      L = VBL(1)/MODULO
      STACK(2,TOP-1) = META(L)
C
C              WRITE DATA STATEMENT
C
      CALL OPCODE(HOLDAT)
C... NUMBER OF CHARACTERS
      READ (CHR,'(I3)') NCHR
      CALL TWOARG(I,NCHR)
C... WRITE CHARACTER STRING TO IL , BY CONVERTING
C    IWRD CHARACTERS AT A TIME TO INTEGER FOR TRANSFER
      IF (MOD(NCHR,IWRD).NE.0) NCHR=(NCHR/IWRD+1)*IWRD
      DO 303 J=4,NCHR,IWRD
        CALL ONEARG(BCDF(CHR(J:J+IWRD-1)))
  303 CONTINUE
      CALL RLSLIN
      TOP=TOP-1
      GO TO 2900
C     CHECK FOR CLDATA(N), OTHERWISE ERROR
  400 J=STACK(1,TOP-4)
      K=NAMTBL(J)
      L=K/MODULO
      IF(K-L*MODULO.NE.CLDATA)GO TO 420
      IF(L.EQ.IDENT(1)/MODULO)CALL SETMOD(TOP-4,PERMID)
      L=COMMA(1)/MODULO
      STACK(1,TOP-1)=STACK(1,TOP)
      STACK(2,TOP-1)=STACK(2,TOP)
      ESTACK(TOP-1)=ESTACK(TOP)
      STACK(1,TOP-3)=COMMA(2)
      STACK(2,TOP-3)=META(L)
      TOP=TOP-1
      GO TO 220
  420 CALL ALARM(1111,TOP-4,8,'RECOG   ')
      GO TO 2810
C     IMPLIED LABEL OR IDENTIFIER TO LABEL
  500 DOJUMP=2
      IF (RELDO.GT.0) CALL LOOP
      K = STACK(1,TOP-1)
      IF (K.LE.NAMMAX) GOTO 530
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
      K=K-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,K,IDUMMY)
      CALL BCDBIN(CNUMTB(K),KK,ICOUNT)
      K=KK+10000
  505 CALL MACLBL(K,-WHCHMN,K)
      STACK(1,TOP-1) = K
      IF(NAMTBL(K)/MODULO .EQ. LABEL(1)/MODULO)GO TO 710
  506 IF((.NOT.FINMAC).AND.(WHCHMN.NE.0))GO TO 510
      NAMTBL(K) = LABEL(1)+WHCHMN
      L = LABEL(1)/MODULO
  507 STACK(2,TOP-1) = META(L)
      CALL LABELZ(K)
      CALL LABCON(-K)
C     ERASE FROM STACK
  520 TOP=TOP-2
      GO TO 2900
  530 IF(WHCHMN.EQ.0)GO TO 506
      IF(NAMTBL(K)/MODULO.NE.LABEL(1)/MODULO)NAMTBL(K)=IMPLAB(1)
      GO TO 505
  510 NAMTBL(K) = IMPLAB(1)+WHCHMN
      L = IMPLAB(1)/MODULO
      GO TO 507
  600 IF(JUMPTO.NE.0)JUMPTO=SEQNO+2
       GO  TO    5
  700 IF(WHCHMN.NE.0)GO TO 500
  710 CALL ALARM(1003,TOP-1,8,'RECOG   ')
      GO TO 520
C...       BINARY OPERATION GENERATIR
  800 ARG1=STACK(1,TOP-3)
      ARG2=STACK(1,TOP-1)
      OP=STACK(1,TOP-2)
      DO 810 L=1,2
      J = MODE(ARGX(L))
      IF(J.EQ.REAL) GO TO 810
      K=2*L-5
      CALL ALARM(1004,TOP+K,8,'RECOG   ')
  810 IF(IFTMP(ARGX(L))) CALL PUTTMP(J)
      RSLT = GETTMP(REAL)
      IF (NAMTBL(OP).NE.SLASH(1)) GOTO 801
      CALL OPCODE (FDIV)
      GO  TO  850
  801 IF (NAMTBL(OP).NE.MINUS(1)) GOTO 802
      CALL OPCODE (FSUB)
      GO  TO  850
  802 IF (NAMTBL(OP).NE.PLUS(1))  GOTO 803
      CALL OPCODE (FADD)
      GO  TO  850
  803 IF (NAMTBL(OP).NE.ASTER(1)) GOTO 804
      CALL OPCODE (FMPY)
      GO  TO  850
  804 CALL OPCODE(FEXP)
  850 CALL ARGCVT(RSLT)
      CALL ARGCVT(ARG1)
      CALL ARGCVT(ARG2)
      CALL RLSLIN
      STACK(1,TOP-3) = RSLT
      L = NAMTBL(RSLT)/MODULO
      STACK(2,TOP-3)=META(L)
  860 STACK(1,TOP-2)=STACK(1,TOP)
      ESTACK(TOP-2)=ESTACK(TOP)
      STACK(2,TOP-2) = STACK(2,TOP)
      TOP = TOP-2
      GO TO 220
C...       INITIALIZE STRING, THEN READ
  900 I = STACK(1,TOP)
      CHR = ZERO//BLK
      CALL CONCAT(CHR,CNAMTB(I))
      GO TO 2900
C
C...     SUBSCRIPT ON RIGHT
 1000 IF(ISSFL)GO TO 1030
      I=STACK(1,TOP-2)
      IF (I.GT.NAMMAX) THEN
        J=NUMBER(1)/MODULO
      ELSE
      J=NAMTBL(I)/MODULO
      ENDIF
      IF(ARGTOP.GT.0)GO TO 1050
      IF(I.GT.NAMMAX)GO TO 1030
      IF(J.EQ.IDENT(1)/MODULO .OR. J.EQ.PERMID(1)/MODULO)GO TO 1050
C    LIEGT EIN   READ-BEFEHL VOR ?
 1030 IF (STACK(1,2).LE.NAMMAX) THEN
        IF(NAMTBL(STACK(1,2)).EQ.19057)CALL  RESRED
      ENDIF
      CALL SUBCOD (TOP-4)
C        MODIFY STACK
 1010 STACK(1,TOP-3)=STACK(1,TOP)
      STACK(2,TOP-3)=STACK(2,TOP)
      ESTACK(TOP-3)=ESTACK(TOP)
      TOP=TOP-3
      GO TO 220
C
C...     CHECK FOR INCLUSIVE SUBSCRIPT FORMAT
C
 1050 IF(J.EQ.IDENT(1)/MODULO)CALL SETMOD(TOP-2,PERMID)
C        PLACE BIT PATTERNS IN TOP OF STACK FOR SEARCH
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=STACK(1,TOP-2)
      ERGSTK(ARGTOP)=ESTACK(TOP-2)
      K=TOP+1
      N5=TOP
      STACK(2,K)=-1
      ATP=1
      IF(ARGTOP.GT.5)ATP=ARGTOP-4
      DO 1060 I=ATP,ARGTOP
      K=K+1
      L=ARGSTK(I)
      IF(L.LE.NAMMAX)GO TO 1052
      IARG=REAL
      GO TO 1058
 1052 M=MODULO*(NAMTBL(L)/MODULO)
      IARG=NAMTBL(L)-M
      IF(IARG.GE.MODHLF)IARG=IARG-MODHLF
      IF (IARG.EQ.0) GOTO 1092
      IF(M.EQ.VBL(1) .OR. M.EQ.TEMP(1))GO TO 1058
      IF(M.EQ.PERMID(1))GO TO 1056
      IF (M.NE.NUMBER(1)) GO TO 1092
      IARG=REAL
      GO TO 1058
 1056 IARG=IARG+50
 1058 STACK(2,K)=PMIDTB(IARG)
 1060 CONTINUE
C        SEARCH SUBSCR PRODUCTIONS
      L=GEOLOC(SUBSCR)
      ERRP=ARGTOP
      KT2=K*2
      I=SEARCH(STACK,KT2,GEOMTB(L),ERRP)
      IF (I.EQ.200) GO TO 1090
      IF (ERRP.GE.ATP) GO TO 1091
      ISSC=1
      J=1
      IF(I.LT.6) GO TO 1070
      II=ARGSTK(ATP)
      I=I-5
 1062 IF(II.LE.NAMMAX)GO TO 1094
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
      II=II-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,II,IDUMMY)
      CALL BCDBIN(CNUMTB(II),III,IDUMMY)
      GO TO (1068,1080,1085),J
C
C        PREPARE AND STORE ISSC
 1068 ISSC=III
 1070 K=ARGSTK(ATP+1)
      IF (K.LE.NAMMAX) THEN
        IF (NAMTBL(K)-NAMTBL(K)/MODHLF*MODHLF.EQ.60)ISSC=-ISSC
      ENDIF
C        PREPARE AND STORE ISSB
      J=2
      IF(I.NE.3 .AND. I.NE.5 )GO TO 1072
      II=ARGSTK(ARGTOP-I/2)
      GOTO 1062
 1072 IF(RNGPT.EQ.1)GO TO 1096
      II=STACK(1,TOP-4)
      III=RNGPT-2
      DO 1075 M=1,III,2
      IF(RANGE(M).EQ.II)GO TO 1076
 1075 CONTINUE
      GO TO 1096
 1076 ISSB=RANGE(M+1)
      GO TO 1082
 1080 ISSB=III
C
C        PREPARE AND STORE ISSA
 1082 J=3
      ISSA=1
      IF (I.LT.4)GOTO 1084
      II=ARGSTK(ARGTOP)
      GOTO 1062
 1085 ISSA=III
C
 1084 IF((ISSB-ISSA)*ISSC.GT.0) GO TO 1086
      II=ISSB
      ISSB=ISSA
      ISSA=II
C        PLACE ISSA IN STACK AND SET FLAG, ETC. IF STRING CONTAINS
C          MORE THAN ONE ITEM
 1086 IF(ISSA.NE.1)GO TO 1088
      STACK(1,TOP-2)=ONEPT
      GO TO 1089
 1088 IICHR=BLK
      CALL BINBCD(ISSA,IICHR,K)
      IICHR(K+1:K+1)='.'
C
      I=NUMB(IICHR(:K+1))
C....ADD OFFSET OF NAMMAX TO CNUMTB ADDRESS FOR COMPATIBILITY
C....WITH PREVIOUS METHOD OF STORING NUMBERS IN NAMTBL
      STACK(1,TOP-2)=I + NAMMAX
 1089 II=NUMBER(1)/MODULO
      ARGTOP=ATP-1
      STACK(2,TOP-2)=META(II)
      ISSA=ISSA+ISSC
      IF(ISSC.LE.0 .AND. (ISSA.LT.ISSB .OR. ISSC.GT.-1))GO TO 1030
      IF(ISSC.GE.0 .AND. (ISSA.GT.ISSB .OR. ISSC.LT.1))GO TO 1030
      ISSVBL=STACK(1,TOP-4)
      ISSTRM(1)=STACK(1,TOP)
      ISSTRM(2)=STACK(2,TOP)
      STACK(1,TOP)=COMMA(2)
      II=COMMA(1)/MODULO
      STACK(2,TOP)=META(II)
      ISSFL=.TRUE.
      GO TO 1030
C
C     'FALSCHE INDIZIERUNGSANGABE'
 1090 IF (ERRP.EQ.ATP)ERRP=ATP
      GOTO 1091
 1092 ERRP=I
 1091 IERROR=2053
      IF (ERRP.EQ.ARGTOP) GOTO 1097
      GO TO 1095
C     'UNZULAESSIGE SYMBOLISCHE ZAHLANGABE'
 1094 IERROR=2054
      IF (J.EQ.3) GOTO 1097
      ERRP=ATP
      IF (J.EQ.2)ERRP=ARGTOP-I/2
 1095 TOP=TOP-2
      ARGTOP=ARGTOP-1
      GO TO 1098
 1097 ERRP=2-TOP
      GO TO 1098
C     'VARIABLE NICHT RESERVIERT'
 1096 IERROR=1013
      ERRP=4-TOP
 1098 CALL ALARM(IERROR,-ERRP,8,'RECOG   ')
      TOP=N5
      GO TO 2810
C
C...     SUBSCRIPT ON LEFT
C          DOES LEFT SIDE HAVE MODE
C
 1100 II=MODE(STACK(1,TOP-1))
 1101 IF(MODE(STACK(1,TOP-6)).NE.0) GO TO 1130
      I=STACK(1,TOP-6)
      NAMTBL(I) = NAMTBL(I)+II
C
C     FIND ARRAY LENGTH IN RANGE
      III=1
 1110 IF(III.GE.RNGPT)GO TO 1130
      IF(RANGE(III).EQ.STACK(1,TOP-6))GO TO 1120
      III=III+2
      GO TO 1110
C
C     RESERVE STORAGE
 1120 CALL RESRVZ(I,II,TXXXX(1,II),RANGE(III+1))
C
C
 1130 IF(II.EQ.BOUNDS .OR. II.EQ.OBJECT) GO TO 1805
      CALL SUBCOD(TOP-6)
C
C     MODIFY STACK
      STACK (1,TOP-5)=STACK(1,TOP-2)
      STACK (2,TOP-5)=STACK(2,TOP-2)
      ESTACK (TOP-5)=ESTACK(TOP-2)
      STACK (1,TOP-4)=STACK(1,TOP-1)
      STACK (2,TOP-4)=STACK(2,TOP-1)
      ESTACK (TOP-4)=ESTACK(TOP-1)
      GO TO 1010
C
 1200 K=STACK (1,TOP-1)
      IF(CNAMTB(K).NE.ON)GOTO 1210
      NOWARN=.TRUE.
      GOTO 1220
 1210 IF(CNAMTB(K).NE.OFF)GOTO 1230
      NOWARN=.FALSE.
 1220 IF (K.LE.NAMMAX) THEN
      IF(NAMTBL(K)/MODULO.EQ.IDENT(1)/MODULO)CALL SETMOD(TOP-1,PERMID)
      ENDIF
      GOTO 5
 1230 CALL ALARM(1008,TOP-1,8,'RECOG   ')
      GOTO 5
C
 1300 IF (STACK(1,TOP-2).LE.NAMMAX) THEN
        IF (NAMTBL(STACK(1,TOP-2)).EQ.MINUS(1)) GOTO 1400
      ENDIF
C     UNARY PLUS
      STACK(1,TOP-2) = STACK(1,TOP-1)
      STACK(2,TOP-2) = STACK(2,TOP-1)
      ESTACK(TOP-2) = ESTACK(TOP-1)
C
      GO TO 1420
C...       UNARY MINUS
 1400 ARG = STACK(1,TOP-1)
      J = MODE(ARG)
      IF(J.EQ.REAL) GO TO 1410
      CALL ALARM(1005,TOP-1,8,'RECOG   ')
 1410 IF(IFTMP(ARG)) CALL PUTTMP(J)
      RSLT = GETTMP(REAL)
      CALL OPCODE (FSUB)
      CALL ARGCVT(RSLT)
      CALL ARGCVT(ZEROPT)
      CALL ARGCVT(ARG)
      CALL RLSLIN
      STACK(1,TOP-2) = RSLT
      L = TEMP(1)/MODULO
      STACK(2,TOP-2)=META(L)
 1420 STACK(1,TOP-1)=STACK(1,TOP)
      STACK(2,TOP-1) = STACK(2,TOP)
      ESTACK(TOP-1) = ESTACK(TOP)
      TOP = TOP-1
      GO TO 220
C...
 1450 IF (STACK(1,TOP).NE.NUMBST+NAMMAX)GOTO 2900
      K=NUMIDX+1
      IF(K.GT.NUMBND)GOTO 1480
      NUMIDX=K
 1460 DO 1470 J=1,3
        TEXTST=TEXTST+1
        CALL MCXTRN(2,TEXTST,ICNUM(J))
 1470 CONTINUE
      CALL HOLFRM(ICNUM,CNUMTB(K),1,12,NWD)
C... INCREMENT FOR NUMBER TABLE ADDRESS
      STACK(1,TOP)=K+NAMMAX
      GOTO 2900
 1480 DO 1490 J=MNMBND,NUMBND
       K=K-1
       IF (CNUMTB(K).EQ.' ') GOTO 1460
 1490 CONTINUE
      K=NUMBND
      GOTO 1460
C...       VECTOR PRODUCTS
 1500 CALL INPUT
      CALL INPUT
      IF (ENDFLG.AND.(STACK(1,TOP-1).NE.DOLLAR(2)) ) GOTO 3
      IF(STACK(1,TOP).EQ.RPAREN(2))GOTO 1530
 1510 CNT=CNT-2
 1520 TOP=TOP-2
      GOTO 3215
 1530 IF(STACK(1,TOP-1).NE.ASTER(2))GOTO 1550
      CALL SETCHR(TOP-2,KREUZ)
      GOTO 1520
 1550 IF(STACK(1,TOP-1).NE.DECMAL(2))GOTO 1510
      CALL SETCHR(TOP-2,DOT)
      GOTO 1520
C...       ARGUMENT LIST
 1600 K=STACK(1,TOP-1)
      ARGTOP=ARGTOP+1
      ARGSTK(ARGTOP)=K
      ERGSTK(ARGTOP)=ESTACK(TOP-1)
      IF(K.GT.NAMMAX)GO TO 860
      IF(IFTMP(K)) CALL PUTTMP(MODE(K))
      J=NAMTBL(K)/MODULO
      IF(J.EQ.IDENT(1)/MODULO)
     /CALL SETMOD(TOP-1,PERMID)
      GO TO 860
C...       FUNCTION CALL GENERATOR
 1700 ARGTOP=ARGTOP+1
      I = STACK(1,TOP-1)
      ARGSTK(ARGTOP) = I
      IF(IFTMP(I)) CALL PUTTMP(MODE(I))
      J = GETTMP(REAL)
      MAJOR=STACK(1,TOP-3)
      IF(INTMED.NE.1)GO TO 1703
      WAY=3
      IF(FINMAC)GO TO 1702
      MAJWRD=MAJOR
 1701 ERGSTK(100)=TOP-3
      CALL MATCH
      IF(.NOT.ENTRY)GO TO 1705
      IF(MAJOR.LE.NAMMAX)GO TO 1706
      CALL ALARM(2025,TOP-3,8,'RECOG   ')
      GO TO 1703
 1706 IF(NAMTBL(MAJOR)/MODULO.NE.FCN(1)/MODULO)CALL ALARM(2025,TOP-3,
     * 8,'RECOG   ')
      GO TO 1703
 1702 CALL PATH
      IF(.NOT.SHOULD)GO TO 1705
 1703 CALL CALLZZ(MAJOR)
      CALL ARGCVT(J)
      CALL ARGGEN
      CALL RLSLIN
      IF(ENTRY)GO TO 1701
 1705 STACK(1,TOP-3)=J
      L = TEMP(1)/MODULO
      STACK(2,TOP-3)=META(L)
      ARGTOP=0
      TOP = TOP-3
      CALL VCTPRD(L)
      IF (L.EQ.1) GOTO 2900
      GOTO 220
C     STACK ARGUMENT
 1800 II = STACK(1,TOP-1)
      II = MOD(NAMTBL(II),MODULO)
      IF(II.GE.MODHLF)II=II-MODHLF
      GOTO 1101
C
C...  ERROR 1029:  'BOUNDED GEOMETRY MUST NOT BE SUBSCRIPTED.  STATE-
C                   MENT IGNORED.'
C
 1805 CALL ALARM(1029,TOP-4,8,'RECOG   ')
      CALL CALLZZ(UNDEF)
      CALL ARGCVT(STACK(1,TOP-6))
      CALL RLSLIN
      GOTO 2810
C...       SCAN PAST RIGHT TERMINATOR
 1900 CALL INPUT
      IF(STACK(1,TOP).EQ.RTERM(2))GO TO 520
      TOP=TOP-1
      GO TO 1900
C     REMOVE PARENTHESIS
C
 2100 STACK(1,TOP-2)=STACK(1,TOP-1)
      STACK(2,TOP-2)=STACK(2,TOP-1)
      ESTACK(TOP-2)=ESTACK(TOP-1)
      TOP=TOP-2
      GO TO 2900
C
C...       CONCATINATE TOP TO STRING, SET STACK TO 'LTR'
 2200 CALL SETCHR(TOP-1,LETTER)
 2500 K=STACK(1,TOP)
 2510 CALL CONCAT(CHR,CNAMTB(K))
      LSTCHR=STACK(1,TOP)
      TOP=TOP-1
      CALL INPUT
      GO TO 25
 2900 CALL INPUT
      IF (STACK(1,TOP).GT.NAMMAX)GOTO 1
      IF(NAMTBL(STACK(1,TOP)).NE.MCLTRM(1))GOTO 1
      BKPT=MBKPNT
      GO TO 1
 2950 IF (.NOT.ISSFL) GOTO 2900
      CALL ISSCOD
      GO TO 20
C...       NESTED ASSIGNMENT
 2300 IF (MODE(STACK(1,TOP-1)).EQ.BOOL)CALL BOOLIF(5)
      CALL REPLAC
      GO TO 860
C...       ASSIGNMENT STATEMENT
 2400 IF (MODE(STACK(1,TOP-1)).EQ.BOOL)CALL BOOLIF(5)
      CALL REPLAC
      GO TO 5
 2600 CALL PRO026
      GO  TO  1
 2700 DOJUMP = 1
      CALL LOOP
      GOTO 6
C     STACK ARGUMENT
 2800 CALL ALARM(1007,ERRP,8,'RECOG   ')
      IF (ICALLF.EQ.1) CALL MACREC(12)
 2810 BIGCNT = 0
      IBR=0
      IF(STACK(1,TOP).EQ.RTERM(2)) GO TO 5
      TOP=99
      CALL INPUT
      GO TO 5
C
C...       IS MODE OF JUMP VARIABLE 'REAL'
C
 3000 IF(ARGTOP.GT.0)CALL ALARM(2052,-ARGTOP,8,'RECOG   ')
      K = STACK(1,TOP-7)
      L = MODE(K)
      IF(L.NE.REAL)
     1CALL ALARM(1008,TOP-7,8,'RECOG   ')
      IF(IFTMP(K)) CALL PUTTMP(L)
      CALL OPCODE (CONJMP)
C
C...       VARIABLE
C
      CALL ARGCVT(K)
C
C...   LABELS
C
      DO 3001 I=1,5,2
      K = TOP-6+I
      K = STACK(1,K)
      IF (K.GT.NAMMAX) GOTO 3004
      J = MODULO*(NAMTBL(K)/MODULO)
      IF(J.NE.LABEL(1) .AND. J.NE.IMPLAB(1))NAMTBL(K)=IMPLAB(1)
      IF(WHCHMN.EQ.0)GO TO 3002
      GO TO 3003
C.... DECREMENT BY NAMMAX FOR ADDRESS IN NUMBER TABLE, CNUMTB
 3004 K=K-NAMMAX
      IF(NLAST.GT.0)CALL MCXTRN(5,K,IDUMMY)
      CALL BCDBIN(CNUMTB(K),KK,ICOUNT)
      K=KK+10000
 3003 CALL MACLBL(K,-WHCHMN,K)
      IF(NAMTBL(K).EQ.0)NAMTBL(K)=IMPLAB(1)+WHCHMN
 3002 CALL LABCON(K)
 3001 CALL ONEARG(K)
      CALL RLSLIN
      GO TO 6
C
 3200 CALL INPUT
      IF (ENDFLG) GOTO 3
      ERRP=TOP-1
      IF(STACK(1,TOP).NE.ASTER(2))GO TO 3210
C                  **  TO  'DBLAST'
      TOP=ERRP
      CALL SETCHR (TOP,DBLAST)
      GO TO 25
 3210 TOP=ERRP
      CNT=CNT-1
 3215 LBKPNT=MBKPNT-6
      GO TO 25
C           VECTOR PRODUCT (STACK PREPARATION)
 3300 IF (STACK(1,TOP-2).LE.NAMMAX) THEN
        IF (NAMTBL(STACK(1,TOP-2)).EQ.DOT(1))GOTO 3320
      ENDIF
      DO 3310 J=1,3,2
      IF (STACK(1,TOP-J).LE.NAMMAX) THEN
      IF(MOD(NAMTBL(STACK(1,TOP-J)),MODHLF).NE.VECTOR)GOTO 3330
      ENDIF
 3310 CONTINUE
 3320 I=-1
      CALL VCTPRD(I)
      GOTO 220
 3330 CALL ALARM(1008,TOP-J,8,'RECOG   ')
      GOTO 2810
C
C...       ENTER DIGIT STRING IN NAME TABLE
 3400 CALL CONCAT(CHR,'.')
      LSTCHR=NUMIDX
 2000 IICHR=CHR(4:15)
      K=I
      I = NUMB(IICHR)
 3405 L = NUMBER(1)/MODULO
C....ADD OFFSET OF NAMMAX TO CNUMTB ADDRESS FOR COMPATIBILITY
C....WITH PREVIOUS METHOD OF STORING NUMBERS IN NAMTBL
      I= I + NAMMAX
 3410 STACK(1,TOP-1) = I
      STACK(2,TOP-1) = META (L)
      ERRP=TOP-1
      IF(K.LT.70)GOTO 220
      IF (K-73)7200,7300,7400
 3500 L = IDENT(1)
      K=I
      READ (CHR,'(I3)') NCHR
      IF(NCHR.GT.6) CALL ALARM(16,TOP-1,4,'RECOG   ')
      IICHR = CHR(4:NCHR+3)
      I = NAME(IICHR)
      IF (NAMTBL(I).EQ.0) NAMTBL(I)=L
      L = NAMTBL(I)/MODULO
      GO TO 3410
C...       SET PERIOD AND CONCATINATE TOP TO DIGIT STRING
 3600 CALL SETCHR(TOP-1,NUMBER)
      GO TO 2500
 3700 CALL PRO020(I)
      IF (I.NE. 38) GO TO 2900
      GO TO 1
C
 4000 CALL KONAST(TENPT)
      GOTO 220
C
C...  MACRO PROCESSING
C
 5100 J = I - 50
      IF(J.EQ.9)CALL LABCON(0)
      CALL MACREC(J)
      GO TO (220,220,1,1,2900,1,5110,1,5110,2900,1),J
 5110 DOJUMP=J-3
      CALL LOOP
      GOTO 1
C
C... LARGE SURFACE PRODUCTIONS  ****************************************
C... IF ACTION NUMBER EQUALS 101, CHANGE STACK FROM CONBIG / TO
C... BIGGEO /.
C... IF ACTION NUMBER IS NOT EQUAL TO 101, ADD 1 TO LARGE SURFACE
C... ARGUMENT COUNT AND CALL LCANON, LARGES OR INPAT
C
 5200 IF(I.NE.101)GO TO 5210
      CALL SETMOD(TOP-1,BIGGEO)
      GO TO 5205
C
 5210 BIGCNT=BIGCNT+1
      IF(IBR.NE.0)GO TO 5250
C
      N3=STACK(1,TOP-3)
      IF(N3.GT.NAMMAX)GO TO 5240
      IF(NAMTBL(N3).NE.CANON(1))GO TO 5240
      IBR=1
      GO TO 5250
 5240 N5=STACK(1,TOP-5)
      M5=NAMTBL(N5)-BIGGEO(1)
      IF(M5.GE.MODHLF)M5=M5-MODHLF
      IF(M5.NE.TABCYL)GO TO 5245
      IBR=2
      GO TO 5250
 5245 IF(M5.NE.PATERN)GO TO 5248
      IBR=3
      GO TO 5250
 5248 ERRP=TOP-5
      IF(M5.NE.SSURF.AND.M5.NE.SCURV)GO TO 2800
      IBR=4
C
 5250 GO TO (5255,5270,5280,5290),IBR
 5255 CALL LCANON(I,BIGCNT)
      GO TO 5205
 5270 CALL LARGES(I,BIGCNT)
      GO TO 5205
 5280 CALL INPAT(I,BIGCNT)
      GO TO 5205
 5290 CALL SSDEF(I,BIGCNT)
C
C... START PRODUCTION SEARCH AT BRKPNT IF CALLED FOR BY PREVIOUS
C... PRODUCTION. IF PREVIOUS PRODUCTION RESULTED IN A NULL STACK, SET
C... NEW STATEMENT FLAG EQUAL TO .TRUE.  IF PREVIOUS PRODUCTION CALLED
C... FOR A NEW CHARACTER TO BE ADDED TO THE STACK, CALL INPUT.
C
C
 5205 IF (I .LE. 102)  LBKPNT = BKPT
      I = I-100
      GO TO (25,1,3,5220,5220) ,I
 5220 CALL INPUT
      GO TO 1
C
 5000 CALL RECOGN(I,IASNRT)
      GO TO(25,220,600,1000,2900),IASNRT
C
 3100 CALL PRO027(5)
      GO TO 5
C
 7100 STACK(1,TOP-1)=STACK(1,TOP)
      STACK(2,TOP-1) = STACK(2,TOP)
      ESTACK(TOP-1) = ESTACK(TOP)
      OPDFLG=.TRUE.
      GOTO 2500
C
 7200 IF(NAMTBL(I).NE.RELAT(1))GOTO 7210
      TOP=TOP+2
      STACK(1,TOP-1)=ZEROPT
      IF(CNAMTB(I).EQ.TRUE)STACK(1,TOP-1)=ONEPT
      NAMTBL(I)=IDENT(1)
      CALL REPLAC
      NAMTBL(I)=VBL(1)+BOOL
      TOP=TOP-3
      GOTO 2900
 7210 IF(OPDFLG)GOTO 7230
 7215 CNT=CNT-1
 7220 TOP=TOP-1
      GOTO 220
C
 7230 OPDFLG=.FALSE.
      IF (L.GT.26.AND.L.LT.31) GOTO 7220
      IF (STACK(1,TOP).LE.NAMMAX) THEN
        IF (CNAMTB(I).EQ.TRUE.OR.CNAMTB(I).EQ.FALSE)GOTO 7220
      ENDIF
      IF (MACLDD)GOTO 7215
      ERRP=TOP
      GOTO 2800
C
 7300 IF (MACLDD)GOTO 7215
      GOTO 900
C
 7400 CALL INPUT
      IF (STACK(1,TOP).LE.NAMMAX) THEN
      IF(NAMTBL(STACK(1,TOP)).EQ.LETTER(1))GOTO 7420
      IF((CNAMTB(STACK(1,TOP-1)).NE.'E   ').AND.
     *   (CNAMTB(STACK(1,TOP-1)).NE.'D   '))GOTO 7420
      ENDIF
      CALL SETCHR(TOP-1,CONAST)
      GOTO 7215
 7420 CHR=ZERO//BLK
      CALL CONCAT(CHR,'.')
      CNT=CNT-1
      K=STACK(1,TOP-1)
      OPDFLG=.TRUE.
      GOTO 2510
C
 7800 IF (STACK(1,TOP-1).LE.NAMMAX) THEN
        IF(MOD(NAMTBL(STACK(1,TOP-1)),MODHLF).NE.BOOL)GOTO 2900
      ENDIF
 7500 J=I-74
      CALL BOOLIF(J)
      IF(TOP)2810,11,220
C
      END
