**** SOURCE FILE : M0011516.V03   ***
*
      SUBROUTINE INTSEC
C
C ROUTINE TO INTERSEC A PLANE WITH SSURF'S  OR
C                       SSURF'S WITH SSURF'S
C
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C  INTERSECTION START POINT
      DOUBLE PRECISION STP(3)
C
C  POLYEDER STORAGE
      DOUBLE PRECISION POED1(3,5,5),POED2(3,5,5),DUMMY1(2),DUMMY2(2)
      EQUIVALENCE (POED1(3,5,5),DUMMY1(1))
      EQUIVALENCE (POED2(3,5,5),DUMMY2(1))
C
C   PLANE STORAGE FOR TRANSFORMATION PURPOSE
      DOUBLE PRECISION PL(4),PL1(6)
      EQUIVALENCE(PL1(2),PL(1))
C
C SS - ARELEM - COMMON
      COMMON/SSARLM/BB(64,4),UU(4),VV(4),
     *              IITOP(6,4,4),IIFLAG(4,4),IPNUM(4)
C
C   SECTION INDICATORS
      INTEGER INTDS(0:900),INTPS(0:900)
C
C   CONTOUR POINTER FIELD
C    JCON(1,X) : POINTER TO FIRST SEGMENT
C    JCON(2,X) : POINTER TO LAST SEGMENT
      INTEGER MCON
      PARAMETER (MCON=50)
      INTEGER JCON(2,MCON)
C    ICON : CURRENT CONTOUR
C    NCON : NEW CONTOUR
      INTEGER ICON,NCON
C
C   CONTOUR SEGMENT FIELD
C    JSIX(1,X) : POINTER TO FIRST POINT IN PT ARRAY
C    JSIX(2,X) : POINTER TO LAST POINT IN PT ARRAY
C    JSIX(3,X) : POINTER TO PREVIOUS CONTOUR SEGMENT
C    JSIX(4,X) : POINTER TO FOLLOWING CONTOUR SEGMENT
      INTEGER MSIX
      PARAMETER (MSIX=200)
      INTEGER JSIX(4,MSIX)
C    ISIX : CURRENT CONTOUR SEGMENT
C    NSIX : NEW CREATET CONTOUR SEGMENT
      INTEGER ISIX,NSIX
C
C   COMMON FOR 2 SURFACE INTERSECTION
      COMMON/INTCOM/IKEEP(255)
C   THICKNESS ON PS AND DS
      DOUBLE PRECISION THICK(2)
      EQUIVALENCE (IKEEP(201),THICK(1))
C   SUBROUTINE TRACE
CCCCC EQUIVALENCE (IKEEP(249),ITRACE)
C   PATCH NUMBER FOR PS AND DS (SURFACE RECNO*1000 + PATCH NO)
      INTEGER IPNR(2)
      EQUIVALENCE (IKEEP(254),IPNR(1))
C
C       TOTAL-LIBRARY.
C
      INCLUDE 'TOTAL.INC'
C
      INCLUDE 'SV.INC'
C
      INCLUDE 'IFXCOR.INC'
C
      DOUBLE PRECISION HMOD
C
C BLANK COMMON
      INCLUDE 'BLANKCOM.INC'
C
C SCRATCH AREA TO STORE THE RESULTING POINTS
      COMMON/SSPAD/NSCNMX,ISCAN,PT(9,1000)
C
C SWITCH FOR PLANE/SSURF (=1) OR SSURF/SSURF (=2) INTERSECTION
      INTEGER IWHAT
C
C CHECK DEFINITION FUNCTION
      LOGICAL CKDEF
C
C STORAGE FOR FIRST AND SECOND SET OF SSURF'S
      INTEGER IFIRST(50), ISECND(50)
C
C CONTROL WORDS
      CHARACTER*8 WITH,DCANON,HEX,TEST
C
      INTEGER BCDF
C
      DOUBLE PRECISION WORD
      INTEGER IWORD(2)
      EQUIVALENCE (WORD,IWORD(1))
      LOGICAL FIRST
      SAVE FIRST,PL1
C
      DATA STP/3*0.D0/
      DATA PL1/1030000.0D0,5*.0D0/
      DATA WITH/'WITH    '/,DCANON/'CANON   '/,HEX/'HEX     '/
      DATA FIRST/.TRUE./
C
C AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
C
C.... INITIALISE CHARACTER ITEM FOR OUTPUT TO EXFILE
C
      IF (FIRST) THEN
        IWORD(1)=BCDF('SYSP')
        IWORD(2)=BCDF('L   ')
        PL1(6)=WORD
        FIRST=.FALSE.
      ENDIF
C
C SET THICKNESS FOR DRIVE-SURFACE
      THDOLD=TH(IDS)
      TOLD=.8D0*(TAU1(IDS)-TAU2(IDS))
      TH(IDS)=TH(IDS)+TAU2(IDS)+TOLD/8.D0
      THICK(1)=TH(IDS)
C
C SET THICKNESS FOR PART-SURFACE
      THPOLD=TH(IPS)
      TOLP=.8D0*(TAU1(IPS)-TAU2(IPS))
      TH(IPS)=TH(IPS)+TAU2(IPS)+TOLP/8.D0
      THICK(2)=TH(IPS)
C
C READ THE INTERSECTION ARGUMENT AND STORE THEM
      NFIRST=0
      NSECND=0
      IWHAT=1
      IOUT=0
      MSCAN=SSCAN(2)
      ISCAN=3
    1 IF(ISCAN.GE.MSCAN) GOTO 20
C
C GEOMETRY ?  (PLANE/LINE OR SSURF)
      IF((SSCAN(ISCAN).NE.1.D0.AND.SSCAN(ISCAN).NE.2.D0)
     *                       .AND.SSCAN(ISCAN).NE.29.D0) GOTO 10
C
C CHECK, IF GEOMETRY IS VALID
      IF(.NOT.CKDEF(SSCAN(ISCAN))) GOTO 2
C
C GEOMETRY ELEMENT IS NOT DEFINED: RETURN WITHOUT RESULT
      CALL ERROR(22830,'INTSEC  ')
      GOTO 999
C
C LINE / PLANE ?
    2 IF(SSCAN(ISCAN).NE.1.D0.AND.SSCAN(ISCAN).NE.2.D0) GOTO 5
C
C  NORMALIZE AND STORE THE PLANE
      SEC=DSQRT(SSCAN(ISCAN+1)**2 + SSCAN(ISCAN+2)**2
     *        + SSCAN(ISCAN+3)**2)
      DO 3 I=1,4
    3 PL(I)=SSCAN(ISCAN+I)/SEC
      PL(4)=SSCAN(ISCAN+4)/SEC+TH(IDS)
C
C INITIALIZE SYSTEM DS PLANE
      IS=IDS
      CALL APT234(HMOD,PL)
C
C   TRANSFORM PLANE FROM LOCAL TO BASIC COORDINATE SYSTEM
      CALL TRANSM(BB(1,2),PL,4,4,-1)
C   SIGNAL THE PLANE
      IIFLAG(1,2)=-1
      IPNR(2)=0
C   CONTINUE WITH SCANNING
      ISCAN=ISCAN+5
      IWHAT=2
      GOTO 1
C
C GET COMMON INDEX OF SSURF
    5 LDAFLG=7
      CALL APT094(LDAFLG,SSCAN(ISCAN+1),CANIND)
      INDCAN=CANIND
      ISCAN=ISCAN+3
      GOTO (7,8),IWHAT
C
C A FIRST SURFACE IS FOUND
    7 NFIRST=NFIRST+1
      IFIRST(NFIRST)=INDCAN
      IF(NFIRST.EQ.1) GOTO 1
C
      JFIRST=NFIRST-1
      DO 17 I=1,JFIRST
      IF(IFIRST(I).NE.INDCAN) GOTO 17
      NFIRST=NFIRST-1
C
C SAME SSURF FOUND TWICE BEFORE WITH, ONLY FIRST FOUND SSURF
C  IN FIRST PART OF THE STATEMENT WILL BE USED
      CALL AERR(-22832,'INTSEC  ')
      GOTO 1
   17 CONTINUE
      GOTO 1
C
C A SECOND SURFACE IS FOUND
    8 NSECND=NSECND+1
      ISECND(NSECND)=INDCAN
      IF(NSECND.EQ.1) GOTO 118
C
      JSECND=NSECND-1
      DO 18 I=1,JSECND
      IF(ISECND(I).NE.INDCAN) GOTO 18
      NSECND=NSECND-1
C
C SAME SSURF FOUND TWICE AFTER WITH, ONLY FIRST FOUND SSURF
C  IN SECOND PART OF THE STATEMENT WILL BE USED
      CALL AERR(-22833,'INTSEC  ')
      GOTO 118
   18 CONTINUE
C
C CHECK, IF SAME SSURF SHOULD BE INTERSECTED
  118 IF(NSECND.EQ.0) GOTO 1
      IF(NFIRST.EQ.0) GOTO 1
      DO 19 I=1,NFIRST
      IF(IFIRST(I).NE.ISECND(NSECND)) GOTO 19
C
C SAME SSURF WILL BE INTERSECTED BY ITSELF, THIS IS NOT POSSIBLE
      CALL ERROR(22834,'INTSEC  ')
      NSECND=NSECND-1
      GOTO 1
   19 CONTINUE
      GOTO 1
C
C CONTROL WORDS
   10 CALL HOLFRM(SSCAN(ISCAN+1),TEST,1,8,NWD)
      IF(TEST.NE.WITH) GOTO 11
      IWHAT=2
      ISCAN=ISCAN+2
      GOTO 1
C
C CANON POINT TO OUTPUT ?
   11 IF(TEST.NE.DCANON) GOTO 12
      IOUT=1
      ISCAN=ISCAN+2
      GOTO 1
C
C HEX OUTPUT ?
   12 IF(TEST.NE.HEX) GOTO 13
      IOUT=2
   13 ISCAN=ISCAN+2
      GOTO 1
C
C PREPARATION OF INTERSECTIONS
   20 IF(NSECND.NE.0) GOTO 21
C
C NO INTERSECTION POSSIBLE
      CALL ERROR(22831,'INTSEC  ')
      GOTO 999
   21 CONTINUE
C
C  INTERSECTIONS
C *********************************************************************
C
C  OUTER LOOP FOR FIRST ARGUMENT SURFACES (DS)
      N1=MAX0(1,NFIRST)
      DO 330 J1=1,N1
      N2=1
      IF(NFIRST.EQ.0)GOTO 210
C
C  LOCATE THE NON PLANE DRIVE SURFACE
      LDAFLG=3
      CALL APT094(LDAFLG,COM(IFIRST(J1)),J11)
      J11=J11-41
C  NUMBER OF PATCHES
      N2=SSCAN(J11+4)
C  SURFACE RECORD NUMBER TIMES 1000 FOR PATCH IDENTIFICATION
      IPNR(2)=SSCAN(J11+1)*1000
C
C  INITIALIZE DRIVE SURFACE
      IS=IDS
      CALL APT234 (HMOD,COM(IFIRST(J1)))
  210 CONTINUE
C
C  PREPARATION OF PATCH REFERENCE OF FIRST ARGUMENT SURFACES
      DO 410 J2=1,N2
  410 INTDS(J2)=0
C *********************************************************************
C
C  OUTER LOOP FOR SECOND ARGUMENT SURFACES (PS)
      DO 320 J3=1,NSECND
      DO 40 J33=1,3
C
C  LOCATE THE PART SURFACE
      LDAFLG=3
      CALL APT094(LDAFLG,COM(ISECND(J3)),J12)
      J12=J12-41
C
C  CHECK SURFACE LOCATION IF DS IS NOT A PLANE
      IF(IIFLAG(1,2).LE.0)GOTO 50
C
C  CHECK SURFACE RECORD NUMBER AND LENGTH
      IF(COM(IFIRST(J1)).EQ.SSCAN(J11+1).AND.
     *   COM(IFIRST(J1)+1).EQ.SSCAN(J11+8))GOTO 50
C
C  LOCATE THE NON PLANE DRIVE SURFACE
      LDAFLG=3
      CALL APT094(LDAFLG,COM(IFIRST(J1)),J11)
      J11=J11-41
   40 CONTINUE
C GET NAME AND INDEX OF SURFACE
   50 CALL UNPACK(COM(ISECND(J3)),MODE,ISIZE,ISBSCT)
      SNAME=COM(ISECND(J3)+ISIZE)
      IF(ISBSCT.GT.1)SNAME=COM(ISECND(J3)+(ISIZE+1)*ISBSCT-1)
      SINDEX=ISBSCT
C  NUMBER OF PATCHES
      N4=SSCAN(J12+4)
C  SURFACE RECORD NUMBER TIMES 1000 FOR PATCH IDENTIFICATION
      IPNR(1)=SSCAN(J12+1)*1000
C
C  INITIALIZE PART SURFACE
      IS=IPS
      CALL APT234 (HMOD,COM(ISECND(J3)))
C
C  PREPARATION OF PATCH REFERENCE OF SECOND ARGUMENT SURFACES
      DO 420 J4=1,N4
  420 INTPS(J4)=0
C
C   PREPARATION OF POINT STORAGE MANAGEMENT
      IPT=1
      MPT=NSCNMX/9
      NPT=0
C
C   PREPARATION OF CONTOUR SEGMENT XREF AND CONTOUR TABLE
      NSIX=0
      NCON=0
C *********************************************************************
C
C  INNER LOOP FOR FIRST ARGUMENT SURFACES OVER THE PATCHES (DS)
      DO 310 J2=1,N2
      IF(NFIRST.EQ.0)GOTO 220
      IF(INTDS(J2).EQ.1)GOTO 310
      CALL LODPCH(SSCAN(J11+1),BB(1,2),IIFLAG(1,2),IITOP(1,1,2),J2,0)
      IPNUM(2)=J2
C  SAVE PATCH POINTER
      J2S=J2
C  COMPUTE THE INDIVIDUAL PATCH
      IPNR(2)=IPNR(2)/1000*1000+J2
C
C   COMPUTE 5*5 POLYHEDRON
      CALL POLMTN (2,POED2,5,5)
  220 CONTINUE
C *********************************************************************
C
C  INNER LOOP FOR SECOND ARGUMENT SURFACES OVER THE PATCHES (PS)
      DO 300 J4=1,N4
      IF(INTPS(J4).EQ.1)GOTO 300
      CALL LODPCH(SSCAN(J12+1),BB(1,1),IIFLAG(1,1),IITOP(1,1,1),J4,0)
      IPNUM(1)=J4
C  SAVE PATCH POINTER
      J4S=J4
C  COMPUTE THE INDIVIDUAL PATCH
      IPNR(1)=IPNR(1)/1000*1000+J4
C
C   COMPUTE 5*5 POLYHEDRON
      CALL POLMTN (1,POED1,5,5)
C
C  SEARCH FOR INTERSECTION
      TOL=(TOLD+TOLP)/2.D0
      TOLTOL=TOL*TOL*2.D0
      IF(NFIRST.EQ.0)CALL PLAPOL(BB(1,2),POED1,5,5,TOL,STP,IRC)
      IF(NFIRST.NE.0)CALL POLPOL(POED2,5,5,POED1,5,5,TOL,STP,IRC)
      IF(IRC.EQ.0)GOTO 300
C
C  CUT!
  430 CONTINUE
C  SUBROUTINE TRACE SWITCH
CCCCC ITRACE=0
      IPT=IPT+NPT
      NPT=MPT-IPT+1
      CALL INTSRF (STP,TOL,PT(1,IPT),NPT,IRC)
      IF(NPT.EQ.0)GOTO 300
      LPT=IPT+NPT-1
C
C   MARK USED PATCHES
      INTDS(IPNUM(2))=1
      INTPS(IPNUM(1))=1
C
C   CREATE A CONTOUR SEGMENT ENTITY FOR A NEW SEGMENT FOUND
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      ISIX=NSIX
      JSIX(1,ISIX)=IPT
      JSIX(2,ISIX)=LPT
      JSIX(3,ISIX)=0
      JSIX(4,ISIX)=0
C
C   CREATE A CONTOUR TABLE ENTRY
      IF(NCON.GE.MCON)GOTO 999
      NCON=NCON+1
      JCON(1,NCON)=ISIX
      JCON(2,NCON)=ISIX
      ICON=NCON
C
C   TEST FOR CLOSED SEGMENT
      D12=(PT(1,IPT)-PT(1,LPT))**2+(PT(2,IPT)-PT(2,LPT))**2
     *                            +(PT(3,IPT)-PT(3,LPT))**2
      IF(D12.LE.TOLTOL)GOTO 470
C
C   SEARCH FOR PREVIOUS CONTOUR SEGMENT
  435 JSIX(3,ISIX)=0
      JSIX1=JSIX(1,ISIX)
      CALL INTTRC (J12,J11,PT(1,JSIX1), 1,IRC)
      IF(IRC.EQ.0)GOTO 449
C  INTERSECTION
      STP(1)=PT(1,JSIX1)
      STP(2)=PT(2,JSIX1)
      STP(3)=PT(3,JSIX1)
      IPT=IPT+NPT
      NPT=MPT-IPT+1
      CALL INTSRF (STP,TOL,PT(1,IPT),NPT,IRC)
      IF(NPT.EQ.0)GOTO 449
      LPT=IPT+NPT-1
C
C   MARK USED PATCHES
      INTDS(IPNUM(2))=1
      INTPS(IPNUM(1))=1
C
C  CHECK THE CONNECTION POINT
      D1=(PT(1,IPT)-PT(1,JSIX1))**2+(PT(2,IPT)-PT(2,JSIX1))**2
     *                             +(PT(3,IPT)-PT(3,JSIX1))**2
      IF(D1.GT.TOLTOL)GOTO 440
C  SAVE POINTERS FOR CLOSED CONTOUR CHECK
      JEND1=LPT
      JEND2=JSIX(2,JCON(2,ICON))
C
C  PREVIOUS SEGMENT, REVERSE ORDER
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      JSIX(1,NSIX)=LPT
      JSIX(2,NSIX)=IPT
      GOTO 442
C
C  CHECK THE CONNECTION POINT
  440 D2=(PT(1,LPT)-PT(1,JSIX1))**2+(PT(2,LPT)-PT(2,JSIX1))**2
     *                             +(PT(3,LPT)-PT(3,JSIX1))**2
      IF(D2.LE.TOLTOL)GOTO 441
C
C  NEW STAND ALLONE SEGMENT
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      JSIX(1,NSIX)=IPT
      JSIX(2,NSIX)=LPT
      JSIX(3,NSIX)=0
      JSIX(4,NSIX)=0
C
C   CREATE A CONTOUR TABLE ENTRY
      IF(NCON.GE.MCON)GOTO 999
      NCON=NCON+1
      JCON(1,NCON)=NSIX
      JCON(2,NCON)=NSIX
      GOTO 449
C  SAVE POINTERS FOR CLOSED CONTOUR CHECK
  441 JEND1=IPT
      JEND2=JSIX(2,JCON(2,ICON))
C
C  PREVIOUS SEGMENT, NORMAL ORDER
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      JSIX(1,NSIX)=IPT
      JSIX(2,NSIX)=LPT
  442 JSIX(3,NSIX)=0
      JSIX(3,ISIX)=NSIX
      JSIX(4,NSIX)=ISIX
      ISIX=NSIX
      JCON(1,ICON)=ISIX
C   TEST FOR CLOSED SEGMENT
      D12=(PT(1,JEND1)-PT(1,JEND2))**2+(PT(2,JEND1)-PT(2,JEND2))**2
     *                                +(PT(3,JEND1)-PT(3,JEND2))**2
      IF(D12.LE.TOLTOL)GOTO 470
      GOTO 435
C
C   SET ISIX TO FORWARD SEARCH
  449 ISIX=JCON(2,ICON)
C
C REINSTAL THE PREVIOUS PATCHES
      IF(IIFLAG(1,2).LE.0)GOTO 448
      CALL LODPCH(SSCAN(J11+1),BB(1,2),IIFLAG(1,2),IITOP(1,1,2),J2S,0)
      IPNUM(2)=J2S
      IPNR(2)=IPNR(2)/1000*1000+J2S
  448 CALL LODPCH(SSCAN(J12+1),BB(1,1),IIFLAG(1,1),IITOP(1,1,1),J4S,0)
      IPNUM(1)=J4S
      IPNR(1)=IPNR(1)/1000*1000+J4S
C
C   SEARCH FOR FOLLOWING CONTOUR SEGMENTS
  450 JSIX(4,ISIX)=0
      JSIX2=JSIX(2,ISIX)
      CALL INTTRC (J12,J11,PT(1,JSIX2),-1,IRC)
      IF(IRC.EQ.0)GOTO 469
C  INTERSECTION
      STP(1)=PT(1,JSIX2)
      STP(2)=PT(2,JSIX2)
      STP(3)=PT(3,JSIX2)
      IPT=IPT+NPT
      NPT=MPT-IPT+1
      CALL INTSRF (STP,TOL,PT(1,IPT),NPT,IRC)
      IF(NPT.EQ.0)GOTO 469
      LPT=IPT+NPT-1
C
C   MARK USED PATCHES
      INTDS(IPNUM(2))=1
      INTPS(IPNUM(1))=1
C
C  CHECK THE CONNECTION POINT
      D1=(PT(1,IPT)-PT(1,JSIX2))**2+(PT(2,IPT)-PT(2,JSIX2))**2
     *                             +(PT(3,IPT)-PT(3,JSIX2))**2
      IF(D1.GT.TOLTOL)GOTO 460
C  SAVE POINTERS FOR CLOSED CONTOUR CHECK
      JEND1=LPT
      JEND2=JSIX(1,JCON(1,ICON))
C
C  FOLLOWING SEGMENT, NORMAL ORDER
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      JSIX(1,NSIX)=IPT
      JSIX(2,NSIX)=LPT
      GOTO 462
C
C  CHECK THE CONNECTION POINT
  460 D2=(PT(1,LPT)-PT(1,JSIX2))**2+(PT(2,LPT)-PT(2,JSIX2))**2
     *                             +(PT(3,LPT)-PT(3,JSIX2))**2
      IF(D2.LE.TOLTOL)GOTO 461
C
C  NEW STAND ALLONE SEGMENT
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      JSIX(1,NSIX)=IPT
      JSIX(2,NSIX)=LPT
      JSIX(3,NSIX)=0
      JSIX(4,NSIX)=0
C
C   CREATE A CONTOUR TABLE ENTRY
      IF(NCON.GE.MCON)GOTO 999
      NCON=NCON+1
      JCON(1,NCON)=NSIX
      JCON(2,NCON)=NSIX
      GOTO 469
C  SAVE POINTERS FOR CLOSED CONTOUR CHECK
  461 JEND1=IPT
      JEND2=JSIX(1,JCON(1,ICON))
C
C  FOLLOWING SEGMENT, REVERSE ORDER
      IF(NSIX.GE.MSIX)GOTO 999
      NSIX=NSIX+1
      JSIX(1,NSIX)=LPT
      JSIX(2,NSIX)=IPT
  462 JSIX(4,NSIX)=0
      JSIX(4,ISIX)=NSIX
      JSIX(3,NSIX)=ISIX
      ISIX=NSIX
      JCON(2,ICON)=ISIX
C   TEST FOR CLOSED SEGMENT
      D12=(PT(1,JEND1)-PT(1,JEND2))**2+(PT(2,JEND1)-PT(2,JEND2))**2
     *                                +(PT(3,JEND1)-PT(3,JEND2))**2
      IF(D12.LE.TOLTOL)GOTO 470
      GOTO 450
  469 CONTINUE
C
C REINSTAL THE PREVIOUS PATCHES
  470 IF(IIFLAG(1,2).LE.0)GOTO 471
      CALL LODPCH(SSCAN(J11+1),BB(1,2),IIFLAG(1,2),IITOP(1,1,2),J2S,0)
      IPNUM(2)=J2S
      IPNR(2)=IPNR(2)/1000*1000+J2S
  471 CALL LODPCH(SSCAN(J12+1),BB(1,1),IIFLAG(1,1),IITOP(1,1,1),J4S,0)
      IPNUM(1)=J4S
      IPNR(1)=IPNR(1)/1000*1000+J4S
  300 CONTINUE
C **********************************************************************
  310 CONTINUE
C
C  OUTPUT OF A SINGLE SURFACE/SURFACE INTERSECTION
      IF(NCON.EQ.0)GOTO 560
      DO 550 ICON=1,NCON
      ISIX=JCON(1,ICON)
  520 IP1=JSIX(1,ISIX)
      IP2=JSIX(2,ISIX)
      INEXT=JSIX(4,ISIX)
      IF(IP2.LT.IP1)GOTO 530
      NPT=IP2-IP1+1
      IPT=IP1
      IDIR=1
      GOTO 540
  530 NPT=IP1-IP2+1
      IPT=IP2
      IDIR=-1
  540 CONTINUE
      CALL INTOUT(IOUT,PT(1,IPT),NPT,IDIR,J11,J12,SNAME,SINDEX)
      IF(INEXT.EQ.0)GOTO 550
      ISIX=INEXT
      GOTO 520
  550 CONTINUE
  560 CONTINUE
C **********************************************************************
  320 CONTINUE
C **********************************************************************
  330 CONTINUE
C **********************************************************************
C
C SET THICKNESS BACK TO OLD VALUES
  999 TH(IDS)=THDOLD
      TH(IPS)=THPOLD
C
      RETURN
      END
