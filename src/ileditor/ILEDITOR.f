**** SOURCE FILE : M0006626.W04   ***
*
C
C              FORTRAN SUBROUTINE CILOUT
C
C LINKAGE      SUBROUTINE CILOUT(COMAND,COUNT,CODE)
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    HOLFRM           SUBROUTINE    ICMPRS
C          SUBROUTINE    CPRINT
C          SUBROUTINE    ICONV
C          SUBROUTINE    RLSBUF
C          SUBROUTINE    ABCDBN
C
      SUBROUTINE CILOUT(COMAND,COUNT,CODE)
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE 'NAMETB.INC'
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL CILPRT
      DIMENSION PRT(7)
C CILPRT:      TRUE WHEN COMPRESSED I.L. PRINTING REQUESTED
      EQUIVALENCE (CILPRT,PRT(1))
C
C       20.    IO - ARRAY
C
      INCLUDE 'DARRAY.INC'
C
C       34.    COMMON BLOCK FOR INTERPRETIVE C.I.L. OUTPUT
C
      INCLUDE 'OUTBUF.INC'
C LABFLG:      INDICATES I.L. COMMAND IS LABEL (INTERPRETER)
C RSVFLG:      TRUE IF I.L. COMMAND IS A RESRV (INTERPRETER)
C IBUF:        NUMBER OF RECORDS IN BUFFER ARRAY
C ILBUF:       NUMBER OF ITEMS IN THE LABBUF ARRAY (INTERPRETER)
C BUFFER:      TEMPORARY STORAGE FOR INTERPRETER OUTPUT (PAGES)
C LABBUF:      TEMPORARY STORAGE FOR LABEL,HOLDAT ENTRY AND RESRV I.L.
C
C       45.    NUMBER TABLE INDICES
C
      INCLUDE 'NUMBLK.INC'
C
C MNMBND:      LAST NAME TABLE ENTRY TO MACRO ASSIGNED NUMBER SECTION
C  NMBRS:      QUANTITY OF NUMBERS IN THE CURRENT STATEMENT
C*
      DIMENSION CODE(90)
C**
C...     IS THIS A HOLDAT STATEMENT
C
      IF( COMAND.EQ.21)GOTO 200
      IBF=COUNT
      IF (COMAND.NE.9) IBF=COUNT+NMBRS
      GOTO 20
C
C...     IS THIS A LABEL OR RESRV STATEMENT
C
   1  IF ((LABFLG).OR.(RSVFLG)) GOTO 100
C
C...     NO
C...     CODE TO GO INTO BUFFER. TEST IF THERE IS ROOM
C
      IF((IBUF+IBF+4).GT.256)CALL RLSBUF
      BUFFER(IBUF+3) = COMAND
      BUFFER(IBUF+4) = IBF
      IBUF=IBUF+2
      IF(COUNT.EQ.0) RETURN
      DO 10 I=1,COUNT
      J=CODE(I)
      IF (J.LE.NAMMAX) GOTO 5
      IF (CODE(I-1).NE.7) GOTO 5
      J=J-NAMMAX
      CALL ABCDBN(CNUMTB(J),BUFFER(IBUF+3),1)
      IBUF=IBUF+1
      GOTO 10
    5 BUFFER(IBUF+3)=J
   10 IBUF=IBUF+1
      IF (COMAND.NE.9)NMBRS=0
      RETURN
C
C...     IS CILPRT MARKER SET
C
   20 IF(.NOT.CILPRT) GOTO 1
C
      CALL ICONV(COMAND,DARRAY,1,6)
      CALL ICONV(IBF,DARRAY,7,6)
      L=13
      DO 1000 I=1,COUNT
      IF (CODE(I).GT.NAMMAX) THEN
        IF (CODE(I-1).EQ.7) THEN
          CALL CFORM(CNUMTB(CODE(I)-NAMMAX),DARRAY,L+2,12)
          L=L+14
        ELSE
          CALL ICONV(CODE(I),DARRAY,L,6)
          L=L+6
        ENDIF
      ELSE
        CALL ICONV(CODE(I),DARRAY,L,6)
        L=L+6
      ENDIF
      IF(L.LE.106) GO TO 1000
      L=13
      CALL CPRINT(DARRAY)
 1000 CONTINUE
      CALL CPRINT(DARRAY)
      GOTO 1
C
C...     LABEL OR RESRV STATEMENT.
C        CODE TO GO INTO LABBUF. TEST IF THERE IS ROOM
C
  100 IF((ILBUF+COUNT+4).GT.254)CALL RLSBUF
      LABBUF(ILBUF+3) = COMAND
      LABBUF(ILBUF+4) = COUNT
      ILBUF=ILBUF+2
      DO 110 I=1,COUNT
      LABBUF(ILBUF+3)=CODE(I)
  110 ILBUF=ILBUF+1
      RETURN
C
C...     HOLDAT STATEMENT
C
  200 LABFLG = .TRUE.
      IF((ILBUF+2*COUNT).GT.256) CALL RLSBUF
      LABFLG = .FALSE.
      LABBUF(ILBUF+3)= COMAND
      LABBUF(ILBUF+5)=CODE(1)
      LABBUF(ILBUF+6)=CODE(2)
C
C
      LABBUF(ILBUF+4)=COUNT
      ILBUF=ILBUF+4
      DO 210 I=3,COUNT
      LABBUF(ILBUF+3)=CODE(I)
  210 ILBUF=ILBUF+1
C
C...     IS CILPRT MARKER SET
C
      IF(.NOT.CILPRT)RETURN
C
      KOUNT = CODE(2)
      CALL ICONV(COMAND,DARRAY,1,6)
      CALL ICONV(COUNT,DARRAY,7,6)
      CALL ICONV(CODE(1),DARRAY,13,6)
      CALL ICONV(CODE(2),DARRAY,19,6)
      L=3
 1001 IF(KOUNT.LE.93) GO TO 1002
      CALL HOLFRM(CODE(L),DARRAY,27,92,NWD)
      CALL CPRINT(DARRAY)
      KOUNT = KOUNT-92
      L=L+23
      GO TO 1001
 1002 CALL HOLFRM (CODE(L),DARRAY,27,KOUNT,NWD)
      CALL CPRINT(DARRAY)
      RETURN
       END
**** SOURCE FILE : M0006764.V01   ***
*
C
C              FORTRAN SUBROUTINE COMPRS
C
C LINKAGE      SUBROUTINE COMPRS
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ACMPRS          SUBROUTINE    RLSLIN
C          SUBROUTINE    ICMPRS
C
      SUBROUTINE COMPRS
C
      IMPLICIT INTEGER (A-Z)
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL INTERP,ASSEMB
      DIMENSION PRT(7)
C INTERP:      NORMALLY TRUE,INDICATING INTERPRETIVE APPROACH DEFAULT
      EQUIVALENCE (INTERP,PRT(3))
C ASSEMB:      SET TRUE INDICATES ASSEMBLY APPROACH (CONTRL/ASMBLE)
      EQUIVALENCE (ASSEMB,PRT(4))
C*
      LOGICAL  PROSW
      DATA     PROSW/.TRUE./
C**
      IF (PROSW) GO TO 100
C  10 IF(ASSEMB)CALL ACMPRS
C     IF(INTERP)CALL ICMPRS
   10 CALL ICMPRS
      RETURN
  100 PROSW=.FALSE.
      CALL PROLOG
      GO TO 10
       END
**** SOURCE FILE : M0006630.V01   ***
*
C
C              FORTRAN SUBROUTINE EPILOG
C
C LINKAGE      SUBROUTINE EPILOG
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    IEPLOG          SUBROUTINE    MACREC
C          SUBROUTINE    LIBOPC          SUBROUTINE    PRO026
C
      SUBROUTINE EPILOG
C
      IMPLICIT INTEGER (A-Z)
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL INTERP,ASSEMB
      DIMENSION PRT(7)
C INTERP:      NORMALLY TRUE,INDICATING INTERPRETIVE APPROACH DEFAULT
      EQUIVALENCE (INTERP,PRT(3))
C ASSEMB:      SET TRUE INDICATES ASSEMBLY APPROACH (CONTRL/ASMBLE)
      EQUIVALENCE (ASSEMB,PRT(4))
C
C       36.    SYSTEM MACRO AND SEGMENT READ VARIABLES
C
      COMMON/MACSEG/MACSEG
      LOGICAL ALOPN
      DIMENSION MACSEG(6)
C ALOPN:       TRUE AFTER MACRO OR PART PROGRAM SEGMENT LIBRARY OPENED
      EQUIVALENCE (ALOPN,MACSEG(1))
C**
C     IF(ASSEMB)CALL AEPLOG
      IF (INTERP) CALL IEPLOG
C...      TERMINATE TRANSLATION
      ASSEMB = .FALSE.
      INTERP = .FALSE.
      IF(ALOPN)CALL LIBOPC(2,IFLAG)
      RETURN
       END
**** SOURCE FILE : M0006637.W01   ***
*
C
C              FORTRAN SUBROUTINE ICMPRS
C
C LINKAGE      SUBROUTINE ICMPRS
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    CILOUT          SUBROUTINE    COMPRS
C          SUBROUTINE    ALARM           SUBROUTINE    IPRLOG
C          SUBROUTINE    HELP
C          SUBROUTINE    BINCHK
C          SUBROUTINE    RLSBUF
C
      SUBROUTINE ICMPRS
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE 'NAMETB.INC'
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C
C        3.    METALINGUISTIC VARIABLE CLASS CODES
C
      COMMON/CODE/CODE
      DIMENSION CODE(150),FCN(2),PROCED(2)
C FCN:         (1)=CODE CLASS 18000,(2)=NAMTBL INDEX OF 'FCN   '
      EQUIVALENCE (FCN(1),CODE(35))
C PROCED:      (1)=CODE CLASS 19000,(2)=NAMTBL INDEX OF 'PROCED'
      EQUIVALENCE (PROCED(1),CODE(37))
C
C       17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C REAL:        MODE CODE (21) FOR A SCALAR
      EQUIVALENCE (REAL,MODX(21))
C BOOL:        MODE CODE (23) FOR BOOLEAN TYPE
      EQUIVALENCE (BOOL,MODX(23))
C
C       19.    INTERMEDIATE LANGUAGE TEXT
C
      COMMON/ILTEXT/ILTEXT
      DIMENSION ILTEXT(94),TEXTIN(90)
C TPNTRX:      POINTER TO LAST TEXTIN ENTRY
      EQUIVALENCE (TPNTRX,ILTEXT(3))
C OPTEXT:      CONTAINS COMMAND CODE FOR CURRENT I.L. COMMAND
      EQUIVALENCE (OPTEXT,ILTEXT(4))
C TEXTIN:      STORAGE FOR CURRENTLY GENERATED I.L. COMMAND ARGUM.LIST
      EQUIVALENCE (TEXTIN(1),ILTEXT(5))
C
C       29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULI
      DIMENSION MODULI(2)
C MODULO:      NAMTBL CLASS AND CODE FACTOR 1000 TO DEVIDE OUT CLASS
      EQUIVALENCE (MODULO,MODULI(1))
C
C       34.    COMMON BLOCK FOR INTERPRETIVE C.I.L. OUTPUT
C
      INCLUDE 'OUTBUF.INC'
C ICOM:        NUMBER OF WORDS OF BLANK COMMON REQUIRED BY LDA
C MACFLG:      TRUE WHEN MACRO PROCESSING IN EFFECT (INTERPRETER)
C LABFLG:      INDICATES I.L. COMMAND IS LABEL (INTERPRETER)
C RSVFLG:      TRUE IF I.L. COMMAND IS A RESRV (INTERPRETER)
C IBUF:        NUMBER OF RECORDS IN BUFFER ARRAY
C PPPAGE:      PAGE NUMBER OF PART PROGRAMMING TEXT (INTERPRETER)
C MCPAGE:      NUMBER OF PAGES OF MACRO I.L. (INTERPRETER)
C IC:          NUMBER OF SCALARS IN BLOCK 1 OF CANONICAL FORMS
      INTEGER IC(4)
      EQUIVALENCE (IC(1),ISC)
C*
      DIMENSION LABSAV(5)
      LOGICAL OPERCK,SEQFLG
      DATA BLKSIZ/128/
      DATA OPERCK/.FALSE./,SEQFLG/.FALSE./
C**
  100 IF(SEQFLG) GOTO 510
  120 GOTO (300,300,300,300,300,400,130,200,500,200,600,700,800,200,
     1      900,200,1000,1100,1200,200,1300),OPTEXT
C
C...    ENTRY - NO OUTPUT
C
  130 RETURN
C
C...     NO SPECIAL TREATMENT REQUIRED - OUTPUT USING CILOUT
C
  200 CALL CILOUT(OPTEXT,TPNTRX,TEXTIN)
      RETURN
C
C...    LABEL - STORE I.L.
C
  400 LABSAV(1) = OPTEXT
      LABSAV(3) = TEXTIN(1)
C
C...     RELEASE I.L. BUFFER IF NECCESSARY
C
      IF((IBUF+2).GT.254) CALL RLSBUF
      LABFLG = .TRUE.
      IF (MACFLG) GOTO 410
      LABSAV(4)=PPPAGE+1
      GO TO 420
C
C...     MACRO PROCESSING IN PROGRESS
C
  410 LABSAV(4) = -MCPAGE-1
  420 LABSAV(2) = 3
      LABSAV(5)=IBUF+3
      CALL CILOUT(LABSAV(1),LABSAV(2),LABSAV(3))
      LABFLG = .FALSE.
      CALL CILOUT(7,0,TEXTIN)
      RETURN
C
C...     SEQNCE COMMAND - STORE I.L. AND SET SEQFLG
C
  500 SEQNUM = TEXTIN(1)
      SEQFLG = .TRUE.
      RETURN
C
C...     RESRV COMMAND - INCREASE APPROPRIATE COUNT AND OUTPUT
C
  700 MODE=TEXTIN(2)
      SIZ=TEXTIN(3)+1
       N=TEXTIN(4)
      IM=1
      RSVFLG =.TRUE.
C        MODE NON-SUBCRIPTED SCALAR
      IF(MODE.NE.REAL.AND.MODE.NE.BOOL.OR.N.NE.1) GOTO 701
      IM = 0
      J = 1
      GOTO 710
C        MODE SUBSRIPTED SCALAR.
  701 IF((MODE.EQ.REAL).AND.(N.NE.1))J=2
      IF((MODE.EQ.BOOL).AND.(N.NE.1))J=2
C        MODE INTERNALLY GENERATED VARIABLE.
      IF(MODE.NE.0) GOTO 705
      J = 4
      SIZ = SIZ-1
      IM = 0
C        MODE BLANK COMMON.
 705  IF(MODE.LT.0) GOTO 760
C        MODE NON-SCALAR
      IF(MODE.GT.0.AND.MODE.NE.REAL.AND.MODE.NE.BOOL) J=3
C...     UP POINTER
  710 JC=IC(J)+N*SIZ+IM
C        WILL FORM FIT IN CURRENT BLOCK.
      IF(IC(J)/BLKSIZ.EQ.JC/BLKSIZ) GOTO 720
C        NO, SPLIT FORM IF INDEXED.
      LEFT=BLKSIZ-MOD(IC(J),BLKSIZ)
C        OBTAIN NO. OF ELEMENTS WHICH WILL FIT IN REST OF BLOCK
      M=(LEFT-1)/SIZ
C        ENTIRE ARRAY CAN NOT FIT
      IF(M.EQ.N) M=M-1
C        INCREASE POINTER, DECREASE  NO. OF ELEMENTS, ITERATE
      IC (J)=IC(J)+LEFT
      N=N-M
      GOTO 710
  720 IC(J)=JC
C
C...     OUTPUT IS TO EXFIL1
C
C.....   INTERNALLY GENERATED VARIABLES
  730 CALL CILOUT(OPTEXT,TPNTRX,TEXTIN)
      RSVFLG = .FALSE.
      RETURN
C
C....    BLANK COMMON
C
  760 ICOM=ICOM+TEXTIN(3)
      GOTO 730
C
C...     CALL COMMAND - FORM CORRECT PROCEDURE NUMBER
C
 1100 ITEXT = TEXTIN(1)
      GOTO 1110
C
C...     CHECK ARGUMENT LIST FOR PROCEDURE INDICES
C
 1120 OPERCK = .TRUE.
      J = TPNTRX-1
      DO 1130 I=2,J,2
      IF (TEXTIN(I).NE.4) GOTO 1130
C
C...     THIS ARGUMENT IS A PROCEDURE INDEX
C
      ITEXT = TEXTIN(I+1)
C
C...     FORM PROCEDURE NUMBER.
C...     ALL PROCEDURES HAVE A UNIQUE MODE, THEREFORE EACH PROCEDURE CAN
C...     BE ASSIGNED A UNIQUE NUMBER.  THIS IS DONE IN ORDER THAT THE
C...     EXECUTION PHASE CAN CALL A PROCEDURE BY NUMBER.
C
 1110 PRONUM = NAMTBL(ITEXT)
      CALTYP = MODULO*(PRONUM/MODULO)
      PRONUM=PRONUM - CALTYP
C
C...     CALTYP IS THE CLASS OF THE PROCEDURE, AND SHOULD THEREFORE BE
C...     EITHER PROCED OR FCN
C
      IF ((CALTYP.NE.PROCED(1)).AND.(CALTYP.NE.FCN(1))) GOTO 9999
      IF(PRONUM.LT.500)GOTO 1125
      PRONUM = ITEXT + 1000
C...PRONUM IS NOW A POINTER TO THE PROCEDURE NUMBER
C
C...     WAS THIS AN ARGUMENT
C
 1125 IF(.NOT.OPERCK) GOTO 1140
C
C...     YES. STORE PROCEDURE NUMBER AND CONTINUE LOOP
C
      TEXTIN(I+1) = PRONUM
 1130 CONTINUE
      OPERCK = .FALSE.
      GOTO 1150
C
C...     STORE PROCEDURE NUMBER AND START TO INSPECT ARGUMENT LIST
C
 1140 TEXTIN(1) = PRONUM
      IF (TPNTRX.GT.1) GOTO 1120
C
C...     OUTPUT I.L.
C
C
C
C...     WAS THIS A CALL TO FINI. IF NOT RETURN
C
 1160 IF(PRONUM.NE.18) GOTO 200
C
C...     CALL WAS TO FINI.
C...     FUTURE I.L. WILL BE MACRO TEXT.
C
      CALL CILOUT(OPTEXT,TPNTRX,TEXTIN)
      CALL RLSBUF
      MACFLG = .TRUE.
      RETURN
C
C...     LAST COMMAND WAS SEQUENCE, AND NOT OUTPUT.
C...    IF THIS IS A LABEL COMMAND,OUTPUT THIS FIRST
C
  510 IF(OPTEXT.EQ.6) GOTO 120
      CALL CILOUT(9,1,SEQNUM)
      SEQFLG=.FALSE.
      GOTO 120
C
C...     THE FOLLOWING CODE IS TO CHECK OPERANDS FOR THOSE WITH A
C...     MODIFIER OF 1, FOLLOWED BY AN INTEGER CONSTANT INDEX.
C...     THESE ARE TO BE CHANGED TO MODIFIER OF 5, FOLLOWED BY
C...     THE BINARY NUMBER ITSELF
C
C
C...     FADD,FSUB,FMPY,FDIV,FEXP
C
  300 CALL BINCHK(1)
      CALL BINCHK(3)
      CALL BINCHK(5)
      GOTO 200
C
C...     CONJMP
C
  600 CALL BINCHK(1)
      GOTO 200
C
C...     CVTSUB
C
  800 CALL BINCHK(5)
      GOTO 200
C
C...     ASNADD
C
  900 GOTO  1120
C
C
C...     REPL
C
 1000 CALL BINCHK(4)
      GOTO 200
C
C...     CALL
C
 1150 J = TPNTRX-1
      DO 1170 I=2,J,2
 1170 CALL BINCHK(I)
      GOTO 1160
C
C...     MOVE
C
 1200 J = TPNTRX-1
      DO 1210 I=3,J,2
 1210 CALL BINCHK(I)
      GOTO 200
C
C...     HOLDAT STATEMENT
C
 1300 J = 4
      SIZ = (TPNTRX+1)/2
      N = 1
      IM=0
      GOTO 710
C
C...     SUPPOSED PROCEDURE DOES NOT HAVE CLASS PROCED OR FCN
C
 9999 CALL ALARM(38,0,8,'ICMPRS  ')
      CALL HELP
      RETURN
       END
**** SOURCE FILE : M0006636.W02   ***
*
C
C              FORTRAN SUBROUTINE IEPLOG
C
C LINKAGE      SUBROUTINE IEPLOG
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    AWRITE          SUBROUTINE    EPILOG
C          SUBROUTINE    MCXTRN
C          SUBROUTINE    NTSHFT
C          SUBROUTINE    RLSBUF
C          SUBROUTINE    TAPOP
C
      SUBROUTINE IEPLOG
C
      IMPLICIT INTEGER (A-Z)
C
C        1.    NAME TABLE AND TABLE LIMITS
C
      INCLUDE 'NAMETB.INC'
C NAMTBL:      INTEGER CORRESPONDING TO NAME TABLE ENTRY
C CNAMTB:      NAME TABLE OR DICTIONARY
C INAMST:      BEGIN GEOMETRIC DEFINITION ROUTINE NAME SECTION(NAMTBL)
C NAMMAX:      NAMTBL INDEX OF END OF THE PART PROGRAM NAME SECTION
C IFIXST:      NAMTBL INDEX OF BEGINNING OF FIXED POINT NUMBER SECTION
C IFIXND:      NAMTBL INDEX OF START OF FIXED POINT NUMBER SECTION
C NUMBST:      NAMTBL INDEX OF BEGINNING OF NUMBER SECTION
C NUMBND:      NAMTBL INDEX OF END OF NUMBER SECTION
C
C       12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE
      DIMENSION CFSIZE(205),MAXSIZ(2)
C MAXSIZ:      SIZE OF THE LAST LARGEST LARGE DATA ARRAY
      EQUIVALENCE (MAXSIZ(1),CFSIZE(4))
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL CILPRT
      DIMENSION PRT(7)
C CILPRT:      TRUE WHEN COMPRESSED I.L. PRINTING REQUESTED
      EQUIVALENCE (CILPRT,PRT(1))
C
C       33.    SYMBOLIC FILE DEFINITIONS
C
      INCLUDE 'SYMFIL.INC'
C MACTXT:      EXTERNAL FILE  OF MACRO TEXT
C ELFIL1:      PACKING FACTOR FOR CREATING PAGES (INTERPRETER)
C ELFIL2:      PART PROGRAMMING TEXT GENERATED BY INTERPRETER
C ELFIL3:      MACRO TEXT GENERATED FOR INTERPRETER
C ELFIL4:      MACRO TEXT GENERATED FOR INTERPRETER
C
C       34.    COMMON BLOCK FOR INTERPRETIVE C.I.L. OUTPUT
C
      INCLUDE 'OUTBUF.INC'
C PAGPAK:      PACKING FACTOR FOR CREATING PAGES (INTERPRETER)
C MACFLG:      TRUE WHEN MACRO PROCESSING IN EFFECT (INTERPRETER)
C LABFLG:      INDICATES I.L. COMMAND IS LABEL (INTERPRETER)
C PPPAGE:      PAGE NUMBER OF PART PROGRAMMING TEXT (INTERPRETER)
C MCPAGE:      NUMBER OF PAGES OF MACRO I.L. (INTERPRETER)
      INTEGER BUF(23),JBUF(11),INUMB,INAME
      LOGICAL LCILPR
      EQUIVALENCE (BUF(1),PAGPAK)
C INUMB:       NUMBER OF ITEMS IN THE LABBUF ARRAY (INTERPRETER)
      EQUIVALENCE (INUMB,JBUF(1),BUF(13))
C INAME:
      EQUIVALENCE (INAME,JBUF(2))
C LCILPR:
      EQUIVALENCE (LCILPR,JBUF(6))
C
C       41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION NTBL(6)
C NMOD:        NUMBER OF ENTRIES PERMITTED IN INTERNAL NUMBER TABLE
      EQUIVALENCE (NMOD,NTBL(1))
C NLAST:       LAST NEW BLOCK NUMBER OF NUMBER TABLE ON THE EXTERN FILE
      EQUIVALENCE (NLAST,NTBL(4))
C NSTR:        NUMBER OF FIRST MACTXT RECORD AVAILABLE FOR NUMBER TABLE
      EQUIVALENCE (NSTR,NTBL(5))
C
C       45.    NUMBER TABLE INDICES
C
      INCLUDE 'NUMBLK.INC'
C MNMBND:      LAST NAME TABLE ENTRY TO MACRO ASSIGNED NUMBER SECTION
C*
C**
C...     CLEAR BUFFERS AND REWIND FILES 2 AND 3
C
      IF (.NOT.MACFLG) GOTO 1
      CALL RLSBUF
      CALL TAPOP (ELFIL3,-2)
    1 LABFLG = .TRUE.
      CALL RLSBUF
      CALL TAPOP(ELFIL2,-2)
      CALL TAPOP(ELFIL1,-2)
C
C...       ALL USEFUL ITEMS IN THE NAMTBL ARE STORED IN BUFFER
C...       TOGETHER WITH ALL RELEVANT PARAMETERS
C
      INAME = NAMMAX - INAMST + 1
      INUMB = MNMBND-IFIXST+1
      JBUF(3)=PPPAGE
      JBUF(4)=MCPAGE
      JBUF(5)=INAMST
      LCILPR=CILPRT
      JBUF(7)=NUMBST
      JBUF(8)=NLAST
      JBUF(9)=NSTR
      JBUF(10)=MAXSIZ(1)
      JBUF(11)=MAXSIZ(2)
      IREC=0
      CALL AWRITE(ELFIL4,IREC,BUF,23,IRET)
C
C...     WRITE NAME TABLE
      IREC=0
C...  4TH ARGUMENT OF CHWRIT IS NUMBER OF BYTES
      I = INAME*6
      CALL CHWRIT(ELFIL4,IREC,CNAMTB(INAMST),I,IRET)
C...  4TH ARGUMENT OF CHWRIT IS NUMBER OF BYTES
      I = INUMB*12
      IREC=0
      CALL CHWRIT(ELFIL4,IREC,CNUMTB(IFIXST),  I  ,IRET)
C
C...     ALL TABLES AND PARAMETERS NOW WRITTEN.  REWIND FILES 4 AND 9.
C
      CALL TAPOP(ELFIL4,-2)
      CALL TAPOP(MACTXT,-3)
      RETURN
       END
**** SOURCE FILE : M0006642.V03   ***
*
C
C              FORTRAN SUBROUTINE IPRLOG
C
C LINKAGE      SUBROUTINE IPRLOG
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    ICMPRS          SUBROUTINE    PROLOG
C          INTEGER FCT.  NAME
C
      SUBROUTINE IPRLOG
C
      IMPLICIT INTEGER (A-Z)
C
C       19.    INTERMEDIATE LANGUAGE TEXT
C
      COMMON/ILTEXT/ILTEXT
      DIMENSION ILTEXT(94),TEXTIN(90)
C TPNTRX:      POINTER TO LAST TEXTIN ENTRY
      EQUIVALENCE (TPNTRX,ILTEXT(3))
C OPTEXT:      CONTAINS COMMAND CODE FOR CURRENT I.L. COMMAND
      EQUIVALENCE (OPTEXT,ILTEXT(4))
C TEXTIN:      STORAGE FOR CURRENTLY GENERATED I.L. COMMAND ARGUM.LIST
      EQUIVALENCE (TEXTIN(1),ILTEXT(5))
C**
      CHARACTER*6 S21TS1
      DATA S21TS1/'$21T$1'/
C
      CALL ICMPRS
      OPTEXT = 12
      TPNTRX=4
      TEXTIN(1)=NAME(S21TS1)
      TEXTIN(2) =21
      TEXTIN(3)= 1
      TEXTIN(4)= 1
      RETURN
      END
**** SOURCE FILE : M0006664.V01   ***
*
C
C              FORTRAN SUBROUTINE PROLOG
C
C LINKAGE      SUBROUTINE PROLOG
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    IPRLOG          SUBROUTINE    COMPRS
C
      SUBROUTINE PROLOG
C
      IMPLICIT INTEGER (A-Z)
C
C       14.    I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      LOGICAL INTERP
      DIMENSION PRT(7)
C INTERP:      NORMALLY TRUE,INDICATING INTERPRETIVE APPROACH DEFAULT
      EQUIVALENCE (INTERP,PRT(3))
C**
C     IF(ASSEMB)CALL APRLOG
      IF(INTERP)CALL IPRLOG
      RETURN
       END
**** SOURCE FILE : M0006681.V05   ***
*
C
C              FORTRAN SUBROUTINE RLSBUF
C
C LINKAGE      SUBROUTINE RLSBUF
C
C          SUBSIDIARIES                  CALLED BY
C          TYPE          ENTRY           TYPE          ENTRY
C          SUBROUTINE    AWRITE          SUBROUTINE    CILOUT
C                                        SUBROUTINE    ICMPRS
C                                        SUBROUTINE    IEPLOG
C
      SUBROUTINE RLSBUF
C
      IMPLICIT INTEGER (A-Z)
C
C       33.    SYMBOLIC FILE DEFINITIONS
C
      INCLUDE 'SYMFIL.INC'
C ELFIL1:          INTERMEDIATE LANGUAGE FILE
C ELFIL2:          PART PROGRAMMING TEXT GENERATED BY INTERPRETER
C ELFIL3:          MACRO TEXT GENERATED FOR INTERPRETER
C
C       34.    COMMON BLOCK FOR INTERPRETIVE C.I.L. OUTPUT
C
      INCLUDE 'OUTBUF.INC'
C MACFLG:      TRUE WHEN MACRO PROCESSING IN EFFECT (INTERPRETER)
C LABFLG:      INDICATES I.L. COMMAND IS LABEL (INTERPRETER)
C RSVFLG:      TRUE IF I.L. COMMAND IS A RESRV (INTERPRETER)
C LPAGE:       NUMBER OF PAGES OF ENTRY,HOLDAT,LABEL AND RESRV COMMANDS
C IBUF:        NUMBER OF RECORDS IN BUFFER ARRAY
C ILBUF:       NUMBER OF ITEMS IN THE LABBUF ARRAY (INTERPRETER)
C PPPAGE:      PAGE NUMBER OF PART PROGRAMMING TEXT (INTERPRETER)
C MCPAGE:      NUMBER OF PAGES OF MACRO I.L. (INTERPRETER)
C BUFFER:      TEMPORARY STORAGE FOR INTERPRETER OUTPUT (PAGES)
C LABBUF:      TEMPORARY STORAGE FOR LABEL,HOLDAT ENTRY AND RESRV I.L.
C*
      INTEGER ZERO
      DATA ZERO/0/
C**
C...     TEST WHETHER THIS IS LABEL AND RESRV CODE
C
      IF ((LABFLG).OR.(RSVFLG)) GOTO 100
C
C
      IF(IBUF.EQ.0) RETURN
C
C...     NO. IS IT MACRO CODE
C
      IF (MACFLG) GOTO 300
C
C...     NO. THIS IS PART-PROGRAM CODE AND IS WRITTEN TO FILE 2
C...     FORM MARKER WORD, AND UPDATE PAGE COUNT
C
  200 PPPAGE = PPPAGE+1
      N=0
      BUFFER(1) = PPPAGE
      BUFFER(2) = IBUF
      CALL AWRITE(ELFIL2,N,BUFFER,256,IRET)
C
C...     RESET BUFFER POINTER AND RETURN
C
  210 IBUF = 0
      RETURN
C
C...     MACRO CODE IS WRITTEN TO FILE 3
C...     FORM MARKER WORD, AND UPDATE PAGE COUNT
C
  300 MCPAGE = MCPAGE+1
      N=0
      BUFFER(1) = -MCPAGE
      BUFFER(2) = IBUF
      CALL AWRITE(ELFIL3,N,BUFFER,256,IRET)
      GOTO 210
C
C...     LABEL AND RESRV CODE IS WRITTEN TO FILE 1
C...     ITS PAGES HAVE ZERO PAGE NUMBERS
C
  100 LPAGE = LPAGE+1
      N=0
      LABBUF(1) = ZERO
      LABBUF(2) = ILBUF
      CALL AWRITE(ELFIL1,N,LABBUF,256,IRET)
C
C...     RESET BUFFER POINTER AND RETURN
C
      ILBUF = 0
      RETURN
       END
