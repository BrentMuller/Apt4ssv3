**** SOURCE FILE : ARTIME00.ORG   ***
*
*
*  * ARTIME *  FORTRAN 77 SUBROUTINE  9-DEC-1985  E.MCLELLAN
*
*  PURPOSE:  EXTRACT CURRENT DATE AND TIME AND STORE IN ATIME BLOCK
*
*  CALLING SEQUENCE:
*                   CALL ARTIME
*
*  ARGUMENTS:  NONE
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   CTIME           ATIME     CHARACTER  CURRENT TIME
*   CDATE           ATIME     CHARACTER  CURRENT DATE
*
*  LOCAL VARIABLES:  NONE
*                   TYPE       DESCRIPTION
*
*  FILES:  NONE
*
*  SUBSIDIARIES:
*              DATE
*              TIME
*
      SUBROUTINE ARTIME
C
      COMMON/ATIME/CTIME,CDATE
C
      CHARACTER CTIME*8,CDATE*9
C
      CALL TIME(CTIME)
      CALL DATE(CDATE)
C
      RETURN
      END
**** SOURCE FILE : CLOSPE00.ORG   ***
*
      SUBROUTINE CLOSPE(ID,IRET)
C
      INTEGER ID,IRET
C
      CLOSE (UNIT=ID,ERR=10,STATUS='KEEP')
      IRET=0
      RETURN
C
  10  IRET=1
      RETURN
      END
**** SOURCE FILE : CPUTIM.ORG   ***
*
c original code in this source file lower-case; made 
c upper-case to distinguish my changes
c     INTEGER*4 FUNCTION CPUTIM
c     INTEGER*2 W_LEN1,W_COD1
c     INTEGER*4 L_ADD1,L_LENADD1
c      INTEGER*4 STATUS,SYS$GETJPI
c     integer*4 sys$getjpi
c     logical status
c     PARAMETER (JPI$_CPUTIM='0407'X)
c     COMMON/JPI_PARAMS/W_LEN1,W_COD1,L_ADD1,L_LENADD1
c     DATA W_LEN1,W_COD1/4,JPI$_CPUTIM/
c     DATA L_LENADD1/0/,ISTART/0/
c      L_ADD1=%LOC(CPUTIM)
c      STATUS=SYS$GETJPI(,,,W_LEN1,,,)
c     status =0
c     IF(.NOT.STATUS)THEN
c           WRITE(6,*)'*** ERROR IN GETTING CPU TIME ***'
c           CPUTIM=0
c           RETURN
c     END IF
c     RETURN
c     END
**** SOURCE FILE : FILOPN00.ORG   ***
*
*
*  * FILOPN *    VAX11 FORTRAN SUBROUTINE  10.5.82 E.MCLELLAN
*                MODIFIED                  18.07.85 E.MCLELLAN
*
*  PURPOSE     TO OPEN A FILE WITH REQUIRED ATTRIBUTES
*
*  CALLING SEQUENCE
*              CALL FILOPN(NO)
*  ARGUMENTS
*              NO    FILE NUMBER
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   FILNAM          FILTAB    CHARACTER  FILE NAME
*   FILACC          FILTAB    CHARACTER  FILE ACCESS
*                                         (DIRECT OR SEQUENTIAL)
*   FILFMT          FILTAB    CHARACTER  FILE FORMAT
*                                         (FORMATTED OR UNFORMATTED)
*   OPSTAT          FILTAB    CHARACTER  OPEN STATUS
*                                         (UNKNOWN,SCRATCH,NEW,OLD)
*   CLSTAT          FILTAB    CHARACTER  CLOSE STATUS (KEEP,DELETE)
*   U               IFILTB    INTEGER    UNIT NUMBER
*   RL              IFILTB    INTEGER    RECORD LENGTH
*   NXTREC          IFILTB    INTEGER    NUMBER OF NEXT RECORD TO BE
*                                        READ OR WRITTEN (DIRECT ACCESS)
*   LSTREC          IFILTB    INTEGER    NUMBER OF LAST RECORD ON FILE
*                                         (DIERECT ACCESS)
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*        DARRAY     CHARACTER  PRINT BUFFER
*        POSN       INTEGER    START POSITION IN PRINT BUFFER
*        SLEN       INTEGER    LENGTH OF STRING ENTERED IN BUFFER
*
*  FILES:  FILE REFERENCED BY FILE NUMBER
*
*  SUBSIDIARIES:
*               CFORM
*               ICONV
*               CPRINT
*
      SUBROUTINE FILOPN(NO)
C
      INCLUDE 'FILTAB.INC'
C
      INTEGER POSN,SLEN
      CHARACTER*80 DARRAY
      DATA DARRAY/' '/
C
c     gfortran doesn't like an option in this open statement
c      OPEN (UNIT=U(NO),FILE=FILNAM(NO),IOSTAT=IRET,ERR=90,
c     1      STATUS=OPSTAT(NO),ACCESS=FILACC(NO),
c     2      FORM=FILFMT(NO),RECL=RL(NO))
      open (unit=u(no),file=filnam(no),iostat=iret,err=90,
c     1      status=opstat(no),access=filacc(no),
     1      access=filacc(no),
     2      form=filfmt(no),recl=rl(no))
C
      RETURN
C
   90 SLEN=0
      CALL CFORM (' **** ERROR OPENING FILE :',DARRAY,2,SLEN)
      POSN=SLEN+3
      SLEN=0
      CALL CFORM (FILNAM(NO),DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+1
      SLEN=0
      CALL CFORM ('; UNIT NO :',DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+1
      CALL ICONV (U(NO),DARRAY,POSN,2)
      POSN=POSN+4
      SLEN=0
      CALL CFORM ('****',DARRAY,POSN,SLEN)
      CALL CPRINT (DARRAY)
      CALL ABNEND
      RETURN
      END
**** SOURCE FILE : BDLIBCOM.V01   ***
*
      BLOCK DATA BDLIBC
C
      INCLUDE 'LIBCOM.INC'
C
      DATA MEMNAM/' '/,APTLIB/'SYS$APTLIB:'/,FILENM/' '/
      DATA IEOF/1/
C
      END
**** SOURCE FILE : FINDME00.V01   ***
*
      SUBROUTINE FINDME(ID,MEMBER,IRET)
C
      INTEGER ID,IRET
      CHARACTER*(*) MEMBER
C
      LOGICAL EX
C
      INCLUDE 'LIBCOM.INC'
C
C.... SET UP FILENAME
C
C
      J=INDEX(MEMBER(1:),' ')
      IF (J.EQ.0) THEN
        FILENM=APTLIB//MEMBER//'.LDA'
      ELSE
        FILENM=APTLIB//MEMBER(1:J-1)//'.LDA'
      ENDIF
C
C.... INQUIRE IF FILE EXISTS
C
      INQUIRE(FILE=FILENM,EXIST=EX)
      IF (EX) THEN
C.... FILE EXISTS - OPEN ATTACHED TO ID
        OPEN(UNIT=ID,FILE=FILENM,ERR=20,STATUS='OLD',
     +       ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
        IRET=0
      ELSE
        IRET=6
      ENDIF
      RETURN
C.... ERROR OPENING FILE
  20  IRET=5
      RETURN
      END
**** SOURCE FILE : LIBOPC00.W01   ***
*
      SUBROUTINE LIBOPC(IND,FLAG)
*
*  * LIBOPC *  VAX-11 FORTRAN VERSION  27.09.82  E.MCLELLAN
*              PORTABLE F77 VERSION REVISED  8-OCT-1987 E.MCLELLAN
*
*  PURPOSE     TO CHECK THE EXISTENCE OF APTLIB
*              OR CLOSE UNIT REFERENCING APTLIB
*  CALLING SEQUENCE
*              CALL LIBOPC(IND,FLAG)
*  ARGUMENTS
*              IND   =1 DOES APTLIB EXIST
*                    =2 CLOSE UNIT WHICH REFERENCES APTLIB
*              FLAG  =0 APTLIB EXISTS
*                    =1 APTLIB DOES NOT EXIST
*                    =2 NOT USED
*                    =3 ALREADY CLOSED (IND=2)
*                    =4 IND IS NOT 1 OR 2
*
      INTEGER FLAG
      LOGICAL OD,EX
C
      INCLUDE 'FILTAB.INC'
C
      INCLUDE 'LIBCOM.INC'
C
C.....UNIT NUMBER FOR APTLIB
C
      ID=U(24)
C
      IF (IND.EQ.1) THEN
C
C.....DOES APTLIB EXIST
C
         INQUIRE(FILE=APTLIB//'INDEX',EXIST=EX)
         IF (EX) THEN
C
C.....APTLIB EXISTS
            FLAG=0
            RETURN
         ELSE
C
C.....APTLIB DOES NOT EXIST
         FLAG=1
         RETURN
         END IF
C
      ELSE IF (IND.EQ.2) THEN
C
C.....IS UNIT OPEN
         INQUIRE(UNIT=ID,OPENED=OD)
         IF (OD) THEN
C
C.....CLOSE UNIT
            CLOSE (UNIT=ID,STATUS=CLSTAT(24))
            RETURN
C
         ELSE
C.....UNIT ALREADY CLOSED
         FLAG=3
         RETURN
         END IF
C
      ELSE
C
C.....IND NOT 1 OR 2
      FLAG=4
      END IF
      RETURN
      END
**** SOURCE FILE : LIBRD000.V01   ***
*
      SUBROUTINE LIBRD(MEMBER,FLAG,ARRAY)
*
*  * LIBRD *  VAX-11 FORTRAN 77 VERSION  28.09.82  E.MCLELLAN
*                              MODIFIED  26.09.86
*
*  PURPOSE    TO READ A RECORD (80 CHARACTERS) FROM THE GIVEN
*             MEMBER FILE OF APTLIB
*  CALLING SEQUENCE
*             CALL LIBRD(MEMBER,FLAG,ARRAY)
*  ARGUMENTS
*             MEMBER    CHARACTER STRING CONTAINING THE
*                       MEMBER NAME (BCD LEFT JUSTIFIED)
*             FLAG      INTEGER SET BY LIBRD
*                       0 = SUCCESSFUL READ
*                       1 = END OF DATA ENCOUNTERED (EOF)
*                       2 = I/O ERROR
*                       3 = NOT USED
*                       4 = A DIFFERENT MEMBER NAME APPEARED WITHOUT
*                           CALLING LIBSCH OR BEFORE END OF DATA
*                           ENCOUNTERED
*             ARRAY     CHARACTER STRING TO CONTAIN A RETRIEVED RECORD
*
      CHARACTER*8 MEMBER,ARRAY*80
      INTEGER FLAG
C
      INCLUDE 'FILTAB.INC'
C
      INCLUDE 'LIBCOM.INC'
C
C
C.....IS MEMBER NAME SAME AS IN LAST CALL TO LIBSCH
C
      IF (MEMBER.NE.MEMNAM) THEN
         FLAG=4
         RETURN
      ELSE
C.....YES - READ A RECORD FROM MEMBER FILE
         ID=U(24)
         READ (UNIT=ID,FMT='(A80)',ERR=80,END=90) ARRAY
         FLAG=0
         RETURN
C
C.....I/O ERROR
   80    FLAG=2
         CLOSE(UNIT=ID)
         RETURN
C
C.....EOF ENCOUNTERED
   90    FLAG=1
         IEOF=1
         CLOSE(UNIT=ID)
         RETURN
      END IF
      END
**** SOURCE FILE : LIBSCH00.V01   ***
*
      SUBROUTINE LIBSCH(MEMBER,FLAG)
*
*  * LIBSCH *  VAX-11 FORTRAN 77 VERSION  27.09.82  E.MCLELLAN
*                               MODIFIED  30.10.86  E.MCLELLAN
*
*  PURPOSE     TO SEARCH APTLIB FOR A GIVEN
*              MEMBER FILE AND TO OPEN SAID FILE
*  CALLING SEQUENCE
*              CALL LIBSCH(MEMBER,FLAG)
*  ARGUMENTS
*              MEMBER    CHARACTER STRING CONTAINING THE
*                        MEMBER NAME (BCD LEFT JUSTIFIED)
*              FLAG      0 = MEMBER FOUND
*                        1 = MEMBER NOT FOUND IN APTLIB
*                        2 = ERROR OPENING FILE
*                        3 = APTLIB DOES NOT EXIST
*                        4 = LIBSCH IS CALLED BEFORE COMPLETING THE
*                            PROCESSING OF PREVIOUS MEMBER
*
      CHARACTER*(*) MEMBER
      INTEGER FLAG
C
      INCLUDE 'FILTAB.INC'
C
      INCLUDE 'LIBCOM.INC'
C
      LOGICAL OD,EX
C
C
C..... DOES APTLIB EXIST
      ID=U(24)
      INQUIRE(FILE=APTLIB//'INDEX',EXIST=EX)
      IF (EX) THEN
C
C.....YES - HAS PROCESSING OF PREVIOUS MEMBER BEEN COMPLETED
         IF (IEOF.EQ.0) THEN
C.....NO
             FLAG=4
             RETURN
C.....YES - SET UP FILE NAME FOR MEMBER
         ELSE
            J=INDEX(MEMBER(1:),' ')
            IF (J.EQ.0) THEN
              FILENM=APTLIB//MEMBER//'.TXT'
            ELSE
              FILENM=APTLIB//MEMBER(1:J-1)//'.TXT'
            ENDIF
C
C.....STORE MEMBER NAME AND RESET EOF FLAG
            MEMNAM=MEMBER
            IEOF=0
C.....DOES FILE EXIST
            INQUIRE(FILE=FILENM,EXIST=EX)
               IF (EX) THEN
C.....YES
               OPEN(UNIT=ID,FILE=FILENM,ERR=90,STATUS='OLD',
     1              ACCESS=FILACC(24),FORM=FILFMT(24))
               FLAG=0
               RETURN
   90          FLAG=2
               RETURN
               ELSE
C.....NO
               FLAG=1
               RETURN
               END IF
C
        END IF
C
      ELSE
C.....APTLIB DOES NOT EXIST
        FLAG=3
      END IF
      RETURN
      END
**** SOURCE FILE : M0002726.W02   ***
c moved this function to an external function to remove compile error
*
C
C
C.....FORTRAN INTEGER FUNCTION  ...APT211    8/68              HG,DE,PH
C
C.....MODIFIED FOR VAX 11 IMPLEMENTATION   02.06.82   E.MCLELLAN
C
C.....MODIFICATION TO PERMIT RESTART PROCEDURE USING
C     VAX CONDITION HANDLING FACILITIES
C
C
c      INTEGER FUNCTION APT211(ADRESS,HDRECT,IAEEE)
cC
c      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
c      DIMENSION ADRESS(*)
cC
c      INCLUDE 'TOTAL.INC'
c      INCLUDE 'DSHAR4.INC'
c      INCLUDE 'FXCOR.INC'
c      INCLUDE 'HOLRTH.INC'
c      INCLUDE 'SV.INC'
c      INCLUDE 'ZNUMBR.INC'
c      INCLUDE 'LDEF.INC'
c      INCLUDE 'ISV.INC'
c      INCLUDE 'IFXCOR.INC'
c      INCLUDE 'KNUMBR.INC'
cC
cC...            SYSTEM I/O FILE NAMES
cC
c      INCLUDE 'SYMFIL.INC'
cC
c      CHARACTER*8 TEST,HNOCS
c      INTEGER BCDF,TDS(2)
c      LOGICAL FIRST
c      SAVE FIRST,HOLDPP,TDS
c      CHARACTER*8 HOLRTH(6)
c      EQUIVALENCE (HOLRTH(1),HLFT)
cC
c      INTEGER Z4E
c      PARAMETER (Z4E=1308622848)
c      INTEGER HOLDPP
c      DIMENSION HOLDPP(8)
cC
c      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
c      COMMON /HSAVE/ SAVEH(50)
c      COMMON/SQNC/ LSEQNO
cC
cC++++ FLAG TO ALLOW A SECOND TRY WITHOUT CHECKING TA TO OVERCOME
cC++++ ERROR 20106
c      INTEGER I20106
cC
cC
c      LOGICAL KCS
cC
c      INCLUDE 'BLANKCOM.INC'
cC
c      DIMENSION MODTYP(3,6)
c      DIMENSION CSSAVE(10)
cC
c      DATA HOLDPP/0,0,Z4E,1,Z4E,1,Z4E,1/
c      DATA HNOCS/'NOCS    '/
c      DATA MODTYP/1,2,3,2,1,3,6*4,1,2,3,2,1,3/
c      DATA ZLIT2/.0349D0/
c      DATA FIRST/.TRUE./
cC
c      IF (FIRST)THEN
c        HOLDPP(1) = BCDF('HOLD')
c        HOLDPP(2) = BCDF('PP  ')
c        TDS(1) = BCDF(HDS(1:4))
c        TDS(2) = BCDF(HDS(5:8))
c        FIRST=.FALSE.
c      ENDIF
cC
c      CALL HOLFRM(HDRECT,TEST,1,8,NWD)
c      IF (IAEEE .EQ. 1) GO TO 8010
c      IF(IAERR.EQ.1) GO TO 1000
c      IF(TEST.EQ.HNOCS) GO TO 8000
c      IF(IGOTO+ICTDEF)1,1,3000
c    1 DO 4001 I=1,6
c      IF(TEST.EQ.HOLRTH(I)) GO TO 4002
c 4001 CONTINUE
c      CALL AERR(20104,'APT211  ')
c      GO TO 1000
c 4002 ISAV=I
c      IF(.NOT.JDS)GO TO 4000
c      KSEQNO = LSEQNO
c      LSEQNO = JSEQNO
c      KCSCNT=ICSCNT
c      KCS=JCS
c      LSAV=ISFTYP(IDS)
c      ISFTYP(IDS)=MSAV
c      ICSCNT=0
c      KIPL=IPL(ICS)
c      KLMFL=LIMFL(ICS)
c      KUNFL=IUNFL(ICS)
c      KFIDN=ISFIDN(ICS)
c      KSTYP=ISFTYP(ICS)
c      KTLON=ITLON(ICS)
c      SPAST=PAST(ICS)
c      KCAN=ICANON(ICS)
c      KFL4=IFL4(ICS)
c      KFAR=IFAR(ICS)
c      DO 1530 IIT = 1,10
c 1530 CSSAVE(IIT) = CANON(IIT+20)
c      CALL APT200(TDS,ADRESS,Z1)
c      IF(IAERR.NE.0)GO TO 1000
c      IF(MOTMOD.EQ.0)GO TO 4004
c      ISFTYP(ICS)=MODTYP(MOTMOD,ISAV)
c      IF(ISFTYP(ICS).EQ.2) PAST(ICS)=-K1
c      IS=IDS
c      GO TO 9200
c 4000 MODFER=TEST
c      IGO=ISAV
c      MSAV=ISFTYP(IDS)
c      IS=IDS
c      CALL APT234(TDS,ADRESS)
c      IF(IAERR.NE.0)GO TO 1000
c      IF(JCS)GO TO 9200
c      JSEQNO = LSEQNO
c      JDS=.TRUE.
cC     INTEG.ON EXFILE DP. 1ST WD UNNORM POWER,2ND INTEG VALUE
c      NR=0
c      CALL EWRITE(EXFILE,NR,HOLDPP,8,IR)
c      JHLDFG=1
c      GO TO 9999
c 4004 CALL AERR(20109,'APT211  ')
c      GO TO 1000
c 9200 CALL APT235
c      IF(IAERR)6000,6000,1000
c 6000 CALL APT240 (NUMDIM)
c   14 ICL = K2
c      NW = 0
c   19 IF (CUTDAT(6).EQ.0.)GO TO 32
c      NUMDIM = K1
c      GO TO 32
c   72 CALL APT236
c      IF(IAERR.NE.0)GO TO 4006
c      IF(JDS)GO TO 4005
c 4006 CONTINUE
c      JHLDFG=0
c      ITHCNT=1
c      JCS=.FALSE.
c      JDS=.FALSE.
c      GO TO 9999
c 4005 JCS=KCS
c      JHLDFG=0
c      GO TO 9500
c 9600 CONTINUE
c      NR=0
c      HOLDPP(8)=K2
c      CALL EWRITE(EXFILE,NR,HOLDPP,8,IR)
c      HOLDPP(8)=K1
c      ISFTYP(IDS)=LSAV
c      LSEQNO = KSEQNO
c      IF(.NOT.JCS)GO TO 4000
c      IPL(ICS)=KIPL
c      LIMFL(ICS)=KLMFL
c      ISFIDN(ICS)=KFIDN
c      ISFTYP(ICS)=KSTYP
c      ITLON(ICS)=KTLON
c      PAST(ICS)=SPAST
c      ICANON(ICS)=KCAN
c      IFL4(ICS)=KFL4
c      IFAR(ICS)=KFAR
c      ICSCNT=KCSCNT
c      JDS=.FALSE.
c      DO 1531 IIT = 1,10
c 1531 CANON(IIT+20) = CSSAVE(IIT)
c      GO TO 4000
c   32 J6 = 0
c      IS=IPS
cC  INITIALIZE VARIABLES FOR AMIND
c   33 IF (JENT(IS)) 301,302,301
c  301 JTN(IS) = K0
c      IOPSET(IS)=0
c      JU1(IS)=0
c      JIOPS(IS)=0
c  302 JAP = K1
c  201 CALL AMIND
c      IF(IAERR)1000,2000,1000
c 2000 IF(IPL(IS))141,140,141
c  141 IF(S(IS))142,39,143
c  142 IF (S(IS)-TAU2(IS)+1.D-4) 36,39,39
c  143 IF (S(IS)-TAU1(IS)-1.D-4) 39,39,36
c  140 IF(RC(IS)*S(IS))34,39,35
c   34 IF(DABS(S(IS))-Z9EM1*TAU(IS)-1.D-4) 39,39,36
c   35 IF(DABS(S(IS))-EPS1(IS)-1.D-2) 39,39,36
c   36 GO TO(505,508,504,204),JAP
c  505 IF (IPL(IS)) 506,202,506
c  202 IF (ISFTYP(IS)-K3) 504,507,504
c  504 RC(IS)=-RC(IS)
c      JAP = JAP + K1
c      GO TO 201
c  506 IF (TH(IS)) 510,510,204
c  507 JAP = K4
c  203 Z(IS)=-Z(IS)
c      GO TO 201
c  510 IF (IAFL(IS)) 507,511,507
c  511 JENT(IS)= -K1
c      JAP = K4
c      GO TO 201
c  508 IF (TH(IS)) 509,204,204
c  509 JAP = JAP + K1
c      GO TO 203
c  204 IF(J6)38,37,38
cC  CUTTER NOT WITHIN TOLERANCE OF DRIVE SURFACE AT START OF CUT SEQUENCE
c   38 CALL AERR (20102,'APT211  ')
c      GO TO 1000
cC  CUTTER NOT WITHIN TOLERANCE OF PART SURFACE AT START OF CUT SEQUENCE
c   37 CALL AERR (20103,'APT211  ')
c      GO TO 1000
c   40 J6=K1
c      IS=IDS
c      GO TO 33
c   39 IF (JAP-K1) 480,481,480
c  480 TPK(1,IS)=TP(1,IS)
c      TPK(2,IS)=TP(2,IS)
c      TPK(3,IS)=TP(3,IS)
c      SNK(1,IS)=SN(1,IS)
c      SNK(2,IS)=SN(2,IS)
c      SNK(3,IS)=SN(3,IS)
c      SK(1,IS) = S(IS)
c  481 IF(J6)41,40,41
cC  DETERMINE GENERAL DIRECTION OF FIRST CUT VECTOR AND STORE IN FWD
c   41 DO 42 K=1,3
c   42 FWD(K)=TE(K)-TEK(K)
c 2001 CALL VNORM(FWD,FWD)
cC  IGO =1 IF LFT, =2 IF RGT, =3 IF FWD, =4 IF BACK, =5 IF UP, =6 IF DOWN
cC  RELATIVE TO LAST COMMAND
c      IF(K4-IGO)43,45,45
c   43 DO 44 K=1,3
c   44 FWD(K)=TA(K)
c      GO TO 50
c   45 CALL CROSS(FWD,TA,FWD)
c      CALL VNORM(FWD,FWD)
c      IF (VTEM.GT.Z1EM6)GO TO 48
c   46 CALL CROSS(PMOVE,TA,FWD)
c      CALL VNORM(FWD,FWD)
c      IF(IER)47,48,47
cC  FWD DIRECTION CANNOT BE DETERMINED
c   47 CALL AERR (20105,'APT211  ')
c      GO TO 1000
c   48 IF(K3-IGO)49,49,50
c   49 CALL CROSS(TA,FWD,FWD)
c      CALL VNORM(FWD,FWD)
c      IF(IER)147,50,147
c  147 GO TO 47
c   50 GO TO (52,54,54,52,54,52),IGO
c   52 DO 53 K=1,3
c   53 FWD(K)=-FWD(K)
cC  CALCULATE TI VECTOR PERPENDICULAR TO BOTH PART AND DRIVE SURFACE
cC  NORMALS
c   54 CALL CROSS(SN(1,IPS),SN(1,IDS),TI)
c      CALL VNORM(TI,TI)
c      IF(IER)58,60,58
c   58 DO 59 K=1,3
c   59 TI(K)=FWD(K)
c      GO TO 67
cC  TI VECTOR AND FWD VECTOR SHOULD NOT BE ORTHOGONAL. IF SO CALL AERR
c   60 TEM(1)= TI(1)*FWD(1) +TI(2)*FWD(2)+TI(3)*FWD(3)
c      IF(DABS(TEM(1)) - ZLIT2) 64,64,63
c   64 IF (I20106.EQ.0) THEN
cC++++ HAVE SECOND TRY WITHOUT CHECKING TA TO AVOID ERROR 20106
c        I20106=1
c        CALL OUTMSG('*** WARNING: ERROR 20106 IN APT201 ***')
c        CALL OUTMSG('*** TRY WITHOUT CHECKING TA        ***')
c        DO 641 K=1,3
c          FWD(K)=TE(K)-TEK(K)
c  641   CONTINUE
c        CALL VNORM(FWD,FWD)
c        GOTO 50
c      ELSE
c        CALL AERR (20106,'APT211  ')
c        GO TO 1000
c      ENDIF
c   63 IF(TEM(1)) 65,65,67
c   65 DO 66 K=1,3
c   66 TI(K)=-TI(K)
c   67 IF(NUMDIM)68,68,73
cC  ICSCNT = NUMBER OF CHECK SURFACES. IF MORE THAN ONE CHECK SURFACE 3D
cC  ROUTES USED
c 68   CONTINUE
c  168 IF(I3DFLG-K1)130,73,130
c  130 IF(ICSCNT-K2)69,73,73
cC  IF THICKNESS OF PART, DRIVE, AND CHECK SURFACE NOT ZERO 3D ROUTES
cC  FOLLOWED
c   69 IF(TH(IPS))173,70,173
c  173 GO TO 73
c   70 IF(TH(IDS))174,71,174
c  174 GO TO 73
c   71 IF(TH(ICS))73,76,73
c   73 CONTINUE
cC  ENTRY FOR 3D CALCULATIONS
c  732 CALL ARLM3
c      APT211=TEMP(1)+0.5
c  101 IF(IAERR)1000,72,1000
c   76 IS=ICS
c      IF(ISFIDN(IDS)-K3)80,86,86
c   80 IF(ISFIDN(ICS)-K3)82,81,81
cC  LINE TO LINE CASE
c   82 JBR=K3
c      GO TO 83
cC  CIRCLE TO LINE OR CIRCLE TO CIRCLE CASE
c   86 JBR=K1
cC  ENTRY FOR 2D CALCULATIONS
c   83 CALL ARLM2
c      APT211=Z1
c      GO TO 101
cC  LINE TO CIRCLE CASE
c   81 JBR=K2
c      GOTO83
c 6001 IF(IGOTO)3001,3001,3002
c 3001 CALL AERR (20107,'APT211  ')
c      GO TO 1000
c 3002 CALL AERR (20108,'APT211  ')
c 1000 CONTINUE
c 6002 APT211=Z1
c      GO TO 72
c 3000 IF(ISRCH)6001,6001,6002
c 9999 CONTINUE
c      RETURN
c 9500 JJ=0
c 9510 JJ=JJ+1
c      IF(JJ.EQ.ITHCNT) GO TO 9590
c      KK=ITABH(JJ)
c      GO TO (9510,9510,9510,9504,9505,9506,9507,9508,9509,
c     C 9550,9511,9512,9513),KK
c 9504 CALL TOLERH
c      GO TO 9510
c 9505 CALL CUTTEH
c      GO TO 9510
c 9506 CALL CUTH
c      GO TO 9510
c 9507 CALL DNTCUH
c      GO TO 9510
c 9508 CALL INTOLH
c      GO TO 9510
c 9509 CALL OUTTOH
c      GO TO 9510
c 9550 CALL MAXDPH
c      GO TO 9510
c 9511 CALL INDRVH
c      GO TO 9510
c 9512 CALL INDRPH
c      GO TO 9510
c 9513 CALL THICKH
c      GO TO 9510
c 9590 ITHCNT=1
c      IF(IAEEE.EQ.1) GO TO 8020
c      GO TO 9600
c 8000 KSEQNO = LSEQNO
c      LSEQNO = JSEQNO
c      CALL APT235
c      IAEEE = 1
c      CALL AERR(20110,'APT211  ')
c 8010 IAERR = 0
c      GO TO 9500
c 8020 IAERR = 1
c      NR = 0
c      HOLDPP(8) = K2
c      CALL EWRITE(EXFILE,NR,HOLDPP,8,IR)
c      HOLDPP(8) = K1
c      LSEQNO = KSEQNO
cC....   RETURN TO CALLER
c      GO TO 1000
c      END
c


C
C.....FORTRAN INTEGER FUNCTION  ...APT201
C
C.....NEW SUBROUTINE FOR VAX 11 IMPLEMENTATION   02.06.82   E.MCLELLAN
C
C.....MODIFICATION TO PERMIT RESTART PROCEDURE USING
C     VAX CONDITION HANDLING FACILITIES
C
C
      INTEGER FUNCTION APT201(ADRESS,HDRECT)
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DIMENSION ADRESS(*)
      INTEGER APT211
C
C
      IAEEE=0
C...ESTABLISH CONDITION HANDLER FOR AERR ERROR
    1 CALL APT241
      APT201 = APT211(ADRESS,HDRECT,IAEEE)
      IF (IAEEE.EQ.1) GO TO 1
C...REVERT TO DEFAULT CONDITION HANDLER
      CALL LIB$REVERT
      RETURN
      END
C
C
**** SOURCE FILE : M0002827.W01   ***
*
C
C...  FORTRAN SUBROUTINE               CUTTER
      SUBROUTINE CUTTER(NMBR,PRM)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C-VAX.... MODIFICATION TO PERMIT RESTART PROCEDURE USING
C-VAX     VAX CONDITION HANDLING FACILITIES
      LOGICAL FLG
      FLG=.FALSE.
C.... ESTABLISH CONDITION HANDLER FRO AERR ERROR
      CALL APT241
   1  CALL CUTTES(NMBR,PRM,FLG)
      IF (FLG) GOTO 1
C.... REVERT TO DEFAULT CONDITION HANDLER
      CALL LIB$REVERT
      RETURN
      END
C
      SUBROUTINE CUTTES(NMBR,PRM,FLG)
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
      INTEGER HCUTER(2)
      INTEGER BCDF
C
C
C     25.   COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM / IAERFG
C
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
      COMMON /HSAVE/ SAVEH(50)
      EQUIVALENCE  (SAVEH( 6),PARAM(1) ),(SAVEH(15),NUMBER    )
      DIMENSION PRM(9)
C     -----------------------------------------------------------
C
C
C...  DEFINES CUTTER SHAPE AND SETS UP TOOL DATA BLOCKS
      DIMENSION PARAM(9)
      LOGICAL FLG
      HCUTER(1) = BCDF('CUTT')
      HCUTER(2) = BCDF('ER  ')
      IF(FLG)GO TO 9990
      FLG=.TRUE.
      DO 500 I=1,9
  500 PARAM(I)=PRM(I)
      NUMBER=NMBR
      IF(JHLDFG.EQ.0) GO TO 501
      ITABH(ITHCNT)=5
      ITHCNT=ITHCNT+1
      RETURN
C
  501 CONTINUE
  105 ICTDEF=K1
C...  ZERO CUTTER PARAMETER STORAGE AREA
      DO 110 J=1,7
  110 CUTDAT(J)=Z0
      CUTDAT(7) = TLHIT
      IF(NUMBER-K7)126,126,125
  125 NUMERR=22201
      GO TO 1000
  126 DO 127 J=1,NUMBER
  127 CUTDAT(J)=PARAM(J)
C  WRITE CUTTER STATEMENT ON EXFILE
      CALL APT299(NUMBER,HCUTER,1,PARAM(1))
      IF(NUMBER.LE.1) GO TO 129
      KK=1
      DO 128 I=2,NUMBER,2
      IF(I.EQ.NUMBER) KK=0
  128 CALL APT299(1,PARAM(I),KK,PARAM(I+1))
C
C  PLACE ZEROES IN TLLDAT BLOCK
C
  129 DO 1 I=1,8
      TLHITE(I)=Z0
      SINL(I)=Z0
      COSL(I)=Z0
      UMAX(I)=Z0
      RI(I)=Z0
      CORRAD(I)=Z0
      TCONT(I)=Z0
      TLINC(I)=Z0
    1 CONTINUE
C  MAKE SURE TOOL DIAMETER NOT LESS THAN ZERO
      IF(CUTDAT(1))2,92,3
    2 NUMERR=22202
      GO TO 1000
C  EXAMINE TOOL HEIGHT. IF LESS THAN ZERO ERROR. SET TO 5 IF = ZERO.
C  OKAY OTHERWISE
    3 IF(CUTDAT(7))4,5,6
    4 NUMERR=22203
      GO TO 1000
    5 CONTINUE
C  SUM OF ANGLES A AND B MUST BE LESS THAN 90 DEGREES
    6 IF(Z90-CUTDAT(5)-CUTDAT( 6))7,7,8
    7 NUMERR=22204
      GO TO 1000
    8 RI(6)=Z5EM1*CUTDAT(1)
      CUTDAT(1)=RI(6)
C  ERROR IF ANGLE A NEGATIVE
      IF(CUTDAT(5))9,10,11
    9 NUMERR=22205
      GO TO 1000
   10 COSL(2)=Z1
      TANHI(1)=Z1E38
      GO TO 12
C  COMPUTE PARAMETERS FOR CERTAIN TOOL SEGMENTS FOR A GREATER THAN ZERO
   11 TLHITE(8)=DEGRAD*CUTDAT(5)
      SINL(2)=DSIN(TLHITE(8))
      COSL(2)=DCOS(TLHITE(8))
      TCONT(1)=SINL(2)/COSL(2)
      TLHITE(6)=TCONT(1)*RI(6)
      TANHI(1)=Z1/TCONT(1)
C  MAKE SURE HEIGHT OF BOTTOM LINE SEGMENT DOES NOT EXCEED TOOL HEIGHT
   12 IF(Z1EM5-DABS(CUTDAT(7)-TLHITE(6))) 13,13,15
   13 IF(CUTDAT(7)-TLHITE(6))14,14,16
   14 NUMERR=22206
      GO TO 1000
   15 TLHITE(6)=CUTDAT(7)
C  ERROR IF ANGLE B NEGATIVE
   16 IPT1=K1
      IF(CUTDAT(6))17,18,19
C                    BELL SHAPED CUTTER
   17 CALL AERR (-22207,'CUTTER  ')
      GO TO 19
   18 SINL(6)=Z1
      GO TO 20
C  COMPUTE PARAMETERS FOR CERTAIN TOOL SEGMENTS FOR B GREATER THAN ZERO
   19 TANHI(8)=DEGRAD*CUTDAT(6)
      SINL(6)=DCOS(TANHI(8))
      COSL(6)=DSIN(TANHI(8))
      TANLO(7)=COSL(6)/SINL(6)
C  FURTHER CALCULATIONS
   20 UMAX(2)=RI(6)/COSL(2)
      UMAX(6)=(CUTDAT(7)-TLHITE(6))/SINL(6)
      RI(7)=RI(6)+COSL(6)*UMAX(6)
      TCONT(2)=Z1
      TCONT(6)=Z1
C  EXAMINE TOOL RADIUS. IF GREATER THAN ZERO, CORNER CIRCLE WILL BE PART
C  OF TOOL CONFIGURATION. IF = ZERO, TOOL WILL CONSIST ONLY OF LINE AND
C  POINT CIRCLE SEGMENTS. ERROR IF NEGATIVE.
      IF(CUTDAT(2))21,22,25
   21 NUMERR=22208
      GO TO 1000
C  COMPARE LENGTH OF UPPER LINE SEGMENT TO ZERO. SET VALUES IN TLLDAT
C  BLOCK ACCORDINGLY
   22 IF(UMAX(6))23,23,24
   23 TANLO(7)=TANHI(1)
      TCONT(6)=Z0
      GO TO 87
   24 TLHITE(4)=TLHITE(6)
      RI(4)=RI(6)
      TANHI(4)=TANLO(7)
      TANLO(4)=TANHI(1)
      GO TO 86
C  COMPUTE CENTER OF CORNER CIRCLE
   27 CUTDAT(3)=RI(6)-CORRAD(4)
      CUTDAT(4)=CORRAD(4)
      GO TO 26
C  STORE RADIUS OF CORNER CIRCLE AND COMPUTE DISTANCE FROM CENTER OF
C  CIRCLE TO BOTTOM LINE (UMAX(3))
   25 CORRAD(4)=CUTDAT(2)
   26 UMAX(3)=CUTDAT(4)*COSL(2)-CUTDAT(3)*SINL(2)
      TANLO(1)=CUTDAT(3)*CUTDAT(3)+CUTDAT(4)*CUTDAT(4)
C  IF = 0, CENTER OF CORNER CIRCLE HAS TO BE CALCULATED
      IF(TANLO(1)+CUTDAT(5)+CUTDAT(6)*CUTDAT(6))28,27,28
C  DISTANCE FROM CENTER OF CIRCLE TO INTERSECTION OF LINE SEGMENTS
   28 UMAX(1)=DSQRT((CUTDAT(3)-RI(6))*(CUTDAT(3)-RI(6))
     1        +(CUTDAT(4)-TLHITE(6))*(CUTDAT(4)-TLHITE(6)))
      UMAX(7)=TANLO(7)*(CUTDAT(7)-TLHITE(6))
C  DISTANCE FROM CENTER OF CIRCLE TO UPPER END OF UPPER LINE SEGMENT
      UMAX(4)=DSQRT((CUTDAT(4)-CUTDAT(7))*(CUTDAT(4)-CUTDAT(7))
     1        +(CUTDAT(3)-RI(7))*(CUTDAT(3)-RI(7)))
C  IF THE Y COORD. (F) OF THE CENTER OF THE CORNER CIRCLE IS LESS THAN
C  THE Y COORD. OF THE INTERSECTION OF THE LINES, THEN ERROR
      IF(CUTDAT(4)+Z1EM5-TLHITE(6))29,29,30
   29 NUMERR=22209
      GO TO 1000
C  IF THE RADIUS IS BOTH LARGER THAN THE DISTANCE TO THE INTERSECTION
C  OF THE LINES AND DIFFERENT THAN THE DISTANCE TO THE ORIGIN OF THE
C  BOTTOM LINE SEGMENT, WE HAVE AN INVALID TOOL CONFIGURATION
   33 IF(Z1EM5-DABS(TANLO(1)-CORRAD(4)*CORRAD(4))) 34,34,35
   34 NUMERR=22210
      GO TO 1000
C  IF E GREATER THAN ZERO, WE HAVE AN INVALID TOOL CONFIGURATION
   35 IF(CUTDAT(3))53,37,34
   53 CALL AERR(-22211,'CUTTER  ')
      TANHI(1)=CUTDAT(4)/CUTDAT(3)
      TCONT(1)=CUTDAT(3)/CUTDAT(4)
C  NO LOWER LINE SEGMENT
   54 TCONT(2)=Z0
C  FURTHER TLLDAT VARIABLES
   55 TANLO(4)=TANHI(1)
   56 UMAX(5)=(RI(6)-CUTDAT(3))*SINL(6)+COSL(6)*(CUTDAT(4)-TLHITE(6))
C  IF = 0, THERE IS NO UPPER LINE SEGMENT AND IN THIS CASE TOOL NO GOOD
      IF(UMAX(6))67,57,67
C  IF GREATER THAN ZERO, RADIUS AND DISTANCE FROM CENTER OF CORNER
C  CIRCLE TO INTERSECTION OF LINES EQUAL.
   67 IF(CORRAD(4)-UMAX(1))68,68,62
   68 TCONT(7)=CORRAD(4)*CORRAD(4)-UMAX(5)*UMAX(5)
C  LENGTH OF UPPER LINE SEGMENT
      UMAX(6)=UMAX(6)+DSQRT(DABS(TCONT(7)))
     1       -DSQRT(UMAX(1)*UMAX(1)-UMAX(5)*UMAX(5))
      UMAX(8)=CUTDAT(4)-CUTDAT(7)-TANLO(7)*(UMAX(7)+RI(6)-CUTDAT(3))
      IF(Z1EM5-DABS(UMAX(8))) 72,72,69
   72 IF(UMAX(8))73,73,77
C  IF GREATER THAN ZERO, UPPER LINE SEGMENT WITH CORNER CIRCLE TANGENT.
C  OTHERWISE CORNER CIRCLE, PT. CIRCLE, UPPER LINE, AND THEN PT. CIRCLE
   73 IF(Z1EM5-DABS(TCONT(7))) 75,75,74
   75 IF(TCONT(7))76,76,83
   76 GO TO 41
   57 NUMERR=22212
      GO TO 1000
C  WE MUST CHANGE PARAMETERS FOR BOTTOM POINT CIRCLE DUE TO NATURE OF
C  CORNER CIRCLE
   37 CALL AERR(-22211,'CUTTER  ')
      TCONT(1)=Z0
      TANHI(1)=Z1E38
      GO TO 54
C  IF GREATER THAN OR EQUAL TO ZERO, CORNER CIRCLE IS A POINT CIRCLE
   30 IF(Z1EM5-DABS(CORRAD(4)-UMAX(1))) 32,31,31
   31 CORRAD(4) = 0.
      TANLO(1) = 0.
      UMAX(1) = 0.
      UMAX(3) = 0.
      UMAX(4) = 0.
      UMAX(7) = 0.
      CUTDAT(2) = 0.
      CUTDAT(3) = 0.
      CUTDAT(4) = 0.
      GO TO 22
   32 IF (CORRAD(4)-UMAX(1)) 38,38,33
   38 IF(RI(6)+TCONT(1)*(TLHITE(6)-CUTDAT(4))-
     1CUTDAT(3)+Z1EM5)39,39,40
C  CORNER CIRCLE INTERSECTS LOWER LINE SEGMENT AT AN UNACCEPTABLE ANGLE
   39 NUMERR=22213
      GO TO 1000
   40 IF(CUTDAT(4)+Z1EM5-TLHITE(6)-TANLO(7)*(RI(6)-
     1CUTDAT(3)))41,41,42
C  CORNER CIRCLE INTERSECTS UPPER LINE SEGMENT AT AN UNACCEPTABLE ANGLE
   41 NUMERR=22214
      GO TO 1000
   42 TANLO(3)=CORRAD(4)*CORRAD(4)-UMAX(3)*UMAX(3)
      IF(TANLO(3).LT.Z0)GO TO 39
C  LENGTH OF LOWER LINE SEGMENT
      UMAX(2)=UMAX(2)+DSQRT(TANLO(3))
     1       -DSQRT(UMAX(1)*UMAX(1)-UMAX(3)*UMAX(3))
      TANLO(8)=CUTDAT(3)+TCONT(1)*CUTDAT(4)
      IF(DABS(TANLO(8))-Z1EM5)43,46,46
C  IF GREATER THAN ZERO, PT. CIRCLE FOLLOWED BY CORNER CIRCLE OR JUST
C  CORNER CIRCLE. OTHERWISE PT. CIRCLE (MAYBE), LOWER LINE SEGMENT, PT.
C  CIRCLE, AND THEN CORNER CIRCLE
   43 IF(Z1EM5-DABS(TANLO(3))) 44,44,54
   44 IF(TANLO(3))45,45,50
   45 GO TO 39
   46 IF(TANLO(8))51,47,47
C  IF GREATER THAN ZERO,PT. CIRCLE (MAYBE), LOWER LINE SEGMENT, PT. CIR-
C  CLE, AND THEN CORNER CIRCLE. IF = 0, PT. CIRCLE AND CORNER CIRCLE.
C  ERROR LESS THAN ZERO
   51 IF(CORRAD(4)*CORRAD(4)-TANLO(1))52,53,50
   52 GO TO 39
C  IF GREATER THAN ZERO, CORNER CIRCLE TANGENT TO LOWER LINE SEGMENT
   47 IF(Z1EM5-DABS(TANLO(3))) 48,48,55
   48 IF(TANLO(3))49,49,50
   49 GO TO 39
C  LOWER LINE SEGMENT, PT. CIRCLE, AND CORNER CIRCLE PARAMETER CALC.
   50 TCONT(3)=DSQRT(TANLO(3))/UMAX(3)
      TANHI(3)=(Z1-TCONT(1)*TCONT(3))/(TCONT(1)+TCONT(3))
      TLHITE(3)=SINL(2)*UMAX(2)
      RI(3)=COSL(2)*UMAX(2)
      TANLO(3)=TANHI(1)
      TANLO(4)=TANHI(3)
      GO TO 56
   62 IF(Z1EM5-DABS(UMAX(4)-CORRAD(4))) 63,63,64
   63 NUMERR=22215
      GO TO 1000
C  IF GREATER THAN ZERO, CORNER CIRCLE MEETS UPPER PT. CIRCLE AT UNAC-
C  CEPTABLE ANGLE. IF = 0 WE MUST CHANGE PARAMETERS FOR UPPER PT. CIRCLE
   64 IF(CUTDAT(7)-CUTDAT(4))78,66,63
   78 CALL AERR(-22216,'CUTTER  ')
      TANLO(7)=(CUTDAT(4)-CUTDAT(7))/(RI(6)+SINL(6)-CUTDAT(3))
   79 TCONT(6)=Z0
   80 TANHI(4)=Z0
      GO TO 85
C  NO UPPER LINE SEGMENT. CHANGE IN PARAMETERS FOR UPPER POINT CIRCLE
C  NECESSARY DUE TO NATURE OF CORNER CIRCLE
   66 CALL AERR(-22216,'CUTTER  ')
      TANLO(7)=Z0
      GO TO 79
C  IF GREATER THAN ZERO,CORNER CIRCLE AND THEN UPPER PT. CIRCLE. OTHER-
C  WISE CORNER CIRCLE, PT. CIRCLE, UPPER LINE, AND THEN UPPER PT. CIRCLE
   69 IF(Z1EM5-DABS(TCONT(7))) 70,70,79
   70 IF(TCONT(7))71,71,83
   71 GO TO 41
   74 TANHI(4)=TANLO(7)
      GO TO 84
   77 IF(Z1EM5-DABS(CORRAD(4)-UMAX(4))) 81,81,78
   81 IF(CORRAD(4)-UMAX(4))82,82,83
   82 GO TO 41
C  FURTHER CALCULATIONS FOR TLLDAT BLOCK PARAMETERS
   83 TCONT(5)=DSQRT(TCONT(7))/UMAX(5)
      TANHI(4)=(TCONT(5)+TANLO(7))/(Z1-TCONT(5)*TANLO(7))
      TANLO(5)=TANHI(4)
      TANHI(5)=TANLO(7)
   84 RI(5)=RI(7)-COSL(6)*UMAX(6)
      TLHITE(5)=CUTDAT(7)-SINL(6)*UMAX(6)
      TLHITE(6)=TLHITE(5)
      RI(6)=RI(5)
   85 TLHITE(4)=CUTDAT(4)
      RI(4)=CUTDAT(3)
   86 TCONT(4)=Z1
   87 TANLO(1)=Z1E38
      TLINC(2)=Z1
      TLINC(6)=Z1
      TLHITE(7)=CUTDAT(7)
  200 IBEGIN=1
C  WE NOW SEARCH EACH OF THE 7 POSSIBLE SEGMENTS TO DETERMINE FIRST ONE
   91 IF(TCONT(IBEGIN))90,88,90
   90 TCONT(IBEGIN-1)=-Z1
      TCONT(8)=-Z1
      TCONT(7)=Z1
      TANHI(7)=-Z1E38
      TANHI(8)=-Z1E38
      TANLO(8)=Z1E38
      TLINC(8)=Z0
      CORRAD(8)=Z0
      ICTDEF=0
      IAERR=0
      CALL TLCONV
      GO TO 9999
   88 IBEGIN=IBEGIN+1
      IF(7-IBEGIN)89,91,91
   89 NUMERR=22217
      GO TO 1000
   92 IF(CUTDAT(7))4,93,10
   93 IPT1=0
      TANLO(7)=Z1E38
      IBEGIN=7
      GO TO 90
C
C        ** CUTTER PARAMETER ERROR-CALL AERR AND DEFINE POINT CUTTER
C
 1000 IAERFG=1
      ICTDEF=0
      CALL AERR(NUMERR,'CUTTER  ')
 9990 DO 1001 JJ=1,7
 1001 PARAM(JJ)=Z0
      NUMBER=K7
      FLG=.FALSE.
      GO TO 105
 9999 CONTINUE
      FLG=.FALSE.
      RETURN
      END
C
C
C
C
      SUBROUTINE CUTTEH
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
      INTEGER HCUTER(2)
      INTEGER BCDF
C
C
C     25.   COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM / IAERFG
C
      COMMON /HSAVE/ SAVEH(50)
      EQUIVALENCE  (SAVEH( 6),PARAM(1) ),(SAVEH(15),NUMBER    )
C     -----------------------------------------------------------
C
C
C...  DEFINES CUTTER SHAPE AND SETS UP TOOL DATA BLOCKS
      DIMENSION PARAM(9)
      HCUTER(1) = BCDF('CUTT')
      HCUTER(2) = BCDF('ER  ')
C
  105 ICTDEF=K1
C...  ZERO CUTTER PARAMETER STORAGE AREA
      DO 110 J=1,7
  110 CUTDAT(J)=Z0
      CUTDAT(7) = TLHIT
      IF(NUMBER-K7)126,126,125
  125 NUMERR=22201
      GO TO 1000
  126 DO 127 J=1,NUMBER
  127 CUTDAT(J)=PARAM(J)
C  WRITE CUTTER STATEMENT ON EXFILE
      CALL APT299(NUMBER,HCUTER,1,PARAM(1))
      IF(NUMBER.LE.1) GO TO 129
      KK=1
      DO 128 I=2,NUMBER,2
      IF(I.EQ.NUMBER) KK=0
  128 CALL APT299(1,PARAM(I),KK,PARAM(I+1))
C
C  PLACE ZEROES IN TLLDAT BLOCK
C
  129 DO 1 I=1,8
      TLHITE(I)=Z0
      SINL(I)=Z0
      COSL(I)=Z0
      UMAX(I)=Z0
      RI(I)=Z0
      CORRAD(I)=Z0
      TCONT(I)=Z0
      TLINC(I)=Z0
    1 CONTINUE
C  MAKE SURE TOOL DIAMETER NOT LESS THAN ZERO
      IF(CUTDAT(1))2,92,3
    2 NUMERR=22202
      GO TO 1000
C  EXAMINE TOOL HEIGHT. IF LESS THAN ZERO ERROR. SET TO 5 IF = ZERO.
C  OKAY OTHERWISE
    3 IF(CUTDAT(7))4,5,6
    4 NUMERR=22203
      GO TO 1000
    5 CONTINUE
C  SUM OF ANGLES A AND B MUST BE LESS THAN 90 DEGREES
    6 IF(Z90-CUTDAT(5)-CUTDAT( 6))7,7,8
    7 NUMERR=22204
      GO TO 1000
    8 RI(6)=Z5EM1*CUTDAT(1)
      CUTDAT(1)=RI(6)
C  ERROR IF ANGLE A NEGATIVE
      IF(CUTDAT(5))9,10,11
    9 NUMERR=22205
      GO TO 1000
   10 COSL(2)=Z1
      TANHI(1)=Z1E38
      GO TO 12
C  COMPUTE PARAMETERS FOR CERTAIN TOOL SEGMENTS FOR A GREATER THAN ZERO
   11 TLHITE(8)=DEGRAD*CUTDAT(5)
      SINL(2)=DSIN(TLHITE(8))
      COSL(2)=DCOS(TLHITE(8))
      TCONT(1)=SINL(2)/COSL(2)
      TLHITE(6)=TCONT(1)*RI(6)
      TANHI(1)=Z1/TCONT(1)
C  MAKE SURE HEIGHT OF BOTTOM LINE SEGMENT DOES NOT EXCEED TOOL HEIGHT
   12 IF(Z1EM5-DABS(CUTDAT(7)-TLHITE(6))) 13,13,15
   13 IF(CUTDAT(7)-TLHITE(6))14,14,16
   14 NUMERR=22206
      GO TO 1000
   15 TLHITE(6)=CUTDAT(7)
C  ERROR IF ANGLE B NEGATIVE
   16 IPT1=K1
      IF(CUTDAT(6))17,18,19
C                    BELL SHAPED CUTTER
   17 CALL AERR (-22207,'CUTTEH  ')
      GO TO 19
   18 SINL(6)=Z1
      GO TO 20
C  COMPUTE PARAMETERS FOR CERTAIN TOOL SEGMENTS FOR B GREATER THAN ZERO
   19 TANHI(8)=DEGRAD*CUTDAT(6)
      SINL(6)=DCOS(TANHI(8))
      COSL(6)=DSIN(TANHI(8))
      TANLO(7)=COSL(6)/SINL(6)
C  FURTHER CALCULATIONS
   20 UMAX(2)=RI(6)/COSL(2)
      UMAX(6)=(CUTDAT(7)-TLHITE(6))/SINL(6)
      RI(7)=RI(6)+COSL(6)*UMAX(6)
      TCONT(2)=Z1
      TCONT(6)=Z1
C  EXAMINE TOOL RADIUS. IF GREATER THAN ZERO, CORNER CIRCLE WILL BE PART
C  OF TOOL CONFIGURATION. IF = ZERO, TOOL WILL CONSIST ONLY OF LINE AND
C  POINT CIRCLE SEGMENTS. ERROR IF NEGATIVE.
      IF(CUTDAT(2))21,22,25
   21 NUMERR=22208
      GO TO 1000
C  COMPARE LENGTH OF UPPER LINE SEGMENT TO ZERO. SET VALUES IN TLLDAT
C  BLOCK ACCORDINGLY
   22 IF(UMAX(6))23,23,24
   23 TANLO(7)=TANHI(1)
      TCONT(6)=Z0
      GO TO 87
   24 TLHITE(4)=TLHITE(6)
      RI(4)=RI(6)
      TANHI(4)=TANLO(7)
      TANLO(4)=TANHI(1)
      GO TO 86
C  COMPUTE CENTER OF CORNER CIRCLE
   27 CUTDAT(3)=RI(6)-CORRAD(4)
      CUTDAT(4)=CORRAD(4)
      GO TO 26
C  STORE RADIUS OF CORNER CIRCLE AND COMPUTE DISTANCE FROM CENTER OF
C  CIRCLE TO BOTTOM LINE (UMAX(3))
   25 CORRAD(4)=CUTDAT(2)
   26 UMAX(3)=CUTDAT(4)*COSL(2)-CUTDAT(3)*SINL(2)
      TANLO(1)=CUTDAT(3)*CUTDAT(3)+CUTDAT(4)*CUTDAT(4)
C  IF = 0, CENTER OF CORNER CIRCLE HAS TO BE CALCULATED
      IF(TANLO(1)+CUTDAT(5)+CUTDAT(6)*CUTDAT(6))28,27,28
C  DISTANCE FROM CENTER OF CIRCLE TO INTERSECTION OF LINE SEGMENTS
   28 UMAX(1)=DSQRT((CUTDAT(3)-RI(6))*(CUTDAT(3)-RI(6))
     1        +(CUTDAT(4)-TLHITE(6))*(CUTDAT(4)-TLHITE(6)))
      UMAX(7)=TANLO(7)*(CUTDAT(7)-TLHITE(6))
C  DISTANCE FROM CENTER OF CIRCLE TO UPPER END OF UPPER LINE SEGMENT
      UMAX(4)=DSQRT((CUTDAT(4)-CUTDAT(7))*(CUTDAT(4)-CUTDAT(7))
     1        +(CUTDAT(3)-RI(7))*(CUTDAT(3)-RI(7)))
C  IF THE Y COORD. (F) OF THE CENTER OF THE CORNER CIRCLE IS LESS THAN
C  THE Y COORD. OF THE INTERSECTION OF THE LINES, THEN ERROR
      IF(CUTDAT(4)+Z1EM5-TLHITE(6))29,29,30
   29 NUMERR=22209
      GO TO 1000
C  IF THE RADIUS IS BOTH LARGER THAN THE DISTANCE TO THE INTERSECTION
C  OF THE LINES AND DIFFERENT THAN THE DISTANCE TO THE ORIGIN OF THE
C  BOTTOM LINE SEGMENT, WE HAVE AN INVALID TOOL CONFIGURATION
   33 IF(Z1EM5-DABS(TANLO(1)-CORRAD(4)*CORRAD(4))) 34,34,35
   34 NUMERR=22210
      GO TO 1000
C  IF E GREATER THAN ZERO, WE HAVE AN INVALID TOOL CONFIGURATION
   35 IF(CUTDAT(3))53,37,34
   53 CALL AERR(-22211,'CUTTEH  ')
      TANHI(1)=CUTDAT(4)/CUTDAT(3)
      TCONT(1)=CUTDAT(3)/CUTDAT(4)
C  NO LOWER LINE SEGMENT
   54 TCONT(2)=Z0
C  FURTHER TLLDAT VARIABLES
   55 TANLO(4)=TANHI(1)
   56 UMAX(5)=(RI(6)-CUTDAT(3))*SINL(6)+COSL(6)*(CUTDAT(4)-TLHITE(6))
C  IF = 0, THERE IS NO UPPER LINE SEGMENT AND IN THIS CASE TOOL NO GOOD
      IF(UMAX(6))67,57,67
C  IF GREATER THAN ZERO, RADIUS AND DISTANCE FROM CENTER OF CORNER
C  CIRCLE TO INTERSECTION OF LINES EQUAL.
   67 IF(CORRAD(4)-UMAX(1))68,68,62
   68 TCONT(7)=CORRAD(4)*CORRAD(4)-UMAX(5)*UMAX(5)
C  LENGTH OF UPPER LINE SEGMENT
      UMAX(6)=UMAX(6)+DSQRT(DABS(TCONT(7)))
     1       -DSQRT(UMAX(1)*UMAX(1)-UMAX(5)*UMAX(5))
      UMAX(8)=CUTDAT(4)-CUTDAT(7)-TANLO(7)*(UMAX(7)+RI(6)-CUTDAT(3))
      IF(Z1EM5-DABS(UMAX(8))) 72,72,69
   72 IF(UMAX(8))73,73,77
C  IF GREATER THAN ZERO, UPPER LINE SEGMENT WITH CORNER CIRCLE TANGENT.
C  OTHERWISE CORNER CIRCLE, PT. CIRCLE, UPPER LINE, AND THEN PT. CIRCLE
   73 IF(Z1EM5-DABS(TCONT(7))) 75,75,74
   75 IF(TCONT(7))76,76,83
   76 GO TO 41
   57 NUMERR=22212
      GO TO 1000
C  WE MUST CHANGE PARAMETERS FOR BOTTOM POINT CIRCLE DUE TO NATURE OF
C  CORNER CIRCLE
   37 CALL AERR(-22211,'CUTTEH  ')
      TCONT(1)=Z0
      TANHI(1)=Z1E38
      GO TO 54
C  IF GREATER THAN OR EQUAL TO ZERO, CORNER CIRCLE IS A POINT CIRCLE
   30 IF(Z1EM5-DABS(CORRAD(4)-UMAX(1))) 32,31,31
   31 CORRAD(4) = 0.
      TANLO(1) = 0.
      UMAX(1) = 0.
      UMAX(3) = 0.
      UMAX(4) = 0.
      UMAX(7) = 0.
      CUTDAT(2) = 0.
      CUTDAT(3) = 0.
      CUTDAT(4) = 0.
      GO TO 22
   32 IF (CORRAD(4)-UMAX(1)) 38,38,33
   38 IF(RI(6)+TCONT(1)*(TLHITE(6)-CUTDAT(4))-
     1CUTDAT(3)+Z1EM5)39,39,40
C  CORNER CIRCLE INTERSECTS LOWER LINE SEGMENT AT AN UNACCEPTABLE ANGLE
   39 NUMERR=22213
      GO TO 1000
   40 IF(CUTDAT(4)+Z1EM5-TLHITE(6)-TANLO(7)*(RI(6)-
     1CUTDAT(3)))41,41,42
C  CORNER CIRCLE INTERSECTS UPPER LINE SEGMENT AT AN UNACCEPTABLE ANGLE
   41 NUMERR=22214
      GO TO 1000
   42 TANLO(3)=CORRAD(4)*CORRAD(4)-UMAX(3)*UMAX(3)
      IF(TANLO(3).LT.Z0)GO TO 39
C  LENGTH OF LOWER LINE SEGMENT
      UMAX(2)=UMAX(2)+DSQRT(TANLO(3))
     1       -DSQRT(UMAX(1)*UMAX(1)-UMAX(3)*UMAX(3))
      TANLO(8)=CUTDAT(3)+TCONT(1)*CUTDAT(4)
      IF(DABS(TANLO(8))-Z1EM5)43,46,46
C  IF GREATER THAN ZERO, PT. CIRCLE FOLLOWED BY CORNER CIRCLE OR JUST
C  CORNER CIRCLE. OTHERWISE PT. CIRCLE (MAYBE), LOWER LINE SEGMENT, PT.
C  CIRCLE, AND THEN CORNER CIRCLE
   43 IF(Z1EM5-DABS(TANLO(3))) 44,44,54
   44 IF(TANLO(3))45,45,50
   45 GO TO 39
   46 IF(TANLO(8))51,47,47
C  IF GREATER THAN ZERO,PT. CIRCLE (MAYBE), LOWER LINE SEGMENT, PT. CIR-
C  CLE, AND THEN CORNER CIRCLE. IF = 0, PT. CIRCLE AND CORNER CIRCLE.
C  ERROR LESS THAN ZERO
   51 IF(CORRAD(4)*CORRAD(4)-TANLO(1))52,53,50
   52 GO TO 39
C  IF GREATER THAN ZERO, CORNER CIRCLE TANGENT TO LOWER LINE SEGMENT
   47 IF(Z1EM5-DABS(TANLO(3))) 48,48,55
   48 IF(TANLO(3))49,49,50
   49 GO TO 39
C  LOWER LINE SEGMENT, PT. CIRCLE, AND CORNER CIRCLE PARAMETER CALC.
   50 TCONT(3)=DSQRT(TANLO(3))/UMAX(3)
      TANHI(3)=(Z1-TCONT(1)*TCONT(3))/(TCONT(1)+TCONT(3))
      TLHITE(3)=SINL(2)*UMAX(2)
      RI(3)=COSL(2)*UMAX(2)
      TANLO(3)=TANHI(1)
      TANLO(4)=TANHI(3)
      GO TO 56
   62 IF(Z1EM5-DABS(UMAX(4)-CORRAD(4))) 63,63,64
   63 NUMERR=22215
      GO TO 1000
C  IF GREATER THAN ZERO, CORNER CIRCLE MEETS UPPER PT. CIRCLE AT UNAC-
C  CEPTABLE ANGLE. IF = 0 WE MUST CHANGE PARAMETERS FOR UPPER PT. CIRCLE
   64 IF(CUTDAT(7)-CUTDAT(4))78,66,63
   78 CALL AERR(-22216,'CUTTEH  ')
      TANLO(7)=(CUTDAT(4)-CUTDAT(7))/(RI(6)+SINL(6)-CUTDAT(3))
   79 TCONT(6)=Z0
   80 TANHI(4)=Z0
      GO TO 85
C  NO UPPER LINE SEGMENT. CHANGE IN PARAMETERS FOR UPPER POINT CIRCLE
C  NECESSARY DUE TO NATURE OF CORNER CIRCLE
   66 CALL AERR(-22216,'CUTTEH  ')
      TANLO(7)=Z0
      GO TO 79
C  IF GREATER THAN ZERO,CORNER CIRCLE AND THEN UPPER PT. CIRCLE. OTHER-
C  WISE CORNER CIRCLE, PT. CIRCLE, UPPER LINE, AND THEN UPPER PT. CIRCLE
   69 IF(Z1EM5-DABS(TCONT(7))) 70,70,79
   70 IF(TCONT(7))71,71,83
   71 GO TO 41
   74 TANHI(4)=TANLO(7)
      GO TO 84
   77 IF(Z1EM5-DABS(CORRAD(4)-UMAX(4))) 81,81,78
   81 IF(CORRAD(4)-UMAX(4))82,82,83
   82 GO TO 41
C  FURTHER CALCULATIONS FOR TLLDAT BLOCK PARAMETERS
   83 TCONT(5)=DSQRT(TCONT(7))/UMAX(5)
      TANHI(4)=(TCONT(5)+TANLO(7))/(Z1-TCONT(5)*TANLO(7))
      TANLO(5)=TANHI(4)
      TANHI(5)=TANLO(7)
   84 RI(5)=RI(7)-COSL(6)*UMAX(6)
      TLHITE(5)=CUTDAT(7)-SINL(6)*UMAX(6)
      TLHITE(6)=TLHITE(5)
      RI(6)=RI(5)
   85 TLHITE(4)=CUTDAT(4)
      RI(4)=CUTDAT(3)
   86 TCONT(4)=Z1
   87 TANLO(1)=Z1E38
      TLINC(2)=Z1
      TLINC(6)=Z1
      TLHITE(7)=CUTDAT(7)
  200 IBEGIN=1
C  WE NOW SEARCH EACH OF THE 7 POSSIBLE SEGMENTS TO DETERMINE FIRST ONE
   91 IF(TCONT(IBEGIN))90,88,90
   90 TCONT(IBEGIN-1)=-Z1
      TCONT(8)=-Z1
      TCONT(7)=Z1
      TANHI(7)=-Z1E38
      TANHI(8)=-Z1E38
      TANLO(8)=Z1E38
      TLINC(8)=Z0
      CORRAD(8)=Z0
      ICTDEF=0
      IAERR=0
      CALL TLCONV
      GO TO 9999
   88 IBEGIN=IBEGIN+1
      IF(7-IBEGIN)89,91,91
   89 NUMERR=22217
      GO TO 1000
   92 IF(CUTDAT(7))4,93,10
   93 IPT1=0
      TANLO(7)=Z1E38
      IBEGIN=7
      GO TO 90
C
C        ** CUTTER PARAMETER ERROR-CALL AERR AND DEFINE POINT CUTTER
C
 1000 IAERFG=1
      ICTDEF=0
      CALL AERR(NUMERR,'CUTTEH  ')
 9990 DO 1001 JJ=1,7
 1001 PARAM(JJ)=Z0
      NUMBER=K7
      GO TO 105
 9999 CONTINUE
      RETURN
       END
C
C
C
C
      SUBROUTINE CUTRED
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'ZNUMBR.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
      INCLUDE 'KNUMBR.INC'
C
C
C
      INTEGER HCUTER(2)
      INTEGER BCDF
C
C
C     25.   COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM / IAERFG
C
      COMMON /HSAVE/ SAVEH(50)
      EQUIVALENCE  (SAVEH( 6),PARAM(1) ),(SAVEH(15),NUMBER    )
C     -----------------------------------------------------------
C
C
C...  DEFINES CUTTER SHAPE AND SETS UP TOOL DATA BLOCKS
      DIMENSION PARAM(9)
C
      HCUTER(1) = BCDF('CUTT')
      HCUTER(2) = BCDF('ER  ')
C
C  PLACE ZEROES IN TLLDAT BLOCK
C        CUTRED ROUTINE TO REDEFINE EXISTING CUTTER FOR NEW UNITS/
  129 DO 1 I=1,8
      TLHITE(I)=Z0
      SINL(I)=Z0
      COSL(I)=Z0
      UMAX(I)=Z0
      RI(I)=Z0
      CORRAD(I)=Z0
      TCONT(I)=Z0
      TLINC(I)=Z0
    1 CONTINUE
C  MAKE SURE TOOL DIAMETER NOT LESS THAN ZERO
      IF(CUTDAT(1))2,92,3
    2 NUMERR=22202
      GO TO 1000
C  EXAMINE TOOL HEIGHT. IF LESS THAN ZERO ERROR. SET TO 5 IF = ZERO.
C  OKAY OTHERWISE
    3 IF(CUTDAT(7))4,5,6
    4 NUMERR=22203
      GO TO 1000
    5 CONTINUE
C  SUM OF ANGLES A AND B MUST BE LESS THAN 90 DEGREES
    6 IF(Z90-CUTDAT(5)-CUTDAT( 6))7,7,8
    7 NUMERR=22204
      GO TO 1000
    8 RI(6)=Z5EM1*CUTDAT(1)
      CUTDAT(1)=RI(6)
C  ERROR IF ANGLE A NEGATIVE
      IF(CUTDAT(5))9,10,11
    9 NUMERR=22205
      GO TO 1000
   10 COSL(2)=Z1
      TANHI(1)=Z1E38
      GO TO 12
C  COMPUTE PARAMETERS FOR CERTAIN TOOL SEGMENTS FOR A GREATER THAN ZERO
   11 TLHITE(8)=DEGRAD*CUTDAT(5)
      SINL(2)=DSIN(TLHITE(8))
      COSL(2)=DCOS(TLHITE(8))
      TCONT(1)=SINL(2)/COSL(2)
      TLHITE(6)=TCONT(1)*RI(6)
      TANHI(1)=Z1/TCONT(1)
C  MAKE SURE HEIGHT OF BOTTOM LINE SEGMENT DOES NOT EXCEED TOOL HEIGHT
   12 IF(Z1EM5-DABS(CUTDAT(7)-TLHITE(6))) 13,13,15
   13 IF(CUTDAT(7)-TLHITE(6))14,14,16
   14 NUMERR=22206
      GO TO 1000
   15 TLHITE(6)=CUTDAT(7)
C  ERROR IF ANGLE B NEGATIVE
   16 IPT1=K1
      IF(CUTDAT(6))17,18,19
C                    BELL SHAPED CUTTER
   17 CALL AERR (-22207,'CUTRED  ')
      GO TO 19
   18 SINL(6)=Z1
      GO TO 20
C  COMPUTE PARAMETERS FOR CERTAIN TOOL SEGMENTS FOR B GREATER THAN ZERO
   19 TANHI(8)=DEGRAD*CUTDAT(6)
      SINL(6)=DCOS(TANHI(8))
      COSL(6)=DSIN(TANHI(8))
      TANLO(7)=COSL(6)/SINL(6)
C  FURTHER CALCULATIONS
   20 UMAX(2)=RI(6)/COSL(2)
      UMAX(6)=(CUTDAT(7)-TLHITE(6))/SINL(6)
      RI(7)=RI(6)+COSL(6)*UMAX(6)
      TCONT(2)=Z1
      TCONT(6)=Z1
C  EXAMINE TOOL RADIUS. IF GREATER THAN ZERO, CORNER CIRCLE WILL BE PART
C  OF TOOL CONFIGURATION. IF = ZERO, TOOL WILL CONSIST ONLY OF LINE AND
C  POINT CIRCLE SEGMENTS. ERROR IF NEGATIVE.
      IF(CUTDAT(2))21,22,25
   21 NUMERR=22208
      GO TO 1000
C  COMPARE LENGTH OF UPPER LINE SEGMENT TO ZERO. SET VALUES IN TLLDAT
C  BLOCK ACCORDINGLY
   22 IF(UMAX(6))23,23,24
   23 TANLO(7)=TANHI(1)
      TCONT(6)=Z0
      GO TO 87
   24 TLHITE(4)=TLHITE(6)
      RI(4)=RI(6)
      TANHI(4)=TANLO(7)
      TANLO(4)=TANHI(1)
      GO TO 86
C  COMPUTE CENTER OF CORNER CIRCLE
   27 CUTDAT(3)=RI(6)-CORRAD(4)
      CUTDAT(4)=CORRAD(4)
      GO TO 26
C  STORE RADIUS OF CORNER CIRCLE AND COMPUTE DISTANCE FROM CENTER OF
C  CIRCLE TO BOTTOM LINE (UMAX(3))
   25 CORRAD(4)=CUTDAT(2)
   26 UMAX(3)=CUTDAT(4)*COSL(2)-CUTDAT(3)*SINL(2)
      TANLO(1)=CUTDAT(3)*CUTDAT(3)+CUTDAT(4)*CUTDAT(4)
C  IF = 0, CENTER OF CORNER CIRCLE HAS TO BE CALCULATED
      IF(TANLO(1)+CUTDAT(5)+CUTDAT(6)*CUTDAT(6))28,27,28
C  DISTANCE FROM CENTER OF CIRCLE TO INTERSECTION OF LINE SEGMENTS
   28 UMAX(1)=DSQRT((CUTDAT(3)-RI(6))*(CUTDAT(3)-RI(6))
     1        +(CUTDAT(4)-TLHITE(6))*(CUTDAT(4)-TLHITE(6)))
      UMAX(7)=TANLO(7)*(CUTDAT(7)-TLHITE(6))
C  DISTANCE FROM CENTER OF CIRCLE TO UPPER END OF UPPER LINE SEGMENT
      UMAX(4)=DSQRT((CUTDAT(4)-CUTDAT(7))*(CUTDAT(4)-CUTDAT(7))
     1        +(CUTDAT(3)-RI(7))*(CUTDAT(3)-RI(7)))
C  IF THE Y COORD. (F) OF THE CENTER OF THE CORNER CIRCLE IS LESS THAN
C  THE Y COORD. OF THE INTERSECTION OF THE LINES, THEN ERROR
      IF(CUTDAT(4)+Z1EM5-TLHITE(6))29,29,30
   29 NUMERR=22209
      GO TO 1000
C  IF THE RADIUS IS BOTH LARGER THAN THE DISTANCE TO THE INTERSECTION
C  OF THE LINES AND DIFFERENT THAN THE DISTANCE TO THE ORIGIN OF THE
C  BOTTOM LINE SEGMENT, WE HAVE AN INVALID TOOL CONFIGURATION
   33 IF(Z1EM5-DABS(TANLO(1)-CORRAD(4)*CORRAD(4))) 34,34,35
   34 NUMERR=22210
      GO TO 1000
C  IF E GREATER THAN ZERO, WE HAVE AN INVALID TOOL CONFIGURATION
   35 IF(CUTDAT(3))53,37,34
   53 CALL AERR(-22211,'CUTRED  ')
      TANHI(1)=CUTDAT(4)/CUTDAT(3)
      TCONT(1)=CUTDAT(3)/CUTDAT(4)
C  NO LOWER LINE SEGMENT
   54 TCONT(2)=Z0
C  FURTHER TLLDAT VARIABLES
   55 TANLO(4)=TANHI(1)
   56 UMAX(5)=(RI(6)-CUTDAT(3))*SINL(6)+COSL(6)*(CUTDAT(4)-TLHITE(6))
C  IF = 0, THERE IS NO UPPER LINE SEGMENT AND IN THIS CASE TOOL NO GOOD
      IF(UMAX(6))67,57,67
C  IF GREATER THAN ZERO, RADIUS AND DISTANCE FROM CENTER OF CORNER
C  CIRCLE TO INTERSECTION OF LINES EQUAL.
   67 IF(CORRAD(4)-UMAX(1))68,68,62
   68 TCONT(7)=CORRAD(4)*CORRAD(4)-UMAX(5)*UMAX(5)
C  LENGTH OF UPPER LINE SEGMENT
      UMAX(6)=UMAX(6)+DSQRT(DABS(TCONT(7)))
     1       -DSQRT(UMAX(1)*UMAX(1)-UMAX(5)*UMAX(5))
      UMAX(8)=CUTDAT(4)-CUTDAT(7)-TANLO(7)*(UMAX(7)+RI(6)-CUTDAT(3))
      IF(Z1EM5-DABS(UMAX(8))) 72,72,69
   72 IF(UMAX(8))73,73,77
C  IF GREATER THAN ZERO, UPPER LINE SEGMENT WITH CORNER CIRCLE TANGENT.
C  OTHERWISE CORNER CIRCLE, PT. CIRCLE, UPPER LINE, AND THEN PT. CIRCLE
   73 IF(Z1EM5-DABS(TCONT(7))) 75,75,74
   75 IF(TCONT(7))76,76,83
   76 GO TO 41
   57 NUMERR=22212
      GO TO 1000
C  WE MUST CHANGE PARAMETERS FOR BOTTOM POINT CIRCLE DUE TO NATURE OF
C  CORNER CIRCLE
   37 CALL AERR(-22211,'CUTRED  ')
      TCONT(1)=Z0
      TANHI(1)=Z1E38
      GO TO 54
C  IF GREATER THAN OR EQUAL TO ZERO, CORNER CIRCLE IS A POINT CIRCLE
   30 IF(Z1EM5-DABS(CORRAD(4)-UMAX(1))) 32,31,31
   31 CORRAD(4) = 0.
      TANLO(1) = 0.
      UMAX(1) = 0.
      UMAX(3) = 0.
      UMAX(4) = 0.
      UMAX(7) = 0.
      CUTDAT(2) = 0.
      CUTDAT(3) = 0.
      CUTDAT(4) = 0.
      GO TO 22
   32 IF (CORRAD(4)-UMAX(1)) 38,38,33
   38 IF(RI(6)+TCONT(1)*(TLHITE(6)-CUTDAT(4))-
     1CUTDAT(3)+Z1EM5)39,39,40
C  CORNER CIRCLE INTERSECTS LOWER LINE SEGMENT AT AN UNACCEPTABLE ANGLE
   39 NUMERR=22213
      GO TO 1000
   40 IF(CUTDAT(4)+Z1EM5-TLHITE(6)-TANLO(7)*(RI(6)-
     1CUTDAT(3)))41,41,42
C  CORNER CIRCLE INTERSECTS UPPER LINE SEGMENT AT AN UNACCEPTABLE ANGLE
   41 NUMERR=22214
      GO TO 1000
   42 TANLO(3)=CORRAD(4)*CORRAD(4)-UMAX(3)*UMAX(3)
      IF(TANLO(3).LT.Z0)GO TO 39
C  LENGTH OF LOWER LINE SEGMENT
      UMAX(2)=UMAX(2)+DSQRT(TANLO(3))
     1       -DSQRT(UMAX(1)*UMAX(1)-UMAX(3)*UMAX(3))
      TANLO(8)=CUTDAT(3)+TCONT(1)*CUTDAT(4)
      IF(DABS(TANLO(8))-Z1EM5)43,46,46
C  IF GREATER THAN ZERO, PT. CIRCLE FOLLOWED BY CORNER CIRCLE OR JUST
C  CORNER CIRCLE. OTHERWISE PT. CIRCLE (MAYBE), LOWER LINE SEGMENT, PT.
C  CIRCLE, AND THEN CORNER CIRCLE
   43 IF(Z1EM5-DABS(TANLO(3))) 44,44,54
   44 IF(TANLO(3))45,45,50
   45 GO TO 39
   46 IF(TANLO(8))51,47,47
C  IF GREATER THAN ZERO,PT. CIRCLE (MAYBE), LOWER LINE SEGMENT, PT. CIR-
C  CLE, AND THEN CORNER CIRCLE. IF = 0, PT. CIRCLE AND CORNER CIRCLE.
C  ERROR LESS THAN ZERO
   51 IF(CORRAD(4)*CORRAD(4)-TANLO(1))52,53,50
   52 GO TO 39
C  IF GREATER THAN ZERO, CORNER CIRCLE TANGENT TO LOWER LINE SEGMENT
   47 IF(Z1EM5-DABS(TANLO(3))) 48,48,55
   48 IF(TANLO(3))49,49,50
   49 GO TO 39
C  LOWER LINE SEGMENT, PT. CIRCLE, AND CORNER CIRCLE PARAMETER CALC.
   50 TCONT(3)=DSQRT(TANLO(3))/UMAX(3)
      TANHI(3)=(Z1-TCONT(1)*TCONT(3))/(TCONT(1)+TCONT(3))
      TLHITE(3)=SINL(2)*UMAX(2)
      RI(3)=COSL(2)*UMAX(2)
      TANLO(3)=TANHI(1)
      TANLO(4)=TANHI(3)
      GO TO 56
   62 IF(Z1EM5-DABS(UMAX(4)-CORRAD(4))) 63,63,64
   63 NUMERR=22215
      GO TO 1000
C  IF GREATER THAN ZERO, CORNER CIRCLE MEETS UPPER PT. CIRCLE AT UNAC-
C  CEPTABLE ANGLE. IF = 0 WE MUST CHANGE PARAMETERS FOR UPPER PT. CIRCLE
   64 IF(CUTDAT(7)-CUTDAT(4))78,66,63
   78 CALL AERR(-22216,'CUTRED  ')
      TANLO(7)=(CUTDAT(4)-CUTDAT(7))/(RI(6)+SINL(6)-CUTDAT(3))
   79 TCONT(6)=Z0
   80 TANHI(4)=Z0
      GO TO 85
C  NO UPPER LINE SEGMENT. CHANGE IN PARAMETERS FOR UPPER POINT CIRCLE
C  NECESSARY DUE TO NATURE OF CORNER CIRCLE
   66 CALL AERR(-22216,'CUTRED  ')
      TANLO(7)=Z0
      GO TO 79
C  IF GREATER THAN ZERO,CORNER CIRCLE AND THEN UPPER PT. CIRCLE. OTHER-
C  WISE CORNER CIRCLE, PT. CIRCLE, UPPER LINE, AND THEN UPPER PT. CIRCLE
   69 IF(Z1EM5-DABS(TCONT(7))) 70,70,79
   70 IF(TCONT(7))71,71,83
   71 GO TO 41
   74 TANHI(4)=TANLO(7)
      GO TO 84
   77 IF(Z1EM5-DABS(CORRAD(4)-UMAX(4))) 81,81,78
   81 IF(CORRAD(4)-UMAX(4))82,82,83
   82 GO TO 41
C  FURTHER CALCULATIONS FOR TLLDAT BLOCK PARAMETERS
   83 TCONT(5)=DSQRT(TCONT(7))/UMAX(5)
      TANHI(4)=(TCONT(5)+TANLO(7))/(Z1-TCONT(5)*TANLO(7))
      TANLO(5)=TANHI(4)
      TANHI(5)=TANLO(7)
   84 RI(5)=RI(7)-COSL(6)*UMAX(6)
      TLHITE(5)=CUTDAT(7)-SINL(6)*UMAX(6)
      TLHITE(6)=TLHITE(5)
      RI(6)=RI(5)
   85 TLHITE(4)=CUTDAT(4)
      RI(4)=CUTDAT(3)
   86 TCONT(4)=Z1
   87 TANLO(1)=Z1E38
      TLINC(2)=Z1
      TLINC(6)=Z1
      TLHITE(7)=CUTDAT(7)
  200 IBEGIN=1
C  WE NOW SEARCH EACH OF THE 7 POSSIBLE SEGMENTS TO DETERMINE FIRST ONE
   91 IF(TCONT(IBEGIN))90,88,90
   90 TCONT(IBEGIN-1)=-Z1
      TCONT(8)=-Z1
      TCONT(7)=Z1
      TANHI(7)=-Z1E38
      TANHI(8)=-Z1E38
      TANLO(8)=Z1E38
      TLINC(8)=Z0
      CORRAD(8)=Z0
      ICTDEF=0
      IAERR=0
      CALL TLCONV
      GO TO 9999
   88 IBEGIN=IBEGIN+1
      IF(7-IBEGIN)89,91,91
   89 NUMERR=22217
      GO TO 1000
   92 IF(CUTDAT(7))4,93,10
   93 IPT1=0
      TANLO(7)=Z1E38
      IBEGIN=7
      GO TO 90
C
C        ** CUTTER PARAMETER ERROR-CALL AERR AND DEFINE POINT CUTTER
C
 1000 IAERFG=1
      ICTDEF=0
      CALL AERR(NUMERR,'CUTRED  ')
 9990 DO 1001 JJ=1,7
 1001 PARAM(JJ)=Z0
      NUMBER=K7
C
      ICTDEF=K1
C...  ZERO CUTTER PARAMETER STORAGE AREA
      DO 110 J=1,7
  110 CUTDAT(J)=Z0
      CUTDAT(7) = TLHIT
      IF(NUMBER-K7)126,126,125
  125 NUMERR=22201
      GO TO 1000
  126 DO 127 J=1,NUMBER
  127 CUTDAT(J)=PARAM(J)
C  WRITE CUTTER STATEMENT ON EXFILE
      CALL APT299(NUMBER,HCUTER,1,PARAM(1))
      IF(NUMBER.LE.1) GO TO 129
      KK=1
      DO 128 I=2,NUMBER,2
      IF(I.EQ.NUMBER) KK=0
  128 CALL APT299(1,PARAM(I),KK,PARAM(I+1))
      GO TO 129
C
 9999 CONTINUE
      RETURN
       END
**** SOURCE FILE : M0004132.V07   ***
*
C
C
      SUBROUTINE GO(HMOD,ADRESS)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'IFXCOR.INC'
C
      DIMENSION ADRESS(*)
      call abort
c      IF(JDS) CALL APT211(0,'NOCS    ',IDUM)
C-IBM-      CALL APT241
      IF(IAERR.EQ.1)GO TO 10
C-VAX-ESTABLISH CONDITION HANDLER
      CALL APT241
   20 IF(ICTDEF.NE.0.AND.IGOTO.EQ.0)CALL AERR(20201,'GO      ')
      IF (IAERR.EQ.1) GOTO 10
      CALL GO2(HMOD,ADRESS)
      IF (IAERR.EQ.1) GOTO 20
C-VAX- REVERT TO DEFAULT CONDITION HANDLER
c   10 CALL LIB$REVERT
c      RETURN
   10 return
      END
**** SOURCE FILE : ADDRSS00.ORG   ***
*
      INTEGER FUNCTION ADDRSS(X)
*
*  * ADDRSS *   VAX11 FORTRAN VERSION    18.2.82  E.MCLELLAN
*
*  PURPOSE     ADDRSS RETURNS AN INTEGER WHICH IS THE
*              ACTUAL MACHINE ADDRESS OF THE ARGUMENT
*
*  CALLING SEQUENCE
*              VALUE=ADDRSS(X)
*  ARGUMENTS
*              X  VARIABLE WHOSE ADDRESS IS TO BE RETURNED
*
      DOUBLE PRECISION X
c      ADDRSS=%LOC(X)
      addrss=loc(x)
C
      RETURN
      END
**** SOURCE FILE : APT24100.ORG   ***
*
      SUBROUTINE APT241
      INTEGER HANDL
      EXTERNAL HANDL
      CALL LIB$ESTABLISH(HANDL)
      RETURN
      END
C
C
      SUBROUTINE APT242
      CALL LIB$SIGNAL(%VAL(SS$_ACCVIO))
      RETURN
      END
C
C
      INTEGER FUNCTION HANDL(S,M)
      INTEGER S(3),M(5)
c      INCLUDE 'SYS$LIBRARY:SIGDEF'
      HANDL=SS$_RESIGNAL
      IF (S(2).EQ.SS$_UNWIND) THEN
      RETURN
      END IF
c      CALL SYS$UNWIND(,)
c   i don't know what to replace this with right now, so..
      call abort
      RETURN
      END
**** SOURCE FILE : OUTSET00.ORG   ***
*
      SUBROUTINE OUTSET(J)
*
*  * OUTSET *  VAX-11 FORTRAN 77 SUBROUTINE   E.MCLELLAN
*
*  PURPOSE     TO SET UP PAPER TAPE CODE CONVERSION TABLE
*
*  CALLING SEQUENCE
*              CALL OUTSET(J)
*  ARGUMENT
*              J  INDICATES REQUIRED CODE
*                 =1  NAS943  ,ODD PARITY, COLUMN BINARY
*                 =2  ISO     ,EVEN PARITY,COLUMN BINARY
*                 =3  ASCII   ,NO PARITY,  NO CONVERSION
*
C
      INCLUDE 'DARRAY.INC'
C
      COMMON/PUNTAB/PUNCOD
C
C...BYTE VARIABLES IN THIS VAX IMPLEMENTATION MIGHT BE ABLE TO BE LOGICA
C...ON OTHER SYSTEMS
c      BYTE PUNCOD(128)
      integer*8 puncod(128)
c      BYTE NAS943(128),ISO(128),ASCII(128)
      integer*8 nas943(128),iso(128),ascii(128)
*
******  NAS943 ODD PARITY COLUMN BINARY
*
      data nas943/
*      0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
c     *Z00,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,Z3E,ZEE,ZEE,ZEE,Z80,ZEE,ZEE,
     *z'00',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'3e',z'ee'
     *,z'ee',z'ee',z'80',z'ee',z'ee',
c     1ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,
     1z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee'
     1,z'ee',z'ee',z'ee',z'ee',z'ee',
c     2Z10,ZEE,ZEE,Z7F,Z80,Z0B,Z70,ZEE,Z0B,Z2A,Z3E,Z70,Z3B,Z40,Z6B,Z31,
     2z'10',z'ee',z'ee',z'7f',z'80',z'0b',z'70',z'ee',z'0b',z'2a',z'3e'
     2,z'70',z'3b',z'40',z'6b',z'31',
c     3Z20,Z01,Z02,Z13,Z04,Z15,Z16,Z07,Z08,Z19,Z7C,Z7A,ZEE,Z7F,ZEE,ZEE,
     3z'20',z'01',z'02',z'13',z'04',z'15',z'16',z'07',z'08',z'19',z'7c'
     3,z'7a',z'ee',z'7f',z'ee',z'ee',
c     4Z0E,Z61,Z62,Z73,Z64,Z75,Z76,Z67,Z68,Z79,Z51,Z52,Z43,Z54,Z45,Z46,
     4z'0e',z'61',z'62',z'73',z'64',z'75',z'76',z'67',z'68',z'79',z'51'
     4,z'52',z'43',z'54',z'45',z'46',
c     5Z57,Z58,Z49,Z32,Z23,Z34,Z25,Z26,Z37,Z38,Z29,ZEE,ZEE,ZEE,ZEE,ZEE,
     5z'57',z'58',z'49',z'32',z'23',z'34',z'25',z'26',z'37',z'38',z'29'
     5,z'ee',z'ee',z'ee',z'ee',z'ee',
c     6ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,
     6z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee'
     6,z'ee',z'ee',z'ee',z'ee',z'ee',
c     7ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE/
     7z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee'
     7,z'ee',z'ee',z'ee',z'ee',z'ee'/
*
******  ISO/
*
      DATA ISO/
*      0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
c     *Z00,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,Z09,Z0A,ZEE,ZEE,Z8D,ZEE,ZEE,
c     1ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,
c     2ZA0,ZEE,ZEE,ZA3,Z24,ZA5,ZA6,Z27,Z28,ZA9,ZAA,Z2B,ZAC,Z2D,Z2E,ZAF,
c     3Z30,ZB1,ZB2,Z33,ZB4,Z35,Z36,ZB7,ZB8,Z39,Z3A,ZEE,ZEE,ZEE,ZEE,ZEE,
c     4ZC0,Z41,Z42,ZC3,Z44,ZC5,ZC6,Z47,Z48,ZC9,ZCA,Z4B,ZCC,Z4D,Z4E,ZCF,
c     5Z50,ZD1,ZD2,Z53,ZD4,Z55,Z56,ZD7,ZD8,Z59,Z5A,ZEE,ZEE,ZEE,ZEE,ZEE,
c     6ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,
c     7ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZFF/

     *z'00',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'09',z'0a'
     *,z'ee',z'ee',z'8d',z'ee',z'ee',
     1z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee'
     1,z'ee',z'ee',z'ee',z'ee',z'ee',
     2z'a0',z'ee',z'ee',z'a3',z'24',z'a5',z'a6',z'27',z'28',z'a9',z'aa'
     2,z'2b',z'ac',z'2d',z'2e',z'af',
     3z'30',z'b1',z'b2',z'33',z'b4',z'35',z'36',z'b7',z'b8',z'39',z'3a'
     3,z'ee',z'ee',z'ee',z'ee',z'ee',
     4z'c0',z'41',z'42',z'c3',z'44',z'c5',z'c6',z'47',z'48',z'c9',z'ca'
     4,z'4b',z'cc',z'4d',z'4e',z'cf',
     5z'50',z'd1',z'd2',z'53',z'd4',z'55',z'56',z'd7',z'd8',z'59',z'5a'
     5,z'ee',z'ee',z'ee',z'ee',z'ee',
     6z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee'
     6,z'ee',z'ee',z'ee',z'ee',z'ee',
     7z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee'
     7,z'ee',z'ee',z'ee',z'ee',z'ff'/
*
******  ASCII 7 BIT NO PARITY
*
      data ascii/
*      0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
c     *Z00,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,Z09,Z0A,ZEE,ZEE,Z0D,ZEE,ZEE,
c     1ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,
c     2Z20,Z21,Z22,Z23,Z24,Z25,Z26,Z27,Z28,Z29,Z2A,Z2B,Z2C,Z2D,Z2E,Z2F,
c     3Z30,Z31,Z32,Z33,Z34,Z35,Z36,Z37,Z38,Z39,Z3A,Z3B,Z3C,Z3D,Z3E,Z3F,
c     4Z40,Z41,Z42,Z43,Z44,Z45,Z46,Z47,Z48,Z49,Z4A,Z4B,Z4C,Z4D,Z4E,Z4F,
c     5Z50,Z51,Z52,Z53,Z54,Z55,Z56,Z57,Z58,Z59,Z5A,Z5B,Z5C,Z5D,Z5E,Z5F,
c     6Z60,Z61,Z62,Z63,Z64,Z65,Z66,Z67,Z68,Z69,Z6A,Z6B,Z6C,Z6D,Z6E,Z6F,
c     7Z70,Z71,Z72,Z73,Z74,Z75,Z76,Z77,Z78,Z79,Z7A,ZEE,ZEE,ZEE,ZEE,Z7F/
     *z'00',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'09',z'0a'
     *,z'ee',z'ee',z'0d',z'ee',z'ee',
     1z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee',z'ee'
     1,z'ee',z'ee',z'ee',z'ee',z'ee',
     2z'20',z'21',z'22',z'23',z'24',z'25',z'26',z'27',z'28',z'29',z'2a'
     2,z'2b',z'2c',z'2d',z'2e',z'2f',
     3z'30',z'31',z'32',z'33',z'34',z'35',z'36',z'37',z'38',z'39',z'3a'
     3,z'3b',z'3c',z'3d',z'3e',z'3f',
     4z'40',z'41',z'42',z'43',z'44',z'45',z'46',z'47',z'48',z'49',z'4a'
     4,z'4b',z'4c',z'4d',z'4e',z'4f',
     5z'50',z'51',z'52',z'53',z'54',z'55',z'56',z'57',z'58',z'59',z'5a'
     5,z'5b',z'5c',z'5d',z'5e',z'5f',
     6z'60',z'61',z'62',z'63',z'64',z'65',z'66',z'67',z'68',z'69',z'6a'
     6,z'6b',z'6c',z'6d',z'6e',z'6f',
     7z'70',z'71',z'72',z'73',z'74',z'75',z'76',z'77',z'78',z'79',z'7a'
     7,z'ee',z'ee',z'ee',z'ee',z'7f'/
*
      IF (J.EQ.1) THEN
         DO 100 I=1,128
  100    PUNCOD(I)=NAS943(I)
*
      ELSE IF (J.EQ.2) THEN
         DO 200 I=1,128
  200    PUNCOD(I)=ISO(I)
*
      ELSE IF (J.EQ.3) THEN
         DO 300 I=1,128
  300    PUNCOD(I)=ASCII(I)
*
      ELSE
         CALL CFORM('**** INVALID ARGUMENT IN CALL TO OUTSET ****',
     1               DARRAY,2,44)
         CALL CPRINT(DARRAY)
         CALL ABNEND
      END IF
      RETURN
      END
**** SOURCE FILE : PARNOM00.ORG   ***
*
      SUBROUTINE PARNOM(N,A,J)
*
*  * PARNOM *  VAX-11 FORTRAN 77 VERSION  26.10.82  E.MCLELLAN
*
*  PURPOSE     PUNCH COLUMN BINARY MATRIX REPRESENTATION OF
*              CHARACTERS USED FOR PUNCH TAPE IDENTIFICATION
*  CALLING SEQUENCE
*              CALL PARNOM(N,A,J)
*  ARGUMENTS
*              N  NUMBER OF BCD CHARACTERS TO BE CONVERTED (MAX 504)
*              A  ARRAY CONTAINING BCD CHARACTERS TO BE CONVERTED
*                 FORMAT A6,2X (6 BCD CHARACTERS FOLLOWED BY 2 BLANKS)
*                 THE BLANKS  ARE IGNORED
*              J  J=0  5*7 MATRIX, COLUMN BINARY, ODD PARITY
*                  =1  IGNORED
*                  =2  5*6 MATRIX, COLUMN BINARY, NO PARITY
*  ALTERNATE ENTRY
*              CALL PARNEM(N,A)
*                   PUNCHES A 5*7 MATRIX,COLUMN BINARY,EVEN PARITY
*
*  NOTE:       THE ALLOWABLE CHARACTERS ARE 0 THRO 9, A THRU Z,
*              AND !"#$%&'()*+,-./:;<=>?@[\]^_
*              IE THE COMPLETE ASCII CHARACTER SET LESS LOWER CASE
*
      DOUBLE PRECISION A(84)
      CHARACTER INFIL*504
*
C
C...BYTE VARIABLES IN THIS VAX IMPLEMENTATION MIGHT BE ABLE TO BE LOGICA
C...ON OTHER SYSTEMS
      BYTE OUT(3024),TABO(6,64),TABE(6,64),TAB56(6,64),CODE(6,64)
      BYTE TBO1(6,32),TBO2(6,32),TBE1(6,32),TBE2(6,32),
     1          TB561(6,32),TB562(6,32)
C
      EQUIVALENCE (TABO(1,1),TBO1(1,1)),(TABO(1,33),TBO2(1,1)),
     1            (TABE(1,1),TBE1(1,1)),(TABE(1,33),TBE2(1,1)),
     2            (TAB56(1,1),TB561(1,1)),(TAB56(1,33),TB562(1,1))
*
      INCLUDE 'DARRAY.INC'
*
******   TABLE FOR 5X7 MATRIX OUTPUT , ODD PARITY , COLUMN BINARY
*
c      DATA TBO1/
*              BLANK                      !
c     1Z80,Z80,Z80,Z80,Z80,Z80, Z80,Z80,Z5E,Z80,Z80,Z80,
c*                "                        #
c     2Z80,Z07,Z80,Z07,Z80,Z80, Z94,Z3E,Z94,Z3E,Z94,Z80,
c*                $                        %
c     3ZAE,Z2A,Z7F,Z2A,ZAE,Z80, ZE3,Z13,Z08,Z34,ZE3,Z80,
c*                &                        `
c     4ZFB,Z45,Z6B,Z10,Z68,Z80, Z80,Z80,Z07,Z80,Z80,Z80,
c*                (                        )
c     5Z80,Z1C,ZA2,ZC1,ZC1,Z80, Z80,ZC1,ZC1,ZA2,Z1C,Z80,
c*                *                        +
c     6Z08,Z2A,Z1C,Z2A,Z08,Z80, Z08,Z08,Z3E,Z08,Z08,Z80,
c*                ,                        -
c     7Z80,Z80,ZD0,ZB0,Z80,Z80, Z08,Z08,Z08,Z08,Z08,Z80,
c*                .                        /
c     8Z80,Z80,ZE0,ZE0,Z80,Z80, Z20,Z10,Z08,Z04,Z02,Z80,
c*                0                        1
c     9Z3E,ZC1,ZC1,ZC1,Z3E,Z80, Z80,Z02,Z7F,Z80,Z80,Z80,
c*                2                        3
c     AZC2,Z61,Z51,Z49,Z46,Z80, ZA1,ZC1,Z49,ZCD,ZB3,Z80,
c*                4                        5
c     BZ98,Z94,Z92,Z7F,Z10,Z80, ZA7,Z45,Z45,Z45,ZB9,Z80,
c*                6                        7
c     CZBC,ZC2,Z49,Z49,ZB0,Z80, Z01,Z01,Z79,Z85,Z83,Z80,
c*                8                        9
c     DZB6,Z49,Z49,Z49,ZB6,Z80, Z86,Z49,Z49,ZA1,Z9E,Z80,
c*                :                        ;
c     EZ80,Z80,ZB6,ZB6,Z80,Z80, Z80,Z80,ZD6,ZB6,Z80,Z80,
c*                <                        =
c     FZ08,Z94,ZA2,ZC1,Z80,Z80, ZA2,ZA2,ZA2,ZA2,ZA2,Z80,
c*                >                        ?
c     GZ80,ZC1,ZA2,Z94,Z08,Z80, Z02,Z01,ZD9,Z85,Z02,Z80/
c      DATA TBO2/
c*                @                        A
c     1Z3E,ZC1,Z5D,ZD5,Z5E,Z80, ZFE,Z91,Z91,Z91,ZFE,Z80,
c*                B                        C
c     2Z7F,Z49,Z49,Z49,ZB6,Z80, Z3E,ZC1,ZC1,ZC1,ZA2,Z80,
c*                D                        E
c     3Z7F,ZC1,ZC1,ZC1,ZE3,Z80, Z7F,Z49,Z49,Z49,ZC1,Z80,
c*                F                        G
c     4Z7F,Z89,Z89,Z89,Z01,Z80, ZE3,ZC1,ZC1,Z49,Z79,Z80,
c*                H                        I
c     5Z7F,Z08,Z08,Z08,Z7F,Z80, Z80,ZC1,Z7F,ZC1,Z80,Z80,
c*                J                        K
c     6Z20,Z40,Z40,ZBF,Z80,Z80, Z7F,Z08,Z94,ZA2,ZC1,Z80,
c*                L                        M
c     7Z7F,Z40,Z40,Z40,Z40,Z80, Z7F,Z02,Z8C,Z02,Z7F,Z80,
c*                N                        O
c     8Z7F,Z02,Z04,Z08,Z7F,Z80, Z3E,Z51,Z49,Z45,Z3E,Z80,
c*                P                        Q
c     9Z7F,Z89,Z89,Z89,Z86,Z80, Z3E,ZC1,Z51,ZA1,Z5E,Z80,
c*                R                        S
c     AZ7F,Z89,Z19,Z29,Z46,Z80, Z46,Z49,Z49,Z49,Z31,Z80,
c*                T                        U
c     BZ01,Z01,Z7F,Z01,Z01,Z80, ZBF,Z40,Z40,Z40,ZBF,Z80,
c*                V                        W
c     CZ8F,ZB0,Z40,ZB0,Z8F,Z80, ZBF,Z40,ZBC,Z40,ZBF,Z80,
c*                X                        Y
c     DZE3,Z94,Z08,Z94,ZE3,Z80, Z07,Z08,Z70,Z08,Z07,Z80,
c*                Z                        [
c     EZ61,Z51,Z49,Z45,Z43,Z80, Z7F,Z7F,ZC1,ZC1,ZC1,Z80,
c*                \                        ]
c     FZ02,Z04,Z08,Z20,Z40,Z80, ZC1,ZC1,ZC1,Z7F,Z7F,Z80,
c*                ^                        _
c     GZ04,Z02,Z01,Z02,Z04,Z80, Z40,Z40,Z40,Z40,Z40,Z80/
c******   TABLE FOR 5X7 MATRIX OUTPUT ,EVEN PARITY , COLUMN BINARY
c*
c      DATA TBE1/
c*              BLANK                      !
c     1ZC0,ZC0,ZC0,ZC0,ZC0,ZC0, ZC0,ZC0,Z2F,ZC0,ZC0,ZC0,
c*                "                        #
c     2ZC0,Z87,ZC0,Z87,ZC0,ZC0, Z14,ZBE,Z14,ZBE,Z14,ZC0,
c*                $                        %
c     3Z2E,ZAA,ZFF,ZAA,Z3A,ZC0, Z63,Z93,Z88,ZE4,Z63,ZC0,
c*                &                        `
c     4Z7B,ZC5,ZEB,Z90,ZE9,ZC0, ZC0,ZC0,Z87,ZC0,ZC0,ZC0,
c*                (                        )
c     5ZC0,Z9C,Z22,Z41,Z41,ZC0, ZC0,Z41,Z41,Z22,Z9C,ZC0,
c*                *                        +
c     6Z88,ZAA,Z9C,ZAA,Z88,ZC0, Z88,Z88,ZBE,Z88,Z88,ZC0,
c*                ,                        -
c     7ZC0,ZC0,Z50,Z30,ZC0,ZC0, Z88,Z88,Z88,Z88,Z88,ZC0,
c*                .                        /
c     8ZC0,ZC0,Z60,Z60,ZC0,ZC0, ZA0,Z90,Z88,Z84,Z82,ZC0,
c*                0                        1
c     9ZBE,Z31,Z31,Z31,ZBE,ZC0, ZC0,Z82,ZFF,ZC0,ZC0,ZC0,
c*                2                        3
c     AZ42,ZE1,ZD1,ZC9,ZC6,ZC0, Z21,Z41,ZC9,Z4D,Z33,ZC0,
c*                4                        5
c     6Z18,Z14,Z12,ZFF,Z90,ZC0, Z27,ZCB,ZC5,ZC5,Z39,ZC0,
c*                6                        7
c     CZ3C,Z42,ZC9,ZC9,Z30,ZC0, Z81,Z81,ZF9,Z05,Z03,ZC0,
c*                8                        9
c     DZ36,ZC9,ZC9,ZC9,Z36,ZC0, Z06,ZC9,ZC9,Z21,Z1E,ZC0,
c*                :                        ;
c     EZC0,ZC0,Z1B,Z1B,ZC0,ZC0, ZC0,ZC0,Z2B,Z1B,ZC0,ZC0,
c*                <                        =
c     FZ88,Z14,Z22,Z41,ZC0,ZC0, Z22,Z22,Z22,Z22,Z22,ZC0,
c*                >                        ?
c     GZC0,Z41,Z22,Z14,Z88,ZC0, Z82,Z81,Z59,Z05,Z82,ZC0/
c      DATA TBE2/
c*                @                        A
c     1ZBE,Z41,ZDD,Z55,ZDF,ZC0, Z7E,Z11,Z11,Z11,Z7E,ZC0,
c*                B                        C
c     2ZFF,ZC9,ZC9,ZC9,Z36,ZC0, ZBE,Z41,Z41,Z41,Z22,ZC0,
c*                D                        E
c     3ZFF,Z41,Z41,Z41,ZBE,ZC0, ZFF,ZC9,ZC9,ZC9,Z41,ZC0,
c*                F                        G
c     4ZFF,Z09,Z09,Z09,Z81,ZC0, ZBE,Z41,Z41,ZC9,ZF9,ZC0,
c*                H                        I
c     5ZFF,Z88,Z88,Z88,ZFF,ZC0, ZC0,Z41,ZFF,Z41,ZC0,ZC0,
c*                J                        K
c     6ZA0,ZC0,ZC0,Z3F,ZC0,ZC0, ZFF,Z88,Z14,Z22,Z41,ZC0,
c*                L                        M
c     7ZFF,ZC0,ZC0,ZC0,ZC0,ZC0, ZFF,Z82,Z0C,Z82,ZFF,ZC0,
c*              BLANK                      O
c     8ZFF,Z82,Z84,Z88,ZFF,ZC0, ZBE,ZD1,ZC9,ZC5,ZBE,ZC0,
c*                P                        Q
c     9ZFF,Z09,Z09,Z09,Z06,ZC0, ZBE,Z41,ZD1,Z21,ZDE,ZC0,
c*                R                        S
c     AZFF,Z09,Z99,ZA9,ZC6,ZC0, ZC6,ZC9,ZC9,ZC9,ZB1,ZC0,
c*                T                        U
c     BZ81,Z81,ZFF,Z81,Z81,ZC0, Z3F,ZC0,ZC0,ZC0,Z3F,ZC0,
c*                V                        W
c     CZ0F,Z30,ZC0,Z30,Z0F,ZC0, Z3F,ZC0,Z3C,ZC0,Z3F,ZC0,
c*                X                        Y
c     DZ63,Z14,Z88,Z14,Z63,ZC0, Z87,Z88,ZF0,Z88,Z87,ZC0,
c*                Z                        [
c     EZE1,ZD1,ZC9,ZC5,ZC3,ZC0, ZFF,ZFF,Z41,Z41,Z41,ZC0,
c*                \                        ]
c     FZ82,Z84,Z88,Z90,ZA0,ZC0, Z41,Z41,Z41,ZFF,ZFF,ZC0,
c*                ^                        _
c     GZ84,Z82,Z81,Z82,Z84,ZC0, Z60,Z60,Z60,Z60,Z60,ZC0/
c******   TABLE FOR 5X6 MATRIX OUTPUT , NO PARITY , COLUMN BINARY
c*
c      DATA TB561/
c*                N                        !
c     1Z00,Z00,Z00,Z00,Z00,Z00, Z00,Z00,Z5E,Z00,Z00,Z00,
c*                "                        #
c     2Z00,Z0E,Z00,Z0E,Z00,Z00, Z14,Z3E,Z14,Z3E,Z14,Z00,
c*                $                        %
c     3Z2E,Z2A,Z7E,Z2A,Z3A,Z00, Z26,Z16,Z08,Z64,Z62,Z00,
c*                &                        `
c     4Z76,Z4A,Z56,Z20,Z50,Z00, Z00,Z00,Z0E,Z00,Z00,Z00,
c*                (                        )
c     5Z00,Z00,Z00,Z3C,Z42,Z00, Z00,Z42,Z3C,Z00,Z00,Z00,
c*                *                        +
c     6Z10,Z54,Z38,Z54,Z10,Z00, Z10,Z10,Z7C,Z10,Z10,Z00,
c*                ,                        -
c     7Z00,Z00,Z50,Z30,Z00,Z00, Z10,Z10,Z10,Z10,Z10,Z00,
c*                .                        /
c     8Z00,Z60,Z60,Z00,Z00,Z00, Z40,Z20,Z10,Z08,Z04,Z00,
c*                0                        1
c     9Z3C,Z42,Z42,Z42,Z3C,Z00, Z00,Z44,Z7E,Z40,Z00,Z00,
c*                2                        3
c     AZ64,Z52,Z4A,Z4A,Z44,Z00, Z22,Z4A,Z4A,Z4E,Z32,Z00,
c*                4                        5
c     BZ0E,Z08,Z08,Z7E,Z08,Z00, Z2E,Z4A,Z4A,Z4A,Z32,Z00,
c*                6                        7
c     CZ3C,Z4A,Z4A,Z4A,Z30,Z00, Z02,Z02,Z72,Z0A,Z06,Z00,
c*                8                        9
c     DZ34,Z4A,Z4A,Z4A,Z34,Z00, Z04,Z4A,Z4A,Z4A,Z3C,Z00,
c*                :                        ;
c     EZ00,Z00,Z36,Z36,Z00,Z00, Z00,Z00,Z56,Z36,Z00,Z00,
c*                <                        =
c     FZ10,Z28,Z44,Z00,Z00,Z00, Z28,Z28,Z28,Z28,Z28,Z00,
c*                >                        ?
c     GZ00,Z00,Z44,Z28,Z10,Z00, Z04,Z02,Z52,Z0A,Z04,Z00/
c      DATA TB562/
c*                @                        A
c     1Z3C,Z42,Z5A,Z5A,Z4C,Z00, Z78,Z14,Z12,Z14,Z78,Z00,
c*                B                        C
c     2Z7E,Z4A,Z4A,Z4A,Z34,Z00, Z3C,Z42,Z42,Z42,Z24,Z00,
c*                D                        E
c     3Z7E,Z42,Z42,Z42,Z3C,Z00, Z7E,Z4A,Z4A,Z42,Z42,Z00,
c*                F                        G
c     4Z7E,Z0A,Z0A,Z02,Z02,Z00, Z3C,Z42,Z42,Z52,Z72,Z00,
c*                H                        I
c     5Z7E,Z08,Z08,Z08,Z7E,Z00, Z00,Z42,Z74,Z42,Z00,Z00,
c*                J                        K
c     6Z20,Z40,Z40,Z40,Z3E,Z00, Z7E,Z08,Z10,Z24,Z42,Z00,
c*                L                        M
c     7Z7E,Z40,Z40,Z40,Z40,Z00, Z7E,Z04,Z08,Z04,Z7E,Z00,
c*                N                        O
c     8Z7E,Z04,Z08,Z30,Z7E,Z00, Z3C,Z42,Z42,Z42,Z3C,Z00,
c*                P                        Q
c     9Z7E,Z0A,Z0A,Z0A,Z04,Z00, Z3C,Z42,Z52,Z22,Z5C,Z00,
c*                R                        S
c     AZ7E,Z0A,Z1A,Z2A,Z44,Z00, Z44,Z4A,Z4A,Z4A,Z32,Z00,
c*                T                        U
c     BZ02,Z02,Z7E,Z02,Z02,Z00, Z3E,Z40,Z40,Z40,Z3E,Z00,
c*                V                        W
c     CZ1E,Z20,Z40,Z20,Z1E,Z00, Z7E,Z20,Z18,Z20,Z7E,Z00,
c*                X                        Y
c     DZ66,Z10,Z08,Z10,Z66,Z00, Z06,Z08,Z70,Z08,Z06,Z00,
c*                Z                        [
c     EZ62,Z52,Z4A,Z42,Z46,Z00, Z7E,Z42,Z42,Z00,Z00,Z00,
c*                \                        ]
c     FZ02,Z04,Z08,Z10,Z20,Z00, Z00,Z00,Z42,Z42,Z7E,Z00,
c*                ^                        _
c     GZ08,Z04,Z02,Z04,Z08,Z00, Z40,Z40,Z40,Z40,Z40,Z00/
C
c*******************************************************      
      data tbo1/
     1z'80',z'80',z'80',z'80',z'80',z'80', z'80',z'80',z'5e',z'80',z'80'
     1,z'80',
     2z'80',z'07',z'80',z'07',z'80',z'80', z'94',z'3e',z'94',z'3e',z'94'
     2,z'80',
     3z'ae',z'2a',z'7f',z'2a',z'ae',z'80', z'e3',z'13',z'08',z'34',z'e3'
     3,z'80',
     4z'fb',z'45',z'6b',z'10',z'68',z'80', z'80',z'80',z'07',z'80',z'80'
     4,z'80',
     5z'80',z'1c',z'a2',z'c1',z'c1',z'80', z'80',z'c1',z'c1',z'a2',z'1c'
     5,z'80',
     6z'08',z'2a',z'1c',z'2a',z'08',z'80', z'08',z'08',z'3e',z'08',z'08'
     6,z'80',
     7z'80',z'80',z'd0',z'b0',z'80',z'80', z'08',z'08',z'08',z'08',z'08'
     7,z'80',
     8z'80',z'80',z'e0',z'e0',z'80',z'80', z'20',z'10',z'08',z'04',z'02'
     8,z'80',
     9z'3e',z'c1',z'c1',z'c1',z'3e',z'80', z'80',z'02',z'7f',z'80',z'80'
     9,z'80',
     az'c2',z'61',z'51',z'49',z'46',z'80', z'a1',z'c1',z'49',z'cd',z'b3'
     a,z'80',
     bz'98',z'94',z'92',z'7f',z'10',z'80', z'a7',z'45',z'45',z'45',z'b9'
     b,z'80',
     cz'bc',z'c2',z'49',z'49',z'b0',z'80', z'01',z'01',z'79',z'85',z'83'
     c,z'80',
     dz'b6',z'49',z'49',z'49',z'b6',z'80', z'86',z'49',z'49',z'a1',z'9e'
     d,z'80',
     ez'80',z'80',z'b6',z'b6',z'80',z'80', z'80',z'80',z'd6',z'b6',z'80'
     e,z'80',
     fz'08',z'94',z'a2',z'c1',z'80',z'80', z'a2',z'a2',z'a2',z'a2',z'a2'
     f,z'80',
     gz'80',z'c1',z'a2',z'94',z'08',z'80', z'02',z'01',z'd9',z'85',z'02'
     g,z'80'/
      data tbo2/
     1z'3e',z'c1',z'5d',z'd5',z'5e',z'80', z'fe',z'91',z'91',z'91',z'fe'
     1,z'80',
     2z'7f',z'49',z'49',z'49',z'b6',z'80', z'3e',z'c1',z'c1',z'c1',z'a2'
     2,z'80',
     3z'7f',z'c1',z'c1',z'c1',z'e3',z'80', z'7f',z'49',z'49',z'49',z'c1'
     3,z'80',
     4z'7f',z'89',z'89',z'89',z'01',z'80', z'e3',z'c1',z'c1',z'49',z'79'
     4,z'80',
     5z'7f',z'08',z'08',z'08',z'7f',z'80', z'80',z'c1',z'7f',z'c1',z'80'
     5,z'80',
     6z'20',z'40',z'40',z'bf',z'80',z'80', z'7f',z'08',z'94',z'a2',z'c1'
     6,z'80',
     7z'7f',z'40',z'40',z'40',z'40',z'80', z'7f',z'02',z'8c',z'02',z'7f'
     7,z'80',
     8z'7f',z'02',z'04',z'08',z'7f',z'80', z'3e',z'51',z'49',z'45',z'3e'
     8,z'80',
     9z'7f',z'89',z'89',z'89',z'86',z'80', z'3e',z'c1',z'51',z'a1',z'5e'
     9,z'80',
     az'7f',z'89',z'19',z'29',z'46',z'80', z'46',z'49',z'49',z'49',z'31'
     a,z'80',
     bz'01',z'01',z'7f',z'01',z'01',z'80', z'bf',z'40',z'40',z'40',z'bf'
     b,z'80',
     cz'8f',z'b0',z'40',z'b0',z'8f',z'80', z'bf',z'40',z'bc',z'40',z'bf'
     c,z'80',
     dz'e3',z'94',z'08',z'94',z'e3',z'80', z'07',z'08',z'70',z'08',z'07'
     d,z'80',
     ez'61',z'51',z'49',z'45',z'43',z'80', z'7f',z'7f',z'c1',z'c1',z'c1'
     e,z'80',
     fz'02',z'04',z'08',z'20',z'40',z'80', z'c1',z'c1',z'c1',z'7f',z'7f'
     f,z'80',
     gz'04',z'02',z'01',z'02',z'04',z'80', z'40',z'40',z'40',z'40',z'40'
     g,z'80'/
******   table for 5x7 matrix output ,even parity , column binary
      data tbe1/
     1z'c0',z'c0',z'c0',z'c0',z'c0',z'c0', z'c0',z'c0',z'2f',z'c0',z'c0'
     1,z'c0',
     2z'c0',z'87',z'c0',z'87',z'c0',z'c0', z'14',z'be',z'14',z'be',z'14'
     2,z'c0',
     3z'2e',z'aa',z'ff',z'aa',z'3a',z'c0', z'63',z'93',z'88',z'e4',z'63'
     3,z'c0',
     4z'7b',z'c5',z'eb',z'90',z'e9',z'c0', z'c0',z'c0',z'87',z'c0',z'c0'
     4,z'c0',
     5z'c0',z'9c',z'22',z'41',z'41',z'c0', z'c0',z'41',z'41',z'22',z'9c'
     5,z'c0',
     6z'88',z'aa',z'9c',z'aa',z'88',z'c0', z'88',z'88',z'be',z'88',z'88'
     6,z'c0',
     7z'c0',z'c0',z'50',z'30',z'c0',z'c0', z'88',z'88',z'88',z'88',z'88'
     7,z'c0',
     8z'c0',z'c0',z'60',z'60',z'c0',z'c0', z'a0',z'90',z'88',z'84',z'82'
     8,z'c0',
     9z'be',z'31',z'31',z'31',z'be',z'c0', z'c0',z'82',z'ff',z'c0',z'c0'
     9,z'c0',
     az'42',z'e1',z'd1',z'c9',z'c6',z'c0', z'21',z'41',z'c9',z'4d',z'33'
     a,z'c0',
     6z'18',z'14',z'12',z'ff',z'90',z'c0', z'27',z'cb',z'c5',z'c5',z'39'
     6,z'c0',
     cz'3c',z'42',z'c9',z'c9',z'30',z'c0', z'81',z'81',z'f9',z'05',z'03'
     c,z'c0',
     dz'36',z'c9',z'c9',z'c9',z'36',z'c0', z'06',z'c9',z'c9',z'21',z'1e'
     d,z'c0',
     ez'c0',z'c0',z'1b',z'1b',z'c0',z'c0', z'c0',z'c0',z'2b',z'1b',z'c0'
     e,z'c0',
     fz'88',z'14',z'22',z'41',z'c0',z'c0', z'22',z'22',z'22',z'22',z'22'
     f,z'c0',
     gz'c0',z'41',z'22',z'14',z'88',z'c0', z'82',z'81',z'59',z'05',z'82'
     g,z'c0'/
      data tbe2/
     1z'be',z'41',z'dd',z'55',z'df',z'c0', z'7e',z'11',z'11',z'11',z'7e'
     1,z'c0',
     2z'ff',z'c9',z'c9',z'c9',z'36',z'c0', z'be',z'41',z'41',z'41',z'22'
     2,z'c0',
     3z'ff',z'41',z'41',z'41',z'be',z'c0', z'ff',z'c9',z'c9',z'c9',z'41'
     3,z'c0',
     4z'ff',z'09',z'09',z'09',z'81',z'c0', z'be',z'41',z'41',z'c9',z'f9'
     4,z'c0',
     5z'ff',z'88',z'88',z'88',z'ff',z'c0', z'c0',z'41',z'ff',z'41',z'c0'
     5,z'c0',
     6z'a0',z'c0',z'c0',z'3f',z'c0',z'c0', z'ff',z'88',z'14',z'22',z'41'
     6,z'c0',
     7z'ff',z'c0',z'c0',z'c0',z'c0',z'c0', z'ff',z'82',z'0c',z'82',z'ff'
     7,z'c0',
     8z'ff',z'82',z'84',z'88',z'ff',z'c0', z'be',z'd1',z'c9',z'c5',z'be'
     8,z'c0',
     9z'ff',z'09',z'09',z'09',z'06',z'c0', z'be',z'41',z'd1',z'21',z'de'
     9,z'c0',
     az'ff',z'09',z'99',z'a9',z'c6',z'c0', z'c6',z'c9',z'c9',z'c9',z'b1'
     a,z'c0',
     bz'81',z'81',z'ff',z'81',z'81',z'c0', z'3f',z'c0',z'c0',z'c0',z'3f'
     b,z'c0',
     cz'0f',z'30',z'c0',z'30',z'0f',z'c0', z'3f',z'c0',z'3c',z'c0',z'3f'
     c,z'c0',
     dz'63',z'14',z'88',z'14',z'63',z'c0', z'87',z'88',z'f0',z'88',z'87'
     d,z'c0',
     ez'e1',z'd1',z'c9',z'c5',z'c3',z'c0', z'ff',z'ff',z'41',z'41',z'41'
     e,z'c0',
     fz'82',z'84',z'88',z'90',z'a0',z'c0', z'41',z'41',z'41',z'ff',z'ff'
     f,z'c0',
     gz'84',z'82',z'81',z'82',z'84',z'c0', z'60',z'60',z'60',z'60',z'60'
     g,z'c0'/
******   table for 5x6 matrix output , no parity , column binary
*
      data tb561/
     1z'00',z'00',z'00',z'00',z'00',z'00', z'00',z'00',z'5e',z'00',z'00'
     1,z'00',
     2z'00',z'0e',z'00',z'0e',z'00',z'00', z'14',z'3e',z'14',z'3e',z'14'
     2,z'00',
     3z'2e',z'2a',z'7e',z'2a',z'3a',z'00', z'26',z'16',z'08',z'64',z'62'
     3,z'00',
     4z'76',z'4a',z'56',z'20',z'50',z'00', z'00',z'00',z'0e',z'00',z'00'
     4,z'00',
     5z'00',z'00',z'00',z'3c',z'42',z'00', z'00',z'42',z'3c',z'00',z'00'
     5,z'00',
     6z'10',z'54',z'38',z'54',z'10',z'00', z'10',z'10',z'7c',z'10',z'10'
     6,z'00',
     7z'00',z'00',z'50',z'30',z'00',z'00', z'10',z'10',z'10',z'10',z'10'
     7,z'00',
     8z'00',z'60',z'60',z'00',z'00',z'00', z'40',z'20',z'10',z'08',z'04'
     8,z'00',
     9z'3c',z'42',z'42',z'42',z'3c',z'00', z'00',z'44',z'7e',z'40',z'00'
     9,z'00',
     az'64',z'52',z'4a',z'4a',z'44',z'00', z'22',z'4a',z'4a',z'4e',z'32'
     a,z'00',
     bz'0e',z'08',z'08',z'7e',z'08',z'00', z'2e',z'4a',z'4a',z'4a',z'32'
     b,z'00',
     cz'3c',z'4a',z'4a',z'4a',z'30',z'00', z'02',z'02',z'72',z'0a',z'06'
     c,z'00',
     dz'34',z'4a',z'4a',z'4a',z'34',z'00', z'04',z'4a',z'4a',z'4a',z'3c'
     d,z'00',
     ez'00',z'00',z'36',z'36',z'00',z'00', z'00',z'00',z'56',z'36',z'00'
     e,z'00',
     fz'10',z'28',z'44',z'00',z'00',z'00', z'28',z'28',z'28',z'28',z'28'
     f,z'00',
     gz'00',z'00',z'44',z'28',z'10',z'00', z'04',z'02',z'52',z'0a',z'04'
     g,z'00'/
      data tb562/
     1z'3c',z'42',z'5a',z'5a',z'4c',z'00', z'78',z'14',z'12',z'14',z'78'
     1,z'00',
     2z'7e',z'4a',z'4a',z'4a',z'34',z'00', z'3c',z'42',z'42',z'42',z'24'
     2,z'00',
     3z'7e',z'42',z'42',z'42',z'3c',z'00', z'7e',z'4a',z'4a',z'42',z'42'
     3,z'00',
     4z'7e',z'0a',z'0a',z'02',z'02',z'00', z'3c',z'42',z'42',z'52',z'72'
     4,z'00',
     5z'7e',z'08',z'08',z'08',z'7e',z'00', z'00',z'42',z'74',z'42',z'00'
     5,z'00',
     6z'20',z'40',z'40',z'40',z'3e',z'00', z'7e',z'08',z'10',z'24',z'42'
     6,z'00',
     7z'7e',z'40',z'40',z'40',z'40',z'00', z'7e',z'04',z'08',z'04',z'7e'
     7,z'00',
     8z'7e',z'04',z'08',z'30',z'7e',z'00', z'3c',z'42',z'42',z'42',z'3c'
     8,z'00',
     9z'7e',z'0a',z'0a',z'0a',z'04',z'00', z'3c',z'42',z'52',z'22',z'5c'
     9,z'00',
     az'7e',z'0a',z'1a',z'2a',z'44',z'00', z'44',z'4a',z'4a',z'4a',z'32'
     a,z'00',
     bz'02',z'02',z'7e',z'02',z'02',z'00', z'3e',z'40',z'40',z'40',z'3e'
     b,z'00',
     cz'1e',z'20',z'40',z'20',z'1e',z'00', z'7e',z'20',z'18',z'20',z'7e'
     c,z'00',
     dz'66',z'10',z'08',z'10',z'66',z'00', z'06',z'08',z'70',z'08',z'06'
     d,z'00',
     ez'62',z'52',z'4a',z'42',z'46',z'00', z'7e',z'42',z'42',z'00',z'00'
     e,z'00',
     fz'02',z'04',z'08',z'10',z'20',z'00', z'00',z'00',z'42',z'42',z'7e'
     f,z'00',
     gz'08',z'04',z'02',z'04',z'08',z'00', z'40',z'40',z'40',z'40',z'40'
     g,z'00'/

      IF (J.EQ.0) THEN
C
C.....5*7 MATRIX, ODD PARITY, COLUMN BINARY
C
      DO 10 I=1,6
      DO 10 K=1,64
   10 CODE(I,K)=TABO(I,K)
C
      ELSE IF (J.EQ.2) THEN
C
C.....5*6 MATRIX, NO PARITY, COLUMN BINARY
C
      DO 20 I=1,6
      DO 20 K=1,64
   20 CODE(I,K)=TAB56(I,K)
C
      ELSE
         CALL CFORM('**** INVALID CALL TO PARNOM ****',DARRAY,2,32)
         CALL CPRINT(DARRAY)
         RETURN
      END IF
      GO TO 100
C
C.....ENTRY PARNEM
C
      ENTRY PARNEM(N,A)
C
C.....5*7 MATRIX, EVEN PARITY, COLUMN BINARY
C
      DO 30 I=1,6
      DO 30 K=1,64
   30 CODE(I,K)=TABE(I,K)
C
C.....CHECK N.LE.504
C
  100 N=ABS(N)
      IF (N.GT.504) THEN
         CALL CFORM('**** MORE THAN 504 CHARACTERS',DARRAY,2,29)
         CALL CFORM('REQUESTED IN CALL TO PARNOM OR PARNEM ****',DARRAY,
     1                32,42)
         CALL CPRINT(DARRAY)
         N=504
      END IF
C
C.....CALCULATE NUMBER OF WORDS CONTAINING CHARACTERS (6 PER WORD)
C
      NUM=N/6
      IF (NUM*6.LT.N) NUM=NUM+1
C
C.....WRITE CHARCTERS FOR CONVERSION TO INTERNAL FILE
C
      WRITE (INFIL,'(84A6)') (A(I),I=1,NUM)
C
C.....FOR EACH CHARACTER INPUT, IDENTIFY POSITION IN ASCII CHAR SET
C
      JC=0
      DO 200 I=1,N
      IC=ICHAR(INFIL(I:I))-31
C
C.....STORE APPROP MATRIX IN OUTPUT ARRAY
C
      DO 200 K=1,6
      JC=JC+1
      OUT(JC)=CODE(K,IC)
  200 CONTINUE
C
C.....OUTPUT TO PUNCH FILE, JC IS NO OF BYTES
C
      CALL TAPEPN(OUT,JC)
      RETURN
      END
**** SOURCE FILE : PUNCHA00.ORG   ***
*
      SUBROUTINE PUNCHA(N,A,J,K)
*
*  * PUNCHA *   VAX-11 FORTRAN 77 VERSION 29.11.82 E.MCLELLAN
*
*  PURPOSE     TO GENERATE REQUIRED PAPER TAPE CODES FOR BCD CHARACTERS
*
*  CALLING SEQUENCE
*              CALL PUNCHA(N,A,J,K)
*  ARGUMENTS
*              N NUMBER OF BCD CHARACTERS IN ARRAY A
*              A ARRAY CONTAINING BCD CHARACTERS
*              J IGNORED
*              K -2  BLANKS AND PERIODS IGNORED
*                -1  PERIODS IGNORED
*                 0  BLANKS IGNORED
*                >0  BLANKS ARE PROCESSED
*
*  ALTERNATE ENTRY
*              CALL PUNCHB(N,A,J,K)
*
C
C...BYTE VARIABLES IN THIS VAX IMPLEMENTATION MIGHT BE ABLE TO BE LOGICA
C...ON OTHER SYSTEMS
C
      COMMON/PUNTAB/PUNCOD
      BYTE PUNCOD(128),ILEGAL
*
      DOUBLE PRECISION A(64)
      CHARACTER*512 INFIL,OUTFIL
      BYTE PUNOUT(512)
      LOGICAL OD
C
      INCLUDE 'DARRAY.INC'
C
c      DATA ILEGAL/ZEE/
      data ilegal/z'ee'/
C
C
      ENTRY PUNCHB(N,A,J,K)
C
      WRITE (INFIL,'(64A8)') (A(I),I=1,64)
C
      M=N
C
      IF (K.LE.0) THEN
         L=1
         DO 10 I=1,N
           IF ((INFIL(I:I).EQ.' ').AND.((K.EQ.0).OR.(K.EQ.-2))) THEN
              GO TO 10
           ELSE IF ((INFIL(I:I).EQ.'.').AND.(K.LT.0)) THEN
              GO TO 10
           ELSE
              OUTFIL(L:L)=INFIL(I:I)
              L=L+1
           END IF
   10    CONTINUE
         M=L-1
      ELSE
C
      OUTFIL=INFIL
C
      END IF
C
C.....CONVERT TO REQUIRED TAPE CODE
C
      JC=0
      DO 100 I=1,M
      IC=ICHAR(OUTFIL(I:I))+1
      IF (PUNCOD(IC).EQ.ILEGAL) THEN
         CALL CFORM('**** ILLEGAL CHARACTER CONVERSION IN PUNCHA ****',
     1              DARRAY,2,48)
         CALL CPRINT(DARRAY)
         GO TO 100
      END IF
C
      JC=JC+1
      PUNOUT(JC)=PUNCOD(IC)
  100 CONTINUE
C
C.....OUTPUT TO PUNCH FILE, JC IS NO OF BYTES
C
      CALL TAPEPN(PUNOUT,JC)
      RETURN
      END
**** SOURCE FILE : PUNCHC00.ORG   ***
*
      SUBROUTINE PUNCHC(N,A,J,K)
*
*  * PUNCHC *   VAX-11 FORTRAN 77 VERSION 29.11.82 E.MCLELLAN
*               REVISED FOR CHARACTER HANDLING 5.9.85 E.MCL.
*
*  PURPOSE     TO GENERATE REQUIRED PAPER TAPE CODES FOR CHARACTERS
*
*  CALLING SEQUENCE
*              CALL PUNCHC(N,A,J,K)
*  ARGUMENTS
*              N NUMBER OF CHARACTERS IN A
*              A CHARACTER STRING TO BE PUNCHED
*              J NUMBER OF CHARACTERS PUNCHED
*              K -2  BLANKS AND PERIODS IGNORED
*                -1  PERIODS IGNORED
*                 0  BLANKS IGNORED
*                >0  BLANKS ARE PROCESSED
*
*  ALTERNATE ENTRY
*              CALL PUNCHD(N,A,J,K)
*
C
C...BYTE VARIABLES IN THIS VAX IMPLEMENTATION MIGHT BE ABLE TO BE LOGICA
C...ON OTHER SYSTEMS
C
      COMMON/PUNTAB/PUNCOD
      BYTE PUNCOD(128),ILEGAL
*
      CHARACTER*512 A
      CHARACTER*512 INFIL,OUTFIL
      BYTE PUNOUT(512)
      LOGICAL OD
C
      INCLUDE 'DARRAY.INC'
C
c      DATA ILEGAL/ZEE/
      data ilegal/z'ee'/
C
C
      ENTRY PUNCHD(N,A,J,K)
C
      INFIL=A
C
      M=N
C
      IF (K.LE.0) THEN
         L=1
         DO 10 I=1,N
           IF ((INFIL(I:I).EQ.' ').AND.((K.EQ.0).OR.(K.EQ.-2))) THEN
              GO TO 10
           ELSE IF ((INFIL(I:I).EQ.'.').AND.(K.LT.0)) THEN
              GO TO 10
           ELSE
              OUTFIL(L:L)=INFIL(I:I)
              L=L+1
           END IF
   10    CONTINUE
         M=L-1
      ELSE
C
      OUTFIL=INFIL
C
      END IF
C
C.....CONVERT TO REQUIRED TAPE CODE
C
      JC=0
      DO 100 I=1,M
      IC=ICHAR(OUTFIL(I:I))+1
      IF (PUNCOD(IC).EQ.ILEGAL) THEN
         CALL CFORM('**** ILLEGAL CHARACTER CONVERSION IN PUNCHC ****',
     1              DARRAY,2,48)
         CALL CPRINT(DARRAY)
         GO TO 100
      END IF
C
      JC=JC+1
      PUNOUT(JC)=PUNCOD(IC)
  100 CONTINUE
C
C.....OUTPUT TO PUNCH FILE, JC IS NO OF BYTES
C
      CALL TAPEPN(PUNOUT,JC)
      J=JC
      RETURN
      END
**** SOURCE FILE : TAPEPN00.ORG   ***
*
      SUBROUTINE TAPEPN(CHAR,N)
*
*  * TAPEPN *  VAX-11 FORTRAN 77 VERSION  26.10.82  E.MCLELLAN
*
*  PURPOSE     TO WRITE COLUMN BINARY DATA TO PAPER TAPE PUNCH FILE
*
*  CALLING SEQUENCE
*              CALL TAPEPN(CHAR,N)
*  ARGUMENTS
*              CHAR  BYTE ARRAY CONTAINING COLUMN BINARY CODES
*              N     NO OF COLUMNS (CHARACTERS) TO BE PUNCHED
*
C
C...BYTE VARIABLES IN THIS VAX IMPLEMENTATION MIGHT BE ABLE TO BE LOGICA
C...ON OTHER SYSTEMS
      BYTE CHAR(3024)
*
      LOGICAL OD
C
      INCLUDE 'DARRAY.INC'
C
C
C.....WRITE IN A FORMAT TO FILE PUNTAP.DAT
C
C.....IS PUNTAP.DAT OPEN
C
      INQUIRE(FILE='PUNTAP.DAT',OPENED=OD)
         IF (.NOT.OD) THEN
            OPEN(UNIT=7,FILE='PUNTAP.DAT',ERR=90,STATUS='NEW',
     1           ACCESS='SEQUENTIAL',FORM='FORMATTED')
         END IF
C
C.....WRITE TO PUNTAP.DAT
C
      WRITE(7,'(80A1)') (CHAR(I),I=1,N)
      RETURN
C
   90 CALL CFORM('**** ERROR OPENING PUNTAP.DAT ****',DARRAY,2,34)
      CALL CPRINT(DARRAY)
      CALL ABNEND
      RETURN
      END
**** SOURCE FILE : WTDIRE00.V01   ***
*
      SUBROUTINE WTDIRE(IU,MEMBER,USERD,NCH,IRET)
C
      INTEGER IU,ID,NCH,IRET
      DOUBLE PRECISION MEMBER,USERD
C
      LOGICAL EX
C
      INCLUDE 'LIBCOM.INC'
      CHARACTER*8 CMEM
      INTEGER NWD
C
      ID=IU
C
C.... SET UP FILENAME
C
      CALL HOLFRM(MEMBER,CMEM,1,8,NWD)
      J=INDEX(CMEM(1:),' ')
C
      IF (J.EQ.0) THEN
         FILENM=APTLIB//CMEM//'.LDA'
      ELSE
         FILENM=APTLIB//CMEM(1:J-1)//'.LDA'
      ENDIF
C
C.... INQUIRE IF FILE EXISTS
C
      INQUIRE(FILE=FILENM,EXIST=EX)
      IF (EX) THEN
C.... FILE ALREADY EXISTS - SHOULD A NEW VERSION BE WRITTEN
        IF (ID.LT.0) THEN
C.... YES - OPEN ATTACHED TO UNIT ID
          ID=IABS(ID)
          OPEN(UNIT=ID,FILE=FILENM,ERR=20,STATUS='NEW',
     +         ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
          IRET=0
        ELSE
          IRET=9
        ENDIF
      ELSE
C.... FILE DOES NOT EXIST - OPEN ATTACHED TO UNIT ID
        OPEN(UNIT=ID,FILE=FILENM,ERR=20,STATUS='NEW',
     +       ACCESS='SEQUENTIAL',FORM='UNFORMATTED')
        IRET=0
      ENDIF
      RETURN
C.... ERROR OPENING FILE
  20  IRET=5
      RETURN
      END
**** SOURCE FILE : M0006620.W02   ***
*
C                                                 8/81     MBB
C...  FORTRAN BLOCK DATA               BD2ITL
C                                                 8/81     MBB
      BLOCK DATA BD2ITL
C
      IMPLICIT INTEGER (A-Z)
C
C...         2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST,STACK,ARGSTK
      DIMENSION STKLST(3),STACK(2,99),ARGSTK(99)
C
      EQUIVALENCE(STKLST(1),TOP),(STKLST(2),ARGTOP),(STKLST(3),IARGDM)
C
C
C...         5.    PROGRAM CONTROL FLAGS
C
      COMMON/FLAGS/FLAGS
      DIMENSION FLAGS(4)
      LOGICAL ENDFLG,NEWSTM,APTRAN,REFFLG
C
      EQUIVALENCE(FLAGS(1),ENDFLG),(FLAGS(2),NEWSTM),(FLAGS(3),APTRAN),
     1           (FLAGS(4),REFFLG)
C
C
C...         6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C
C...      13.      NAMTBL POINTERS TO NEGATIVE NUMBERS
C
      COMMON/NEGPTR/NONEPT
C
C...        11.    SEQUENCE NUMBER STORAGE
C
C                  COMMENT OF  SEQNO AND SEQNUM
C
      INCLUDE 'SEQCOM.INC'
C
C...        12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE,MAXSIZ,CANSIZ,ISC,KSC
      DIMENSION  CFSIZE(3),MAXSIZ(2),CANSIZ(2,100),KSC(3,300)
      LOGICAL PARDEF,TABCYS
C
      EQUIVALENCE(CFSIZE(1),CANTOP),(CFSIZE(2),PARDEF),
     1           (CFSIZE(3),TABCYS)
C
C
C...      14.      I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      DIMENSION PRT(7)
      LOGICAL    CILPRT,  ILPRT, INTERP, ASSEMB, TRACFL
     /          ,PRTERR,  MCHDNG
C
      EQUIVALENCE(PRT(1),CILPRT),(PRT(2),ILPRT ),(PRT(3),INTERP),
     1           (PRT(4),ASSEMB),(PRT(5),TRACFL),(PRT(6),PRTERR),
     2           (PRT(7),MCHDNG)
C
C
C...        15.    ARRAY LIMIT STORAGE
C
      COMMON/SBSCPT/RNGPT,RANGE
      DIMENSION RANGE(400)
C
C...        16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C
      EQUIVALENCE(IL( 1),FADD  ),(IL( 2),FSUB  ),(IL( 3),FMPY  ),
     1           (IL( 4),FDIV  ),(IL( 5),FEXP  ),(IL( 6),LABELX),
     2           (IL( 7),ENTRYX),(IL( 8),JUMP  ),(IL( 9),SEQNCE),
     3           (IL(10),RETMC ),(IL(11),CONJMP),(IL(12),RESRV ),
     4           (IL(13),CVTSUB),(IL(14),CALMC ),(IL(15),ASNADD),
     5           (IL(16),ASNJMP),(IL(17),REPL  ),(IL(18),CALL  ),
     7           (IL(19),MOVE  ),(IL(20),VBLJMP),(IL(21),HOLDAT)
C
C
C...        17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C
      EQUIVALENCE(MODX( 1),LINE  ),(MODX( 2),PLANE ),(MODX( 3),CYLNDR),
     1           (MODX( 4),CIRCLE),(MODX( 5),SPHERE),(MODX( 6),HYPERB),
     2           (MODX( 7),CONIC ),(MODX( 8),ELLIPS),(MODX( 9),CONE  ),
     3           (MODX(10),GCONIC),(MODX(11),TABCYL),(MODX(12),RLDSRF),
     4           (MODX(13),POLCON),(MODX(14),QADRIC),(MODX(15),PARSRF),
     5           (MODX(16),UNUS1 ),(MODX(17),UNUS2 ),(MODX(18),MATRIX),
     6           (MODX(19),POINT ),(MODX(20),VECTOR),(MODX(21),REAL  ),
     7           (MODX(22),INTGER),(MODX(23),BOOL  ),(MODX(24),SUBSCR),
     8           (MODX(25),STRING),(MODX(26),PATERN),(MODX(27),BOUNDS),
     9           (MODX(28),OBJECT),(MODX(29),SSURF ),(MODX(30),SCURV ),
     A           (MODX(31),UNUS3 ),(MODX(32),UNUS4 )
C
C
C...        18.    STRING STORAGE AREA
C
      COMMON/CHRX/CHR
      CHARACTER CHR*400
C
C...      19.      INTERMEDIATE LANGUAGE TEXT
C
      COMMON/ILTEXT/ILTEXT,TEXTIN
      DIMENSION TEXTIN(90),ILTEXT(4)
      LOGICAL COMFIN
      EQUIVALENCE(ILTEXT(1),COMFIN),(ILTEXT(2),LENGTH),
     1           (ILTEXT(3),TPNTRX),(ILTEXT(4),OPTEXT)
C
C
C         22.      MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      DIMENSION MACXX1(71)
      LOGICAL MACLDD ,CALLON ,CALLMV ,ILHLT  ,MVMAC  ,MACRED ,MVTRUE ,
     1        FINMAC ,ENTRY  ,NESTG  ,ENDMCH ,MACLK  ,MACEND ,SHOULD
C
      EQUIVALENCE(MACXX1( 1),MACDFP),(MACXX1( 2),MCNMB ),
     1           (MACXX1( 3),MCHSTP),(MACXX1( 4),MCTXTP),
     2           (MACXX1( 5),MCSAVP),(MACXX1( 6),MNMVBP),
     3           (MACXX1( 7),MACLDD),(MACXX1( 8),TEMP1 ),
     4           (MACXX1( 9),TEMP2 ),(MACXX1(10),CALLON),
     5           (MACXX1(11),CALLMV),(MACXX1(12),MVSEG ),
     6           (MACXX1(13),CALLPT),(MACXX1(14),ILHLT ),
     7           (MACXX1(15),TEXTST),(MACXX1(16),MVPNT ),
     8           (MACXX1(17),MVMAC ),(MACXX1(18),MACRED),
     9           (MACXX1(19),MVTRUE),(MACXX1(20),BRANCH),
     A           (MACXX1(21),MAXSPS),(MACXX1(22),INTMED)
      EQUIVALENCE(MACXX1(23),MAJWRD),(MACXX1(24),FINMAC),
     1           (MACXX1(25),NMLINE),(MACXX1(26),WAY   ),
     2           (MACXX1(27),NUMVAR),(MACXX1(28),NUMCAL),
     3           (MACXX1(29),BITWDS),(MACXX1(30),MBPTR ),
     4           (MACXX1(31),LSTWRT),(MACXX1(32),MCDFDM),
     5           (MACXX1(33),MHSTDM),(MACXX1(34),MCSVDM),
     6           (MACXX1(35),MNMVDM),(MACXX1(36),MSEQDM),
     7           (MACXX1(37),MACLNT),(MACXX1(38),MCSLNT),
     8           (MACXX1(39),MSP   ),(MACXX1(40),ENTRY ),
     9           (MACXX1(41),MVEXST),(MACXX1(42),MACTOP),
     A           (MACXX1(43),MCSTRT),(MACXX1(44),MAJOR )
      EQUIVALENCE(MACXX1(45),NESTG ),(MACXX1(46),ROUTE ),
     1           (MACXX1(47),ROAD  ),(MACXX1(48),SAVMSP),
     2           (MACXX1(49),TYP   ),(MACXX1(50),ENDMCH),
     3           (MACXX1(51),LNUSDP),(MACXX1(52),MCTOPP),
     4           (MACXX1(53),LNSDDM),(MACXX1(54),MVARDM),
     5           (MACXX1(55),MASDM ),(MACXX1(56),NUMBIT),
     6           (MACXX1(57),MCSPDP),(MACXX1(58),MACLK ),
     7           (MACXX1(59),MCSRCH),(MACXX1(60),MACFND),
     8           (MACXX1(61),NUMARG),(MACXX1(62),MACEND),
     9           (MACXX1(63),WHCHMN),(MACXX1(64),LARGMV),
     A           (MACXX1(65),MSPDDM),(MACXX1(66),VBLSVP)
      EQUIVALENCE(MACXX1(67),IVSVDM),(MACXX1(68),PATHLN),
     1           (MACXX1(69),NEXTLN),(MACXX1(70),SHOULD),
     2           (MACXX1(71),PATHCH)
C
C
C         23.      MACRO PROCESSING ARRAYS
C
      COMMON/MACXX2/MACXX2
      DIMENSION MACXX2(902),MBREC(2),MBUFF(350,2),MACRTB(200)
      EQUIVALENCE(MACXX2(  1),MBREC(1)),(MACXX2( 3),MBUFF(1,1))
      EQUIVALENCE(MACXX2(703),MACRTB(1))
C
C         24.      MACRO PROCESSING ARRAYS
C
      COMMON/MACXX3/MACXX3
      DIMENSION MACXX3(2630),MACDF1(400),MACDF2(400),MACHST(1800),
     1                       MACSV1( 10),MACSV2( 10),MACSV3( 10)
      EQUIVALENCE(MACXX3(   1),MACDF1(1)),(MACXX3( 401),MACDF2(1)),
     1           (MACXX3( 801),MACHST(1)),(MACXX3(2601),MACSV1(1)),
     2           (MACXX3(2611),MACSV2(1)),(MACXX3(2621),MACSV3(1))
C
C         25.      MACRO PROCESSING ARRAYS
C
      COMMON/MACXX4/MACXX4
      DIMENSION MACXX4( 100),MNMVB ( 25),MNMVC ( 25),MACSEQ( 50)
      EQUIVALENCE(MACXX4( 1),MNMVB(1)),(MACXX4(26),MNMVC(1)),
     1           (MACXX4(51),MACSEQ(1))
C
C         25A.     MACRO PROCESSING ARRAYS
C
      COMMON/MACXX5/ITMPSV
      DIMENSION ITMPSV(135)
C
C         26.      MACRO PROCESSING ARRAYS
C
      COMMON/MACXX6/MACXX6
      DIMENSION MACXX6(1300),VBLSAV(900)
      EQUIVALENCE(MACXX6(401),VBLSAV(1))
C
C         26A.     MACRO PROCESSING ARRAYS
C
      COMMON/MACXX7/MACXX7
      DIMENSION MACXX7(182),LINUSD(50),MAS(100),MACVAR(32)
      EQUIVALENCE(MACXX7(  1),LINUSD(1)),(MACXX7( 51),MAS(1)),
     1           (MACXX7(151),MACVAR(1))
C
C...        27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION    OPMOD(8)
C
      EQUIVALENCE(OPMOD(1),NOUGHT),(OPMOD(2),DLR   ),(OPMOD(3),DBLDLR),
     1           (OPMOD(4),TRPDLR),(OPMOD(5),QUADLR),(OPMOD(6),QUIDLR),
     2           (OPMOD(7),HEXDLR),(OPMOD(8),SPTDLR)
C
C
C...        29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULO,MODHLF
C
C...        30.   NAMTBL POINTERS TO FIRST CANONICAL FORMS IN EACH BLOCK
C
      COMMON/BLKCFS/FIRST
      DIMENSION  FIRST(2,3)
C....
C           31.   COMMON BLOCK FOR PRO026 AND MOTION
C....
      COMMON /COMP26/COMP26,TAGTBL
      DIMENSION TAGTBL(3),COMP26(13)
      LOGICAL FEDSAV, FMTERR, MCSJMP, JMPING
C
      EQUIVALENCE(COMP26( 1),INTOF ),(COMP26( 2),ARGCNT),
     1           (COMP26( 3),CSPNTR),(COMP26( 4),JMPCS ),
     2           (COMP26( 5),NUMBCS),(COMP26( 6),TEST  ),
     3           (COMP26( 7),TEST1 ),(COMP26( 8),FEDSAV),
     4           (COMP26( 9),FMTERR),(COMP26(10),MCSJMP),
     5           (COMP26(11),JMPING),(COMP26(12),K     ),
     6           (COMP26(13),LERR  )
C
C
C           32.   COMMON BLOCK FOR SETBIT AND BITMCH
C
      COMMON/BITCOM/BIT
      DIMENSION BIT(32)
      DIMENSION LOBIT(16),HIBIT(16)
      EQUIVALENCE (LOBIT(1),BIT(1)),(HIBIT(1),BIT(17))
C...
C ...       35.    COMMON BLOCK FOR BOUNDED GEOMETRY AND CFSAVE
C
C
      COMMON/BGEOM/BGEOM
      DIMENSION     BGEOM(4)
C
      EQUIVALENCE(BGEOM(1),IFBNDS),(BGEOM(2),IFDUMP),(BGEOM(3),J     ),
     1           (BGEOM(4),L     )
C
C           36.    SYSTEM MACRO AND SEGMENT READ VARIABLES
C
      COMMON/MACSEG/MACSEG
      DIMENSION     MACSEG(6)
      LOGICAL ALOPN,LMRSTR,LMREND
C
      EQUIVALENCE(MACSEG(1),ALOPN ),(MACSEG(2),NMSEG ),
     1           (MACSEG(3),NMMAC ),(MACSEG(4),LMRSTR),
     2           (MACSEG(5),ITMPCT),(MACSEG(6),LMREND)
C
C...        37.    INCLUSIVE SUBSCRIPT VARIABLES
C
      COMMON/ISSCOM/ISSCOM,ISSTRM
      DIMENSION ISSTRM(2),ISSCOM(7)
      LOGICAL ISSFL,ISSEND
C
      EQUIVALENCE(ISSCOM(1),ISSA  ),(ISSCOM(2),ISSB  ),
     1           (ISSCOM(3),ISSC  ),(ISSCOM(4),ISSVBL),
     2           (ISSCOM(5),ISSMOD),(ISSCOM(6),ISSFL ),
     3           (ISSCOM(7),ISSEND)
C
C
C...        39.    COMMON BLOCK LIBRARY PRINTING FLAG
C
      COMMON/LIBPRT/LIBPRT
      LOGICAL       LIBPRT
C
C...        41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION   NTBL(6)
C
      EQUIVALENCE(NTBL(1),NMOD  ),(NTBL(2),NCRNT ),(NTBL(3),NNDX  ),
     1           (NTBL(4),NLAST ),(NTBL(5),NSTR  ),(NTBL(6),NMAX  )
C
C
C           42.    COMMON BLOCK FOR CANON AND OBTAIN ARGUMENT STORAGE
C
      COMMON/CANSTR/CANSTR,CANSTK
      DIMENSION CANSTK(16),CANSTR(2)
C
      EQUIVALENCE(CANSTR(1),CANPTR),(CANSTR(2),CANCHK)
C
C
C           43.    COMMON BLOCK FOR LOOP
C
      COMMON/DOLOOP/DOLOOP
      DIMENSION DOLOOP(9)
      LOGICAL DOFLAG,DLRFLG,IFFLAG
C
      EQUIVALENCE(DOLOOP(1),JUMPTO),(DOLOOP(2),ABSDO ),
     1           (DOLOOP(3),RELDO ),(DOLOOP(4),DONEST),
     2           (DOLOOP(5),DOMAX ),(DOLOOP(6),DOJUMP),
     3           (DOLOOP(7),DOFLAG),(DOLOOP(8),DLRFLG),
     4           (DOLOOP(9),IFFLAG)
C
C
C           44.    COMMON BLOCK FOR ERROR POSITIONS
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS(302),ERRPNT(100),ESTACK(100),ERGSTK(100)
      LOGICAL NOWARN
C
      EQUIVALENCE(ERRPOS(1),NOWARN),(ERRPOS(3),ERRPNT(1)),
     1           (ERRPOS(103),ESTACK(1)),(ERRPOS(203),ERGSTK(1))
C
C
C           45.    NUMBER TABLE INDICES
C
      INCLUDE 'NUMBLK.INC'
                          
C     DATA STATEMENTS
C
C...         2.    STACK AND POINTER STORAGE
C
      DATA TOP,ARGTOP,IARGDM/0,0,99/
C
C...         5.    PROGRAM CONTROL FLAGS
C
      DATA ENDFLG,NEWSTM,APTRAN,REFFLG/.TRUE.,.TRUE.,.FALSE.,.FALSE./
C
C...         6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C
C***  DATA SPECIFICATIONS TO COMPLEMENT 'INITAL'
C
C     LINE
      DATA TXXXX(1, 1),TXXXX(2, 1)/4,0/
C     PLANE
      DATA TXXXX(1, 2),TXXXX(2, 2)/4,0/
C     CYLINDER
      DATA TXXXX(1, 3),TXXXX(2, 3)/7,0/
C     CIRCLE
      DATA TXXXX(1, 4),TXXXX(2, 4)/7,0/
C     SPHERE
      DATA TXXXX(1, 5),TXXXX(2, 5)/4,0/
C     HYPERBOLA
      DATA TXXXX(1, 6),TXXXX(2, 6)/10,0/
C     LOFT CONIC
      DATA TXXXX(1, 7),TXXXX(2, 7)/10,0/
C     ELLIPSE
      DATA TXXXX(1, 8),TXXXX(2, 8)/10,0/
C     CONE
      DATA TXXXX(1, 9),TXXXX(2, 9)/7,0/
C     GENERAL CONIC
      DATA TXXXX(1,10),TXXXX(2,10)/10,0/
C     TABULATED CYLINDER
      DATA TXXXX(1,11),TXXXX(2,11)/2,0/
C     RULED SURFACE
      DATA TXXXX(1,12),TXXXX(2,12)/2,0/
C     POLYCONIC SURFACE
      DATA TXXXX(1,13),TXXXX(2,13)/2,0/
C     QUADRIC
      DATA TXXXX(1,14),TXXXX(2,14)/10,0/
C     PARAMETRIC SURFACE
      DATA TXXXX(1,15),TXXXX(2,15)/10,0/
C     UNUSED
      DATA TXXXX(1,16),TXXXX(2,16)/0,0/
C     UNUSED
      DATA TXXXX(1,17),TXXXX(2,17)/0,0/
C     MATRIX
      DATA TXXXX(1,18),TXXXX(2,18)/12,0/
C     POINT
      DATA TXXXX(1,19),TXXXX(2,19)/3,0/
C     VECTOR
      DATA TXXXX(1,20),TXXXX(2,20)/3,0/
C     REAL
      DATA TXXXX(1,21),TXXXX(2,21)/1,0/
C     INTEGER
      DATA TXXXX(1,22),TXXXX(2,22)/1,0/
C     BOOLEAN
      DATA TXXXX(1,23),TXXXX(2,23)/1,0/
C     SUBSCRIPT
      DATA TXXXX(1,24),TXXXX(2,24)/1,0/
C     STRING
      DATA TXXXX(1,25),TXXXX(2,25)/12,0/
C     PATERN
      DATA TXXXX(1,26),TXXXX(2,26)/2,0/
C     BOUNDS
      DATA TXXXX(1,27),TXXXX(2,27)/0,0/
C     OBJECT
      DATA TXXXX(1,28),TXXXX(2,28)/0,0/
C     SSURF
      DATA TXXXX(1,29),TXXXX(2,29)/2,0/
C     SCURV
      DATA TXXXX(1,30),TXXXX(2,30)/2,0/
C     UNUSED
      DATA TXXXX(1,31),TXXXX(2,31)/0,0/
C     UNUSED
      DATA TXXXX(1,32),TXXXX(2,32)/0,0/
C
C...      13.      NAMTBL POINTERS TO NEGATIVE NUMBERS
C
C
C...        11.    SEQUENCE NUMBER STORAGE
C
      DATA     SEQNO/1/
C
C...        12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      DATA  MAXSIZ,CANSIZ,KSC,CANTOP,ISC /1102*0,100,3/
      DATA PARDEF,TABCYS/.FALSE.,.FALSE./
C
C...      14.      I. L. LIST OPTION FLAGS
C
      DATA       CILPRT,  ILPRT, INTERP, ASSEMB, TRACFL
     /          ,PRTERR,  MCHDNG/
     /           2*.FALSE.,.TRUE.,4*.FALSE./
C
C...        15.    ARRAY LIMIT STORAGE
C
      DATA RNGPT,RANGE/1,400*0/
C
C...        16.    LITERALS FOR I. L. OPERATION CODES
C
      DATA FADD  / 1/
      DATA FSUB  / 2/
      DATA FMPY  / 3/
      DATA FDIV  / 4/
      DATA FEXP  / 5/
      DATA LABELX/ 6/
      DATA ENTRYX/ 7/
      DATA JUMP  / 8/
      DATA SEQNCE/ 9/
      DATA RETMC /10/
      DATA CONJMP/11/
      DATA RESRV /12/
      DATA CVTSUB/13/
      DATA CALMC /14/
      DATA ASNADD/15/
      DATA ASNJMP/16/
      DATA REPL  /17/
      DATA CALL  /18/
      DATA MOVE  /19/
      DATA VBLJMP/20/
      DATA HOLDAT/21/
C
C...        17.    MODE CODES
C
      DATA  LINE  / 1/
      DATA  PLANE / 2/
      DATA  CYLNDR/ 3/
      DATA  CIRCLE/ 4/
      DATA  SPHERE/ 5/
      DATA  HYPERB/ 6/
      DATA  CONIC / 7/
      DATA  ELLIPS/ 8/
      DATA  CONE  / 9/
      DATA  GCONIC/10/
      DATA  TABCYL/11/
      DATA  RLDSRF/12/
      DATA  POLCON/13/
      DATA  QADRIC/14/
      DATA  PARSRF/15/
      DATA  UNUS1 /16/
      DATA  UNUS2 /17/
      DATA  MATRIX/18/
      DATA  POINT /19/
      DATA  VECTOR/20/
      DATA  REAL  /21/
      DATA  INTGER/22/
      DATA  BOOL  /23/
      DATA  SUBSCR/24/
      DATA  STRING/25/
      DATA  PATERN/26/
      DATA  BOUNDS/27/
      DATA  OBJECT/28/
      DATA  SSURF /29/
      DATA  SCURV /30/
      DATA  UNUS3 /31/
      DATA  UNUS4 /32/
C
C...        18.    STRING STORAGE AREA
C
      DATA CHR    /' '/
C
C...      19.      INTERMEDIATE LANGUAGE TEXT
C
      DATA COMFIN,LENGTH,TPNTRX/.FALSE.,0,0/
C
C         22.      MACRO PROCESSING VARIABLES
C
      DATA MACDFP ,MCNMB  ,MCHSTP ,MCTXTP ,MCSAVP ,MNMVBP ,MVSEG  ,
     1     CALLPT ,TEXTST ,MVPNT  ,BRANCH ,MAXSPS ,INTMED ,MAJWRD ,
     2     NMLINE ,WAY    ,BITWDS ,MCSLNT ,MACLNT ,MSP    ,MVEXST ,
     3     MACTOP ,MCSTRT ,MAJOR  ,ROUTE  ,ROAD   ,SAVMSP ,TYP    ,
     4     LNUSDP ,MCTOPP ,MCSPDP ,MCSRCH ,NUMARG ,WHCHMN ,LARGMV ,
     5     VBLSVP ,PATHLN ,NEXTLN ,PATHCH ,NUMVAR,NUMCAL  /41*0/
C
      DATA MACLDD ,CALLON ,CALLMV ,ILHLT  ,MVMAC  ,MACRED ,MVTRUE ,
     1     FINMAC ,ENTRY  ,NESTG  ,ENDMCH ,MACLK  ,MACEND ,SHOULD
     2     /14*.FALSE./
C
      DATA MBPTR  ,LSTWRT ,MCDFDM ,MHSTDM ,MCSVDM ,MNMVDM ,MSEQDM
     1    /    2  ,     1 ,   400 ,  1800 ,    10 ,    25 ,    50/
      DATA LNSDDM ,MVARDM ,MASDM  ,NUMBIT ,MACFND ,MSPDDM ,IVSVDM
     1    /    50 ,    32 ,  100  ,    31 ,    -1 ,  1300 ,   900/
C
C         23.      MACRO PROCESSING ARRAYS
C
      DATA  MACXX2/1,2,900*0/
C
C         24.      MACRO PROCESSING ARRAYS
C
      DATA  MACXX3/2630*0/
C
C         25.      MACRO PROCESSING ARRAYS
C
      DATA  MACXX4/100*0/
C
C         25A.     MACRO PROCESSING ARRAYS
C
C
C         26.      MACRO PROCESSING ARRAYS
C
      DATA  MACXX6/1300*0/
C
C         26A.     MACRO PROCESSING ARRAYS
      DATA  MACXX7/182*0/
C
C...        27.    OPERAND MODIFIERS
C
      DATA NOUGHT/0/
      DATA DLR   /1/
      DATA DBLDLR/2/
      DATA TRPDLR/3/
      DATA QUADLR/4/
      DATA QUIDLR/5/
      DATA HEXDLR/6/
      DATA SPTDLR/7/
C
C...        29.    CLASS CODE MODULI
C
      DATA MODULO /1000/
      DATA MODHLF / 500/
C
C...        30.   NAMTBL POINTERS TO FIRST CANONICAL FORMS IN EACH BLOCK
C
      DATA  FIRST /6*0/
C....
C           31.   COMMON BLOCK FOR PRO026 AND MOTION
C....
      DATA JMPING,FMTERR,MCSJMP,FEDSAV/4*.FALSE./
      DATA NUMBCS/0/
C
C           32.   COMMON BLOCK FOR SETBIT AND BITMCH
C
      DATA LOBIT( 1),LOBIT( 2),LOBIT( 3),LOBIT( 4),
     1     LOBIT( 5),LOBIT( 6),LOBIT( 7),LOBIT( 8),
     2     LOBIT( 9),LOBIT(10),LOBIT(11),LOBIT(12),
     3     LOBIT(13),LOBIT(14),LOBIT(15),LOBIT(16)
C    4    /Z80000000,Z40000000,Z20000000,Z10000000,
     4  /-2147483648,1073741824,536870912,268435456,
C    5     Z 8000000,Z 4000000,Z 2000000,Z 1000000,
     5     134217728, 67108864, 33554432, 16777216,
C    6     Z  800000,Z  400000,Z  200000,Z  100000,
     6       8388608,  4194304,  2097152,  1048576,
C    7     Z   80000,Z   40000,Z   20000,Z   10000/
     7        524288,   262144,   131072,    65536/
      DATA HIBIT( 1),HIBIT( 2),HIBIT( 3),HIBIT( 4),
     1     HIBIT( 5),HIBIT( 6),HIBIT( 7),HIBIT( 8),
     2     HIBIT( 9),HIBIT(10),HIBIT(11),HIBIT(12),
     3     HIBIT(13),HIBIT(14),HIBIT(15),HIBIT(16)
C    4    /Z    8000,Z    4000,Z    2000,Z    1000,
     4    /    32768,    16384,     8192,     4096,
C    5     Z     800,Z     400,Z     200,Z     100,
     5          2048,     1024,      512,      256,
C    6     Z      80,Z      40,Z      20,Z      10,
     6           128,       64,       32,       16,
C    7     Z       8,Z       4,Z       2,Z       1/
     7             8,        4,        2,        1/
C...
C ...       35.    COMMON BLOCK FOR BOUNDED GEOMETRY AND CFSAVE
C
C
C
C           36.    SYSTEM MACRO AND SEGMENT READ VARIABLES
C
      DATA ALOPN,LMRSTR,LMREND/3*.FALSE./
      DATA NMSEG,NMMAC,ITMPCT/3*0/
C
C...        37.    INCLUSIVE SUBSCRIPT VARIABLES
C
      DATA ISSFL,ISSEND/2*.FALSE./
C
C...        39.    COMMON BLOCK LIBRARY PRINTING FLAG
C
      DATA LIBPRT/.FALSE./
C
C...        41.    NUMBER TABLE OVERFLOW VARIABLES
C
      DATA NCRNT,NLAST,NSTR,NMAX/1,0,1,100/
C
C           42.    COMMON BLOCK FOR CANON AND OBTAIN ARGUMENT STORAGE
C
      DATA CANPTR,CANCHK/0,16/
C
C           43.    COMMON BLOCK FOR LOOP
C
      DATA DOFLAG,DLRFLG,IFFLAG/3*.FALSE./
      DATA JUMPTO,ABSDO,RELDO,DONEST,DOMAX,DOJUMP/0,0,0,10,13,0/
C
C           44.    COMMON BLOCK FOR ERROR POSITIONS
C
      DATA NOWARN/.FALSE./
C
C           45.    NUMBER TABLE INDICIES
C
      DATA NMBRS,LSTCHR,MASGND/0,13,2000/
C
      END
