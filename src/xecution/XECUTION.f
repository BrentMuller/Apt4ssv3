**** SOURCE FILE : M0000746.V03   ***
*
C
C.....FORTRAN ROUTINE              ..ADV..     HL GRAY 3/68         *ID*
      SUBROUTINE ADV
C
C FORTRAN SUBROUTINE ADV --- ADVANCE LOCATION COUNTER
C
C PURPOSE      'ADV'    ADVANCES THE INTERPRETER PSEUDOLOCATION
C              COUNTER, 'ILC' BY ONE INTERMEDIATE LANGUAGE INSTRUCTION.
C              OTHER DEPENDENT VARIABLES ARE SET TO CORRESPONDING
C              VALUES.
C
C LINKAGE      CALL ADV
C
C ARGUMENTS    THROUGH COMMON
C
C NOTES        THIS ROUTINE IS QUITE SIMILAR TO 'SET'   .  THE MAIN
C              DIFFERENCE IS THAT 'ADV'    DOES NOT EXAMINE VARIABLES
C              DEPENDING ON THE PSEUDOLOCATION COUNTER UNTIL A PAGE
C              BREAK OCCURS.
C
C METHOD       THE PSEUDOLOCATION COUNTER IS ADVANCED BY THE LENGTH
C              OF THE INSTRUCTION JUST PROCESSED.  IF THE PAGE BREAK
C              OCCURS, SUITABLE RESETTING OCCURS.
C
C--------------------------------------------------------------CDE PAK
C
C
C
C UNLABELED COMMON
C
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
C
C
C
C WORK--COMMON CONTAINING WORKING VARIABLES
C
C
      COMMON/WORK/  PGC,      PGCN,     ILC,      IXC
      INTEGER       PGC,      PGCN,     ILC,      IXC
C
C
C
C
C---------------------------------------------------------------------
C
      INTEGER K
      EXTERNAL PAGE
      INTEGER  PAGE
C
C
C
C        ADVANCE INDEX
C
      K=PP(ILC+1)+2
      IXC = IXC + K
C
C        TEST--HAS PAGE BREAK OCCURRED
C
      IF ( IXC .GT. PGCN) GO TO 50
C
C        NO.  UPDATE LOCATION COUNTER, THEN RETURN
C
      ILC = ILC + K
C
C
      RETURN
C
C
C        ADVANCE LOCATION COUNTER TO BEGINING OF NEW PAGE
C
 50   IF(PGC.LT.0)GOTO 60
      ILC = PAGE(PGC+1)
C
C        UPDATE PAGE NUMBER
      PGC = PGC + 1
      GO TO 70
C
 60   ILC = PAGE(PGC-1)
C
C        UPDATE PAGE NUMBER
      PGC = PGC -1
C
C        EXTRAC NUMBER OF WORDS ON THIS PAGE
 70   PGCN = PP(ILC+1)+2
C
C
C        SET LOCATION COUNTER TO FIRST INSTRUCTION
C
      ILC = ILC + 2
C
C        RESET INDEX
C
      IXC = 3
C
      RETURN
      END
**** SOURCE FILE : M0000882.V04   ***
*
C.....FORTRAN BLOCK DATA ROUTINE  ...DATA    8/68                 HG
C.....FORTRAN ROUTINE              ..DATA..    HL GRAY 3/68         *ID*
      BLOCK DATA DAT0
C
C
C
C
C ABBREVIATIONS AND TERMS
C
C
C
C
C     THE FOLLOWING ABBREVIATIONS AND TERMS ARE USED THROUGHOUT THE
C     CODING OF THE INTERPRETER.  IN GENERAL, TERMS ARE FORMED BY
C     CONCATENATING ROOT WORDS.  FOR EXAMPLE
C
C              NT        FOR NAME TABLE
C              P         FOR POINTER
C
C     FORM
C
C              NTP       NAME TABLE POINTER
C
C     AND ARE PRESENTED IN THIS GLOSSARY AS
C
C              NT.P
C
C     WHERE THE PERIODS INDICATE THE CONCATENATION AS A MEMORY AID.
C
C
C
C
C TERM         DEFINITION                                          TYPE
C
C
C A            ARRAY                                             MIXED
C
C AVT          ACTUAL VS VIRTUAL ADDRESS TABLE
C
C B            BEGINNING (USUALLY OF AN ARRAY)                     I
C
C C            CURRENT
C
C CF           CANONICAL FORM                                      D
C
C CF.B         CANONICAL FORM TABLE BEGINNING                      I
C
C CF.E         CANONICAL FORM TABLE END                            I
C
C CF.N         CANONICAL FORM TABLE LENGTH                         I
C
C CF.P         CANONICAL FORM TABLE POINTER                        I
C
C CILPRT       PRINT COMPRESSED I.L. FLAG
C
C COM          STORAGE (BLANK COMMON)                              D
C
C COM.B        STORAGE BEGINNING                                   I
C
C COM.E        STORAGE END                                         I
C
C COM.N        TOTAL LENGTH OF COMMON
C
C COM.P        STORAGE POINTER                                     I
C
C COM.S        SIZE OF ASSIGNED STORAGE FOR COMMON
C
C CM           STORAGE (BLANK COMMON) SAME AS COM)                 I
C
C E            END (USUALLY OF AN ARRAY)                           I
C
C FP           FLOATING POINT NUMBER TABLE                         D
C
C FP.B         FLOATING POINT TABLE BEGINNING                      I
C
C FP.E         FLOATING POINT TABLE END                            I
C
C FP.N         FLOATING POINT TABLE LENGTH                         I
C
C FP.P         FLOATING POINT TABLE POINTER                        I
C
C IA           INTERNAL ARRARY                                     D
C
C IA.B         INTERNAL ARRAY BEGINNING                            I
C
C IA.P         INTERNAL ARRAY POINTER                              I
C
C IL           INTERMEDIATE LANGUAGE INSTRUCTION.  AN N-TUPLE      I
C              WHOSE FORM IS SHOWN UNDER STRUCTURE.
C
C IL.C         POSITION OF CURRENT INTERMEDIATE LANGUAGE           I
C              INSTRUCTION RELATIVE TO PART PROGRAM BEGINNING
C
C IX           INDEX.  POINTER RELATIVE TO BEGINNING OF PAGE.      I
C              FIRST WORD OF PAGE HAS ZERO INDEX.
C
C IX.C         POSITION OF CURRENT INTERMEDIATE LANGUAGE           I
C              INSTRUCTION RELATIVE TO BEGINNING OF CURRENT PAGE
C
C K.           INTRODUCES A CONSTANT
C
C K.CB.N       EXTERNAL CANNON BLOCK LENGTH
C
C K.COM.F      LENGTH OF FIXED PORTION OF COMMON
C
C K.COM.T      LENGTH OF TEMPORARY PORTION OF COMMON
C
C K.IL.N       CONSTANT WHICH ADDED TO NUMBER OF PARAMETERS IN     I
C              ANY INTERMEDIATE LANGUAGE INSTRUCTION GIVES LENGTH
C              OF THAT INSTRUCTION IN WORDS.
C
C K.IL.P       POSITION RELATIVE TO BEGINNING OF INSTRUCTION  OF   I
C              THE WORD CONTAINING NUMBER OF PARAMETERS IN THE
C              INSTRUCTION.
C
C K.IL.1       POSTION RELATIVE TO BEGINNING OF PAGE OF FIRST
C              INSTRUCTION.
C
C K.NT.P       CORRECTION TO NAME TABLE POINTER TO EFFECT
C              PART PROGRAM CORRESPONDENCE
C
C K.MT.ST      MACRO TEXT FITS IN MEMORY                           L
C
C K.PG.LN      PAGE TO LINE PACKING FACTOR                         I
C
C K.PG.N       PAGE LENGTH                                         I
C K.PK.M       PACKING FACTOR FOR MODE                             I
C
C K.PK.S       PACKING FACTOR FOR SIZE                             I
C
C
C K.PP.ST      PART PROGRAM FITS IN MEMORY (INCLUDING MACRO TEXT)  L
C
C
C LN           LINE = (PAGE,INDEX)ING FACTOR) + INDEX              I
C
C LN.A         LINE ARRAY.  CONTAINS LINE NUMBERS FOR              I
C
C LN.C         CURRENT LINE NUMBER   GC*KPGLN + IXC)               I
C
C MT           MACRO TEXT (A PORTION OF THE PART PROGRAM)          H
C
C MT.B         MACRO TEXT BEGINNING                                I
C
C MT.E         MACRO TEXT END                                      I
C
C MT.N         MACRO TEXT LENGTH                                   I
C
C N            LENGTH (USUALLY OF AN ARRAY)                        I
C
C NB           NAME TABLE (SAME AS NT)                             D
C
C NBLK         NUMBER OF BLOCKS OF CANNON ALLOWED
C
C NS           NONSCALAR ARRAY                                     D
C
C NS.B         NONSCALAR ARRAY BEGINNING                           I
C
C NS.P         NONSCALAR ARRAY POINTER                             I
C
C NT           NAME TABLE                                          I
C
C NT.B         NAME TABLE BEGINNING                                I
C
C NT.E         NAME TABLE END                                      I
C
C NT.N         NAME TABLE LENGTH                                   I
C
C NT.P         NAME TABLE POINTER                                  I
C
C OD           OPERAND.  AN ORDERED PAIR, (TYPE, VALUE).           I
C
C OP           OPCODE (PORTION OF INTERMEDIATE LANGUAGE
C              INSTRUCTION)
C
C P            POINTER (USUALLY TO AN ELEMENT IN AN ARRAY          I
C
C PG           PAGE OF TEXT--POSITIVE FOR PART PROGRAM, NEGATIVE   I
C              FOR MACRO TEXT
C
C PG.C         CURRENT PAGE NUMBER                                 I
C
C PG.C.N       NUMBER OF WORDS ON CURRENT PAGE                     I
C
C PP           PART PROGRAM (INCLUDING MACRO TEXT)                 H
C
C PP.B         PART PROGRAM BEGINNING                              I
C
C PP.E         PART PROGRAM END                                    I
C
C PP.N         PART PROGRAM LENGTH                                 I
C
C RT.P         RETURN POINTER.  POINTS TO RETURN LINE IN MACRO     I
C              CALL/RETURN ARRAY, LN.A.
C
C SA           SCALAR ARRAY                                        D
C
C SA.B         SCALAR ARRAY TABLE BEGINNING                        I
C
C SA.E         SCALAR ARRAY TABLE END                              I
C
C SA.N         SCALAR ARRAY TABLE LENGTH                           I
C
C SA.P         SCALAR ARRAY TABLE POINTER                          I
C
C SC           SCALAR                                              R
C
C SC.B         SCALAR TABLE BEGINNING                              I
C
C SC.E         SCALAR TABLE END                                    I
C
C SC.N         SCALAR TABLE LENGTH                                 I
C
C SC.P         SCALAR TABLE POINTER                                I
C
C
C
C
C
C MASTER COMMON DECK
C--------------------------------------------------------------CDE PAK
C
C
C
C UNLABELED COMMON
C
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
C NAME TABLE
      INCLUDE 'NAMETB.INC'
C
C
C
C STOR--COMMON CONTAINING STORAGE PARAMETERS
C
C
      COMMON/STOR/  NTB,      FPB,      PPB,      COMN,  CFB,  NBLK
      INTEGER       NTB,      FPB,      PPB,      COMN,  CFB,  NBLK
C
C   ADDITIONAL STOR PARAMETERS USED FOR NUMBER TABLE DIRECT ACCESS
C
      COMMON/STOR/  NRECRD,  NTPARM
      DIMENSION     NRECRD(10), NTPARM(10)
      EQUIVALENCE   (NTPARM(1),NUMST), (NTPARM(2),NUMOD ),
     .              (NTPARM(3),NDAFLG), (NTPARM(4),NRECST),
     .              (NTPARM(5),IPAGE )
C
C WORK--COMMON CONTAINING WORKING VARIABLES
C
C
      COMMON/WORK/  PGC,      PGCN,     ILC,      IXC
      INTEGER       PGC,      PGCN,     ILC,      IXC
C
      COMMON/WORK/  SCP,      SAP,      NSP,      IAP,   CFP,   COMP
      INTEGER       SCP,      SAP,      NSP,      IAP,   CFP,   COMP
C
      COMMON/WORK/     NTP,   LNA,    RTP
C  THIS LOCATION IS USED TO PASS FUNCTION RESULTS FROM XCALL
      COMMON/WORK/AC
C   THIS ARRAY USED BY THE ROUTINES INCAN AND XCANON
      COMMON/WORK/AVT,IWRIT
      INTEGER  FPP,    NTP,    LNA,    RTP
      INTEGER                            AVT
      EQUIVALENCE  (FPP,   NTP)
      DIMENSION                LNA(2,20),      AVT(32)
      INTEGER       AC
C
C
C CONST--COMMON CONTAINING CONSTANTS
C
C
      COMMON/CONST/KCOMT,KCOMF,CILPRT,KCBN
      LOGICAL CILPRT
C
C
C
C
C---------------------------------------------------------------------
      DATA          PGC,   PGCN,   ILC,   IXC   / 0, 0, 0, 0/
      DATA          NTB/0/,RTP/0/,COMN/5000/,AVT/32*0/,IWRIT/0/
      DATA          KCOMF/40/,KCOMT/16/,KCBN/128/
      DATA          NRECRD,NTPARM /10*0, 10*0/
       END
**** SOURCE FILE : DELALL00.ORG   ***
*
      SUBROUTINE DELALL
C
C....DUMMY ROUTINE - DELALL NOT NEEDED IF DYNAMIC LOADING NOT AVAILABLE
C
      RETURN
      END
**** SOURCE FILE : M0001665.V04   ***
*
C
C....FORTRAN SUBROUTINE  ...EXEC...       5/69                   HG
C
      SUBROUTINE EXEC
C
C
C...THIS IS THE MAIN ROUTINE FOR THE EXECUTION COMPLEX.
C
C
C...      32.  PARAMETERS REQUIRED BY SUPERVISOR
C
      INCLUDE 'SUPER.INC'
C
      INTEGER  ONE
      DATA  ONE/1/
C
C...     SET UP INITIAL SEQUENCE NUMBER
      CALL SEQ(ONE)
C
C... CALL THE MAIN ROUTINE FOR THE INTERPRETIVE APPROACH.
      CALL IMAIN
C
C... INDICATE NORMAL ENDING.
      ABEND = .FALSE.
C
C... FREEMAIN OF SECUDARY LOADED MODULS,IF NESSESARY
      CALL DELALL
      RETURN
      END
**** SOURCE FILE : M0000717.W02   ***
*
C.....FORTRAN SUBROUTINE  ....GET            8/68                 HG
C.....FORTRAN FUNCTION             ..GET..     HL GRAY 3/68         *ID*
      DOUBLE PRECISION FUNCTION   GET(OD)
C
C FORTRAN FUNCTION 'GET(OD)'--GET ARGUMENT FROM OPERAND, OD
C
C PURPOSE      TO GET THE VALUE OF AN ARGUMENT GIVEN THE
C              INTERMEDIATE LANGUAGE OPERAND POINTER, OD.
C
C LINKAGE      GET(OD)
C
C              WHERE
C              OD IS THE POINTER TO THE OPERAND IN THE PART
C                 PROGRAM
C
C METHOD       THE OPERAND IS EVALUATED ACCORDING TO TYPE
C              (SEE INTRODUCTORY DOCUMENTATION).  THE VALUE
C              OF THE ARGUMENT IS THEN TAKEN FROM THE APPRO-
C              PRIATE LOCATION.
C
C              TYPE     VALUE
C               0        INDEX TO NAME TABLE WHICH CONTAINS POINTER
C                        TO STORED VARIABLE
C               1        INDEX TO FLOATING POINT NUMBER TABLE
C               2        INDEX TO ALPHANUMERIC CONSTANTS
C               3        INDEX TO NAME TABLE(POINTS TO VARIABLE)
C               4        PROCEDURE NUMBER
C               5        INTEGER
C               6        UNFRACTIONAL NUMBER (I4-FORMAT)
C               7        FRACTIONAL NUMBER   (R8-FORMAT)
C              -N        INDEX TO NAME TABLE WHICH CONTAINS POINTER
C                        TO BASE ADDRESS.  EFFECTIVE ADDRESS IS--
C
C                           BA + N-1
C
C                        AND ALWAYS REFERS TO INTERNAL ARRAYS
C
C--------------------------------------------------------------CDE PAK
C
C
C
C UNLABELED COMMON
C
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
C
C
C
C STOR--COMMON CONTAINING STORAGE PARAMETERS
C
C
      COMMON/STOR/  NTB,      FPB,      PPB,      COMN,  CFB,  NBLK
      INTEGER       NTB,      FPB,      PPB,      COMN,  CFB,  NBLK
C
C   ADDITIONAL STOR PARAMETERS USED FOR NUMBER TABLE DIRECT ACCESS
C
      COMMON/STOR/  NRECRD,  NTPARM
      DIMENSION     NRECRD(10), NTPARM(10)
      EQUIVALENCE   (NTPARM(1),NUMBST), (NTPARM(2),NUMOD ),
     .              (NTPARM(3),NDAFLG), (NTPARM(4),NRECST),
     .              (NTPARM(5),IPAGE )
C
C WORK--COMMON CONTAINING WORKING VARIABLES
C
C
      COMMON/WORK/  PGC,      PGCN,     ILC,      IXC
      INTEGER       PGC,      PGCN,     ILC,      IXC
C
      COMMON/WORK/  SCP,      SAP,      NSP,      IAP,   CFP,   COMP
      INTEGER       SCP,      SAP,      NSP,      IAP,   CFP,   COMP
C
      COMMON/WORK/         NTP,   LNA,   RTP
      INTEGER  FPP,    NTP,    LNA,    RTP
      EQUIVALENCE  (FPP,   NTP)
      DIMENSION                   LNA(2,20)
C
C
C CONST--COMMON CONTAINING CONSTANTS
C
C
      COMMON/CONST/KCOMT,KCOMF
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
C
      COMMON/ILD/ILD
C
C---------------------------------------------------------------------
C
C
C
      EXTERNAL XCANON
      INTEGER   XCANON,OD,K,L
      DATA ISPECL /319951634/
C
C
C        EXTRACT TYPE AND ADD ONE FOR 'GO TO' (L)
C
      J = ILC + ILD + OD
      L = PP(J) + 1
C
C        EXTRACT VALUE OF OPERAND (K)
C
      K = PP(J+1)
C
C        GET OPERAND ACCORDING TO TYPE
C
      IF (L .LE. 0) GO TO 70
C
C             0   1   2   3   4   5   6   7  TYPE
C
      GO TO (10, 20, 30, 10, 50, 60, 60, 80),L
C
C
C
C
C
C        TYPE 0.,3.
C
C        GET NAME TABLE POINTER
C
   10 CONTINUE
      NTP=NTB+K
      K=NT(1,NTP)
C---     SPECIAL LOGIC FOR INDIRECT ADRS AND NUMBER REFERENCE
      IF(L.NE.4) GO TO 11
      IF(NT(2,NTP).NE.ISPECL) GO TO 11
C---     INVOKE NUMBER TABLE PAGE AN ADDRESS REASSIGNMENT, IF NECESSARY
      IF(NDAFLG.NE.0) CALL XNUMBR(K)
      COMP=FPB+K
      GET=FP(COMP)
      RETURN
C---     NORMAL PATH FOR FETCHING CAN FORM OR NUMBER
   11 CONTINUE
      COMP=K
      GO TO 100
C
C
C
C
C        TYPE 1.
C
C        COMPUTE FLOATING TABLE POINTER, EXTRACT VARIABLE AND EXIT
C
   20 IF (NDAFLG .NE. 0) CALL XNUMBR(K)
      COMP=FPB+K
      GET = FP(COMP)
      RETURN
C
C
C
C
C        TYPE 2.
C
C        COMPUTE NAME TABLE POINTER, EXTRACT VARIABLE AND EXIT
C
 30   COMP = NTB + K
      GET = NB(COMP)
      RETURN
C
C
C
C
C        TYPE 4.
C
C
C
 50   COMP = K
      GET = 0.0
      RETURN
C
C
C
C
C        TYPE 5 AND TYPE 6.
C
 60   COMP = KCOMT
      COM(COMP) = K
      GET = COM(COMP)
      RETURN
C
C        TYPE 7.
C     RECEIVE FRACTIONAL NUMBER FROM INPUT FILE
C
 80   COMP = KCOMT
      CM(1,COMP)=PP(J+1)
      CM(2,COMP)=PP(J+2)
      ILD = ILD+1
      GET = COM(COMP)
      RETURN
C
C
C
C        TYPE (-N)
C
C
C        COMPUTE EFFECTIVE ADDRESS = BASE ADDRESS + INDEX,
C        STORE ARGUMENT AND EXIT
 70   NTP = NTB + K
      COMP = NT(1,NTP) - L
  100 I=COMP
      IF(CANFLG) I = XCANON(I)
      GET = COM(I)
C
  110 RETURN
      END
**** SOURCE FILE : M0000743.V01   ***
*
C.....FORTRAN ROUTINE          ..AIMAIN..      6/69       HLG       *ID*
      SUBROUTINE IMAIN
C
C PURPOSE      THIS IS THE MAIN ROUTINE FOR THE INTERPRETIVE APPROACH.
C NOTE THE MAIN ROUTINE FOR THE ASSEMBLY APPROACH
C WILL BE CALLED AMAIN, WHEN IMPLEMENTED, & WHICH ROUTINE
C IS USED DEPENDS ON THE APPROACH  REQUESTED BY THE PART PROGRAM.
C
C CALLED BY    THE ROUTINE MAIN
C
C
C...  INITALIZE STORAGE
      CALL INIT
C
C...  GO TO INTERPRETER
      CALL INTRP
C
      RETURN
      END
**** SOURCE FILE : M0001190.V14   ***
*
C.....FORTRAN ROUTINE              ..INIT..    HL GRAY 3/68, 8/68
      SUBROUTINE  INIT
C--------------------------------------------------------------CDE PAK
C UNLABELED COMMON
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
C NAME TABLE
      INCLUDE 'NAMETB.INC'
C SYSTEM DEPENDENT PARAMETERS
      INCLUDE 'SDP.INC'
C
C STOR--COMMON CONTAINING STORAGE PARAMETERS
      COMMON/STOR/  NTB,      FPB,      PPB,      COMN,  CFB,  NBLK
      INTEGER       NTB,      FPB,      PPB,      COMN,  CFB,  NBLK
C
C   ADDITIONAL STOR PARAMETERS USED FOR NUMBER TABLE DIRECT ACCESS
C
      COMMON/STOR/  NRECRD,  NTPARM
      DIMENSION     NRECRD(10), NTPARM(10)
      EQUIVALENCE   (NTPARM(1),NUMST), (NTPARM(2),NUMOD ),
     X              (NTPARM(3),NDAFLG), (NTPARM(4),NRECST),
     X              (NTPARM(5),IPAGE )
C
C WORK--COMMON CONTAINING WORKING VARIABLES
      COMMON/WORK/  PGC,      PGCN,     ILC,      IXC
      INTEGER       PGC,      PGCN,     ILC,      IXC
C
      COMMON/WORK/  SCP,      SAP,      NSP,      IAP,   CFP,   COMP
      INTEGER       SCP,      SAP,      NSP,      IAP,   CFP,   COMP
C CONST--COMMON CONTAINING CONSTANTS
C
      COMMON/CONST/KCOMT,KCOMF,CILPRT,KCBN
      LOGICAL CILPRT
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
C               SYSTEM I/O FILE NAMES
      INCLUDE 'SYMFIL.INC'
C
      DIMENSION IN(23)
      EQUIVALENCE (IN(2),SCN),(IN(3),SAN),(IN(4),NSN)
     1           ,(IN(5),IAN),(IN(6),COMS),(IN(12),LPG)
     2           ,(IN(13),FPN),(IN(14),NTN),(IN(15),PPPG)
     3           ,(IN(16),MTPG),(IN(18),LOGCAL)
     4           ,(IN(22),MAXSZ1),(IN(23),MAXSZ2)
      LOGICAL LOGCAL
C
      INCLUDE 'DARRAY.INC'
C
C---     MAXLDA CONTAINS THE MAXIMUM SPACE AVAILABLE FOR LDA'S
      COMMON/MAXLDA/MAXLDA
C---------------------------------------------------------------------
C
      INTEGER  SCN,SAN,NSN,LPG,PPPG,MTPG,IAN,FPN,NTN,COMS,K
      DOUBLE PRECISION ZERO
      CHARACTER*8 BLANK
      INTEGER BCDF
      DATA ZERO/0.D0/,KPGN/256/,BLANK/'        '/
C
C---     COMN REFLECTS THE TOTAL SPACE AVAILABLE IN BLANK COMMON (COM)
C---     IF DIMENSION OF COM IS CHANGED, THEN VALUE OF COMN IS CHANGED
C---     HERE AUTOMATICALLY
      COMN=COMSIZ
      IRISK=1
C---      IF IRISK IS 1, THEN SYSTEM WILL NOT TERMINATE FOR
C---      LACK OF SPACE BUT WILL PROCEED AT RISK
C     ---------
      COM(1) = ZERO
      NR=0
      CALL AREAD (ELFIL4,NR,IN,23,IR)
      CILPRT = LOGCAL
      NUMST = IN(19)
      NDAFLG = IN(20)
      NRECST = IN(21)
C
C---     PRELIMINARY CALCULATION TO SET ASIDE SPACE FOR LARGE DDATA
C---     FIXED ALLOCATIONS ARE MADE FOR ARELEM PART,DRIVE AND
C---     AND CHECK SURFACES,TEMPORARY MATRIX, NAME TABLE
C---     AND NUMBER TABLE
      NCFB=KCOMF+NTN+KCOMT+FPN
C---     MINIMUM SPACE FOR CANON DATA AND PART PROGRAM DATA
      MCANPG=SCN+SAN+NSN+IAN
      KK1=9*KCBN
      KK2=(KPGN/4)*4+1
      IF(MCANPG.GT.KK1) MCANPG=KK1+KK2
      IF(MCANPG.LE.KK1) MCANPG=MCANPG+KK2
C
C---      FIRST ATTEMPT, SPACE FOR THE LARGEST PLUS NEXT LARGEST
C---      ALLOCATE SPACE (COMS) FOR LARGE DATA ARRAYS
      COMS=MAXSZ1+MAXSZ2+90
      ISURP=COMN-COMS-MCANPG-NCFB
      IF(ISURP.LT.0) GO TO 5
      COMS=COMS+ISURP/2
      GO TO 6
    5 CONTINUE
C---      TRY SPACE FOR ONLY ONE LDA IN MEMORY
      COMS=COMS-MAXSZ2
      ISURP=ISURP+MAXSZ2
C---      QUIT NOW IF THERE IS NOT SPACE FOR EVEN ONE LDA.
      IF(ISURP.LT.0.AND.IRISK.EQ.0) GO TO 80
C------ALTERNATE CODE TO CONTINUE AT RISK
      COMS=COMN-MCANPG-NCFB
      IF(COMS.LT.0) GO TO 80
      CALL CFORM(' PREDICTED LDA SIZE TOO LARGE, PROCEED AT RISK',
     X  DARRAY,1,46)
      CALL CPRINT(DARRAY)
      CALL BAD(1,0,'COMN',COMN)
      CALL BAD(1,0,'COMS',COMS)
      CALL BAD(1,0,'MXS1',MAXSZ1)
      CALL BAD(-1,0,'MXS2',MAXSZ2)
C---      NOW COMS IS THE TOTAL SPACE FOR LARGE DATA.
    6 CONTINUE
      MAXLDA=COMS
      J0 = IN(17)
      JN = NTN
      NR=0
C---     READ IN THE NAME TABLE ENTRIES
      CALL CHREAD (ELFIL4,NR,CNAMTB(J0),JN,IR)
C
C... LOAD BCD EQUIVALENT OF CNAMTB ENTRIES IN NT
C
      J1=KCOMF+KCOMT+COMS+1
      J2=J0+NTN-1
      DO 8 J=J0,J2
        NT(1,J1)=BCDF(CNAMTB(J)(1:IWRD))
        NT(2,J1)=BCDF(CNAMTB(J)(IWRD+1:)//BLANK)
        J1=J1+1
   8  CONTINUE
C
C---     PRINT OUT THE COMPLETE NAME TABLE IF COMPRESSED PRINT IS ON
      IF(.NOT.CILPRT) GO TO 50
      CALL CFORM('0 LIST OF ALPHANUMERIC NAME TABLE ENTRIES',
     X    DARRAY,1,41)
      CALL CPRINT(DARRAY)
      KLL=IN(17)-1
      JCOL=2
      JTOP=J0+NTN-1
      DO 60 LL=J0,JTOP
      KLL=KLL+1
      IF(CNAMTB(LL).EQ.BLANK) GO TO 60
      CALL ICONV(KLL,DARRAY,JCOL,4)
      JCOL=JCOL+5
      CALL CFORM(CNAMTB(LL),DARRAY,JCOL,6)
      JCOL=JCOL+9
      IF(JCOL+14.LE.120) GO TO 60
      CALL CPRINT(DARRAY)
      JCOL=2
   60 CONTINUE
      CALL CPRINT(DARRAY)
   50 CONTINUE
C
      K0 = J1
      J0 = J1 - NTN
C
C        IF NDAFLG IS NOT ZERO THEN DIRECT ACCESS IS USED TO STORE
C        NUMBER TABLE VALUES. ONLY FIXED NUMBERS ARE PASSED ON ELFIL4.
      IF (NDAFLG .EQ. 0) GO TO 1003
      NUMOD = FPN-NUMST
      KN=(FPN-NUMOD)
      GO TO 1004
C
 1003 KN=FPN
 1004 NR = 0
      IF(J0+NTN+KN.GT.COMN) GO TO 80
      CALL FREAD(ELFIL4,NR,FP(K0),KN,IR,3)
      CALL TAPOP (ELFIL4,-1)
C
      NTB = J0-IN(17)
      FPB = NTB
      COMP = KCOMF + 1
      SCP = K0 + FPN
      CFB = SCP
      SAP= SCP+ SCN
      NSP = SAP+ SAN
      IAP = NSP + NSN
      PPB = (IAP + IAN)*2 - 1
      KCOMT = KCOMF + COMS + 1
C
      IF(.NOT.CILPRT) GOTO 90
C PRINT  INTERPRETER PARAMETERS
      CALL CFORM('1   EXECUTION PHASE ',DARRAY,1,20)
      CALL CPRINT (DARRAY)
      CALL CFORM('ENTR=INIT TABLES',DARRAY,4,16)
      CALL CPRINT(DARRAY)
      CALL BAD(-23,0,'IN  ',IN)
      CALL BAD(1,0,'KCMF',KCOMF)
      CALL BAD(1,0,'COMS',COMS)
      CALL BAD(1,0,'MXS1',MAXSZ1)
      CALL BAD(1,0,'MXS2',MAXSZ2)
      CALL BAD(-1,0,'KCMT',KCOMT)
      CALL BAD(1,0,'NTN ',NTN)
      CALL BAD(1,0,'FPN ',FPN)
      CALL BAD(1,0,'KCBN',KCBN)
      CALL BAD(1,0,'KPGN',KPGN)
      CALL BAD(-1,0,'COMN',COMN)
C        CAN ALL CANNONICAL FORMS PLUS 4 PAGES OF I.L. FIT IN CORE
   90 IF((PPB+4*KPGN-1).LE.2*COMN) GOTO 20
C        NO, STORE CANNONICAL FORMS ON EXTERNAL FILE.
      CANFLG = .TRUE.
C        AT LEAST 9 BLOCKS OF CANNON & 4 PAGES OF I.L. MUST FIT IN CORE
      I = COMN-CFB-9*KCBN-4*KPGN/2+1
      IF(I.GE.0) GOTO 10
C
C---     TERMINATE EXECUTION PHASE FOR LACK OF SPACE
   80 CONTINUE
      CALL CFORM('029002 LARGEST CANONICAL FORM IS TOO LARGE',
     1      DARRAY,1,42)
      CALL CPRINT(DARRAY)
      CALL CFORM('0TABLE SIZES FROM TRANSLATOR',DARRAY,1,28)
      CALL CPRINT(DARRAY)
      CALL BAD(23,0,'IN  ',IN)
      CALL BAD(-1,0,' ',0)
C
      KKMIN=NCFB+MCANPG+MAXSZ1+40
      KKREC=KKMIN+MAXSZ2
      CALL CFORM('0SPACE NOW ALLOCATED ',DARRAY,1,21)
      CALL ICONV(COMN,DARRAY,25,5)
      CALL CPRINT(DARRAY)
      CALL CFORM('0MIN SPACE RQD',DARRAY,1,14)
      CALL ICONV(KKMIN,DARRAY,22,5)
      CALL CFORM('RECOMMENDED SPACE IS',DARRAY,35,20)
      CALL ICONV(KKREC,DARRAY,57,5)
      CALL CPRINT(DARRAY)
C
      CALL HELP
C
C        DIVIDE SPACE LEFT - A BLOCK OF CANNON FOR EACH PAGE OF I.L.
   10 NBLK = I/(KCBN+KPGN/2)+9
C        ADJUST POINTERS
      PPB = (CFB+NBLK*KCBN)*2-1
C        DETERMINE NUMBER OF ADDITIONAL WORDS REQUIRED FOR EACH TYPE OF
C        CANNONICAL FORM.
      ISCN = (SCN/KCBN+1)*2
      ISAN = (SAN/KCBN+1)*2
      INSN = (NSN/KCBN+1)*11
      SAP = SCP+((SCN+ISCN)/KCBN+1)*KCBN
      NSP = SAP+((SAN+ISAN)/KCBN+1)*KCBN
      IAP = NSP+((NSN+INSN)/KCBN+1)*KCBN
C
      IF(.NOT.CILPRT) GOTO 20
      CALL CFORM(' XCANON IN EFFECT ',DARRAY,1,17)
      CALL CPRINT(DARRAY)
   20 RETURN
      END
**** SOURCE FILE : M0004105.W03   ***
*
C.....FORTRAN SUBROUTINE  ....INTRP          8/68                 HG
C.....FORTRAN ROUTINE              ..INTRP..   HL GRAY 3/68         *ID*
      SUBROUTINE INTRP
C FORTRAN SUBROUTINE 'INTRP', THE MAIN INTERPRETER
C
C PURPOSE      THIS ROUTINE EXECUTES APT INTERMEDIATE LANGUAGE
C              INSTRUCTIONS ONE-BY-ONE.
C
C LINKAGE      CALL INTRP
C
C ARGUMENTS    THROUGH COMMON
C
C SUBSIDIARIES 'ADV'     ADVANCE LOCATION COUNTER
C              'SET'     SET LOCATION COUNTER
C              'LIB'     CALL LIBRARY ROUTINE
C               GET      OBTAIN AN OPERAND OR OPERAND ADDRESS
C               RESRV    RESERVE STORAGE ROUTINE
C               PUT      STORE OPERAND
C               SEQ      SEQUENCE ROUTINE
C               APT295   EXPONENTIATION ROUTINE
C
C
C METHOD       THE INTERMEDIATE LANGUAGE OPCODE IS EXTRACTED (L300).
C              A BRANCH THEN OCCURS TO A SMALL SUBSECTION WHICH
C              EXECUTES THE INSTRUCTION.
C
C              IF THE INSTRUCTION DOES NOT CONTAIN A JUMP, THE RETURN
C              CAUSES THE PSEUDOLOCATION COUNTER TO ADVANCE ONE
C              INSTRUCTION (L200), THEN EXTRACTION OCCURS
C
C              IF THE INSTRUCTION CONTAINS A JUMP, THE PSEUDOLOCATION
C              COUNTER IS RESET TO THE DESTINATION INSTRUCTION AND THE
C              RETURN IS TO THE EXTRACTION PROCESS.
C
C--------------------------------------------------------------CDE PAK
C
C
C
C
C UNLABELED COMMON
C
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
C
C
C
C STOR--COMMON CONTAINING STORAGE PARAMETERS
C
C
      COMMON/STOR/  NTB,      FPB,      PPB,      COMN,  CFB
      INTEGER       NTB,      FPB,      PPB,      COMN,  CFB
C
C
C WORK--COMMON CONTAINING WORKING VARIABLES
C
C
      COMMON/WORK/  PGC,      PGCN,     ILC,      IXC
      INTEGER       PGC,      PGCN,     ILC,      IXC
C
      COMMON/WORK/  SCP,      SAP,      NSP,      IAP,   CFP,   COMP
      INTEGER       SCP,      SAP,      NSP,      IAP,   CFP,   COMP
C
      COMMON/WORK/         NTP,   LNA,   RTP
      INTEGER  FPP,    NTP,    LNA,    RTP
      EQUIVALENCE  (FPP,   NTP)
      DIMENSION                   LNA(2,20)
C
C
C
C CONST--COMMON CONTAINING CONSTANTS
C
C
      COMMON/CONST/KCOMT,KCOMF,CILPRT,KCBN
      LOGICAL CILPRT
C
C
      INCLUDE 'DARRAY.INC'
C
C
      COMMON/ILD/ILD
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
C
C---------------------------------------------------------------------
      INTEGER       XCANON
      EXTERNAL  GET,XCANON
      INTEGER  OP,LN,COMP1,I,J,K,NTP1,NTP2,KOUNT,TT,X4
      DIMENSION LN(2),TT(2),X4(2)
      DOUBLE PRECISION XTEMP,A,B,C,GET,X8
      EQUIVALENCE (XTEMP,TT(1)),(X8,X4(1))
      DOUBLE PRECISION XL
      DIMENSION LL(2)
      EQUIVALENCE (LL(1),XL)
      LOGICAL CKDEF
      DATA LL(2)/0/
      DATA ISPECL /319951634/
C
C
C
C        ADVANCE PSEUDOLOCATION COUNTER
C
  200 CALL ADV
C
C        EXTRACT OPCODE FROM INSTRUCTION AND EXECUTE IT.
  300 OP = PP(ILC)
      J=PP(ILC+1)+ILC+1
      IF(.NOT.CILPRT) GO TO 2
C  PRINT COMPRESSED I.L.
      JC = J
      CALL CFORM('PAG',DARRAY,2,3)
      CALL ICONV(PGC,DARRAY,5,4)
      CALL CFORM('(    ),LOC(      )',DARRAY,9,18)
      CALL ICONV(IXC,DARRAY,10,4)
      CALL ICONV(ILC,DARRAY,20,6)
      IF(OP.EQ.21) JC = ILC+3
      I=ILC
 8999 L=29
 9000 K=PP(I)
      CALL ICONV(K,DARRAY,L,5)
      L=L+6
      IF (K.NE.7.OR.I.LT.ILC+2) GO TO 99
C            1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
      GOTO (98,98,98,98,98,99,99,99,99,99,98,99,98,99,98,99,98,98,98,
     +      99,99),OP
   98 IF (PP(I-1).EQ.5.OR.PP(I-1).EQ.6)GOTO 99
      X4(1)=PP(I+1)
      X4(2)=PP(I+2)
      CALL FCONV(X8,DARRAY,L,12,5)
      I=I+2
      L=L+13
   99 IF(I.EQ.JC) GO TO 9002
      I=I+1
      IF(L.LT.101) GO TO 9000
      CALL CPRINT(DARRAY)
      GO TO 8999
 9002 CALL CPRINT(DARRAY)
      IF(OP.NE.21) GO TO 2
 9003 L=K
      IF(K.GT.92) L=92
      CALL HOLFRM(PP(I+1),DARRAY,25,L,NW)
      CALL CPRINT(DARRAY)
      IF(K.LE.92)  GO TO 2
      I=I+NW
      K=K-92
      GO TO 9003
    2 IF(OP.LT.1.OR.OP.GT.21) GO TO 9020
      ILD=0
C
C OPCODE     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
C
      GO TO (1,1,1,1,1,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),OP
C            . . . . . . . . .  .  .  .  .  .  .  .  .  .  .  .  .
C            . . . . . . . . .  .  .  .  .  .  .  .  .  .  .  .  .
C            . . . . FEXP. . .  RETMC .  .  .  ASNADD.  .  .  VBLJMP
C            . . . FDIV. . . SEQNCE.  .  .  CALMC .  .  .  MOVE  .
C            . . FMPY  . . JUMP    .  .  CVTSUB   .  .  CALL     .
C            . FSUB    . ENTRY     .  RESRV       .  REPL        .
C            FADD      LABEL       CONJMP         ASNJMP         HOLDAT
C
C
C
C
C
C
C        PROCESS ARITHMETIC OPCODES
C
C
C        GET ARGUMENTS FROM OPERANDS
C
 1    A = GET(4)
      B = GET(6)
C
C        BRANCH TO CALCULATE  C = (A) OPERATION (B)
C
C        OPCODE +     -     *     /    **
      GO TO (1001, 1002, 1003, 1004, 1005), OP
C
C        ADDITION
C
 1001 C = A+B
      GO TO 1006
C
C        SUBTRACTION
C
 1002 C = A-B
      GO TO 1006
C
C        MULTIPLICATION
C
 1003 C = A*B
      GO TO 1006
C
C        DIVISION
C
 1004 C = A/B
      GO TO 1006
C
C        EXPONENTIATION
C
 1005 CALL  APT295(C,A,B)
      GO TO 1006
C
C        STORE RESULT IN FIRST OPERAND AND RETURN
C
 1006 CALL PUT(C,2)
C
      GO TO 200
C
C
C
C
C       PROCESS LABEL INSTRUCTIONS
C        PROCESS LABEL AND ENTRY INSTRUCTIONS
C
C
C        COMPUTE NAME TABLE POINTER, ENTER LINE, AND RETURN
C
 6    NTP = NTB + PP(ILC + 2)
      NT(1,NTP) = PP(ILC + 3)
      NT(2,NTP) = PP(ILC + 4)
      GO TO 200
C
C
C       PROCESS ENTRY INSTRUCTION (THIS ALSO USED AS A NOOP INSTRUCTION)
C
C
    7 GO TO 200
C
C
C        PROCESS JUMP INSTRUCTION
C
C
C        GET INDEX OF LABEL
C
 8    NTP1 = PP(ILC+2)
C
C
C        COMPUTE NAME TABLE POINTER--ALSO ENTRY FROM CONJMP INSTRUCTION
C
 8001 NTP = NTP1 + NTB
C
C        EXTRACT LINE
      LN(1) = NT(1,NTP)
      LN(2) = NT(2,NTP)
C
C        RESET LOCATION COUNTER
C
      CALL SET(LN)
C
C        AND RETURN
      GO TO 300
C
C
C
C
C        PROCESS SEQUENCE INSTRUCTION
C
C
 9    CALL SEQ(PP(ILC +2))
      ISCHRO=0
      GO TO 200
C
C
C
C
C        PROCESS RETMAC INSTRUCTION
C
C        SET LOCATION COUNTER TO TOP OF MACRO STACK
C
 10   CALL SET(LNA(1,RTP))
C
C        POP UP MACRO STACK
      RTP = RTP-1
C
C        ADVANCE LOCATION COUNTER
      GO TO 200
C
C
C
C        PROCESS CONJUMP INSTRUCTION
C
C
C        GET VALUE OF OPERAND
C
 11   A = GET(2)
C
C        TEST VALUE AND GO TO JUMP WITH PROPER POINTER
C
C              )0     =0     >0
      IF (DABS(A) .LT.  1.0D-12) GO TO 11002
      IF (A) 11001, 11002, 11003
C
11001 NTP1 = PP(ILC + ILD + 4)
      GO TO 8001
C
11002 NTP1 = PP(ILC + ILD + 5)
      GO TO 8001
C
11003 NTP1 = PP(ILC + ILD + 6)
      GO TO 8001
C
C
C
C
C        PROCESS RESRV INSTRUCTION
C
C        ALL RESRS INSTRUCTIONS EXECUTED DURING INITIALIZATION
C
12    CALL RESRV
      GO TO 200
C
C
C
C
C        PROCESS CVTSUB
C
C
C        GET SUBSCRIPT
C        FIND LOCATION OF X(I)
 13    I  = GET(6)
      NTP = NTB + PP(ILC+5)
      KSIZE = PP(ILC+8)+1
      LOCX1=NT(1,NTP) - CFB
      LOCXI=LOCX1-(I  -1)*KSIZE
      IF(.NOT.CANFLG) GOTO 1310
C        IS X(I) IN FIRST BLOCK OF X ARRAY
      IF(LOCX1  /KCBN.EQ. LOCXI  /KCBN) GOTO 1310
C        NO,FIND NO. OF ELEMENTS OF X IN FIRST BLOCK
      NF = MOD(LOCX1,KCBN)/KSIZE+1
C        FIND NO. OF  FULL BLOCKS OF X ELEMENTS
      NBK= (I-NF)/((KCBN-1)/KSIZE)
C        FIND NO. OF ELEMENTS OF X IN MIDDLE BLOCKS
      NM =          NBK          *((KCBN-1)/KSIZE)
C        FIND  NO. OF ELEMENTS OF X IN LAST BLOCK
      NL =  I   - NF - NM
      LOCXI=LOCX1-(NF+NL-1)*KSIZE-NBK*KCBN-1
      IF(NL.EQ.0)LOCXI=LOCXI+MOD(KCBN-1,KSIZE)+1
C
C        STORE ADDRESS
 1310 NTP = NTB + PP(ILC+3)
      NT(1,NTP) = LOCXI + CFB
C
C  CHECK IF INDEX IS IN RANGE.
      IF(LOCXI+CFB.GT.IAP) GOTO 9010
      IX = LOCXI+CFB
      IF(CANFLG)IX= XCANON(IX)
      IF(KSIZE.EQ.2) GOTO 1320
      CALL UNPACK(COM(IX),IM,IS,IX)
      IF(IX.EQ.0) IX=1
 1330 IF(IX.NE.I) GOTO 9010
      GO TO 200
 1320 IX = COM(IX+1)
      GOTO 1330
C
C
C
C     PROCESS CALMC INSTRUCTION
C
C        PUSH DOWN MACRO STACK
C
14    RTP = RTP + 1
C
C        SAVE LINE(PAGE AND INDEX  OF THIS INSTRUCTION
C
      LNA(1,RTP) = PGC
      LNA(2,RTP) = IXC
C
C        RESET LOCATION COUNTER TO MACRO ADDRESS
C
      NTP = PP(ILC + 2) + NTB
      CALL SET(NT(1,NTP))
      GO TO 300
C
C
C        PROCESS ASNADD INSTRUCTION
C
C        GET COM POINTER OF OPERAND
   15 CONTINUE
      KZTEMP=PP(ILC+3)
      IF(KZTEMP.NE.1) GO TO 1510
C---     SPECIAL ACTION FOR NUMBER ASSIGNMENT IN PAGING ENVIRONMENT
      NTP=NTB+PP(ILC+2)
      NT(1,NTP)=PP(ILC+4)
      NT(2,NTP)=ISPECL
      GO TO 200
 1510 CONTINUE
      XTEMP=GET(3)
      NTP=NTB+PP(ILC+2)
      NT(1,NTP)=COMP
      NT(2,NTP)=0
      GO TO 200
C
C
C        PROCESS ASNJMP INSTRUCTION
C
C        COMPUTE THE TWO NAME TABLE POINTERS, TRANSFER DATA AND EXIT
C
16    NTP1 = NTB + PP(ILC + 2)
      NTP2 = NTB + PP(ILC + 3)
      NB(NTP1) = NB(NTP2)
      GO TO 200
C
C
C        PROCESS REPL INSTRUCTION
C
C        GET COM POINTER OF OPERAND
 17   XTEMP = GET(3)
      COMP1 = COMP
C
C        GET COM POINTER OF RESULTANT
      XTEMP = GET(5)
      IF(.NOT.CANFLG) GOTO 1705
      COMP1 = XCANON(COMP1)
      COMP = XCANON(COMP)
C  ABFANGEN BEI FEHLERHAFTEM EINGABEELEMENT
 1705 LLLL=PP(ILC+5)
      IF(LLLL.GT.0.AND.LLLL.NE.3)GOTO 1709
      LLL=0
      IF(LLLL.LT.0) LLL=1+LLLL
      IF(.NOT.CKDEF(COM(COMP+LLL))) GOTO 1709
      GOTO 1708
C        REPLACE ELEMENTS
 1709 KOUNT = PP(ILC + 2)
      DO 1710 I=1,KOUNT
      COM(COMP1) = COM(COMP)
      COMP = COMP + 1
 1710 COMP1= COMP1+ 1
C
      GO TO 200
C
C
C        PROCESS CALL INSTRUCTION
C
 18   IF(ISCHRO.NE.0) GOTO 181
      CALL LIB
 181  IF(PP(ILC+2).EQ.18) RETURN
      GO TO 200
C
C
C        PROCESS MOVE INSTRUCTION
C
C        GET COM POINTER OF OPERAND
 19   XTEMP = GET(2)
      COMP1 = COMP
      IF(CANFLG) COMP1 = XCANON(COMP1)
C
C        MOVE ELEMENTS
      KOUNT = PP(ILC+1)
      DO 1910 I=4,KOUNT,2
      K=ILC+ILD+I
      IF (K.GE.J)GOTO 200
      COM(COMP1) = GET(I)
      LLLL=PP(K)
      IF(LLLL.GT.0.AND.LLLL.NE.3) GOTO 1910
      LLL=0
      IF(LLLL.LT.0) LLL=1+LLLL
      COMP=COMP+LLL
      IF(CANFLG) COMP=XCANON(COMP)
      IF(.NOT.CKDEF(COM(COMP))) GOTO 1910
      COMP1=COMP
      GOTO 1708
 1910 COMP1 =COMP1 + 1
C
      GO TO 200
C
C
C        PROCESS VBLJMP INSTRUCTION
C
C        OBTAIN INDEX TO JUMP
C.... USING MODIFIED IL FOR INDEX WHICH IS NOT SYSTEM DEPENDENT
   20 XTEMP=GET(2)
      KOUNT=INT(XTEMP)
C
C        IF INDEX NOT IN RANGE,CONTINUE
      IF(KOUNT.GE.(PP(ILC+1)-1).OR.KOUNT.LE.0) GO TO 200
C
C        GO TO LABEL INDICATED BY INDEX
      KOUNT = KOUNT + ILC + 3
      NTP1 = PP(KOUNT)
      GO TO 8001
C
C
C        PROCESS HOLDAT INSTRUCTION
C
C        THE FOLLOWING CODE IS IMPLIMENTATION DEPENDENT             *ID*
C        ALL HOLDAT INSTRUCTIONS EXECUTED DURING INITIALIZATION
C
C        STORE NUMBER OF WORDS OF BCD DATA
 21   TT(1) = PP(ILC+1)
C
C        STORE NUMBER OF CHARACTERS
      TT(2) = PP(ILC+3)
C
      L=IAP
C
C        STORE CHARACTERS
      K=PP(ILC+3)/8
      IF (PP(ILC+3).GT.K*8) K=K+1
      IF(.NOT.CANFLG) GOTO 2105
C        WILL STORAGE REQUIREMENTS EXCEED BLOCK LENGTH
      IF((L-CFB+K)/KCBN.EQ.(L-CFB)/KCBN) GOTO 2102
C        YES,INDICATE NO. OF WORDS TO BE SKIPPED.
      J= XCANON(L)
      LL(1)=KCBN-MOD((L-CFB),KCBN)
      IA(J)=XL
C        SKIP TO NEXT BLOCK OF STORAGE
      L=((L-CFB+K)/KCBN)*KCBN+CFB
      IAP=L
 2102 L=XCANON(L)
 2105 IA(L)=XTEMP
      DO 2110 I = 1,K
      L=L+1
      J = ILC + 2*(I+1)
C
C        OBTAIN CHARACTERS ONE INTEGER WORD FULL AT A TIME
      TT(1) = PP(J)
      TT(2) = PP(J+1)
      IA(L)=XTEMP
C
C        STORE CHARACTERS EIGHT AT A TIME
 2110               CONTINUE
C        STORE POINTER
      NTP = NTB+PP(ILC+2)
      NT(1,NTP) = IAP
      IAP = IAP + K + 1
C
      GO TO 200
C
C
 9010 CALL RECORD (SQNC)
      CALL CFORM('029003 INDEX OUT OF RANGE. ISN=',DARRAY,1,31)
      CALL ICONV (SQNC,DARRAY,32,4)
      CALL CFORM (' INDEX=',DARRAY,36,7)
      CALL ICONV (I,DARRAY,41,5)
      CALL CPRINT(DARRAY)
      CALL HELP
 9020 CALL RECORD(SQNC)
      CALL CFORM('029004 SYSTEM ERR-ILLEGAL I.L. INSTRUCTION. ISN= '  ,
     X    DARRAY,1,49)
      CALL ICONV (SQNC,DARRAY,51,4)
      CALL CPRINT(DARRAY)
      CALL HELP
      RETURN
C  AUSGABE DER FEHLERHAFTEN GEOMETRIE-NAMEN
 1708 ISCHRO=1
      IF(COMP1.GE.SCP) GOTO 1720
C  NAME EINES SKALARELEMENTES
      ISIZE=1
      ISUB=0
      GOTO 1750
 1720 IF(COMP1.GE.SAP) GOTO 1730
C  NAME EINES INDIZIERTEN SKALARELEMENTES
      ISIZE=2
      ISUB=COM(COMP1+1)
      ISIZE1=ISUB*2
      GOTO 1750
C  NAME EINES GEOMETRIEELEMENTES
 1730 CALL UNPACK(COM(COMP1),MODE,ISIZE,ISUB)
      IF(ISUB.GE.1) ISIZE1=ISUB*ISIZE+ISUB-1
 1750 CALL CFORM(' WRONG INPUT ELEMENT        :',DARRAY,1,29)
      IF(ISUB.GE.1) GOTO 1706
C  NICHT INDIZIERTE VARIABLE
      CALL HOLFRM(COM(COMP1+ISIZE),DARRAY,30,8,NWD)
      GOTO 1707
C  INDIZIERTE VARIABLE
 1706 CALL HOLFRM(COM(COMP1+ISIZE1),DARRAY,30,8,NWD)
      CALL CFORM('(      )',DARRAY,38,8)
      CALL ICONV(ISUB,DARRAY,40,4)
 1707 CALL CPRINT(DARRAY)
      GOTO 200
      END
**** SOURCE FILE : M0002658.W03   ***
*
C.....FORTRAN SUBROUTINE  ....LIB            8/68                 HG
C.....FORTRAN ROUTINE              ..LIB..     HL GRAY 3/68         *ID*
      SUBROUTINE  LIB
C--------------------------------------------------------------CDE PAK
C
C
C
C UNLABELED COMMON
C
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
C
C
C
C STOR--COMMON CONTAINING STORAGE PARAMETERS
C
C
      COMMON/STOR/  NTB,      FPB,      PPB,      COMN,  CFB,  NBLK
      INTEGER       NTB,      FPB,      PPB,      COMN,  CFB,  NBLK
C
C   ADDITIONAL STOR PARAMETERS USED FOR NUMBER TABLE DIRECT ACCESS
C
      COMMON/STOR/  NRECRD,  NTPARM
      DIMENSION     NRECRD(10), NTPARM(10)
      EQUIVALENCE   (NTPARM(1),NUMBST), (NTPARM(2),NUMOD ),
     .              (NTPARM(3),NDAFLG), (NTPARM(4),NRECST),
     .              (NTPARM(5),IPAGE )
C
C
C WORK--COMMON CONTAINING WORKING VARIABLES
C
C
      COMMON/WORK/  PGC,      PGCN,     ILC,      IXC
      INTEGER       PGC,      PGCN,     ILC,      IXC
C
      COMMON/WORK/  SCP,      SAP,      NSP,      IAP,   CFP,   COMP
      INTEGER       SCP,      SAP,      NSP,      IAP,   CFP,   COMP
C
      COMMON/WORK/         NTP,   LNA,   RTP
      INTEGER  FPP,    NTP,    LNA,    RTP
      EQUIVALENCE  (FPP,   NTP)
      DIMENSION                   LNA(2,20)
C
      COMMON/WORK/XXX( 1),AVT,IWRIT
      INTEGER                            AVT
      DIMENSION                                AVT(32)
C
C CONST--COMMON CONTAINING CONSTANTS
C
C
      COMMON/CONST/KTEMPB,KCOMF
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
      INCLUDE 'DARRAY.INC'
C
      COMMON/SQNC/SQNO
      INTEGER SQNO
C
C---------------------------------------------------------------------
      EXTERNAL XCANON
      INTEGER PTABLE,N,I,J,K,TERM,XCANON
      DIMENSION PTABLE(50)
      DATA TERM/-999/,ISPECL/319951634/
C
      N=PP(ILC+1)
      K=1
      KK=IWRIT
      JTEMP=KTEMPB
C
C.....ENTER MODE OF SUBROUTINE TO BE CALLED,INTO PARM. TABLE
      IF(PP(ILC+2).LT.1000) GOTO 80
      NTP = PP(ILC+2)-1000+NTB
      PTABLE(1)=-NT(1,NTP)
      GOTO 90
 80   PTABLE(1)=-PP(ILC+2)
C
C.....IF NO PARAMETERS, TERMINATE.
 90   IF(N.EQ.1) GOTO 20
C
C
C.....GENERATE INDEX TO COM FOR EACH PARAMETER.  PARAMETERS CONSIST OF
C     TWO PARTS(TYPE AND A POINTER).
      N=ILC+N+1
      III=ILC+3
      I=III
      DO 10 M=III,N,2
      J=PP(I)+1
C
C.....CHECK PARM. TYPE.
      IF(J.LE.0)GOTO 160
      GOTO (100,110,120,130,140,150,180,190),J
C
C.....  TYPE 0,3  NAME TABLE HOLDS INDEX TO COM FOR PARAMETER
  130 CONTINUE
      NTP=NTB+PP(I+1)
      IF(NT(2,NTP).NE.ISPECL) GO TO 131
C---    INDIRECT REFERENCE IS TO A LITERAL NUMBER, MODIFY
C---    NUMBER TABLE INDEX BY PAGING IF NECESSARY
      KZTEMP=NT(1,NTP)
      IF(NDAFLG.NE.0) CALL XNUMBR(KZTEMP)
      COMP=FPB+KZTEMP
      GO TO 165
  131 CONTINUE
      COMP=NT(1,NTP)
      GO TO 165
  100 CONTINUE
      NTP=NTB+PP(I+1)
      COMP=NT(1,NTP)
      GOTO 165
C
C.....TYPE 1 - FLOATING POINT NUMBERS STORED IN NUMBER TABLE
C.....STORE EACH VALUE IN TEMPORARY UNTIL THIS CALL IS COMPLETED
  110 IPNTR=PP(I+1)
      IF (NDAFLG .NE. 0) CALL XNUMBR(IPNTR)
      IPNTR=NTB+IPNTR
      COM(JTEMP)=COM(IPNTR)
      GO TO 155
C.....TYPE 2 - NAMETABLE HAS ACTUAL VALUE. CALCULATE INDEX TO COM.
  120 COMP=NTB+PP(I+1)
      GOTO 170
C
C.....TYPE 4 PARM. IS THE MODE NO. OF A ROUTINE
  140 COMP= -PP(I+1)
      GOTO 170
C
C.....TYPE 5, PARM IS AN INTEGER LITERAL.
  150 CM(1,JTEMP)=PP(I+1)
  155 COMP=JTEMP
      JTEMP=JTEMP+1
      IF (JTEMP .LE. 16+KTEMPB)GO TO 170
      GO TO 25
C
C.....TYPE 6, PARM IS AN UNFRACTIONAL NUMBER
  180 COM(JTEMP)=PP(I+1)
      GOTO 155
C
C.....TYPE 7, PARM IS A FRACTIONAL NUMBER
  190 CM(1,JTEMP) = PP(I+1)
      CM(2,JTEMP) = PP(I+2)
      I=I+1
      GOTO 155
C
C.....NAMETABLE CONTAINS INDEX TO INTERNAL ARRAY.  J POINTS TO ELEMENT
C     OF THAT ARRAY
  160 NTP=NTB+PP(I+1)
      COMP=NT(1,NTP)-J
  165 IF(CANFLG) COMP=XCANON(COMP)
  170 K=K+1
C
C.....FILL PARAMETER TABLE.
      PTABLE(K)=COMP
      I=I+2
   10 CONTINUE
C
C
C        ARE MORE BLOCKS OF CANNON REQUIRED THAN SPACE ALLOWS
   20 IF(IWRIT-KK.LT.NBLK.OR..NOT.CANFLG) GOTO 30
   25 CALL CFORM('029006 SYSTEM ERR-ILLEGAL I.L. CALL. ISN= ',
     C  DARRAY,1,41)
      CALL ICONV(SQNO,DARRAY,42,4)
      CALL CPRINT(DARRAY)
      CALL HELP
C..... TERMINATE PARM.  TABLE
   30 PTABLE(K+1)=TERM
C
C.....CALL ROUTINE WHICH CHANGES INDICES TO ADDRESSES AND PREFORMS THE
C     ACTUAL CALL TO SUBROUTINE INDICATED BY THE I.L..
      CALL XCALL(PTABLE)
      RETURN
      END
**** SOURCE FILE : M0004101.V11   ***
*
C
C.....IMPLEMENTATION DEPENDENT FUNCTION     .....PAGE...    8/68     HG
C.....FORTRAN FUNCTION              ..PAGE..     HG   6/68
C
      INTEGER FUNCTION PAGE(M)
C
C
C PG.C1        LOAD POINT OF CURRENT PAGE
C PG.P         LOAD POINT FOR LAST PAGE LOADED
C PG.L         LAST PAGE TO BE LOADED. =0 DURING LOADING OF LABEL,RESERV
C              TEXT
C PAG          TABLE GIVING LOCATION OF A PAGE.  IF PAGE NOT
C              IN CORE,TABLE ENTRY = 0.
C I.PG.P       PAGE INITIAL LOAD POINT
C N            NUMBER OF REQUIRED PAGE
C I            = 1 FOR PART PROGRAM TEXT,=2 FOR MACRO TEXT
C
C
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
C
      COMMON/STOR/ NTB, FPB, PPB, COMN
      INTEGER      NTB, FPB, PPB, COMN
      COMMON/WORK/ PGC
      INTEGER      PGC
C
C...            SYSTEM I/O FILE NAMES
C
      INCLUDE 'SYMFIL.INC'
C
      INCLUDE 'DARRAY.INC'
C
      INTEGER N,PGL,I,PGP,ELFIL,JN,IPGP,PGC1
      INTEGER   PAG
      INTEGER DIAG
      DIMENSION PAG(600,2),PGL(2),ELFIL(2)
      LOGICAL PAGFLG
      EQUIVALENCE (ELFIL2,ELFIL(1))
C
      SAVE PGP,PGC1,PAG,PGL
C
      DATA PGP/2000000/,PGC1/0/,PAG/1200*0/,PGL/2*0/
C
C
      N = M
C CHECK IF N WITHIN LIMITS
      IF(IABS(N).GT.600)GOTO 9998
C
C SET PAGE TYPE INDICATOR I.
      I=1
      IF(N)110,9998,120
  110 N=-N
      I=2
C
C IS PAGE IN CORE
  120 IF(PAG(N,I).NE.0)GOTO 140
C
C NO
C IS PAGE TO BE LOADED LABEL,RESERV TEXT
      IF(PGL(1).NE.0)GOTO 200
C
C YES
C LOAD LABEL,RESERV TEXT
      JN=0
      CALL AREAD(ELFIL1,JN,PP(PPB),256,IR)
      IF(IR.EQ.1) GO TO 400
C INDICATE BEGINNING OF PAGE
      PAGE=PPB
C
C KEEP CURRENT PAGE NUMBER AT 0
      PGC=-1
      RETURN
C
C
C NO.  MACRO OR PART PROGRAM TEXT
C BEGIN CYCLIC SEARCH
  200 PAGFLG=.TRUE.
C
C HOLD STARTING POINT
      IPGP=PGP
C
C OBTAIN NEW LOAD POINT
  210 PGP=PGP+256
C
C WILL PAGE BE OUTSIDE LIMITS OF STORAGE
      IF(PGP+255.LE.COMN*2)GOTO 220
C
C YES
C RETURN POINTER TO INITIAL LOAD POINT
      PGP=PPB
C
C HAS COMPLETE CYCLE BEEN MADE
  220 IF(IPGP.NE.PGP)GOTO 230
C
C YES,A MACRO TEXT PAGE MAY NOW BE SCRATCHED
      PAGFLG=.FALSE.
      GOTO 210
C
C NO,CYCLE NOT COMPLETE
C IS LOAD POINT AT CURRENT PAGE
C IF YES, CONTINUE SEARCH, CURRENT PAGE IS NOT TO BE SCRATCHED
  230 IF(PGP.EQ.PGC1)GOTO 210
C
C NO
C CAN MACRO TEXT BE SCRATCHED
      IF(.NOT.PAGFLG)GOTO 300
C
C NO,IS PAGE MACRO TEXT.  IF YES CONTINUE SEARCH.
      IF(PP(PGP).LT.0)GOTO 210
C
C PAGE CAN BE SCRATCHED
C  REMOVE REFERENCE TO DELETED PAGE
  300 K = 1
      J = PP(PGP)
      IF(J.EQ.0) GOTO 306
      IF(J.GT.0) GOTO 303
      J = - J
      K = 2
  303 PAG(J,K) = 0
C
C NEXT
C LOAD DESIRED PAGE
  306 CALL AREAD(ELFIL(I),N,PP(PGP),256,IR)
      IF(IR.EQ.1) GO TO 9998
C
C SAVE NUMBER OF LAST PAGE TO BE LOADED
  130 PGL(I)=N
C
C SET POINTER TO PAGE
C---    STORE A COMPACT VERSION OF THE PAGE LOCATION IN PAG
      PAG(N,I)=(PGP-1)/2
C
C INDICATE STARTING LOCATION OF PAGE
C---    RETRIEVE THE CURRENT PAGE LOCATION
  140 PAGE=PAG(N,I)*2+1
C
C SAVE CURRENT PAGE LOAD POINT
      PGC1=PAGE
      RETURN
C
C ERROR TOO MANY PAGES-N TOO LARGE.
 9998 CALL CFORM('029001 TOO MANY STATEMENTS IN THIS PART PROGRAM ',
     C DARRAY,1,47)
      CALL CPRINT (DARRAY)
      CALL  HELP
      RETURN
C
C CLEAR PAGE AREA
  400 PGP=PPB
  410 PP(PGP) = 0
      PGP = PGP + 256
      IF(PGP.GE.COMN*2) GOTO 200
      GOTO 410
      END
**** SOURCE FILE : M0000952.V04   ***
*
C.....FORTRAN SUBROUTINE  ....PUT            8/68                 HG
C.....FORTRAN FUNCTION             ..PUT..     HL GRAY 3/68         *ID*
      SUBROUTINE PUT (ARG, OD)
C
C FORTRAN SUBROUTINE 'PUT (ARG, OD)'--PUT ARGUMENT INTO OPERAND
C
C PURPOSE      TO PUT THE VALUE OF AN ARGUMENT INTO THE PART PROGRAM
C              OPERAND, OD
C
C LINKAGE      CALL PUT(ARG, OD)
C
C ARGUMENTS    ARG    IS THE VALUE TO BE STORED
C              OD     IS THE ORDINAL NUMBER OF THE OPERAND
C
C METHOD       THE OPERAND CONSISTS OF THE ORDERED PAIR (TYPE, VALUE)
C              WHERE--
C
C              TYPE     VALUE
C               0        INDEX TO NAME TABLE WHICH CONTAINS POINTER
C                        TO STORAGE FOR VARIABLE
C               1,2      ERROR CONDITION
C               3        INDEX TO NAME TABLE
C              -N        INDEX TO NAME TABLE WHICH CONTAINS BASE ADDR.
C
C--------------------------------------------------------------CDE PAK
C
C
C
C UNLABELED COMMON
C
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
C
C
C
C STOR--COMMON CONTAINING STORAGE PARAMETERS
C
C
      COMMON/STOR/  NTB,      FPB,      PPB,      COMN
      INTEGER       NTB,      FPB,      PPB,      COMN
C
C
C WORK--COMMON CONTAINING WORKING VARIABLES
C
C
      COMMON/WORK/  PGC,      PGCN,     ILC,      IXC
      INTEGER       PGC,      PGCN,     ILC,      IXC
C
      COMMON/WORK/  SCP,      SAP,      NSP,      IAP,    CFP,    COMP
      INTEGER       SCP,      SAP,      NSP,      IAP,    CFP,    COMP
C
      COMMON/WORK/         NTP,   LNA,   RTP
      INTEGER  FPP,    NTP,    LNA,    RTP
      EQUIVALENCE  (FPP,   NTP)
      DIMENSION                   LNA(2,20)
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
C
C
C---------------------------------------------------------------------
C
      INTEGER OD,K,L,XCANON
      DOUBLE PRECISION ARG
      EXTERNAL XCANON
C
C        EXTRACT TYPE AND ADD ONE FOR 'GO TO' (L)
C
      K=ILC + OD
      L = PP(K) + 1
C
C        EXTRACT VALUE OF OPERAND (K)
C
      K = PP(K+1)
C
C        PUT OPERAND ACCORDING TO TYPE
C
      IF (L .LE. 0) GO TO 50
C
C
C        COMPUTE NAME TABLE POINTER, STORE ARG AND EXIT
C
 10   NTP = NTB + K
      K = NT(1,NTP)
      IF(CANFLG) K=XCANON(K)
      CF(K) = ARG
      RETURN
C
C
C        TYPE -N
C
C        COMPUTE EFFECTIVE ADDRESS = BASE ADDRESS + INDEX,
C        STORE ARGUMENT AND EXIT
C
 50   NTP = NTB + K
      K = NT(1,NTP) - L
      IF(CANFLG) K=XCANON(K)
      IA(K) = ARG
      RETURN
C
      END
**** SOURCE FILE : M0000959.W01   ***
*
C.....FORTRAN SUBROUTINE  ....RESRV          8/68                 HG
C.....FORTRAN ROUTINE              ..RESRV..   HL GRAY 3/68         *ID*
      SUBROUTINE RESRV
C
C FORTRAN SUBROUTINE 'RESRV'--PROCESS INTERMEDIATE LANGUAGE RESRV
C              INSTRUCTION
C
C PURPOSE      TO ESTABLISH STORAGE FOR CANONICAL FORMS AND BLANK COMMON
C              TO PLACE POINTERS IN NAME TABLE
C
C LINKAGE      CALL RESRV
C
C ARGUMENTS    THROUGH COMMON
C
C METHOD       ALL ELEMENTS ARE STORED IN THE CANONICAL FORMS ARRAY   OR
C              BLANK COMMON.  SEPERATE POINTERS ARE MAINTAINED FOR---
C
C                   SCALARS
C                   SCALAR ARRAYS
C                   NONSCALARS
C                   INTERNAL ARRAYS
C                   BLANK COMMON
C
C              MODE AND NUMBER ARE EXAMINED TO DETERMINE WHICH
C              TYPE OF PROCESSING IS REQUIRED.
C
C--------------------------------------------------------------CDE PAK
C
C
C
C UNLABELED COMMON
C
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
C
C
C
C STOR--COMMON CONTAINING STORAGE PARAMETERS
C
C
      COMMON/STOR/  NTB,      FPB,      PPB,      COMN,      CFB
      INTEGER       NTB,      FPB,      PPB,      COMN,      CFB
C
C
C WORK--COMMON CONTAINING WORKING VARIABLES
C
C
      COMMON/WORK/  PGC,      PGCN,     ILC,      IXC
      INTEGER       PGC,      PGCN,     ILC,      IXC
C
      COMMON/WORK/  SCP,      SAP,      NSP,      IAP,   CFP,   COMP
      INTEGER       SCP,      SAP,      NSP,      IAP,   CFP,   COMP
C
      COMMON/WORK/         NTP,   LNA,   RTP
      INTEGER  FPP,    NTP,    LNA,    RTP
      EQUIVALENCE  (FPP,   NTP)
      DIMENSION                   LNA(2,20)
C
C
C CONST--COMMON CONTAINING CONSTANTS
C
      COMMON/CONST/KCOMT,KCOMF,CILPRT,KCBN
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'LDEF.INC'
C
C
C---------------------------------------------------------------------
C
      EXTERNAL XCANON,BCDF
      INTEGER  K,M,N,MODE,P,SIZ,R,P1,P0,R1,R0,XCANON,RR,BCDF
      DIMENSION  P(4),R(4),RR(2)
      DOUBLE PRECISION  NDEX,RR1
      EQUIVALENCE  (P(1),SCP),(RR(1),RR1)
      DATA R/4*128/,RR/2*0/
C
C
      N=PP(ILC+5)
C
      SIZ=PP(ILC+4)+1
      MODE=PP(ILC+3)
      MD=MODE
      IF (MODE.EQ.23)MODE=21
      NTP=NTB+PP(ILC+2)
C        IF MODE IS ZERO, PROCESS AS AN INTERNAL ARRAY
      IF(MODE.NE.0) GOTO 5
      M = 4
      SIZ = SIZ-1
C        IF MODE .GT. 0 AND .NE. 21, PROCESS AS NON-SCALAR
    5 IF(MODE.GT.0 .AND. MODE.NE.21) M=3
C        IF MODE .LT. 0, PROCESS AS BLANK COMMON
      IF(MODE.LT.0) GOTO 50
C        IF MODE IS 21, PROCESS AS A NON- OR SUB- SCRIPTED SCALAR
      IF(MODE.EQ.21 .AND. N.GT.1) M=2
      IF(MODE.NE.21.OR.N.NE.1)GOTO  7
      M=1
      SIZ=SIZ-1
C        CALCULATE INDEX AND REMAINING SPACE IN BLOCK(R0).
    7 NDEX = (MD*100+SIZ-1)*10000
      IF(N.EQ.1)NDEX=NDEX-1.0
      R0 = R(M)
      R1 = 0
C  OBTAIN CURRENT VERTUAL(P0) AND ACTUAL(P1) POINTERS TO BLOCK M.
      P0 = P(M)
      P1 = P0
      IF(.NOT.CANFLG) GOTO 30
   10 P0 = P0 + R1
C        WILL CANNONICAL FORM FIT IN BLOCK
      IF((R0-SIZ*N) .GE. (2-M/4)) GOTO 25
C        NO,SPLIT IF INDEXED
C        HOW MANY ELEMENTS OF ARRAY FIT
      K = (R0-1)/SIZ
C        ENTIRE CANNONICAL FORM CAN NOT FIT
      IF(K.EQ.N ) K = K-1
C        IF NO ELEMENTS FIT, BEGIN NEW BLOCK
      IF(K.NE.0) GOTO 15
      P0 = P0+R0
      R0 = KCBN
      GOTO 10
C        DETERMINE SPACE NOT OCCUPIED
   15 R1 = R0-K*SIZ-1
C        DETERMINE REMAINING SPACE WHICH CAN BE OCCUPPIED
      R0 = R0-R1
      P1 = XCANON(P0)
C        FLAG SPACE THAT IS NOT OCCUPIED
   20 RR(1) = R1
      RR(2) = (P0-CFB)/KCBN+1+BCDF('BK')
      CF(P1) = RR1
C        ADVANCE POINTER
      P0 = P0+R1
   25 P1 = XCANON(P0)
C        INITIALIZE CANNONICAL FORM
   30 GOTO (31,32,33,34), M
C        NON-SUBSCRIPTED SCALAR
   31 CALL TRASH(CF(P1))
      GOTO 34
C        SUBSCRIPTED SCALAR
   32 CALL TRASH(CF(P1))
      CF(P1+1)= N
      GOTO 34
C        NON-SCALAR
   33 CF(P1) = NDEX+N
      CALL TRASH(CF(P1+1))
C        INTERNAL ARRAY REQUIRES NO INITIALIZATION
   34 P1 = P1+SIZ
      P0 = P0+SIZ
      R0 = R0-SIZ
      N = N-1
C        IF NOT ENOUGH SPACE OR NO MORE FORMS OR NOT
C        ENOUGH SPACE FOR LAST FORM, START NEW BLOCK
      IF(CANFLG)GO TO 38
      IF(N.GE.1)GO TO 30
      GO TO 40
   38 IF((R0-SIZ.GE.1).AND.(N.GT.1))GO TO 30
      IF((R0-SIZ.GE.2-M/4).AND.(N.EQ.1)) GOTO 30
C        SAVE SPACE COUNT, INDICATE NEW BLOCK
      R1 = R0
      R0 = KCBN
      RR(1) = R1
      RR(2) = (P0-CFB)/KCBN+1+BCDF('BK')
      CF(P1) = RR1
C        STILL MORE FORMS
      IF(N.GE.1) GOTO 10
C        NO, STORE NAME IF REQUIRED
   40 GO TO (41,41,41,42), M
   41 CF(P1) = NB(NTP)
      P1=P1+1
      P0   = P0+1
      R1   = R1-1
C
   42 IF(.NOT.CANFLG)GOTO 43
      RR(1) = R1
      RR(2)=(P0-CFB)/KCBN+1+BCDF('BK')
      CF(P1) = RR1
   43 P(M) = P0
      R(M) = R1
C         STORE POINTER TO FORM(S)
      IF(M.LE.2)SIZ=SIZ+1
   45 NT(1,NTP) = P0  -SIZ
      RETURN
C
C        BLANK COMMON
C
 50   NTP = NTB + PP(ILC+2)
      NT(1,NTP) = COMP
      COMP = COMP + PP(ILC +5)
      RETURN
      END
**** SOURCE FILE : SAVEAC.V01   ***
*
      SUBROUTINE SAVEAC(AC)
C
C   PURPOSE: SYSTEM INDEPENDENT ROUTINE TO SAVE VALUE REFERENCED BY .AC.
C
      INTEGER AC,XCANON
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
      INCLUDE 'LDEF.INC'
C
      COMMON/STOR/NTB,FPB,PPB,COMN,CFB
      INTEGER NTB,FPB,PPB,COMN,CFB
C
C    .AC. IS IN FIXED LOCATION OF NAMTBL
C
      NTP=NTB+166
C
      J=NT(1,NTP)
      IF (CANFLG)J=XCANON(J)
C
      COM(J)=DBLE(AC)
C
      RETURN
      END
         
**** SOURCE FILE : M0000962.V03   ***
*
C.....IMPLEMENTATION DEPENDENT SUBROUTINE ...SEQ           8/68      HG
C.....FORTRAN ROUTINE              ..SEQ..     HL GRAY 3/68         *ID*
      SUBROUTINE  SEQ (N)
C        THIS ROUTINE EXISTS ONLY BECAUSE     SQNC MAY ONLY APPEAR IN
C        A PROGRAM COMPILED IN EBCDIC.
      COMMON/SQNC/SQNC
      INTEGER  SQNC
      INTEGER N
      SQNC = N
      RETURN
      END
**** SOURCE FILE : M0000732.V07   ***
*
C
C.....FORTRAN ROUTINE              ..SET..     HL GRAY 3/68         *ID*
      SUBROUTINE  SET(LN)
C
C FORTRAN SUBROUTINE 'SET(LN)'  -- SET LOCATION COUNTER TO LINE
C
C PURPOSE      'SET'    SETS THE INTERPRETER PSEUDOLOCATION  COUNTER,
C              'ILC' AND OTHER DEPENDENT VARIABLES TO THE VALUES
C              CORRESPONDING TO THE INPUT LINE.
C
C LINKAGE      CALL SET(LN)
C
C              WHERE
C              LN IS ANY LINE
C
C--------------------------------------------------------------CDE PAK
C
C
C
C UNLABELED COMMON
C
C
       INCLUDE 'BLANKCOM.INC'
       INCLUDE 'INTRPEQ.INC'
C
C
C
C
C WORK--COMMON CONTAINING WORKING VARIABLES
C
C
      COMMON/WORK/  PGC,      PGCN,     ILC,      IXC
      INTEGER       PGC,      PGCN,     ILC,      IXC
C
C
C
C---------------------------------------------------------------------
C
      INTEGER SQNC
C
      INCLUDE 'DARRAY.INC'
C
C         LN IS ANY LINE(PAGE AND INDEX)
      INTEGER LN
      DIMENSION LN(2)
C
      EXTERNAL PAGE
      INTEGER  PAGE
      LN1=IABS(LN(1))
      IF((LN1.GT.0.AND.LN1.LE.400).AND.(LN(2).GT.0.AND.
     1 LN(2).LE.256)) GOTO 100
      CALL RECORD(SQNC)
      CALL CFORM('029007 UNDEFINED LABEL REFERENCED. ISN=',DARRAY,1,39)
      CALL ICONV(SQNC,DARRAY,40,4)
      CALL CPRINT(DARRAY)
      CALL HELP
C
C        SET LOCATION COUNTER TO BEGINNING OF PAGE
C
  100 ILC = PAGE(LN(1))
C
C        SET NEW PAGE NUMBER AND INDEX
C
      PGC = LN(1)
C
      IXC = LN(2)
C
C
C        SET NUMBER OF WORDS ON CURRENT PAGE
C
      PGCN = PP(ILC+1)+2
C
C        ADVANCE LOCATION COUNTER TO INSTRUCTION
C
      ILC = ILC + IXC -1
      RETURN
      END
**** SOURCE FILE : UNASGN00.ORG   ***
*
      SUBROUTINE UNASGN
*
*     CALL ABNEND TO TERMINATE PROCESSING
*
      CALL ABNEND
      RETURN
      END
**** SOURCE FILE : XCALL000.V06   ***
*
      SUBROUTINE XCALL(IP)
*
*  *  XCALL  *   VAX11 FORTRAN VERSION  17.3.82  E.MCLELLAN
*
*  PURPOSE    TO CONVERT THE PARAMETER LIST GENERATED BY 'LIB'
*             TO ACTUAL ADDRESSES IN UNLABELLED COMMON AND TO
*             PERFORM THE NECESSARY SUBROUTINE CALL
*  CALLING SEQUENCE
*             CALL XCALL(IP)
*  ARGUMENTS
*             IP   PARAMETER LIST
*
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C   UNLABELED COMMON
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
C
      DIMENSION IP(50)
      INTEGER TERM,AC,APT201
      DATA TERM/-999/
C
C
C   SUBROUTINE MODE
C
      MODE=-IP(1)
C
C   BRANCH ACCORDING TO SUBROUTINE MODE
C
      GOTO (  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15,
     1       16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30,
     2       31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45,
     3       46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60,
     4       61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75,
     5       76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90,
     6       91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,
     7      106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,
     8      121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,
     9      136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,
     A      151,152,153,154,155,156,157,158,159,160,161,162,163,164,165,
     B      166,167,168,169,170,171,172,173,174,175,176,177,178,179,180,
     C      181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,
     D      196,197,198,199,200,201,202,203,204,205,206,207,208,209,210,
     E      211,212,213,214,215,216,217,218,219,220,221,222,223,224,225,
     F      226,227,228,229,230,231,232,233,234,235,236,237,238,239,240,
     G      241,242,243,244,245,246,247,248,249),MODE
      CALL ABNEND
      RETURN
C
    1 CALL TLLFT
      RETURN
    2 CALL TLRGT
      RETURN
    3 CALL TLON
      RETURN
    4 CALL TLONPS
      RETURN
    5 CALL TLOFPS
      RETURN
    6 CALL MULTAX(COM(IP(2)))
      RETURN
    7 CALL NOPS
      RETURN
    8 CALL AUTOPS
      RETURN
    9 CALL CUT
      RETURN
   10 CALL DNTCUT
      RETURN
   11 CALL NDTEST
      RETURN
   12 CALL COMP3D
      RETURN
   13 CALL GOUGCK(COM(IP(2)))
      RETURN
   14 CALL UNASGN
      RETURN
   15 CALL UNASGN
      RETURN
   16 CALL UNASGN
      RETURN
   17 CALL REFSYS(COM(IP(2)))
      RETURN
   18 CALL FINI
      RETURN
   19 CALL UNASGN
      RETURN
   20 CALL UNASGN
      RETURN
   21 CALL UNASGN
      RETURN
   22 CALL DYNDMP(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
   23 CALL ZSURF(COM(IP(2)))
      RETURN
   24 CALL UNASGN
      RETURN
   25 CALL GO(COM(IP(2)),COM(IP(3)))
      RETURN
   26 CALL GODLTA(COM(IP(2)),COM(IP(3)))
      RETURN
   27 CALL TOLER(CM(1,IP(2)),COM(IP(3)))
      RETURN
   28 CALL INTOL(CM(1,IP(2)),COM(IP(3)))
      RETURN
   29 CALL OUTTOL(CM(1,IP(2)),COM(IP(3)))
      RETURN
   30 CALL CUTTER(CM(1,IP(2)),COM(IP(3)))
      RETURN
   31 CALL MAXDP(COM(IP(2)),COM(IP(3)))
      RETURN
   32 CALL NUMPTS(COM(IP(2)))
      RETURN
   33 CALL THICK(CM(1,IP(2)),COM(IP(3)))
      RETURN
   34 CALL UNASGN
      RETURN
   35 CALL GOTO (COM(IP(2)))
      RETURN
   36 CALL FROM(COM(IP(2)))
      RETURN
   37 CALL INDIRV(COM(IP(2)),COM(IP(3)))
      RETURN
   38 CALL SRFVCT(COM(IP(2)),COM(IP(3)))
      RETURN
   39 CALL TLAXIS(CM(1,IP(2)),CM(1,IP(3)),COM(IP(4)))
      RETURN
   40 CALL INDIRP(COM(IP(2)),COM(IP(3)))
      RETURN
   41 CALL PSIS(COM(IP(2)),COM(IP(3)))
      RETURN
   42 CALL PRINT(CM(1,IP(2)),COM(IP(3)),CM(1,IP(4)))
      RETURN
   43 CALL UNASGN
      RETURN
   44 CALL UNASGN
      RETURN
   45 CALL UNASGN
      RETURN
   46 CALL UNASGN
      RETURN
   47 CALL UNASGN
      RETURN
   48 CALL POCKET (COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)),
     1             COM(IP(6)),COM(IP(7)),COM(IP(8)),COM(IP(9)),
     2             COM(IP(10)),COM(IP(11)))
      RETURN
   49 CALL UNASGN
      RETURN
   50 CALL PUNCH(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
   51 CALL UNASGN
      RETURN
   52 CALL UNASGN
      RETURN
   53 CALL UNASGN
      RETURN
   54 CALL UNASGN
      RETURN
   55 CALL UNASGN
      RETURN
   56 CALL UNASGN
      RETURN
   57 CALL LDARD(CM(1,IP(2)),COM(IP(3)),CM(1,IP(4)))
      RETURN
   58 CALL UNITS(CM(1,IP(2)))
      RETURN
   59 CALL UNASGN
      RETURN
   60 CALL UNASGN
      RETURN
   61 CALL UNASGN
      RETURN
   62 CALL UNASGN
      RETURN
   63 CALL CLDAT(CM(1,IP(2)),CM(1,IP(3)),CM(1,IP(4)),CM(1,IP(5)))
      RETURN
   64 CALL CHKSRF(COM(IP(2)),COM(IP(3)))
      RETURN
   65 CALL AVCTRL(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)),
     +            COM(IP(6)),COM(IP(7)),COM(IP(8)))
      RETURN
   66 CALL REGION(COM(IP(2)),COM(IP(3)))
      RETURN
   67 CALL UNASGN
      RETURN
   68 CALL UNASGN
      RETURN
   69 CALL UNASGN
      RETURN
   70 CALL UNASGN
      RETURN
   71 CALL UNASGN
      RETURN
   72 CALL UNASGN
      RETURN
   73 CALL UNASGN
      RETURN
   74 CALL UNASGN
      RETURN
   75 CALL UNASGN
      RETURN
   76 CALL UNASGN
      RETURN
   77 CALL UNASGN
      RETURN
   78 CALL UNASGN
      RETURN
   79 CALL UNASGN
      RETURN
   80 CALL UNASGN
      RETURN
   81 CALL UNASGN
      RETURN
   82 CALL UNASGN
      RETURN
   83 CALL UNASGN
      RETURN
   84 CALL UNASGN
      RETURN
   85 CALL UNASGN
      RETURN
   86 CALL UNASGN
      RETURN
   87 CALL UNASGN
      RETURN
   88 CALL UNASGN
      RETURN
   89 CALL UNASGN
      RETURN
   90 CALL UNASGN
      RETURN
   91 CALL UNASGN
      RETURN
   92 CALL UNASGN
      RETURN
   93 CALL UNASGN
      RETURN
   94 CALL UNASGN
      RETURN
   95 CALL UNASGN
      RETURN
   96 CALL UNASGN
      RETURN
   97 CALL UNASGN
      RETURN
   98 CALL UNASGN
      RETURN
   99 CALL UNASGN
      RETURN
  100 CALL UNDEF(COM(IP(2)))
      RETURN
  101 CALL APT001(COM(IP(2)))
      RETURN
  102 CALL APT003(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  103 CALL APT004(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)),COM(IP(5)))
      RETURN
  104 CALL APT005(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)),COM(IP(5)))
      RETURN
  105 CALL APT006(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  106 CALL APT007(COM(IP(2)),COM(IP(3)))
      RETURN
  107 CALL APT008(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)),COM(IP(5)))
      RETURN
  108 CALL APT009(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  109 CALL APT010(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)),COM(IP(5)))
      RETURN
  110 CALL APT011(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  111 CALL APT012(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)),
     1            COM(IP(6)))
      RETURN
  112 CALL APT014(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  113 CALL APT015(COM(IP(2)),COM(IP(3)),INT(COM(IP(4))),COM(IP(5)))
      RETURN
  114 CALL APT016(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)),INT(COM(IP(5))),
     1            COM(IP(6)))
      RETURN
  115 CALL APT017(COM(IP(2)),COM(IP(3)),INT(COM(IP(4))),COM(IP(5)))
      RETURN
  116 CALL APT018(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  117 CALL APT019(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  118 CALL APT020(COM(IP(2)),COM(IP(3)),INT(COM(IP(4))),COM(IP(5)))
      RETURN
  119 CALL APT021(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)),INT(COM(IP(5))),
     1            COM(IP(6)))
      RETURN
  120 CALL APT022(COM(IP(2)),COM(IP(3)),INT(COM(IP(4))),COM(IP(5)),
     1            COM(IP(6)))
      RETURN
  121 CALL APT023(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  122 CALL APT024(INT(COM(IP(2))))
      RETURN
  123 CALL APT025(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  124 CALL APT026(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  125 CALL APT027(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  126 CALL APT028(COM(IP(2)),COM(IP(3)),INT(COM(IP(4))),COM(IP(5)))
      RETURN
  127 CALL APT029(COM(IP(2)),COM(IP(3)),INT(COM(IP(4))),COM(IP(5)),
     1            COM(IP(6)))
      RETURN
  128 CALL APT030(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)),INT(COM(IP(5))),
     1            COM(IP(6)),COM(IP(7)))
      RETURN
  129 CALL APT031(COM(IP(2)),INT(COM(IP(3))),INT(COM(IP(4))),COM(IP(5)),
     1            INT(COM(IP(6))),COM(IP(7)),COM(IP(8)))
      RETURN
  130 CALL APT032(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)),INT(COM(IP(5))),
     1            INT(COM(IP(6))),COM(IP(7)),COM(IP(8)))
      RETURN
  131 CALL APT033(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)),
     1            COM(IP(6)),COM(IP(7)),COM(IP(8)),COM(IP(9)),
     2            (CM(1,IP(10))),COM(IP(11)))
      RETURN
  132 CALL APT035(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  133 CALL APT036(COM(IP(2)),COM(IP(3)),INT(COM(IP(4))))
      RETURN
  134 CALL APT037(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  135 CALL APT038(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  136 CALL APT039(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  137 CALL APT040(COM(IP(2)),COM(IP(3)))
      RETURN
  138 CALL APT044(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)),
     1            COM(IP(6)))
      RETURN
  139 CALL APT045(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  140 CALL APT046(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  141 CALL APT047(COM(IP(2)),COM(IP(3)),INT(COM(IP(4))),COM(IP(5)))
      RETURN
  142 CALL APT048(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  143 CALL APT049(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  144 CALL APT050(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  145 CALL APT051(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  146 CALL APT052(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  147 CALL APT053(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)),
     1            COM(IP(6)))
      RETURN
  148 CALL APT054(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)),
     1            COM(IP(6)),COM(IP(7)))
      RETURN
  149 CALL APT055(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  150 CALL APT056(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  151 CALL APT057(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)),
     1            COM(IP(6)))
      RETURN
  152 CALL APT058(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)),
     1            COM(IP(6)))
      RETURN
  153 CALL APT060(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)),
     1            COM(IP(6)),COM(IP(7)),COM(IP(8)))
      RETURN
  154 CALL APT061(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)),
     1            COM(IP(6)),COM(IP(6)),INT(COM(IP(8))))
      RETURN
  155 CALL APT062(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)),
     1            COM(IP(6)),COM(IP(7)),COM(IP(8)),COM(IP(9)),
     2            COM(IP(10)),COM(IP(11)),COM(IP(12)))
      RETURN
  156 CALL APT063(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  157 CALL APT064(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)))
      RETURN
  158 CALL APT065(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  159 CALL APT066(COM(IP(2)),COM(IP(3)),COM(IP(4)),INT(COM(IP(5))))
      RETURN
  160 CALL APT067(COM(IP(2)),COM(IP(3)))
      RETURN
  161 CALL APT068(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  162 CALL APT073(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  163 CALL APT075(COM(IP(2)),COM(IP(3)))
      RETURN
  164 CALL APT077(COM(IP(2)),INT(COM(IP(3))))
      RETURN
  165 CALL APT078(COM(IP(2)),INT(COM(IP(3))))
      RETURN
  166 CALL APT079(COM(IP(2)),INT(COM(IP(3))))
      RETURN
  167 CALL APT081(COM(IP(2)),INT(COM(IP(3))))
      RETURN
  168 CALL APT083(COM(IP(2)),INT(COM(IP(3))))
      RETURN
  169 CALL APT085
      RETURN
  170 CALL APT087(COM(IP(2)),COM(IP(3)))
      RETURN
  171 CALL APT088(COM(IP(2)),INT(COM(IP(3))),CM(1,IP(4)),
     1            INT(COM(IP(5))),INT(COM(IP(6))),INT(COM(IP(7))),
     2            COM(IP(8)))
      RETURN
  172 CALL APT090(CM(1,IP(2)),COM(IP(3)),CM(1,IP(4)),COM(IP(5)),
     1            COM(IP(6)),COM(IP(7)),COM(IP(8)),COM(IP(9)))
      RETURN
  173 CALL UNASGN
      RETURN
  174 CALL UNASGN
      RETURN
  175 CALL APT094(INT(COM(IP(2))),COM(IP(3)),COM(IP(4)))
      RETURN
  176 CALL APT100(INT(COM(IP(2))),COM(IP(3)))
      RETURN
  177 CALL APT200(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  178 AC = APT201(COM(IP(2)),COM(IP(3)))
      CALL SAVEAC(AC)
      RETURN
  179 CALL APT298(INT(COM(IP(2))),COM(IP(3)),COM(IP(4)))
      RETURN
  180 CALL APT299(CM(1,IP(2)),CM(1,IP(3)),CM(1,IP(4)),CM(1,IP(5)))
      RETURN
  181 CALL ABSF(COM(IP(2)),COM(IP(3)))
      RETURN
  182 CALL ATANF(COM(IP(2)),COM(IP(3)))
      RETURN
  183 CALL UNASGN
      RETURN
  184 CALL COSF(COM(IP(2)),COM(IP(3)))
      RETURN
  185 CALL NULL
      RETURN
  186 CALL DOTF(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  187 CALL EXPF(COM(IP(2)),COM(IP(3)))
      RETURN
  188 CALL UNASGN
      RETURN
  189 CALL LNTHF(COM(IP(2)),COM(IP(3)))
      RETURN
  190 CALL LOGF(COM(IP(2)),COM(IP(3)))
      RETURN
  191 CALL SINF(COM(IP(2)),COM(IP(3)))
      RETURN
  192 CALL SQRTF(COM(IP(2)),COM(IP(3)))
      RETURN
  193 CALL APT041(COM(IP(2)),COM(IP(3)),COM(IP(4)),INT(COM(IP(5))))
      RETURN
  194 CALL APT042(COM(IP(2)),COM(IP(3)),COM(IP(4)),INT(COM(IP(5))))
      RETURN
  195 CALL APT043(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  196 CALL APT295(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  197 CALL ANGLF(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  198 CALL APT069(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  199 CALL APT070(COM(IP(2)),COM(IP(3)),INT(COM(IP(4))),COM(IP(5)),
     1            COM(IP(6)))
      RETURN
  200 CALL APT071(COM(IP(2)),COM(IP(3)))
      RETURN
  201 CALL APT072(COM(IP(2)),INT(COM(IP(3))),INT(COM(IP(4))),
     1            INT(COM(IP(5))))
      RETURN
  202 CALL DEFEXT(COM(IP(2)))
      RETURN
  203 CALL APT074(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)),COM(IP(5)),
     1            COM(IP(6)),COM(IP(7)),COM(IP(8)))
      RETURN
  204 CALL APT034(COM(IP(2)),COM(IP(3)),INT(COM(IP(4))),COM(IP(5)),
     1            INT(COM(IP(6))),COM(IP(7)),COM(IP(8)))
      RETURN
  205 CALL APT296
      RETURN
  206 CALL APT297
      RETURN
C  207 CALL APT101(COM(IP(2)),COM(IP(3)),COM(IP(4)),INT(COM(IP(5))),
C    1            COM(IP(6)),COM(IP(7)),COM(IP(8)),COM(IP(9)),
C     2            COM(IP(10)),COM(IP(11)),COM(IP(12)))
  207 CALL UNASGN
      RETURN
  208 CALL GOTOPN(COM(IP(2)),INT(COM(IP(3))),INT(COM(IP(4))),
     1            INT(COM(IP(5))),INT(COM(IP(6))),COM(IP(7)),COM(IP(8)))
      RETURN
  209 CALL APT105(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)),INT(COM(IP(5))),
     1            COM(IP(6)))
      RETURN
  210 IF (IP(4).EQ.TERM) THEN
        CALL NUMF1(COM(IP(2)),COM(IP(3)))
      ELSE
        CALL NUMF2(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      END IF
      RETURN
  211 CALL APT106(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  212 CALL TRANSF(COM(IP(2)),COM(IP(3)),INT(COM(IP(4))),INT(COM(IP(5))),
     1            INT(COM(IP(6))))
      RETURN
  213 CALL APT104(COM(IP(2)))
      RETURN
  214 CALL APT102(COM(IP(2)),COM(IP(3)),COM(IP(4)),INT(COM(IP(5))))
      RETURN
  215 CALL APT103(COM(IP(2)),COM(IP(3)),INT(COM(IP(4))))
      RETURN
  216 CALL APT107(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  217 CALL APT013(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)),INT(COM(IP(5))),
     1            COM(IP(6)),INT(COM(IP(7))),COM(IP(8)))
      RETURN
  218 CALL APT108(COM(IP(2)),COM(IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  219 CALL APT109(COM(IP(2)),INT(COM(IP(3))),COM(IP(4)),COM(IP(5)),
     1            COM(IP(6)),COM(IP(7)),COM(IP(8)),COM(IP(9)))
      RETURN
  220 CALL DISTF(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  221 CALL LOG10F(COM(IP(2)),COM(IP(3)))
      RETURN
  222 CALL TANF(COM(IP(2)),COM(IP(3)))
      RETURN
  223 CALL ATANF(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  224 CALL COTANF(COM(IP(2)),COM(IP(3)))
      RETURN
  225 CALL ARSINF(COM(IP(2)),COM(IP(3)))
      RETURN
  226 CALL ARCOSF(COM(IP(2)),COM(IP(3)))
      RETURN
  227 CALL SINB(COM(IP(2)),COM(IP(3)))
      RETURN
  228 CALL COSB(COM(IP(2)),COM(IP(3)))
      RETURN
  229 CALL TANB(COM(IP(2)),COM(IP(3)))
      RETURN
  230 CALL COTANB(COM(IP(2)),COM(IP(3)))
      RETURN
  231 CALL ARSINB(COM(IP(2)),COM(IP(3)))
      RETURN
  232 CALL ARCOSB(COM(IP(2)),COM(IP(3)))
      RETURN
  233 CALL ATANB(COM(IP(2)),COM(IP(3)))
      RETURN
  234 CALL ATAN2B(COM(IP(2)),COM(IP(3)))
      RETURN
  235 CALL SINHF(COM(IP(2)),COM(IP(3)))
      RETURN
  236 CALL COSHF(COM(IP(2)),COM(IP(3)))
      RETURN
  237 CALL TANHF(COM(IP(2)),COM(IP(3)))
      RETURN
  238 CALL MINF(IP)
      RETURN
  239 CALL MAXF(IP)
      RETURN
  240 CALL MODF(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  241 CALL INTF(COM(IP(2)),COM(IP(3)))
      RETURN
  242 CALL SIGNF(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  243 CALL SPATF(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  244 CALL ANGLB(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  245 IF (IP(4).EQ.TERM) THEN
        CALL PARMF1(COM(IP(2)),COM(IP(3)))
      ELSE
        CALL PARMF2(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      END IF
      RETURN
  246 CALL CANF(COM(IP(2)),COM(IP(3)),COM(IP(4)))
      RETURN
  247 CALL APT110(COM(IP(2)),COM(IP(3)))
      RETURN
  248 CALL LOGIF(COM(IP(2)),CM(1,IP(3)),COM(IP(4)),COM(IP(5)))
      RETURN
  249 CALL CLDATF(COM(IP(2)),COM(IP(3)),CM(1,IP(4)),COM(IP(5)))
      RETURN
      END
**** SOURCE FILE : M0002657.V09   ***
*
C---    IMPLEMENTATION DEPENDENT ROUTINES XCANON & INCAN
C
C
      INTEGER FUNCTION XCANON(V)
C
C---    PURPOSE IS TO PROVIDE ACCESS TO CANON FILE ON DISK
C---   INPUT V = VIRTUAL ADDRESS OF A CANONICAL FORM
C      OUTPUT XCANON = ACTUAL ADDRESS OF A CANONICAL FORM
C---   (A CANONICAL FORM PAGE IS BROUGHT IN IF NECESSARY)
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
C
      COMMON/STOR/ NTB, FPB, PPB, COMN, CFB
      INTEGER      NTB, FPB, PPB, COMN, CFB
      COMMON/CONST/ KCOMT, KCOMF, CILPRT, KCBN
      LOGICAL CILPRT
      INCLUDE 'DARRAY.INC'
      COMMON /WORK/ IIIIII(53), IPAGE, IWRIT
      INTEGER IPAGE(32)
      INTEGER V
      INCLUDE 'SYMFIL.INC'
C
C---      NFOR REPRESENT FORWARD POINTERS SHOWING PROGRESSIVELY
C---      OLDER PAGES.   NFOR(1) IS NOT A CORE SLOT POINTER, BUT
C---      AN INITIALIZING LOCATION FOR THE LIST POINTERS.
C---      NBACK REPRESENTS BACKWARD POINTERS TO PROGESSIVELY
C---      MORE RECENTLY USED CORE SLOTS
C---      IPAGE GIVES THE CURRENT PAGE LOADED INTO A CORE SLOT
C---      INCOR GIVES THE SLOT IN CORE NOW OCCUPIED BY EACH PAGE
C---      LOCREC GIVES THE RECORD LOCATION OF EACH PAGE ON EXTERNAL FILE
C
      INTEGER INCOR(256),LOCREC(256),NFOR(33),NBACK(33)
C
C---      MAXPAG IS THE MAXIMUM NUMBER OF PAGES IN CORE NOW
C---      MAXCOR IS THE ABSOLUTE MAXIMUM NUMBER OF PAGES IN CORE
C---      MAXFIL IS THE MAXIMUM NUMBER OF PAGES ALLOWED ON EXTERNAL FILE
C---      NPGCNT IS THE MAXIMUM PAGE ENCOUNTERED TO DATE
      INTEGER NZERO
C
      DATA INCOR/256*0/,LOCREC/256*0/,NFOR/33*0/,NBACK/33*0/
      DATA MAXPAG/0/,MAXCOR/32/,MAXFIL/256/,NPGCNT/0/
      DATA NZERO/0/
      DATA NAVAIL/2/
C
C     CALL BAD(-1,-6,'ENTR','XCANON')
      IF(V-CFB.GE.0) GO TO 10
C---     THE REFERENCED CANON FORM IS BELOW THE CANON AREA.
      XCANON=V
      GO TO 999
C
   10 CONTINUE
      IF(MAXPAG.NE.0) GO TO 50
C---     INITIAL CALL, SET UP
      LENPAG=2*KCBN
C---     LENPAG IS THE LENGTH OF A CANON PAGE IN SINGLE PRECISION WORDS
C---     MAXPAG IS THE MAXIMUM NUMBER OF PAGES THAT FIT IN CORE
      MAXPAG=((PPB+3)/4-CFB)/KCBN
      MAXPAG=MIN0(MAXCOR,MAXPAG)
C---     SET UP THE INITIAL DOUBLY LINKED LIST POINTERS
      NFOR(1)=1
      NBACK(1)=1
      DO 20 L=1,MAXCOR
   20 IPAGE(L)=0
C     CALL BAD(1,0,'PPB ',PPB)
C     CALL BAD(1,0,'CFB ',CFB)
C     CALL BAD(-1,0,'MXPG',MAXPAG)
C
C---     NORMAL CONTINUING POINT OF CALCULATION
   50 CONTINUE
C---     COMPUTE THE IDEAL PAGE NUMBER AND INCREMENT INTO PAGE
      IVPAGE=(V-CFB)/KCBN+1
C     CALL BAD(1,0,'V   ',V)
C     CALL BAD(-1,0,'IVPG',IVPAGE)
      IF(IVPAGE.LT.MAXFIL+1) GO TO 60
C---     PAGE EXCEEDS THE ABSOLUTE MAXIMUM FOR EXTERNAL PAGES
      CALL CFORM('0 TOO MANY PAGES OF CANONICAL DATA IN XCANON',
     X     DARRAY,1,44)
      GO TO 995
C
   60 CONTINUE
C---     IF PAGE IS NOW IN CORE, SKIP LOAD/UNLOAD LOGIC
      IF(INCOR(IVPAGE).GT.NZERO) GO TO 400
C---     THE PAGE IS NOT NOW IN CORE - LOAD IT IF NECESSARY
      IF(NAVAIL.LT.MAXPAG+2) GO TO 100
C---     ALL AVAILABLE CORE SLOTS ARE IN USE.  THE OLDEST
C---     PAGE(LEAST RECENTLY USED) SHOULD FIRST BE REMOVED.
      NXSLOT=NBACK(1)-1
C---     PAGE NUMBER OF THIS OLDEST PAGE
      IP=IPAGE(NXSLOT)
C---     LOCATION OF THIS OLD PAGE IN CORE
      LOC=CFB+(INCOR(IP)-1)*KCBN
C---     SET FLAGS FOR WRITING AT END OF FILE
C     CALL BAD(1,0,'WRIT',IP)
C     CALL BAD(-1,0,'SLOT',NXSLOT)
      NR=0
      IR=0
C---      NOW WRITE PAGE OUT TO XCAN FILE
      LNPG=LENPAG
      CALL AWRITE(XCAN,NR,CF(LOC),LNPG,IR)
C***     TERMINATE IF AN ERROR OCCURRED.
      IF(IR.NE.0) GO TO 997
C---      INCREMENT WRITE COUNT  *** IWRIT USED IN LIB ***
      IWRIT = IWRIT + 1
C
C---     UPDATE THE STATUS OF PAGE IP
      IPAGE(NXSLOT)=IVPAGE
      INCOR(IVPAGE)=INCOR(IP)
      INCOR(IP)=-INCOR(IP)
      LOCREC(IP)=NR
      GO TO 200
C
  100 CONTINUE
C---     A SLOT IS STILL OPEN IN CORE, SO NO PAGE NEED BE REMOVED
      NXSLOT=NAVAIL-1
      NAVAIL=NAVAIL+1
C---     EXPAND THE LIST LINKAGES.
      NN=NBACK(1)
      NFOR(NN)=NXSLOT+1
      NBACK(1)=NXSLOT+1
      NFOR(NXSLOT+1)=1
      NBACK(NXSLOT+1)=NN
      INCOR(IVPAGE)=NXSLOT
  200 CONTINUE
C
C---      NEXT CHECK WHETHER THE SOUGHT-AFTER PAGE HAS BEEN WRITTEN
C---      TO THE DISK FILE EARLIER.
      IF(LOCREC(IVPAGE).EQ.NZERO) GO TO 300
C---      SINCE THAT PAGE IS ON DISK, IT SHOULD BE RETRIEVED.
C---      SELECT THE DISK RECORD NUMBER
      NR=LOCREC(IVPAGE)
C---      SELECT LOCATION INTO WHICH DATA IS READ
      LOC=CFB+(INCOR(IVPAGE)-1)*KCBN
C     CALL BAD(1,0,'READ',IVPAGE)
C     CALL BAD(-1,0,'SLOT',NXSLOT)
      IR=0
C---      FETCH THE DATA FROM DISK INTO CORE
      LNPG=LENPAG
      CALL AREAD(XCAN,NR,CF(LOC),LNPG,IR)
C***      BRANCH IF READ CAUSED AND ERROR
      IF(IR.NE.0) GO TO 998
C
  300 CONTINUE
      IPAGE(NXSLOT)=IVPAGE
C
  400 CONTINUE
C---     DESIRED PAGE IS NOW IN CORE
      IN1=INCOR(IVPAGE)+1
      NN=NFOR(1)
      IF(IN1.EQ.NN.OR.NAVAIL.EQ.2) GO TO 500
C---      DESIRED PAGE IS NOT NOW THE MOST RECENTLY USED
C---      ALTER THE LINKED LIST SO THAT IT IS THE MOST RECENT
C---      FIRST REMOVE IN1 FROM THE LINKED LIST TEMPORARILY
      NFSAVE=NFOR(IN1)
      NBSAVE=NBACK(IN1)
      NFOR(NBSAVE)=NFSAVE
      NBACK(NFSAVE)=NBSAVE
C---      NOW RESET IN1 INTO THE TOP OF THE USAGE HISTORY LIST
      NOWTOP=NFOR(1)
      NFOR(1)=IN1
      NFOR(IN1)=NOWTOP
      NBACK(NOWTOP)=IN1
      NBACK(IN1)=1
C
  500 CONTINUE
C---      COMPUTE THE ACTUAL ADDRESS OF THIS CANON FORM
      XCANON=CFB+(INCOR(IVPAGE)-1)*KCBN+MOD(V-CFB,KCBN)
      GO TO 999
C
C
  997 CONTINUE
      CALL CFORM(' CANON PAGE WRITE ERROR IN XCANON',
     X     DARRAY,1,33)
      GO TO 996
  998 CONTINUE
      CALL CFORM(' CANON PAGE READ ERROR IN XCANON ',
     X     DARRAY,1,33)
  996 CONTINUE
      CALL ICONV(IR,DARRAY,35,8)
  995 CONTINUE
      CALL CPRINT(DARRAY)
      CALL BAD(1,0,'V   ',V)
      CALL BAD(1,0,'IVPG',IVPAGE)
      CALL BAD(1,0,'LENP',LENPAG)
      CALL BAD(1,0,'LNPG',LNPG)
      CALL BAD(1,0,'MXPG',MAXPAG)
      CALL BAD(1,0,'NR  ',NR)
      CALL BAD(1,0,'NAVL',NAVAIL)
      CALL BAD(1,0,'NSLT',NXSLOT)
      CALL BAD(-1,0,'NPCN',NPGCNT)
C
C     NPGCNT=MAX0(IVPAGE,NPGCNT)
C     CALL SBAD(-MAXPAG,0,'IPAG',IPAGE)
C     NN=MAXPAG+1
C     CALL SBAD(-NN,0,'NFOR',NFOR)
C     CALL SBAD(-NN,0,'NBAC',NBACK)
C     CALL SBAD(-NPGCNT,0,'LOCR',LOCREC)
C     CALL SBAD(-NPGCNT,0,'INCO',INCOR)
      CALL HELP
  999 CONTINUE
C
C     NPGCNT=MAX0(IVPAGE,NPGCNT)
C     CALL SBAD(-MAXPAG,0,'IPAG',IPAGE)
C     NN=MAXPAG+1
C     CALL SBAD(-NN,0,'NFOR',NFOR)
C     CALL SBAD(-NN,0,'NBAC',NBACK)
C     CALL SBAD(-NPGCNT,0,'LOCR',LOCREC)
C     CALL SBAD(-NPGCNT,0,'INCO',INCOR)
      RETURN
C     END
C     SUBROUTINE SBAD(N1,N2,N3,N4)
C     DIMENSION N4(1),NN(100)
C     INTEGER N4
C     N=IABS(N1)
C     N=MIN0(N,100)
C     DO 10 I=1,N
C     NN(I)=N4(I)
C  10 CONTINUE
C     IF(N1.LT.0) N=-N
C     CALL BAD(N,0,N3,NN)
C     RETURN
      END
C
C
C
C
C---    IMPLEMENTATION DEPENDENT ROUTINE
C
      SUBROUTINE INCAN(AV)
C
C
      COMMON/STOR/ NTB, FPB, PPB, COMN, CFB
      INTEGER      NTB, FPB, PPB, COMN, CFB
      COMMON/CONST/ KCOMT, KCOMF, CILPRT, KCBN
      LOGICAL CILPRT
      COMMON /WORK/ IIIIII(53), IPAGE, IWRIT
      INTEGER IPAGE(32)
C
C---      NFOR REPRESENT FORWARD POINTERS SHOWING PROGRESSIVELY
C---      OLDER PAGES.   NFOR(1) IS NOT A CORE SLOT POINTER, BUT
C---      AN INITIALIZING LOCATION FOR THE LIST POINTERS.
C---      NBACK REPRESENTS BACKWARD POINTERS TO PROGESSIVELY
C---      MORE RECENTLY USED CORE SLOTS
C---      IPAGE GIVES THE CURRENT PAGE LOADED INTO A CORE SLOT
C---      INCOR GIVES THE SLOT IN CORE NOW OCCUPIED BY EACH PAGE
C---      LOCREC GIVES THE RECORD LOCATION OF EACH PAGE ON EXTERNAL FILE
C
      INTEGER INCOR(256),LOCREC(256),NFOR(33),NBACK(33)
C
C---      MAXPAG IS THE MAXIMUM NUMBER OF PAGES IN CORE NOW
C---      MAXCOR IS THE ABSOLUTE MAXIMUM NUMBER OF PAGES IN CORE
C---      MAXFIL IS THE MAXIMUM NUMBER OF PAGES ALLOWED ON EXTERNAL FILE
C---      NPGCNT IS THE MAXIMUM PAGE ENCOUNTERED TO DATE
      INTEGER AV
C
      DATA INCOR/256*0/,LOCREC/256*0/,NFOR/33*0/,NBACK/33*0/
      DATA MAXPAG/0/,MAXCOR/32/,MAXFIL/256/,NPGCNT/0/
C
C
C
C---      ROUTINE TO CALCULATE A VIRTUAL ADDRESS GIVEN
C---      A CURRENT ACTUAL ADDRESS.
      IP=(AV-CFB)/KCBN+1
      AV=CFB+(IPAGE(IP)-1)*KCBN+MOD(AV-CFB,KCBN)
C
C     NPGCNT=MAX0(IVPAGE,NPGCNT)
C     CALL SBAD(-MAXPAG,0,'IPAG',IPAGE)
C     NN=MAXPAG+1
C     CALL SBAD(-NN,0,'NFOR',NFOR)
C     CALL SBAD(-NN,0,'NBAC',NBACK)
C     CALL SBAD(-NPGCNT,0,'LOCR',LOCREC)
C     CALL SBAD(-NPGCNT,0,'INCO',INCOR)
      RETURN
C     END
C     SUBROUTINE SBAD(N1,N2,N3,N4)
C     DIMENSION N4(1),NN(100)
C     INTEGER N4
C     N=IABS(N1)
C     N=MIN0(N,100)
C     DO 10 I=1,N
C     NN(I)=N4(I)
C  10 CONTINUE
C     IF(N1.LT.0) N=-N
C     CALL BAD(N,0,N3,NN)
C     RETURN
      END
**** SOURCE FILE : M0000989.V05   ***
*
C
C-------- FORTRAN SUBROUTINE... XNUMBR           R.COLLINS  4/16/70
C
      SUBROUTINE  XNUMBR(IPNTR)
C
C
C-----PURPOSE.......TO PROVIDE ACCESS TO THE NUMBER TABLE VALUES WHEN
C                   PASSED ON DIRECT ACCESS FILE FROM THE TRANSLATOR
C
C-----ARGUMENTS.....IPNTR - VIRTUAL POINTER TO NUMBER TABLE VALUE -
C                   CHANGED TO ACTUAL POINTER TO VALUE UPON EXIT
C
C-----CALLED BY.....GET, LIB
C
C-----SUBSIDIARIES..NONE
C
C-----DIAGNOSTICS...NONE
C
C
C
C--------**** COMMON AREAS NEEDED FOR THIS ROUTINE ****
C
C--------UNLABELED COMMON - COM
C
      INCLUDE 'BLANKCOM.INC'
      INCLUDE 'INTRPEQ.INC'
C
C
C STOR--COMMON CONTAINING STORAGE PARAMETERS
C
      COMMON/STOR/  NTB,      FPB,      PPB,      COMN,  CFB,  NBLK
      INTEGER       NTB,      FPB,      PPB,      COMN,  CFB,  NBLK
C
C   ADDITIONAL STOR PARAMETERS USED FOR NUMBER TABLE DIRECT ACCESS
C
      COMMON/STOR/  NRECRD,  NTPARM
      DIMENSION     NRECRD(10), NTPARM(10)
      EQUIVALENCE   (NTPARM(1),NUMBST), (NTPARM(2),NUMOD ),
     .              (NTPARM(3),NDAFLG), (NTPARM(4),NRECST),
     .              (NTPARM(5),IPAGE )
C
C
C...  20. SYSTEM I/O FILE NAMES
C
      INCLUDE 'SYMFIL.INC'
C
C  ------------------------------------------------------------------
C
C--------CALCULATE VIRTUAL PAGE POINTER AND ACTUAL NUMBER TABLE
C--------POINTER USING CURRENT VIRTUAL NUMBER TABLE POINTER
C
      IF(IPNTR.LT.NUMBST) GO TO 999
      IPMOD=(IPNTR-NUMBST)/NUMOD + 1
      IPNTR=IPNTR-(IPMOD-1)*NUMOD
C
C--------IF NEW PAGE IS CURRENTLY IN COMMON AREA - RETURN
      IF (IPMOD .EQ. IPAGE) GO TO 999
C
C
      JREC = IPMOD*2-1
      NSTRT = NTB + NUMBST
      L=NUMOD/2
      CALL FREAD (XNUM,JREC,FP(NSTRT),L,IR)
      NSTRT = NSTRT + L
      JREC = JREC + 1
      CALL FREAD(XNUM,JREC,FP(NSTRT),L,IR)
C
C--------SET CURRENT PAGE POINTER AND RETURN
      IPAGE=IPMOD
  999 RETURN
      END
