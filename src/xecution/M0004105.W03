*
C.....FORTRAN SUBROUTINE  ....INTRP          8/68                 HG
C.....FORTRAN ROUTINE              ..INTRP..   HL GRAY 3/68         *ID*
      SUBROUTINE INTRP
C FORTRAN SUBROUTINE 'INTRP', THE MAIN INTERPRETER
C
C PURPOSE      THIS ROUTINE EXECUTES APT INTERMEDIATE LANGUAGE
C              INSTRUCTIONS ONE-BY-ONE.
C
C LINKAGE      CALL INTRP
C
C ARGUMENTS    THROUGH COMMON
C
C SUBSIDIARIES 'ADV'     ADVANCE LOCATION COUNTER
C              'SET'     SET LOCATION COUNTER
C              'LIB'     CALL LIBRARY ROUTINE
C               GET      OBTAIN AN OPERAND OR OPERAND ADDRESS
C               RESRV    RESERVE STORAGE ROUTINE
C               PUT      STORE OPERAND
C               SEQ      SEQUENCE ROUTINE
C               APT295   EXPONENTIATION ROUTINE
C
C
C METHOD       THE INTERMEDIATE LANGUAGE OPCODE IS EXTRACTED (L300).
C              A BRANCH THEN OCCURS TO A SMALL SUBSECTION WHICH
C              EXECUTES THE INSTRUCTION.
C
C              IF THE INSTRUCTION DOES NOT CONTAIN A JUMP, THE RETURN
C              CAUSES THE PSEUDOLOCATION COUNTER TO ADVANCE ONE
C              INSTRUCTION (L200), THEN EXTRACTION OCCURS
C
C              IF THE INSTRUCTION CONTAINS A JUMP, THE PSEUDOLOCATION
C              COUNTER IS RESET TO THE DESTINATION INSTRUCTION AND THE
C              RETURN IS TO THE EXTRACTION PROCESS.
C
C--------------------------------------------------------------CDE PAK
C
C
C
C
C UNLABELED COMMON
C
C
      INCLUDE (BLANKCOM)
      INCLUDE (INTRPEQ)
C
C
C
C STOR--COMMON CONTAINING STORAGE PARAMETERS
C
C
      COMMON/STOR/  NTB,      FPB,      PPB,      COMN,  CFB
      INTEGER       NTB,      FPB,      PPB,      COMN,  CFB
C
C
C WORK--COMMON CONTAINING WORKING VARIABLES
C
C
      COMMON/WORK/  PGC,      PGCN,     ILC,      IXC
      INTEGER       PGC,      PGCN,     ILC,      IXC
C
      COMMON/WORK/  SCP,      SAP,      NSP,      IAP,   CFP,   COMP
      INTEGER       SCP,      SAP,      NSP,      IAP,   CFP,   COMP
C
      COMMON/WORK/         NTP,   LNA,   RTP
      INTEGER  FPP,    NTP,    LNA,    RTP
      EQUIVALENCE  (FPP,   NTP)
      DIMENSION                   LNA(2,20)
C
C
C
C CONST--COMMON CONTAINING CONSTANTS
C
C
      COMMON/CONST/KCOMT,KCOMF,CILPRT,KCBN
      LOGICAL CILPRT
C
C
      INCLUDE (DARRAY)
C
C
      COMMON/ILD/ILD
C
      INCLUDE (TOTAL)
      INCLUDE (LDEF)
C
C---------------------------------------------------------------------
      INTEGER       XCANON
      EXTERNAL  GET,XCANON
      INTEGER  OP,LN,COMP1,I,J,K,NTP1,NTP2,KOUNT,TT,X4
      DIMENSION LN(2),TT(2),X4(2)
      DOUBLE PRECISION XTEMP,A,B,C,GET,X8
      EQUIVALENCE (XTEMP,TT(1)),(X8,X4(1))
      DOUBLE PRECISION XL
      DIMENSION LL(2)
      EQUIVALENCE (LL(1),XL)
      LOGICAL CKDEF
      DATA LL(2)/0/
      DATA ISPECL /319951634/
C
C
C
C        ADVANCE PSEUDOLOCATION COUNTER
C
  200 CALL ADV
C
C        EXTRACT OPCODE FROM INSTRUCTION AND EXECUTE IT.
  300 OP = PP(ILC)
      J=PP(ILC+1)+ILC+1
      IF(.NOT.CILPRT) GO TO 2
C  PRINT COMPRESSED I.L.
      JC = J
      CALL CFORM('PAG',DARRAY,2,3)
      CALL ICONV(PGC,DARRAY,5,4)
      CALL CFORM('(    ),LOC(      )',DARRAY,9,18)
      CALL ICONV(IXC,DARRAY,10,4)
      CALL ICONV(ILC,DARRAY,20,6)
      IF(OP.EQ.21) JC = ILC+3
      I=ILC
 8999 L=29
 9000 K=PP(I)
      CALL ICONV(K,DARRAY,L,5)
      L=L+6
      IF (K.NE.7.OR.I.LT.ILC+2) GO TO 99
C            1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19
      GOTO (98,98,98,98,98,99,99,99,99,99,98,99,98,99,98,99,98,98,98,
     +      99,99),OP
   98 IF (PP(I-1).EQ.5.OR.PP(I-1).EQ.6)GOTO 99
      X4(1)=PP(I+1)
      X4(2)=PP(I+2)
      CALL FCONV(X8,DARRAY,L,12,5)
      I=I+2
      L=L+13
   99 IF(I.EQ.JC) GO TO 9002
      I=I+1
      IF(L.LT.101) GO TO 9000
      CALL CPRINT(DARRAY)
      GO TO 8999
 9002 CALL CPRINT(DARRAY)
      IF(OP.NE.21) GO TO 2
 9003 L=K
      IF(K.GT.92) L=92
      CALL HOLFRM(PP(I+1),DARRAY,25,L,NW)
      CALL CPRINT(DARRAY)
      IF(K.LE.92)  GO TO 2
      I=I+NW
      K=K-92
      GO TO 9003
    2 IF(OP.LT.1.OR.OP.GT.21) GO TO 9020
      ILD=0
C
C OPCODE     1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21
C
      GO TO (1,1,1,1,1,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21),OP
C            . . . . . . . . .  .  .  .  .  .  .  .  .  .  .  .  .
C            . . . . . . . . .  .  .  .  .  .  .  .  .  .  .  .  .
C            . . . . FEXP. . .  RETMC .  .  .  ASNADD.  .  .  VBLJMP
C            . . . FDIV. . . SEQNCE.  .  .  CALMC .  .  .  MOVE  .
C            . . FMPY  . . JUMP    .  .  CVTSUB   .  .  CALL     .
C            . FSUB    . ENTRY     .  RESRV       .  REPL        .
C            FADD      LABEL       CONJMP         ASNJMP         HOLDAT
C
C
C
C
C
C
C        PROCESS ARITHMETIC OPCODES
C
C
C        GET ARGUMENTS FROM OPERANDS
C
 1    A = GET(4)
      B = GET(6)
C
C        BRANCH TO CALCULATE  C = (A) OPERATION (B)
C
C        OPCODE +     -     *     /    **
      GO TO (1001, 1002, 1003, 1004, 1005), OP
C
C        ADDITION
C
 1001 C = A+B
      GO TO 1006
C
C        SUBTRACTION
C
 1002 C = A-B
      GO TO 1006
C
C        MULTIPLICATION
C
 1003 C = A*B
      GO TO 1006
C
C        DIVISION
C
 1004 C = A/B
      GO TO 1006
C
C        EXPONENTIATION
C
 1005 CALL  APT295(C,A,B)
      GO TO 1006
C
C        STORE RESULT IN FIRST OPERAND AND RETURN
C
 1006 CALL PUT(C,2)
C
      GO TO 200
C
C
C
C
C       PROCESS LABEL INSTRUCTIONS
C        PROCESS LABEL AND ENTRY INSTRUCTIONS
C
C
C        COMPUTE NAME TABLE POINTER, ENTER LINE, AND RETURN
C
 6    NTP = NTB + PP(ILC + 2)
      NT(1,NTP) = PP(ILC + 3)
      NT(2,NTP) = PP(ILC + 4)
      GO TO 200
C
C
C       PROCESS ENTRY INSTRUCTION (THIS ALSO USED AS A NOOP INSTRUCTION)
C
C
    7 GO TO 200
C
C
C        PROCESS JUMP INSTRUCTION
C
C
C        GET INDEX OF LABEL
C
 8    NTP1 = PP(ILC+2)
C
C
C        COMPUTE NAME TABLE POINTER--ALSO ENTRY FROM CONJMP INSTRUCTION
C
 8001 NTP = NTP1 + NTB
C
C        EXTRACT LINE
      LN(1) = NT(1,NTP)
      LN(2) = NT(2,NTP)
C
C        RESET LOCATION COUNTER
C
      CALL SET(LN)
C
C        AND RETURN
      GO TO 300
C
C
C
C
C        PROCESS SEQUENCE INSTRUCTION
C
C
 9    CALL SEQ(PP(ILC +2))
      ISCHRO=0
      GO TO 200
C
C
C
C
C        PROCESS RETMAC INSTRUCTION
C
C        SET LOCATION COUNTER TO TOP OF MACRO STACK
C
 10   CALL SET(LNA(1,RTP))
C
C        POP UP MACRO STACK
      RTP = RTP-1
C
C        ADVANCE LOCATION COUNTER
      GO TO 200
C
C
C
C        PROCESS CONJUMP INSTRUCTION
C
C
C        GET VALUE OF OPERAND
C
 11   A = GET(2)
C
C        TEST VALUE AND GO TO JUMP WITH PROPER POINTER
C
C              )0     =0     >0
      IF (DABS(A) .LT.  1.0D-12) GO TO 11002
      IF (A) 11001, 11002, 11003
C
11001 NTP1 = PP(ILC + ILD + 4)
      GO TO 8001
C
11002 NTP1 = PP(ILC + ILD + 5)
      GO TO 8001
C
11003 NTP1 = PP(ILC + ILD + 6)
      GO TO 8001
C
C
C
C
C        PROCESS RESRV INSTRUCTION
C
C        ALL RESRS INSTRUCTIONS EXECUTED DURING INITIALIZATION
C
12    CALL RESRV
      GO TO 200
C
C
C
C
C        PROCESS CVTSUB
C
C
C        GET SUBSCRIPT
C        FIND LOCATION OF X(I)
 13    I  = GET(6)
      NTP = NTB + PP(ILC+5)
      KSIZE = PP(ILC+8)+1
      LOCX1=NT(1,NTP) - CFB
      LOCXI=LOCX1-(I  -1)*KSIZE
      IF(.NOT.CANFLG) GOTO 1310
C        IS X(I) IN FIRST BLOCK OF X ARRAY
      IF(LOCX1  /KCBN.EQ. LOCXI  /KCBN) GOTO 1310
C        NO,FIND NO. OF ELEMENTS OF X IN FIRST BLOCK
      NF = MOD(LOCX1,KCBN)/KSIZE+1
C        FIND NO. OF  FULL BLOCKS OF X ELEMENTS
      NBK= (I-NF)/((KCBN-1)/KSIZE)
C        FIND NO. OF ELEMENTS OF X IN MIDDLE BLOCKS
      NM =          NBK          *((KCBN-1)/KSIZE)
C        FIND  NO. OF ELEMENTS OF X IN LAST BLOCK
      NL =  I   - NF - NM
      LOCXI=LOCX1-(NF+NL-1)*KSIZE-NBK*KCBN-1
      IF(NL.EQ.0)LOCXI=LOCXI+MOD(KCBN-1,KSIZE)+1
C
C        STORE ADDRESS
 1310 NTP = NTB + PP(ILC+3)
      NT(1,NTP) = LOCXI + CFB
C
C  CHECK IF INDEX IS IN RANGE.
      IF(LOCXI+CFB.GT.IAP) GOTO 9010
      IX = LOCXI+CFB
      IF(CANFLG)IX= XCANON(IX)
      IF(KSIZE.EQ.2) GOTO 1320
      CALL UNPACK(COM(IX),IM,IS,IX)
      IF(IX.EQ.0) IX=1
 1330 IF(IX.NE.I) GOTO 9010
      GO TO 200
 1320 IX = COM(IX+1)
      GOTO 1330
C
C
C
C     PROCESS CALMC INSTRUCTION
C
C        PUSH DOWN MACRO STACK
C
14    RTP = RTP + 1
C
C        SAVE LINE(PAGE AND INDEX  OF THIS INSTRUCTION
C
      LNA(1,RTP) = PGC
      LNA(2,RTP) = IXC
C
C        RESET LOCATION COUNTER TO MACRO ADDRESS
C
      NTP = PP(ILC + 2) + NTB
      CALL SET(NT(1,NTP))
      GO TO 300
C
C
C        PROCESS ASNADD INSTRUCTION
C
C        GET COM POINTER OF OPERAND
   15 CONTINUE
      KZTEMP=PP(ILC+3)
      IF(KZTEMP.NE.1) GO TO 1510
C---     SPECIAL ACTION FOR NUMBER ASSIGNMENT IN PAGING ENVIRONMENT
      NTP=NTB+PP(ILC+2)
      NT(1,NTP)=PP(ILC+4)
      NT(2,NTP)=ISPECL
      GO TO 200
 1510 CONTINUE
      XTEMP=GET(3)
      NTP=NTB+PP(ILC+2)
      NT(1,NTP)=COMP
      NT(2,NTP)=0
      GO TO 200
C
C
C        PROCESS ASNJMP INSTRUCTION
C
C        COMPUTE THE TWO NAME TABLE POINTERS, TRANSFER DATA AND EXIT
C
16    NTP1 = NTB + PP(ILC + 2)
      NTP2 = NTB + PP(ILC + 3)
      NB(NTP1) = NB(NTP2)
      GO TO 200
C
C
C        PROCESS REPL INSTRUCTION
C
C        GET COM POINTER OF OPERAND
 17   XTEMP = GET(3)
      COMP1 = COMP
C
C        GET COM POINTER OF RESULTANT
      XTEMP = GET(5)
      IF(.NOT.CANFLG) GOTO 1705
      COMP1 = XCANON(COMP1)
      COMP = XCANON(COMP)
C  ABFANGEN BEI FEHLERHAFTEM EINGABEELEMENT
 1705 LLLL=PP(ILC+5)
      IF(LLLL.GT.0.AND.LLLL.NE.3)GOTO 1709
      LLL=0
      IF(LLLL.LT.0) LLL=1+LLLL
      IF(.NOT.CKDEF(COM(COMP+LLL))) GOTO 1709
      GOTO 1708
C        REPLACE ELEMENTS
 1709 KOUNT = PP(ILC + 2)
      DO 1710 I=1,KOUNT
      COM(COMP1) = COM(COMP)
      COMP = COMP + 1
 1710 COMP1= COMP1+ 1
C
      GO TO 200
C
C
C        PROCESS CALL INSTRUCTION
C
 18   IF(ISCHRO.NE.0) GOTO 181
      CALL LIB
 181  IF(PP(ILC+2).EQ.18) RETURN
      GO TO 200
C
C
C        PROCESS MOVE INSTRUCTION
C
C        GET COM POINTER OF OPERAND
 19   XTEMP = GET(2)
      COMP1 = COMP
      IF(CANFLG) COMP1 = XCANON(COMP1)
C
C        MOVE ELEMENTS
      KOUNT = PP(ILC+1)
      DO 1910 I=4,KOUNT,2
      K=ILC+ILD+I
      IF (K.GE.J)GOTO 200
      COM(COMP1) = GET(I)
      LLLL=PP(K)
      IF(LLLL.GT.0.AND.LLLL.NE.3) GOTO 1910
      LLL=0
      IF(LLLL.LT.0) LLL=1+LLLL
      COMP=COMP+LLL
      IF(CANFLG) COMP=XCANON(COMP)
      IF(.NOT.CKDEF(COM(COMP))) GOTO 1910
      COMP1=COMP
      GOTO 1708
 1910 COMP1 =COMP1 + 1
C
      GO TO 200
C
C
C        PROCESS VBLJMP INSTRUCTION
C
C        OBTAIN INDEX TO JUMP
C.... USING MODIFIED IL FOR INDEX WHICH IS NOT SYSTEM DEPENDENT
   20 XTEMP=GET(2)
      KOUNT=INT(XTEMP)
C
C        IF INDEX NOT IN RANGE,CONTINUE
      IF(KOUNT.GE.(PP(ILC+1)-1).OR.KOUNT.LE.0) GO TO 200
C
C        GO TO LABEL INDICATED BY INDEX
      KOUNT = KOUNT + ILC + 3
      NTP1 = PP(KOUNT)
      GO TO 8001
C
C
C        PROCESS HOLDAT INSTRUCTION
C
C        THE FOLLOWING CODE IS IMPLIMENTATION DEPENDENT             *ID*
C        ALL HOLDAT INSTRUCTIONS EXECUTED DURING INITIALIZATION
C
C        STORE NUMBER OF WORDS OF BCD DATA
 21   TT(1) = PP(ILC+1)
C
C        STORE NUMBER OF CHARACTERS
      TT(2) = PP(ILC+3)
C
      L=IAP
C
C        STORE CHARACTERS
      K=PP(ILC+3)/8
      IF (PP(ILC+3).GT.K*8) K=K+1
      IF(.NOT.CANFLG) GOTO 2105
C        WILL STORAGE REQUIREMENTS EXCEED BLOCK LENGTH
      IF((L-CFB+K)/KCBN.EQ.(L-CFB)/KCBN) GOTO 2102
C        YES,INDICATE NO. OF WORDS TO BE SKIPPED.
      J= XCANON(L)
      LL(1)=KCBN-MOD((L-CFB),KCBN)
      IA(J)=XL
C        SKIP TO NEXT BLOCK OF STORAGE
      L=((L-CFB+K)/KCBN)*KCBN+CFB
      IAP=L
 2102 L=XCANON(L)
 2105 IA(L)=XTEMP
      DO 2110 I = 1,K
      L=L+1
      J = ILC + 2*(I+1)
C
C        OBTAIN CHARACTERS ONE INTEGER WORD FULL AT A TIME
      TT(1) = PP(J)
      TT(2) = PP(J+1)
      IA(L)=XTEMP
C
C        STORE CHARACTERS EIGHT AT A TIME
 2110               CONTINUE
C        STORE POINTER
      NTP = NTB+PP(ILC+2)
      NT(1,NTP) = IAP
      IAP = IAP + K + 1
C
      GO TO 200
C
C
 9010 CALL RECORD (SQNC)
      CALL CFORM('029003 INDEX OUT OF RANGE. ISN=',DARRAY,1,31)
      CALL ICONV (SQNC,DARRAY,32,4)
      CALL CFORM (' INDEX=',DARRAY,36,7)
      CALL ICONV (I,DARRAY,41,5)
      CALL CPRINT(DARRAY)
      CALL HELP
 9020 CALL RECORD(SQNC)
      CALL CFORM('029004 SYSTEM ERR-ILLEGAL I.L. INSTRUCTION. ISN= '  ,
     X    DARRAY,1,49)
      CALL ICONV (SQNC,DARRAY,51,4)
      CALL CPRINT(DARRAY)
      CALL HELP
      RETURN
C  AUSGABE DER FEHLERHAFTEN GEOMETRIE-NAMEN
 1708 ISCHRO=1
      IF(COMP1.GE.SCP) GOTO 1720
C  NAME EINES SKALARELEMENTES
      ISIZE=1
      ISUB=0
      GOTO 1750
 1720 IF(COMP1.GE.SAP) GOTO 1730
C  NAME EINES INDIZIERTEN SKALARELEMENTES
      ISIZE=2
      ISUB=COM(COMP1+1)
      ISIZE1=ISUB*2
      GOTO 1750
C  NAME EINES GEOMETRIEELEMENTES
 1730 CALL UNPACK(COM(COMP1),MODE,ISIZE,ISUB)
      IF(ISUB.GE.1) ISIZE1=ISUB*ISIZE+ISUB-1
 1750 CALL CFORM(' WRONG INPUT ELEMENT        :',DARRAY,1,29)
      IF(ISUB.GE.1) GOTO 1706
C  NICHT INDIZIERTE VARIABLE
      CALL HOLFRM(COM(COMP1+ISIZE),DARRAY,30,8,NWD)
      GOTO 1707
C  INDIZIERTE VARIABLE
 1706 CALL HOLFRM(COM(COMP1+ISIZE1),DARRAY,30,8,NWD)
      CALL CFORM('(      )',DARRAY,38,8)
      CALL ICONV(ISUB,DARRAY,40,4)
 1707 CALL CPRINT(DARRAY)
      GOTO 200
      END
