      PROGRAM FTORUS
C
C  PURPOSE: TO DEFINE A NON-NATIVE CANONICAL FORM FOR A TORUS
C           FORMATTED TO SATISFY THE APT4 DATA STRUCTURE
C           AND STORE IT IN APT4 EXTERNAL LDA FORM
C
      DOUBLE PRECISION RESULT(4,8),TORCAN(110)
      COMMON/TOR/TORCAN
C
      COMMON/SDP/NBCHAR,NBWRD,IWRD,IFAC
C
C
C.... DEFINE TORUS CANONICAL FORM IN APT4 DATA STRUCTURE
C
      CALL DEFTOR
C
C.... OUTPUT TORUS CANONICAL FORM IN APT4 LDA EXTERNAL FILE FORMAT
C
      CALL PUNTOR
C
      STOP
      END
      BLOCK DATA SDPDAT
C
      COMMON/SDP/NBCHAR,NBWRD,IWRD,IFAC
C
C
C     NBCHAR:  NO. OF BITS PER BYTE
      DATA NBCHAR/8/
C     NBWRD:   NO. OF BITS PER WORD
      DATA NBWRD/32/
C     IWRD:    NO. OF BYTES PER WORD
      DATA IWRD/4/
C     IFAC:    BYTE LEFT SHIFT MULTIPLICATION FACTOR
      DATA IFAC/256/
C
      END
      SUBROUTINE DEFTOR
      DOUBLE PRECISION A(3),P(3),C(3),TORCAN(110),TEMP
      DOUBLE PRECISION TOT,R1,R2,UM,VM
      INTEGER ITEMP(2),BCDF
      EQUIVALENCE (TEMP,ITEMP(1))
      COMMON/TOR/TORCAN
C
C SUBROUTINE TO SET UP A CANONICAL ARRAY FOR A TORUS AS 4 PATCHES.
C
C FOR EACH PATCH DATA CONSISTS OF:
C           1-3   = AXIS OF SYMMETRY
C           4-6   = CENTRE OF TOROID
C           7-9   = REF AXIS ( START OF PARAMETERIZATION)
C           10    = MAJOR RADIUS R1
C           11    = MINOR RADIUS R2
C           12,13 = UMIN,UMAX (IN RADIANS)
C           14,15 = VMIN,VMAX (IN RADIANS)
C
      PRINT*,' '
      PRINT*,
     1' THIS PROGRAM SETS UP THE CANONICAL FORM OF A TORUS AS 4 PATCHES'
      PRINT*,' AND CREATES AN APT4 LDA EXTERNAL FILE'
      PRINT*,' '
      PRINT*,' INPUT MAJOR AND MINOR RADII OF TORUS'
      READ*,R1,R2
      PRINT*,' AXIS OF SYMMETRY VECTOR ?'
      READ*,A(1),A(2),A(3)
      PRINT*,' CENTRE OF TORUS ?'
      READ *,C(1),C(2),C(3)
      PRINT*,' REF POINT (START OF PARAMETERIZATION, IE. U=0,V=0) ?'
      READ *,P(1),P(2),P(3)
      PRINT*, 'UMAX,VMAX (IN RADIANS) ?'
      PRINT*,' NOTE: U - MINOR RADIUS DIRECTION'
      PRINT*,'       V - MAJOR RADIUS DIRECTION'
      READ*, UM,VM
C NORMALISE AXIS VECTOR
      TOT=A(1)*A(1)+A(2)*A(2)+A(3)*A(3)
      TOT=DSQRT(TOT)
      IF(TOT.LE.1.0E-6) GO TO 200
      DO 10 I=1,3
      A(I)=A(I)/TOT
 10   P(I)=P(I)-C(I)
      TOT=0.0
      DO 20 I=1,3
 20   TOT=TOT+A(I)*P(I)
      DO 30 I=1,3
  30  P(I)=P(I)-A(I)*TOT
      TOT=0.0
C P WILL NOW DEFINE THE NORMALISED REFERENCE AXIS
      DO 40 I=1,3
  40  TOT=TOT+P(I)*P(I)
      TOT=DSQRT(TOT)
      IF(TOT.LE.1.0E-6) GO TO 200
      DO 50 I=1,3
  50  P(I)=P(I)/TOT
C SET UP HEADER BLOCK
      TORCAN(2)=60.0
      TORCAN(3)=16.0
      TORCAN(4)=4.0
      TORCAN(5)=2.0
      TORCAN(6)=1.0
      TORCAN(7)=1.0
      TORCAN(8)=110.
      TORCAN(9)=3.0
      TORCAN(10)=3.0
C PATCH HEADER BLOCKS
C
C.... INSERT NON-NATIVE SURFACE TYPE NAME IN SYSTEM INDEPENDENT
C     INTERNAL FORM
      ITEMP(1)=BCDF('TORU')
      ITEMP(2)=BCDF('S   ')
      DO 60 I=11,29,6
       DO 55 J=1,3
        TORCAN(I+J)=0.0
  55   CONTINUE
       TORCAN(I+4)=TEMP
  60  CONTINUE
      TORCAN(16)=95.0
      TORCAN(22)=99.0
      TORCAN(28)=103.0
      TORCAN(34)=107.0
      TORCAN(11)=35.0
      TORCAN(17)=50.0
      TORCAN(23)=65.0
      TORCAN(29)=80.0
C PATCH GEOMETRY BLOCKS
      DO 70 I=34,79,15
       DO 65 J=1,3
        TORCAN(I+J)=A(J)
        TORCAN(I+3+J)=C(J)
        TORCAN(I+6+J)=P(J)
  65   CONTINUE
       TORCAN(I+10)=R1
       TORCAN(I+11)=R2
  70  CONTINUE
      TORCAN(46)=0.0
      TORCAN(47)=UM/2.0
      TORCAN(49)=VM/2.0
      TORCAN(48)=0.0
      TORCAN(61)=UM/2.0
      TORCAN(62)=UM
      TORCAN(63)=0.0
      TORCAN(64)=VM/2.0
      TORCAN(76)=0.0
      TORCAN(77)=UM/2.0
      TORCAN(78)=VM/2.0
      TORCAN(79)=VM
      TORCAN(91)=UM/2.0
      TORCAN(92)=UM
      TORCAN(93)=VM/2.0
      TORCAN(94)=VM
C PATCH TOPOLOGY DATA
      TORCAN(95)=0.0
      TORCAN(96)=0.0
      TORCAN(97)=2.0
      TORCAN(98)=3.0
      TORCAN(99)=0.0
      TORCAN(100)=1.0
      TORCAN(101)=0.0
      TORCAN(102)=4.0
      TORCAN(103)=1.0
      TORCAN(104)=0.0
      TORCAN(105)=4.0
      TORCAN(106)=0.0
      TORCAN(107)=2.0
      TORCAN(108)=3.0
      TORCAN(109)=0.0
      TORCAN(110)=0.0
C
      RETURN
 200  PRINT*,' AXIS VECTOR MAGNITUDE TOO SMALL'
      RETURN
      END
      SUBROUTINE PUNTOR
C
C    PURPOSE: TO OUTPUT THE APT4 FORMATTED CANONICAL FORM OF A TORUS
C             IN APT4 LDA EXTERNAL FILE FORMAT
C
      DOUBLE PRECISION TORCAN(110)
      COMMON/TOR/TORCAN
C
      COMMON/SDP/NBCHAR,NBWRD,IWRD,IFAC
C
C
      CHARACTER*6 SSNAME
      CHARACTER FILNAM*40,CSTAT*6
      CHARACTER RES*1
C
      DOUBLE PRECISION ARRAY(10)
      INTEGER IARRAY(2,10),SIZE,BCDF,ILEN,LEN,ID
      EQUIVALENCE (ARRAY(1),IARRAY(1,1))
C
      PRINT *,' APT SURFACE NAME (MAX 6 CHARACTERS) ?'
      READ (*,'(A6)') SSNAME
C
      PRINT *,' DEFAULT FILENAME : NAME.LDA - IS THIS OK (Y/N)?'
  10  READ (*,'(A1)') RES
      IF (RES.EQ.'Y') THEN
        FILNAM=SSNAME
        ILEN=6
      ELSE IF (RES.EQ.'N') THEN
        PRINT *,' FILENAME (MAX 40 CHARACTERS) ?'
        READ (*,'(A40)') FILNAM
        ILEN=40
      ELSE
        PRINT *,' Y OR N ?'
        GO TO 10
      ENDIF
C
      DO 20 I=ILEN,1,-1
        IF (FILNAM(I:I).NE.' ') THEN
          LEN=I
          GOTO 22
        ENDIF
   20 CONTINUE
C
C.... NULL FILENAME
      FILNAM='TOR'
      LEN=3
C.... APPEND FILE TYPE TO NAME
   22 FILNAM=FILNAM(1:LEN)//'.LDA'
      LEN=LEN+4
C
C.... OPEN LDA EXTERNAL FILE
C
      ID=30
      OPEN (UNIT=ID,FILE=FILNAM(1:LEN),STATUS='NEW',ERR=100,
     +      FORM='UNFORMATTED',ACCESS='SEQUENTIAL')
C
C.... SET UP FILE HEADER INFORMATION FOR EXTERNAL FILE
C
C.... SET UP SURFACE NAME IN SAME INTERNAL FORM AS USED IN APT4,
C     IN FIRST D.P. WORD
C
      IARRAY(1,1)=BCDF(SSNAME(1:IWRD))
      IARRAY(2,1)=BCDF(SSNAME(IWRD+1:6))
C
C.... SUBSCRIPT ?
C
      ARRAY(2)=0.D0
C.... MODE
      IARRAY(1,3)=29
C.... LENGTH OF HEADER IN D.P. WORDS ?
      IARRAY(2,3)=5
C
      IARRAY(1,4)=0
C.... SIZE OF CANONICAL FORM FOR TORUS
      SIZE=INT(TORCAN(8))
      IARRAY(2,4)=SIZE
C
      ARRAY(5)=0.D0
C
C
C.... STORE LDA CANONICAL FORM IN EXTERNAL FILE
C
      CNT=0
      JJ=6
      I1=SIZE-1
      DO 30 I=1,I1
       ARRAY(JJ)=TORCAN(I+1)
       IF (I.EQ.I1) GOTO 25
       JJ=JJ+1
       IF (JJ.LE.9) GOTO 30
  25   CNT=CNT+1
       ARRAY(10)=CNT
C.... WRITE TO LDA FILE
       WRITE(UNIT=ID,ERR=200) (ARRAY(J),J=1,10)
       DO 26 J=1,10
         ARRAY(J)=0.D0
  26   CONTINUE
       JJ=1
  30  CONTINUE
C
      CSTAT='KEEP'
      GOTO 900
C
  100 PRINT *,' ERROR OPENING FILE: ',FILNAM(1:LEN)
      GOTO 999
C
  200 PRINT *,' ERROR WRITING TO EXTERNAL FILE: ',FILNAM(1:LEN)
      CSTAT='DELETE'
      GOTO 900
C
  900 CLOSE(UNIT=ID,STATUS=CSTAT)
C
  999 RETURN
      END
***********************
*    SSV3 ROUTINES    *
***********************
*
*  * BCDF *  FORTRAN 77 INTEGER FUNCTION  19-DEC-1985  E.MCLELLAN
*            MODIFIED                      2-FEB-1988  E.MCLELLAN
*
*  PURPOSE:  CONVERT A STRING OF CHARACTERS WHICH OCCUPY THE SAME
*            NUMBER OF BYTES AS AN INTEGER WORD INTO AN EQUIVALENT
*            INTEGER VALUE
*
*  CALLING SEQUENCE:
*                   VALUE=BCDF(STR)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*       STR         CHARACTER  STRING TO BE CONVERTED
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   IWRD            SDP       INTEGER    NO. OF BYTES PER WORD
*   NBCHAR          SDP       INTEGER    NO. OF BITS PER BYTE
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*        I          INTEGER    LOOP COUNT
*        BCD        INTEGER    VARIABLE FOR BUILDING UP BCD VALUE
*        TSTR       CHARACTER  TEMPORARY STORAGE FOR STRING
*
*  FILES:  NONE
*
*  SUBSIDIARIES:  NONE
*
      INTEGER FUNCTION BCDF(STR)
C
      INCLUDE (SDP)    
C
      INTEGER  BCD
      CHARACTER*(*) STR,TSTR*10
C
      BCD=0
      TSTR=STR//' '
      DO 10 I=1,IWRD
      BCD=ISHFT(BCD,NBCHAR)+ICHAR(TSTR(I:I))
  10  CONTINUE
C
      BCDF=BCD
C
      END
*
*  * HOLFRM *  FORTRAN 77 SUBROUTINE  16.7.86  E.MCLELLAN
*                MODIFIED                 2-FEB-1988  E.MCLELLAN
*
*  PURPOSE:  TO INSERT SPECIFIED NUMBER OF CHARACTERS IN BCDF FORM
*            FROM INTEGER ARRAY INTO CHARACTER VARIABLE
*            STARTING FROM SPECIFIED LOCATION - RETURNING THE NUMBER
*            OF INTEGER WORDS OCCUPIED
*
*  CALLING SEQUENCE:
*                   CALL HOLFRM(IARR,STR,IST,NCHR,NWD)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*       IARR        INTEGER    ARRAY CONTAINING BCDF CHARACTERS
*       STR         CHARACTER  STRING INTO WHICH CHARACTERS ARE
*                              TO BE LOADED
*       IST         INTEGER    START LOCATION IN STR
*       NCHR        INTEGER    NUMBER OF CHARACTERS TO BE INSERTED
*       NWD         INTEGER    NUMBER OF WORDS OCCUPIED
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*     IWRD          SDP       INTEGER    NO OF BYTES PER WORD
*     NBCHAR        SDP       INTEGER    NO OF BITS PER BYTE
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*     IVAL          INTEGER    VALUE OF INTEGER WORD
*     JVAL          INTEGER    INDEX OF CHARACTER IN CONCATINATION
*                              SEQUENCE
*
*  FILES:  NONE
*
*  SUBSIDIARIES:  NONE
*
      SUBROUTINE HOLFRM(IARR,STR,IST,NCHR,NWD)
C
C.... SYSTEM DEPENDENT PARAMETERS
C
      INCLUDE (SDP)    
C
      INTEGER IARR(*),IST,NCHR,NWD,IVAL,JVAL,SLEN
C
      CHARACTER*(*) STR
C
      SLEN=LEN(STR)
      NWD=NCHR/IWRD
      IF (NCHR.GT.NWD*IWRD) NWD=NWD+1
      DO 20 I=1,NWD
        IVAL=IARR(I)
        K1=IST+I*IWRD
        DO 10 J=IWRD,1,-1
          K=K1-J
          JJ=NBCHAR*(J-1)
          JVAL=ISHFT(IVAL,-JJ)
          IF (K.LE.SLEN) THEN
            STR(K:K)=CHAR(JVAL)
          ENDIF
          IVAL=(IVAL-ISHFT(JVAL,JJ))
  10    CONTINUE
  20  CONTINUE
C
      END
