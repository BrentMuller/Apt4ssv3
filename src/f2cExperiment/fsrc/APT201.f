**** SOURCE FILE : M0002726.W02   ***
c moved this function to an external function to remove compile error
*
C
C
C.....FORTRAN INTEGER FUNCTION  ...APT211    8/68              HG,DE,PH
C
C.....MODIFIED FOR VAX 11 IMPLEMENTATION   02.06.82   E.MCLELLAN
C
C.....MODIFICATION TO PERMIT RESTART PROCEDURE USING
C     VAX CONDITION HANDLING FACILITIES
C
C
c      INTEGER FUNCTION APT211(ADRESS,HDRECT,IAEEE)
cC
c      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
c      DIMENSION ADRESS(*)
cC
c      INCLUDE 'TOTAL.INC'
c      INCLUDE 'DSHAR4.INC'
c      INCLUDE 'FXCOR.INC'
c      INCLUDE 'HOLRTH.INC'
c      INCLUDE 'SV.INC'
c      INCLUDE 'ZNUMBR.INC'
c      INCLUDE 'LDEF.INC'
c      INCLUDE 'ISV.INC'
c      INCLUDE 'IFXCOR.INC'
c      INCLUDE 'KNUMBR.INC'
cC
cC...            SYSTEM I/O FILE NAMES
cC
c      INCLUDE 'SYMFIL.INC'
cC
c      CHARACTER*8 TEST,HNOCS
c      INTEGER BCDF,TDS(2)
c      LOGICAL FIRST
c      SAVE FIRST,HOLDPP,TDS
c      CHARACTER*8 HOLRTH(6)
c      EQUIVALENCE (HOLRTH(1),HLFT)
cC
c      INTEGER Z4E
c      PARAMETER (Z4E=1308622848)
c      INTEGER HOLDPP
c      DIMENSION HOLDPP(8)
cC
c      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
c      COMMON /HSAVE/ SAVEH(50)
c      COMMON/SQNC/ LSEQNO
cC
cC++++ FLAG TO ALLOW A SECOND TRY WITHOUT CHECKING TA TO OVERCOME
cC++++ ERROR 20106
c      INTEGER I20106
cC
cC
c      LOGICAL KCS
cC
c      INCLUDE 'BLANKCOM.INC'
cC
c      DIMENSION MODTYP(3,6)
c      DIMENSION CSSAVE(10)
cC
c      DATA HOLDPP/0,0,Z4E,1,Z4E,1,Z4E,1/
c      DATA HNOCS/'NOCS    '/
c      DATA MODTYP/1,2,3,2,1,3,6*4,1,2,3,2,1,3/
c      DATA ZLIT2/.0349D0/
c      DATA FIRST/.TRUE./
cC
c      IF (FIRST)THEN
c        HOLDPP(1) = BCDF('HOLD')
c        HOLDPP(2) = BCDF('PP  ')
c        TDS(1) = BCDF(HDS(1:4))
c        TDS(2) = BCDF(HDS(5:8))
c        FIRST=.FALSE.
c      ENDIF
cC
c      CALL HOLFRM(HDRECT,TEST,1,8,NWD)
c      IF (IAEEE .EQ. 1) GO TO 8010
c      IF(IAERR.EQ.1) GO TO 1000
c      IF(TEST.EQ.HNOCS) GO TO 8000
c      IF(IGOTO+ICTDEF)1,1,3000
c    1 DO 4001 I=1,6
c      IF(TEST.EQ.HOLRTH(I)) GO TO 4002
c 4001 CONTINUE
c      CALL AERR(20104,'APT211  ')
c      GO TO 1000
c 4002 ISAV=I
c      IF(.NOT.JDS)GO TO 4000
c      KSEQNO = LSEQNO
c      LSEQNO = JSEQNO
c      KCSCNT=ICSCNT
c      KCS=JCS
c      LSAV=ISFTYP(IDS)
c      ISFTYP(IDS)=MSAV
c      ICSCNT=0
c      KIPL=IPL(ICS)
c      KLMFL=LIMFL(ICS)
c      KUNFL=IUNFL(ICS)
c      KFIDN=ISFIDN(ICS)
c      KSTYP=ISFTYP(ICS)
c      KTLON=ITLON(ICS)
c      SPAST=PAST(ICS)
c      KCAN=ICANON(ICS)
c      KFL4=IFL4(ICS)
c      KFAR=IFAR(ICS)
c      DO 1530 IIT = 1,10
c 1530 CSSAVE(IIT) = CANON(IIT+20)
c      CALL APT200(TDS,ADRESS,Z1)
c      IF(IAERR.NE.0)GO TO 1000
c      IF(MOTMOD.EQ.0)GO TO 4004
c      ISFTYP(ICS)=MODTYP(MOTMOD,ISAV)
c      IF(ISFTYP(ICS).EQ.2) PAST(ICS)=-K1
c      IS=IDS
c      GO TO 9200
c 4000 MODFER=TEST
c      IGO=ISAV
c      MSAV=ISFTYP(IDS)
c      IS=IDS
c      CALL APT234(TDS,ADRESS)
c      IF(IAERR.NE.0)GO TO 1000
c      IF(JCS)GO TO 9200
c      JSEQNO = LSEQNO
c      JDS=.TRUE.
cC     INTEG.ON EXFILE DP. 1ST WD UNNORM POWER,2ND INTEG VALUE
c      NR=0
c      CALL EWRITE(EXFILE,NR,HOLDPP,8,IR)
c      JHLDFG=1
c      GO TO 9999
c 4004 CALL AERR(20109,'APT211  ')
c      GO TO 1000
c 9200 CALL APT235
c      IF(IAERR)6000,6000,1000
c 6000 CALL APT240 (NUMDIM)
c   14 ICL = K2
c      NW = 0
c   19 IF (CUTDAT(6).EQ.0.)GO TO 32
c      NUMDIM = K1
c      GO TO 32
c   72 CALL APT236
c      IF(IAERR.NE.0)GO TO 4006
c      IF(JDS)GO TO 4005
c 4006 CONTINUE
c      JHLDFG=0
c      ITHCNT=1
c      JCS=.FALSE.
c      JDS=.FALSE.
c      GO TO 9999
c 4005 JCS=KCS
c      JHLDFG=0
c      GO TO 9500
c 9600 CONTINUE
c      NR=0
c      HOLDPP(8)=K2
c      CALL EWRITE(EXFILE,NR,HOLDPP,8,IR)
c      HOLDPP(8)=K1
c      ISFTYP(IDS)=LSAV
c      LSEQNO = KSEQNO
c      IF(.NOT.JCS)GO TO 4000
c      IPL(ICS)=KIPL
c      LIMFL(ICS)=KLMFL
c      ISFIDN(ICS)=KFIDN
c      ISFTYP(ICS)=KSTYP
c      ITLON(ICS)=KTLON
c      PAST(ICS)=SPAST
c      ICANON(ICS)=KCAN
c      IFL4(ICS)=KFL4
c      IFAR(ICS)=KFAR
c      ICSCNT=KCSCNT
c      JDS=.FALSE.
c      DO 1531 IIT = 1,10
c 1531 CANON(IIT+20) = CSSAVE(IIT)
c      GO TO 4000
c   32 J6 = 0
c      IS=IPS
cC  INITIALIZE VARIABLES FOR AMIND
c   33 IF (JENT(IS)) 301,302,301
c  301 JTN(IS) = K0
c      IOPSET(IS)=0
c      JU1(IS)=0
c      JIOPS(IS)=0
c  302 JAP = K1
c  201 CALL AMIND
c      IF(IAERR)1000,2000,1000
c 2000 IF(IPL(IS))141,140,141
c  141 IF(S(IS))142,39,143
c  142 IF (S(IS)-TAU2(IS)+1.D-4) 36,39,39
c  143 IF (S(IS)-TAU1(IS)-1.D-4) 39,39,36
c  140 IF(RC(IS)*S(IS))34,39,35
c   34 IF(DABS(S(IS))-Z9EM1*TAU(IS)-1.D-4) 39,39,36
c   35 IF(DABS(S(IS))-EPS1(IS)-1.D-2) 39,39,36
c   36 GO TO(505,508,504,204),JAP
c  505 IF (IPL(IS)) 506,202,506
c  202 IF (ISFTYP(IS)-K3) 504,507,504
c  504 RC(IS)=-RC(IS)
c      JAP = JAP + K1
c      GO TO 201
c  506 IF (TH(IS)) 510,510,204
c  507 JAP = K4
c  203 Z(IS)=-Z(IS)
c      GO TO 201
c  510 IF (IAFL(IS)) 507,511,507
c  511 JENT(IS)= -K1
c      JAP = K4
c      GO TO 201
c  508 IF (TH(IS)) 509,204,204
c  509 JAP = JAP + K1
c      GO TO 203
c  204 IF(J6)38,37,38
cC  CUTTER NOT WITHIN TOLERANCE OF DRIVE SURFACE AT START OF CUT SEQUENCE
c   38 CALL AERR (20102,'APT211  ')
c      GO TO 1000
cC  CUTTER NOT WITHIN TOLERANCE OF PART SURFACE AT START OF CUT SEQUENCE
c   37 CALL AERR (20103,'APT211  ')
c      GO TO 1000
c   40 J6=K1
c      IS=IDS
c      GO TO 33
c   39 IF (JAP-K1) 480,481,480
c  480 TPK(1,IS)=TP(1,IS)
c      TPK(2,IS)=TP(2,IS)
c      TPK(3,IS)=TP(3,IS)
c      SNK(1,IS)=SN(1,IS)
c      SNK(2,IS)=SN(2,IS)
c      SNK(3,IS)=SN(3,IS)
c      SK(1,IS) = S(IS)
c  481 IF(J6)41,40,41
cC  DETERMINE GENERAL DIRECTION OF FIRST CUT VECTOR AND STORE IN FWD
c   41 DO 42 K=1,3
c   42 FWD(K)=TE(K)-TEK(K)
c 2001 CALL VNORM(FWD,FWD)
cC  IGO =1 IF LFT, =2 IF RGT, =3 IF FWD, =4 IF BACK, =5 IF UP, =6 IF DOWN
cC  RELATIVE TO LAST COMMAND
c      IF(K4-IGO)43,45,45
c   43 DO 44 K=1,3
c   44 FWD(K)=TA(K)
c      GO TO 50
c   45 CALL CROSS(FWD,TA,FWD)
c      CALL VNORM(FWD,FWD)
c      IF (VTEM.GT.Z1EM6)GO TO 48
c   46 CALL CROSS(PMOVE,TA,FWD)
c      CALL VNORM(FWD,FWD)
c      IF(IER)47,48,47
cC  FWD DIRECTION CANNOT BE DETERMINED
c   47 CALL AERR (20105,'APT211  ')
c      GO TO 1000
c   48 IF(K3-IGO)49,49,50
c   49 CALL CROSS(TA,FWD,FWD)
c      CALL VNORM(FWD,FWD)
c      IF(IER)147,50,147
c  147 GO TO 47
c   50 GO TO (52,54,54,52,54,52),IGO
c   52 DO 53 K=1,3
c   53 FWD(K)=-FWD(K)
cC  CALCULATE TI VECTOR PERPENDICULAR TO BOTH PART AND DRIVE SURFACE
cC  NORMALS
c   54 CALL CROSS(SN(1,IPS),SN(1,IDS),TI)
c      CALL VNORM(TI,TI)
c      IF(IER)58,60,58
c   58 DO 59 K=1,3
c   59 TI(K)=FWD(K)
c      GO TO 67
cC  TI VECTOR AND FWD VECTOR SHOULD NOT BE ORTHOGONAL. IF SO CALL AERR
c   60 TEM(1)= TI(1)*FWD(1) +TI(2)*FWD(2)+TI(3)*FWD(3)
c      IF(DABS(TEM(1)) - ZLIT2) 64,64,63
c   64 IF (I20106.EQ.0) THEN
cC++++ HAVE SECOND TRY WITHOUT CHECKING TA TO AVOID ERROR 20106
c        I20106=1
c        CALL OUTMSG('*** WARNING: ERROR 20106 IN APT201 ***')
c        CALL OUTMSG('*** TRY WITHOUT CHECKING TA        ***')
c        DO 641 K=1,3
c          FWD(K)=TE(K)-TEK(K)
c  641   CONTINUE
c        CALL VNORM(FWD,FWD)
c        GOTO 50
c      ELSE
c        CALL AERR (20106,'APT211  ')
c        GO TO 1000
c      ENDIF
c   63 IF(TEM(1)) 65,65,67
c   65 DO 66 K=1,3
c   66 TI(K)=-TI(K)
c   67 IF(NUMDIM)68,68,73
cC  ICSCNT = NUMBER OF CHECK SURFACES. IF MORE THAN ONE CHECK SURFACE 3D
cC  ROUTES USED
c 68   CONTINUE
c  168 IF(I3DFLG-K1)130,73,130
c  130 IF(ICSCNT-K2)69,73,73
cC  IF THICKNESS OF PART, DRIVE, AND CHECK SURFACE NOT ZERO 3D ROUTES
cC  FOLLOWED
c   69 IF(TH(IPS))173,70,173
c  173 GO TO 73
c   70 IF(TH(IDS))174,71,174
c  174 GO TO 73
c   71 IF(TH(ICS))73,76,73
c   73 CONTINUE
cC  ENTRY FOR 3D CALCULATIONS
c  732 CALL ARLM3
c      APT211=TEMP(1)+0.5
c  101 IF(IAERR)1000,72,1000
c   76 IS=ICS
c      IF(ISFIDN(IDS)-K3)80,86,86
c   80 IF(ISFIDN(ICS)-K3)82,81,81
cC  LINE TO LINE CASE
c   82 JBR=K3
c      GO TO 83
cC  CIRCLE TO LINE OR CIRCLE TO CIRCLE CASE
c   86 JBR=K1
cC  ENTRY FOR 2D CALCULATIONS
c   83 CALL ARLM2
c      APT211=Z1
c      GO TO 101
cC  LINE TO CIRCLE CASE
c   81 JBR=K2
c      GOTO83
c 6001 IF(IGOTO)3001,3001,3002
c 3001 CALL AERR (20107,'APT211  ')
c      GO TO 1000
c 3002 CALL AERR (20108,'APT211  ')
c 1000 CONTINUE
c 6002 APT211=Z1
c      GO TO 72
c 3000 IF(ISRCH)6001,6001,6002
c 9999 CONTINUE
c      RETURN
c 9500 JJ=0
c 9510 JJ=JJ+1
c      IF(JJ.EQ.ITHCNT) GO TO 9590
c      KK=ITABH(JJ)
c      GO TO (9510,9510,9510,9504,9505,9506,9507,9508,9509,
c     C 9550,9511,9512,9513),KK
c 9504 CALL TOLERH
c      GO TO 9510
c 9505 CALL CUTTEH
c      GO TO 9510
c 9506 CALL CUTH
c      GO TO 9510
c 9507 CALL DNTCUH
c      GO TO 9510
c 9508 CALL INTOLH
c      GO TO 9510
c 9509 CALL OUTTOH
c      GO TO 9510
c 9550 CALL MAXDPH
c      GO TO 9510
c 9511 CALL INDRVH
c      GO TO 9510
c 9512 CALL INDRPH
c      GO TO 9510
c 9513 CALL THICKH
c      GO TO 9510
c 9590 ITHCNT=1
c      IF(IAEEE.EQ.1) GO TO 8020
c      GO TO 9600
c 8000 KSEQNO = LSEQNO
c      LSEQNO = JSEQNO
c      CALL APT235
c      IAEEE = 1
c      CALL AERR(20110,'APT211  ')
c 8010 IAERR = 0
c      GO TO 9500
c 8020 IAERR = 1
c      NR = 0
c      HOLDPP(8) = K2
c      CALL EWRITE(EXFILE,NR,HOLDPP,8,IR)
c      HOLDPP(8) = K1
c      LSEQNO = KSEQNO
cC....   RETURN TO CALLER
c      GO TO 1000
c      END
c


C
C.....FORTRAN INTEGER FUNCTION  ...APT201
C
C.....NEW SUBROUTINE FOR VAX 11 IMPLEMENTATION   02.06.82   E.MCLELLAN
C
C.....MODIFICATION TO PERMIT RESTART PROCEDURE USING
C     VAX CONDITION HANDLING FACILITIES
C
C
      INTEGER FUNCTION APT201(ADRESS,HDRECT)
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DIMENSION ADRESS(*)
      INTEGER APT211
C
C
      IAEEE=0
C...ESTABLISH CONDITION HANDLER FOR AERR ERROR
    1 CALL APT241
      APT201 = APT211(ADRESS,HDRECT,IAEEE)
      IF (IAEEE.EQ.1) GO TO 1
C...REVERT TO DEFAULT CONDITION HANDLER
c      CALL LIB$REVERT
      call libsrevert
      RETURN
      END
C
C
