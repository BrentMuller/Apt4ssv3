**** SOURCE FILE : M0004316.W03   ***
*
      SUBROUTINE DDSSRF(SS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------ BEGIN SCULPTURED SURFACE TOOL RAY INTERSECTION ALGORITHM
      DIMENSION SS(*)
C
C
      INCLUDE 'TOTAL.INC'
      INCLUDE 'FXCOR.INC'
      INCLUDE 'SV.INC'
      INCLUDE 'ISV.INC'
      INCLUDE 'IFXCOR.INC'
      INCLUDE 'ISHR18.INC'
C
C
      COMMON/MODESS/MODESS,MSSCHK,MSSARL
C
      COMMON/IDDST/IDDST
C
      COMMON/IBUGG/IBUG,I1,I2
C
      COMMON/SSARLM/B(64,4),U(4),V(4),ITOP(6,4,4),IFLAG(4,4),IPNUM(4),
     X              ISEQLS,NLAST,MCAT,
     X              IDDLAS(4),JENLAS(4),LODFLG(4),
     X              NCALMX,NCMX
C
      INCLUDE 'CHEKFL.INC'
C
      DIMENSION DIF(3)
C
      DIMENSION SPSAV(3),DSAV(3)
C
      DATA ZERO,ONE,SMAL/0.D0,1.D0,1.D-12/
      DATA Z5EM1/0.5D0/,ZM5EM1/-0.5D0/
C
      IAERR=0
      LOD63=0
      IDEBUG=0
      IDEBUX=0
      IF(IBUG.EQ.1.OR.IBUG.EQ.2) IDEBUG=1
      IF(IBUG.EQ.2) IDEBUX=1
C
C
      NLAST=NLAST+1
      IP=IS-1
C             /-SAVE UV,PATCH NUMBER IN CASE OF TROUBLE
      USAVE=U(IP)
      VSAVE=V(IP)
      IPSAVE=IPNUM(IP)
C             /-SAVE OLD SP VALUE
      DO 8 I=1,3
    8 SPSAV(I)=SP(I,IS)
      IF(ISEQLS.EQ.ISEQNO) GO TO 20
C             /-RESET INITIALIZING DATA FOR ALL SURFACES FOR NEW STATEME
      DO 30 I=1,4
   30 LODFLG(I)=1
   20 CONTINUE
      IF(JENT(IS).EQ.1.AND.JENLAS(IP).EQ.0) LODFLG(IP)=1
C             /-SET COUNT OF NUMBER OR RETRY-S WITHIN DDSSRF
      KRETRY=0
C
C             /-NLAST RECORDS TOTAL NUMBER OF CALLS TO DDSSRF
C             /-NCALMX IS NUMBER OF CALLS SINCE LAST CUT VECTOR
C             /-NCMX IS MAX NUMBER OF CALLS ALLOWED FOR ONE CUT VECTOR
C             /-ICLCUR IS NUMBER OF CURRENT CL POINT IN CUT RECORD
C             /-MCAT IS LAST VALUE OF ICLCUR ON EXIT FROM DDSSRF
      ICLCUR=NMPNTS-NUMPT1+1
      IF(ICLCUR.NE.MCAT) NCALMX=0
C             /-RESET NUMBER OF CALLS FOR NEW DS
      IF(JENLAS(IP).EQ.0.AND.JENT(IS).EQ.1) NCALMX=0
      NCALMX=NCALMX+1
      IF(NCALMX.GT.NCMX) IAERR=25403
      IF(IAERR.NE.0) GO TO 999
C
      IF(IDEBUG.LE.0) GO TO 40
      CALL BAD(-1,0,'DSRF',NLAST)
      CALL BAD(1,0,'ISEQ',ISEQNO)
      CALL BAD(1,0,'CLPT',ICLCUR)
      CALL BAD(1,0,'MODS',MODESS)
      CALL BAD(1,0,'MSCK',MSSCHK)
      CALL BAD(1,0,'IS  ',IS)
      CALL BAD(-1,0,'DDST',IDDST)
      CALL BAD(1,0,'JTN ',JTN(IS))
      CALL BAD(1,0,'MDIC',MDIC)
      CALL BAD(1,0,'INDR',INDIR(IS))
      CALL BAD(-3,1,'TE  ',TE (1))
      CALL BAD(3,1,'TP  ',TP(1,IS))
      CALL BAD(-3,1,'TN  ',TN(1,IS))
   40 CONTINUE
C
C             /-SET MODE FOR DD CALCULATION- USE SNXP WITH MODE=0,
C             /-OR ELSE USE DDST WITH MODE=-1
C             /-FOR VERY FIRST ENTRY USE MODE=0
      MODE=-1
      IF(MDIC.GT.0) GO TO 50
      IF(INDIR(IS).EQ.1.AND.ISTRUP.NE.0.AND.JENT(IS).EQ.1) GO TO 50
      IF(MSSCHK.EQ.0.AND.MODESS.NE.11) GO TO 50
C             /-SET MODE TO SNXP IF ABOVE CONDITIONS DO NOT EXIST
      MODE=0
   50 CONTINUE
C
C             /-INITIAL PHASE, SCAN SURFACE FOR BEST CANDIDATE
C             /-THIS IS USED FOR ERROR RESTART OR INITIAL PROCESSING
C             /-LOAD INITIAL PATCH IF DDST MODE OR MODE HAS CHANGED
      IF(IDDLAS(IP).NE.IDDST) GO TO 63
C             /-DO NOT LOAD IF LODFLG IS ZERO AND MDIC IS ZERO
      IF(LODFLG(IP).EQ.0.AND.MDIC.EQ.0) GO TO 60
   63 CONTINUE
C             /-LOAD A PATCH DURING ERROR PROCESSING OR INITIAL PROCESSI
C
      CALL LODINT(SS,B(1,IP),U(IP),V(IP),TP(1,IS),TN(1,IS),
     X            IFLAG(1,IP),ITOP(1,1,IP),IPNUM(IP),MODE)
      IF(IDEBUG.LE.0) GO TO 66
      CALL BAD(1,0,'LODI',MODE)
      CALL BAD(1,1,'UIP ',U(IP))
      CALL BAD(-1,1,'VIP ',V(IP))
   66 CONTINUE
C
C             /-TRUNCATE INITIAL U,V TO LIE INSIDE PATCH BOUNDARY
      CALL SQRCUT(Z5EM1,Z5EM1,U(IP),V(IP),UU,VV,ICKBN)
      U(IP)=Z5EM1+.9999D0*(UU-Z5EM1)
      V(IP)=Z5EM1+.9999D0*(VV-Z5EM1)
   80 CONTINUE
      LODFLG(IP)=0
      IF(IDEBUG.LE.0) GO TO 70
      CALL BAD(1,0,'LINT',IPNUM(IP))
      CALL BAD(1,0,'ICKB',ICKBN)
      CALL BAD(1,1,'UU  ',UU)
      CALL BAD(-1,1,'VV  ',VV)
   70 CONTINUE
C
   60 CONTINUE
C
C             /-CALL THE MAIN ALGORITHM FOR DETERMINING THE RELATION
C             /-BETWEEN THE SURFACE AND EXTERIOR POINT OR TOOL RAY
C...CALL PCHPRC.  LAST PARAMETER .FALSE. FOR NO GEOMETRIC CONSTRUCTION
C
      CALL PCHPRC( SS,B(1,IP),U(IP),V(IP),
     1         TP(1,IS),TN(1,IS),UA,VA,
     2         SP(1,IS),SN(1,IS),SLX(1,IS),
     3         IFLAG(1,IP),ITOP(1,1,IP),IPNUM(IP),
     4         MODE,IDEBUX,IRR,.FALSE.)
C
      IF(IDEBUG.LE.0) GO TO 100
      CALL BAD(1,0,'PCHP',IRR)
      CALL BAD(1,0,'MODE',MODE)
      CALL BAD(1,0,'PCNO',IPNUM(IP))
      CALL BAD(1,1,'UA  ',UA)
      CALL BAD(-1,1,'VA  ',VA)
      CALL BAD(3,1,'SP  ',SP(1,IS))
      CALL BAD(-3,1,'SN  ',SN(1,IS))
  100 CONTINUE
C
      IF(IRR.NE.0) GO TO 800
C
C
      IF ( (ICHEKF.NE.1).OR.(LOD63.EQ.1)) THEN
        CONTINUE
      ELSE
        LOD63=1
        DO 109 I=1,3
          DIF(I) = SP(I,IS) - TP(I,IS)
  109   CONTINUE
        CALL DOTF(DCK,TI,DIF)
        IF (DCK.LT.ZM5EM1) GOTO 63
      ENDIF
C             /-CHECK FURTHER TO SEE WHETHER U,V ARE VALID
      NOPATC=SS(4)
      IRR=0
      IF(IPNUM(IP).LT.1.OR.IPNUM(IP).GT.NOPATC) GO TO 70
C---  DOUBLE CHECK TO SEE IF UA,VA ARE ON A LEGAL EXTENSION
      IUR=2
      IF(UA.LT.ZERO) IUR=1
      IF(UA.GT.ONE) IUR=3
      IVR=2
      IF(VA.LT.ZERO) IVR=1
      IF(VA.GT.ONE) IVR=3
      ISQNO=IUR+3*(IVR-1)
C---  IF UA,VA ARE INSIDE THE PATCH BOUNDS ITS O.K.
      IF(ISEQNO.EQ.5.AND.IP.EQ.K1) IPCHN=0
      IF(ISQNO.EQ.5) GO TO 230
      IF(MOD(ISQNO,2).NE.0) GO TO 240
C---  UA,VA IS ON EXT DIRECTLY OPPOSITE A BOUNDARY
      IB1  =ISQNO/2
C---  CHECK IF A PATCH IS HOOKED TO THIS BOUNDARY
      IF(ITOP(2,IB1  ,IP).EQ.0) GO TO 230
      IRR=2
      GO TO 230
  240 CONTINUE
C---  UA,VA ARE ON A CORNER EXTENSION, CHECK TWO BOUNDARIES
      IB1=1
      IB2=2
      IF(ISQNO.EQ.7) IB1=4
      IF(ISQNO.EQ.3) IB2=3
      IF(ISQNO.EQ.9) IB1=4
      IF(ISQNO.EQ.9) IB2=3
C---  IB1,IB2 ARE THE BOUNDARIES, CHECK IF EITHER HAS A PATCH
      IF(ITOP(2,IB1,IP).EQ.0.AND.ITOP(2,IB2,IP).EQ.0) GO TO 230
      IRR=3
  230 CONTINUE
C
      IF(IRR.EQ.0.OR.IDEBUG.LE.0) GO TO 885
      CALL RECORD(II)
      CALL BAD(1,0,'ISEQ',II)
      CALL BAD(1,0,'IRR ',IRR)
      CALL BAD(1,0,'IPNM',IPNUM(IP))
      CALL BAD(1,1,'U   ',U(IP))
      CALL BAD(-1,1,'V   ',V(IP))
      CALL BAD(1,0,'ISQN',ISQNO)
      CALL BAD(1,1,'UA  ',UA)
      CALL BAD(-1,1,'VA  ',VA)
      DO 825 LL=1,4
      CALL BAD(1,0,'ITOP',ITOP(2,LL,IP))
  825 CONTINUE
      CALL BAD(-1,0,' ',0)
  885 CONTINUE
C             /-QUIT IF IRR IS  NOT ZERO NOW
      IF(IRR.NE.0) GO TO 800
      IER=0
C             /-SET TN ONLY IF MODE=0 AND MODESS.NE.11(Z DETERMINATION)
      IF(MODE.NE.0) GO TO 310
      W1=ONE
      IF(JTN(IS).EQ.0) W1=-ONE
      W1=W1*Z(IS)
      DO 320 I=1,3
      TN(I,IS)=W1*SN(I,IS)
  320 CONTINUE
  310 CONTINUE
      DO 300 I=1,3
      TEMP(I)=SP(I,IS)-TP(I,IS)
  300 CONTINUE
C             /-MODIFY TN FOR CASE OF MODESS.EQ.11
      IF(MODESS.NE.11) GO TO 330
      CALL DOTF(W1,TN(1,IS),TEMP)
      IF(W1.GE.ZERO) GO TO 330
C             /-REVERSE TN TO POINT TOWARD SP
      DO 360 I=1,3
      TN(I,IS)=-TN(I,IS)
  360 CONTINUE
  330 CONTINUE
      CALL DOTF(S(IS),TEMP(1),TEMP(1))
      S(IS)=DSQRT(S(IS))
      CALL DOTF(W1,TEMP,TN(1,IS))
      S(IS)=DSIGN(ONE,W1)*S(IS)
C
      U(IP)=UA
      V(IP)=VA
C             /-SET THE VALUE OF THE LAST SURFACE POINT
      IEQUAL=1
      DO 410 I=1,3
      W1=SP(I,IS)-SPSAV(I)
      IF(DABS(W1).GT.SMAL) IEQUAL=0
  410 CONTINUE
C             /-IF SPSAV IS DIFFERENT AND MODESS.NE.11, SET SPL=SPSAV
      IF(IEQUAL.EQ.1.OR.MODESS.EQ.11) GO TO 420
      DO 430 I=1,3
  430 SPL(I,IS)=SPSAV(I)
      GO TO 999
  420 CONTINUE
      DO 440 I=1,3
  440 SPL(I,IS)=SPSAV(I)
C
      GO TO 999
C
C             /-ERROR PROCESSING
  800 CONTINUE
      KRETRY=KRETRY+1
      IF(KRETRY.EQ.1) GO TO 340
C.... ACCEPT SURFACE POINT
C.... IF DISTANCE BETWEEN CUTTER AND SP IS LARGE (DIST.GE.10)
C.... AND DISTANCE TO PATCH BOUNDARY IS SMALL (UVDIST.LE.0.05)
      IF ((DIST.GE.10.D0).AND.(UVDIST.LE.0.05D0)) THEN
        IRR=0
        GOTO 885
      ENDIF
      IF(KRETRY.EQ.2) GO TO 350
      GO TO 355
C             /-RELOAD INITIAL DATA AND RETRY
  340 CONTINUE
      U(IP)=USAVE
      V(IP)=VSAVE
      IPNUM(IP)=IPSAVE
C             /-BRANCH BACK TO LOAD INITIAL PATCH
      LODFLG(IP)=1-LODFLG(IP)
      IF (MODE.NE.0.OR.MODES.NE.11) GO TO 50
C     IF MODE=0, RETRY WITH NEW TE,TP
      DO 345 I=1,3
  345 DSAV(I)=TE(I)-TP(I,IS)
      CALL DOTV (W1,DSAV,DSAV)
      W1=DSQRT(W1)
      IF(DABS(W1).LT.SMAL) GO TO 355
      DO 346 I=1,3
      DSAV(I) =DSAV(I)/W1
  346 CONTINUE
      W1=0.5D0*W1
      DO 347 I=1,3
      TE(I)=TE(I)+W1*DSAV(I)
  347 TP(I,IS)=TP(I,IS)+W1*DSAV(I)
      GO TO 50
C
  350 CONTINUE
      IER=IRR
      IF(MODE.EQ.0) GO TO 355
      IER=0
      IF(IDDST.EQ.1) GO TO 999
      IER=0
      MODE=0
      MDIC=1
      GO TO 63
C
  355 CONTINUE
C             /- FATAL ERROR IN SNXP MODE
C                IF IBUG=1 OR 2, DO AGAIN TO GET DYDMP-LIST
      IF (IBUG.LE.0) GO TO 356
      IDEBUG=1
      IDEBUX=1
      GO TO 50
  356 IAERR=25402
      GO TO 999
  999 CONTINUE
      IF(IDEBUG.GT.0) CALL BAD(1,0,'IER ',IER)
      IF(IDEBUG.GT.0) CALL BAD(-1,0,'AERR',IAERR)
      MCAT=ICLCUR
      ISEQLS=ISEQNO
      IDDLAS(IP)=IDDST
      JENLAS(IP)=JENT(IS)
      IF(IAERR.NE.0)IBUG=0
      IF (IAERR.NE.0) IAER1=IAERR
      IF(IAERR.NE.0) CALL AERR(IAER1,'DDSSRF  ')
      RETURN
      END
