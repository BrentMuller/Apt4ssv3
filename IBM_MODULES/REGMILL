**** SOURCE FILE : M0011443.W01   ***
*
      SUBROUTINE APT110(ARG1,ARG2)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C-- MAIN PROGRAM FOR REGIONAL MILLING(SMIL OR SCON)
C-- PART PROGRAMMER INPUT LANGUAGE IS RESIDENT IN BLANK COMMON.
C
      INCLUDE (BLANKCOM)    
C
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
      CHARACTER*6 XSMIL,TEST,BADMSG*66
      DIMENSION XSMIL(7),FDUMMY(2)
      DATA XSMIL/'SCON  ','SMIL  ','GCLEAR','GOMILL',
     +           'INTSEC','GOLOFT','PLOTFT'/
      DATA ZERO/0.0D0/
C
      NT=SSCAN(2)
      NT=NT*2
      IF(IBUG.EQ.11) CALL BAD(-NT,2,'CANN',SSCAN)
      CALL HOLFRM(ARG1,TEST,1,6,NWD)
      DO 8 I=1,7
      IF(TEST.NE.XSMIL(I))GOTO 8
      MODE=5
      FDUMMY(1)=ZERO
      FDUMMY(2)=SSCAN(2)-1.D0
      ZWI=SSCAN(1)
      CALL APT094(MODE,FDUMMY,SSCAN)
      SSCAN(1)=ZWI
      GOTO(1,2,3,4,5,6,6),I
    1 CALL SCON
      GOTO 30
    2 CALL SMIL
      GOTO 30
    3 CALL GCLEAR(ARG2)
      GOTO 30
    4 CALL GOMILL
      GOTO 30
    5 CALL INTSEC
      GOTO 30
    6 CALL GOLOVO(ARG2)
      GOTO 30
    8 CONTINUE
   10 BADMSG=' ARGUMENT '//TEST//' NOT VALID IN CALL TO APT110'
      CALL CPRINT(BADMSG)
   30 RETURN
      END
**** SOURCE FILE : M0011518.V01   ***
*
CK    SUBROUTINE    ABW       FORT      3-D     GEOLAN       WEISS
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++790724
C   LETZTE AENDERUNG: D790724.T0835
C     SUBROUTINE ABW(X1,X2,T1,T2,ERR)
C     *********************************
C
C     KURZBESCHREIBUNG:
C     DAS UNTERPROGRAMM BERECHNET DIE MAXIMALE ABWEICHUNG EINER
C     SPLINE-KURVE ZWISCHEN ZWEI PUNKTEN VON DER VERBINDENDEN
C     GERADEN
C
C     EINGABE:
C     X1      KOORDINATEN DES ERSTEN PUNKTES, BLOCK DER LAENGE 3
C     X2      KOORDINATEN DES ZWEITEN PUNKTES, BLOCK DER LAENGE 3
C     T1      TANGENTENVEKTOR IM ERSTEN PUNKT,BLOCK DER LAENGE 3
C     T2      TANGENTENVEKTOR IM ZWEITEN PUNKT, BLOCK DER LAENGE 3
C
C     ERGEBNIS:
C     ERR     GESCHAETZTE ABSOLUTE ABWEICHUNG
C
C     UNTERPROGRAMME: DOTF FUER SCALP
C
C     ERSTELLER: WEISS, GDT4
C                PLARRE,CAMI-UMSTELLUNG
C
      SUBROUTINE ABW(X1,X2,T1,T2,ERR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DOUBLE PRECISION X1(3),X2(3),T1(3),T2(3),A(3)
      KQ = 6
      PI = 3.1415926535
      DO 1 I = 1,3
    1 A(I) = X2(I) - X1(I)
      CALL DOTF(AL,A,A)
      AL = DSQRT(AL)
      CALL DOTF(COS1,A,T1)
      COS1 = COS1/AL
      IF(DABS(COS1) .LE. 1.0) GOTO 3
      IF (COS1 .GT. 1.0) COS1 = 1.0
      IF (COS1 .LT. -1.0) COS1 = -1.0
    3 B1  = DARCOS(COS1)
      BETA = B1*180.0/PI
      CALL DOTF(COS2,A,T2)
      COS2 = COS2/AL
      IF (DABS(COS2) .LE. 1.0) GOTO 5
      IF (COS2 .LT. -1.0) COS2 = -1.0
      IF (COS2 .GT. 1.0) COS2 = 1.0
    5 C1 = DARCOS(COS2)
      GAMMA = C1*180.0/PI
      A1 = (180.0 - BETA - GAMMA)*PI/180.0
      C = AL*DSIN(C1)/DSIN(A1)
      ERR = C*DSIN(B1)*0.1
      ERR = DABS(ERR)
      IF (KQ .NE. 0) WRITE(KQ,2)X1,X2,T1,T2,ERR
    2 FORMAT(' ABW:X1,X2,T1,T2,ERR:',
     */,1H ,13F10.4)
      RETURN
      END
**** SOURCE FILE : M0001038.X02   ***
*
      SUBROUTINE AXSET(MODE,FAX,VAX,AX)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
C--PURPOSE IS TO SET AXIS AX TO FAX IF MODE IS 0 OR VAX IF
C--MODE IS NOT ZERO.  IF VAX IS ZERO, AX WILL BE SET TO FAX
C.... IF MODE=2 THEN VAX WILL BE VARIED BY APPLYING ANGLE ALPHA
C                    IN DIRECTION INDICATED BY FAX
      DIMENSION FAX(3),VAX(3),AX(4),FAXN(3)
      CHARACTER*20 BADMSG
      INCLUDE (TAC)    
      DATA ONE,SMAL/1.0D0,1.0D-38/
C
      IF(MODE.NE.0) GO TO 50
C--FIXED AXIS CASE
   10 CONTINUE
      DO 20 I=1,3
   20 AX(I)=FAX(I)
      AX(4)=ONE
      GO TO 100
C
   50 CONTINUE
C---VARIABLE AXIS CASE
      CALL DOTF(SIZ,VAX,VAX)
      IF(SIZ.LT.SMAL) GO TO 10
      FAC=ONE/DSQRT(SIZ)
C--ADJUST SIGN OF AXIS ACCORDING TO SIGN OF MODE
      IF(MODE.LT.0) FAC=-FAC
      DO 60 I=1,3
   60 AX(I)=VAX(I)*FAC
C...NOW APPLY ALPHA IF REQUIRED
      IF (ABS(MODE).EQ.2) THEN
C... NORMALIZE FAX
        CALL VNORM(FAX,FAXN)
        DO 70 I=1,3
          AX(I)=COSA*AX(I)+SINA*FAXN(I)
   70   CONTINUE
      ENDIF
C
  100 CONTINUE
      IF(IBUG.NE.11) GO TO 1999
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER AXSET'
      CALL CPRINT(BADMSG)
      CALL BAD(1,0,'MODE',MODE)
      CALL BAD(-3,1,'AX  ',AX)
 1999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001040.V02   ***
*
      SUBROUTINE BALLOC(B,IFLAG,ITOP,SIDE,TC,RAD,TD,U,V,DIST,
     X                  MAXREP,IFREE,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION B(*),IFLAG(*),ITOP(6,4),TC(*),TD(*)
      DIMENSION R(32)
      DATA FAC/.999D0/,BIG/1.D+22/
C
C           /-PURPOSE IS TO FIND QUICK ESTIMATE OF LINEUP FROM
C           /-BALL TOOL TO SURFACE.
C
      U1=U
      V1=V
      DIST=BIG
      IF(IFREE.EQ.0) GO TO 10
C            /-IF IFREE=1, INITIAL U,V SHOULD BE IN A VALID SECTOR
C            /-U,V SHOULD ALSO REMAIN IN A VALID SECTOR
      IRR=1
      CALL CHKTOP(U1,V1,ITOP,IOK)
      IF(IOK.NE.0) GO TO 999
C
   10 CONTINUE
C           /-LOOP WITH LINEAR ESTIMATES FOR GOOD APPROXIMATION
      DO 20 I=1,MAXREP
      CALL CNSURF(U1,V1,B,R,IFLAG,1)
      CALL BALONE(R,SIDE,TC,RAD,TD,DU,DV,DA,IRR)
      IF(IRR.EQ.0) GO TO 30
C           /-ON FAILURE ACCEPT THE LAST GOOD U,V
      IF(I.GT.1) GO TO 100
      IRR=2
      GO TO 999
C
   30 CONTINUE
      IF(IFREE.EQ.0) GO TO 40
C           /-TRUNCATE U,V IF THEY LEAD TO A NEW SECTOR
      CALL SQRBN(U1,V1,DU,DV,DU1,DV1,FAC,ISQR)
      IF(ISQR.GT.0) DU=DU1
      IF(ISQR.GT.0) DV=DV1
   40 CONTINUE
      U1=U1+DU
      V1=V1+DV
      DIST=DA
   20 CONTINUE
C
  100 CONTINUE
      IRR=0
      U=U1
      V=V1
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001041.V01   ***
*
      SUBROUTINE BALONE(R,SIDE,TC,RAD,TD,DU,DV,DIST,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C           /-PURPOSE TO USE LINEAR ESTIMATE OF SURFACE(STORED IN R ) TO
C           /-CALCULATE DISTANCE TO MOVE BALL CUTTER CENTERED AT TC
C           /-IN DIRECTION TD TOWARD SURFACE
C           /-INPUT FOLLOWS
C           /-R(1-32) CONTAINS SURFACE COORDS,FIRST AND SECOND DERIVATIV
C           /-TC,TD DENOTE TOOL CENTER AND TOOL DIRECTION TO SURFACE
C           /-RAD DENOTES THE RADIUS OF THE BALL TOOL
C           /-SIDE DENOTES NON MATERIAL SIDE OF SURFACE(+1 FOR U X V )
C           /-OUTPUT
C           /-DIST DISTANCE TOOL CENTER SHOULD BE MOVED TO CONTACT PLANE
C           /-DU,DV SURFACE COORDINATE CHANGES FOR TOOL CONTACT PT.
C           /-IRR IS NON ZERO ON OUTPUT IF AN ERROR OCCURRED HERE.
C
      DIMENSION TC(3),TD(3),R(32)
      DIMENSION RMOD(3),DEL(3)
      DATA ZERO,ONE,SMAL/0.0D0,1.0D0,1.0D-18/
C
C           /-COMPUTE MODIFIED SURFACE POINT FOR INTERSECTION PLANE
      FACTOR=SIDE*RAD
      DO 10 I=1,3
   10 RMOD(I)=R(I)+FACTOR*R(I+28)
C           /-COMPUTE DISTANCE OF TC ALONG TD TO THIS PLANE
C           /- DIST SATISFIES EQN, (TC+DIST*TD-RMOD,SN)=0
      CALL DOTF(TDSN,TD,R(29))
      IRR=1
      IF(DABS(TDSN).LT.SMAL) GO TO 999
      DIST=ZERO
      DO 20 I=1,3
   20 DIST=DIST+(RMOD(I)-TC(I))*R(I+28)
      DIST=DIST/TDSN
C           /-COMPUTE INCREMENTAL VECTOR FROM RMOD TO TC , TD PIERCE POI
      DO 30 I=1,3
   30 DEL(I)=TC(I)+DIST*TD(I)-RMOD(I)
C           /-COMPUTE CHANGE IN U,V TO REACH DEL
      CALL DOTF(SUU,R(5),R(5))
      CALL DOTF(SUV,R(5),R(9))
      CALL DOTF(SVV,R(9),R(9))
      CALL DOTF(DELU,DEL,R(5))
      CALL DOTF(DELV,DEL,R(9))
      DISCR=SUU*SVV-SUV**2
      IRR=2
      IF(DABS(DISCR).LT.SMAL) GO TO 999
      DU=(DELU*SVV-DELV*SUV)/DISCR
      DV=(SUU*DELV-SUV*DELU)/DISCR
      IRR=0
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001042.V02   ***
*
      SUBROUTINE BALSCN(SURF,SIDE,TC,RAD,TD,U,V,DIST,NPAT,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C           /-PURPOSE IS TO SCAN ALL PATCHES IN SURFACE AND SELECT
C           /-BEST CANDIDATE FOR LINEUP WITH TOOL
C           /-INPUT
C           /-SURF- INPUT SCULPTURED SURFACE LARGE DATA ARRAY
C           /-OUTPUT
C           /-NPAT PATCH NUMBER OF BEST CANDIDATE
C           /-PATCH U,V COORDINATES AT ESTIMATED CONTACT POINT
C           /-DIST ESTIMATED DISPLACEMENT FROM CURRENT CUTTER POSN TO SU
C
      DIMENSION SURF(*),TC(*),TD(*)
      DIMENSION B(64),IFLAG(6),ITOP(6,4)
      DATA HALF,BIG/0.5D0,1.0D22/
C
      U=HALF
      V=HALF
      NPAT=1
      DIST=BIG
      IR=1
      NUMPAT=SURF(4)
C
      DO 10 I=1,NUMPAT
C           /-LOAD THE ITH PATCH
      CALL LODPCH(SURF,B,IFLAG,ITOP,I,3)
      MAXREP=5
      IFREE=0
      U1=HALF
      V1=HALF
      IRR=0
      CALL BALLOC(B,IFLAG,ITOP,SIDE,TC,RAD,TD,U1,V1,DA,
     X            MAXREP,IFREE,IRR)
      IF(IRR.NE.0) GO TO 20
      CALL CHKTOP(U1,V1,ITOP,IOK)
      IF(IOK.EQ.0) GO TO 30
   20 CONTINUE
      IF(DABS(DIST).LT.BIG) GO TO 10
      U1=HALF
      V1=HALF
      MAXREP=1
      IFREE=1
      IRR=0
      CALL BALLOC(B,IFLAG,ITOP,SIDE,TC,RAD,TD,U1,V1,DA,
     X            MAXREP,IFREE,IRR)
      IF(IRR.NE.0) GO TO 10
   30 CONTINUE
      IF(DABS(DIST).LT.DABS(DA))  GO TO 10
C           /-UPDATE BEST PATCH BASED ON SMALLEST DISTANCE
      DIST=DA
      U=U1
      V=V1
      NPAT=I
      IR=0
C           /-UPDATE ERROR FLAG TO INDICATE SUCCESS
   10 CONTINUE
C
      IRR=IR
      RETURN
      END
**** SOURCE FILE : M0001043.V03   ***
*
      SUBROUTINE BALSRF(SURF,SIDE,TC,RAD,TD,NPAT,U,V,DIST,
     X                  R,TOL,MODE,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C           /-PURPOSE IS TO DETERMINE CONTACT POINT FROM TOOL TO SURFACE
C           /-INPUT
C           /-SURF INPUT SCULPTURED SURFACE
C           /- 1 OR -1 TO INDICATE CUTTING SIDE OF SURFACE
C           /-TC,TD,RAD TOOL CENTER, RADIUS AND DIRECTION
C           /-TOL TOLERANCE FOR TOOL ALIGNMENT
C           /-MODE 0 FOR FIRST CALL, 1 FOR CONTINUING CALLS
C           /-OUTPUT
C           /-NPAT,U,V OUTPUT PATCH NUMBER AND U,V COORDS AT CONTACT
C           /-DIST DISTANCE TOOL MUST MOVE TO CONTACT POINT
C           /-R SURFACE DERIVATIVES AT POINT OF CONTACT
C           /-IRR ERROR FLAG, 0 IF NO ERROR, NON ZERO OTHERWISE.
C
      DIMENSION SURF(*),TC(*),TD(*),R(*)
      DIMENSION B(64),IFLAG(6),ITOP(6,4)
      DATA ZERO,ONE,HALF,ONEBIG/0.0D0,1.0D0,0.5D0,1.00001D0/
      DATA ONELIT/0.99999D0/
      DATA MXSRCH,MXNITS,MXEXCH/1,25,15/
C
C            /-ISRCH IS A COUNT OF CALLS FOR GLOBAL SEARCH
C            /-IEXCHG IS A COUNT OF PATCH EXCHANGES
      ISRCH=0
      IEXCHG=0
      U1=U
      V1=V
C***  CALL BAD(-1,0,4HMODE,MODE)
C***  CALL BAD(1,0,4HU   ,U)
C***  CALL BAD(-1,0,4HV   ,V)
C
      IF(MODE.EQ.0) GO TO 20
   10 CONTINUE
C           /-INITIAL ENTRY OR RELOAD PATH
      ISRCH=ISRCH+1
      IRR=1
      IF(ISRCH.GT.MXSRCH) GO TO 999
C
      CALL BALSCN(SURF,SIDE,TC,RAD,TD,U1,V1,DIST,NPAT,IR)
C***  CALL BAD(1,0,4HBSCN,IR)
C***  CALL BAD(1,1,4HDIST,DIST)
C***  CALL BAD(1,1,4HU1  ,U1)
C***  CALL BAD(1,1,4HV1  ,V1)
C***  CALL BAD(-1,0,4HNPAT,NPAT)
      IRR=2
      IF(IR.NE.0) GO TO 999
C
      CALL LODPCH(SURF,B,IFLAG,ITOP,NPAT,3)
C
   20 CONTINUE
C           /-SET ITERATION COUNTER FOR PATCH TO TOOL LINEUP
      NITS=0
      IOKLAS=0
C
   30 CONTINUE
C***  CALL BAD(-1,0,4HNITS,NITS)
      NITS=NITS+1
      IF(NITS.GT.MXNITS) GO TO 10
C           /-CALCULATE SURFACE DERIVATIVES AT THIS U,V
      CALL CNSURF(U1,V1,B,R,IFLAG,1)
C***  CALL BAD(-12,1,4HCNSF,R)
C           /- DETERMINE IF PATCH IS WITHIN TOLERANCE OF TOOL YET
      CALL BALTOL(R,SIDE,TC,RAD,TD,DIST,TOL,IOK)
C***  CALL BAD(1,1,4HTOL ,TOL)
C***  CALL BAD(1,1,4HDIST,DIST)
C***  CALL BAD(-1,0,4HIOK ,IOK)
      IF(IOK.NE.0) GO TO 40
C           /-TOOL IN TOLERANCE , EXAMINE U,V VALUES FURTHER
      CALL CHKTOP(U1,V1,ITOP,IOK)
C***  CALL BAD(2,2,4HU1  ,U1)
C***  CALL BAD(2,2,4HV1   ,V1)
C***  CALL BAD(-1,0,4HCTOP,IOK)
      IRR=0
      IF(IOK.EQ.0) GO TO 100
C
   70 CONTINUE
C***  CALL BAD(-1,0,4HEXCG,IEXCHG)
      IEXCHG=IEXCHG+1
      IRR=3
      IF(IEXCHG.GT.MXEXCH) GO TO 999
      NPAT=IOK
C            /-IOK IS A CANDIDATE PATCH IF NON ZERO.
      U1=HALF
      V1=HALF
      CALL LODPCH(SURF,B,IFLAG,ITOP,NPAT,3)
      IFREE=0
      MAXREP=5
      CALL BALLOC(B,IFLAG,ITOP,SIDE,TC,RAD,TD,
     X            U1,V1,DIST,MAXREP,IFREE,IRR)
C***  CALL BAD(1,0,4HBLOC,IRR)
C***  CALL BAD(1,1,4HU1  ,U1)
C***  CALL BAD(1,1,4HV1  ,V1)
C***  CALL BAD(-1,1,4HDIST,DIST)
      IF(IRR.NE.0) GO TO 10
      GO TO 20
C
   40 CONTINUE
      CALL BALONE(R,SIDE,TC,RAD,TD,DU,DV,DA,IRR)
C***  CALL BAD(1,0,4HBONE,IRR)
C***  CALL BAD(1,1,4HDU  ,DU)
C***  CALL BAD(1,1,4HDV  ,DV)
C***  CALL BAD(-1,1,4HDA  ,DA)
      DUK=DU
      DVK=DV
      MAXREP=25
      CALL BALTWO(R,SIDE,TC,RAD,TD,DU,DV,DA,MAXREP,TOL,IRR)
C***  CALL BAD(1,0,4HBTWO,IRR)
C***  CALL BAD(1,1,4HDU  ,DU)
C***  CALL BAD(1,1,4HDV  ,DV)
C***  CALL BAD(-1,1,4HDA  ,DA)
      IF(IRR.EQ.0) GO TO 50
      DU=DUK
      DV=DVK
   50 CONTINUE
C***  CALL BAD(2,2,4HU1  ,U1)
C***  CALL BAD(-2,2,4HV1  ,V1)
C***  CALL BAD(2,2,4HDU  ,DU)
C***  CALL BAD(-2,2,4HDV  ,DV)
      CALL SQRBN(U1,V1,DU,DV,DUK,DVK,ONE,IOK)
C***  CALL BAD(2,2,4HDUK ,DUK)
C***  CALL BAD(-2,2,4HDVK ,DVK)
C***  CALL BAD(-1,0,4HSRBN,IOK)
      IF(IOK.EQ.0.OR.IOK.EQ.5) GO TO 60
      IF(IOKLAS.NE.0) GO TO 55
C             /-CASE.  IOK.NE.0.AND.IOKLAS.EQ.0
C             /-CUT DU,DV TO LIE WITHIN PRESENT SECTOR AND PROCEED AGAIN
      DU=DUK
      DV=DVK
      GO TO 60
   55 CONTINUE
C             /-CASE.  IOK.NE.0.AND.IOKLAS.NE.0
C             /-SET DU,DV SO THAT POINT MOVES TO NEW SECTOR
C             /-CHECK TO SEE IF THE NEW MOVEMENT IS SMALL
      CALL DOTV(W,R(5),R(5))
      DU1=DU*DSQRT(W)
      CALL DOTV(W,R(9),R(9))
      DV1=DV*DSQRT(W)
      IF(DSQRT(DU1**2+DV1**2).GT.TOL/2.) GO TO 56
C             /-MOVEMENT IS WITHIN TOLERANCE BAND
      IOK=0
      DU=DUK
      DV=DVK
      GO TO 60
C
   56 CONTINUE
      DU=DUK*ONEBIG
      DV=DVK*ONEBIG
      U2=U1+DU
      V2=V1+DV
C             /-CHECK TO SEE IF NEW U,V LIE IN LEGITIMATE REGION
C             /-ELSE, OBTAIN A NEW PATCH.
      CALL CHKTOP(U2,V2,ITOP,IOK)
C***  CALL BAD(-1,0,4HCKTP,IOK)
C***  CALL BAD(2,2,4HU2  ,U2)
C***  CALL BAD(2,2,4HV2  ,V2)
C***  CALL BAD(1,1,4HU2  ,U2)
C***  CALL BAD(-1,1,4HV2  ,V2)
      IF(IOK.EQ.0) GO TO 60
      IOKLAS=0
      NPAT=IOK
      GO TO 70
C
   60 CONTINUE
      IOKLAS=IOK
      U1=U1+DU
      V1=V1+DV
      DIST=DA
C***  CALL BAD(1,0,4H101 ,IOK)
C***  CALL BAD(1,1,4HU1  ,U1)
C***  CALL BAD(1,1,4HV1  ,V1)
C***  CALL BAD(-1,1,4HDIST,DIST)
      IRR=0
      GO TO 30
C
  100 CONTINUE
      U=U1
      V=V1
C
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001044.V02   ***
*
      SUBROUTINE BALTOL(R,SIDE,TC,RAD,TD,DIST,TOL,IOK)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C           /-PURPOSE IS TO VERIFY THAT CUTTER IS WITHIN TOLERANCE OF
C           /-SURFACE AT THIS POINT
C           /-IOK=0 IF IT IS AND SET TO NON-ZERO VALUE OTHERWISE
C
      DIMENSION R(*),TC(*),TD(*)
      DIMENSION ST(3)
      DATA ZERO,ONE,SMAL,FLIPCK/0.0D0,1.0D0,1.D-22,.99995D0/
C
      FAC=SIDE*RAD
      DO 10 I=1,3
   10 ST(I)=TC(I)+DIST*TD(I)-R(I)-FAC*R(I+28)
      CALL DOTV(STLEN,ST,ST)
      IOK=0
C            /-IF STLEN IS VERY SMALL, ACCEPT THIS RESULT
      IF(STLEN.LT.SMAL) GO TO 999
      STLEN=DSQRT(STLEN)
      IOK=1
C            /-IF STLEN EXCEEDS TOLERANCE, DO NOT ACCEPT
      IF(STLEN.GT.TOL) GO TO 999
C            /-MEASURE ANGLE FROM NORMAL TO ST
      DO 20 I=1,3
   20 ST(I)=TC(I)+DIST*TD(I)-R(I)
      CALL DOTV(STLEN,ST,ST)
      IF(STLEN.LT.SMAL) GO TO 999
      CALL DOTV(ANG,ST,R(29))
      ANG=ANG/DSQRT(STLEN)*SIDE
      IOK=2
C            /-VECTOR LINEUP IS REQUIRED ONLY FOR NON ZERO RADIUS
      IF(RAD.GT.SMAL.AND.ANG.LT.FLIPCK) GO TO 999
      IOK=0
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001045.W01   ***
*
      SUBROUTINE BALTWO(R,SIDE,TC,RAD,TD,U,V,A,MAXREP,TOL,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
      DIMENSION PS(3),SU(3),SV(3)
      DIMENSION CA(3),CU(3),CV(3),COEF(3)
      DIMENSION TC(3),TD(3),R(32)
      CHARACTER*20 BADMSG
      DATA SMAL,SMAL1/1.D-3,1.D-4/
C           /-PURPOSE OF ROUTINE IS TO USE NEWTON RHAPSON METHOD
C           /-TO MOVE BALL CUTTER INTO CONTACT WITH 2ND ORDER EXPANSION
C           /-SURFACE ABOUT A POINT.
C           /-INPUT
C           /-R SURFACE POINT, FIRST AND SECOND DERIVATIVES
C           /-TC,TD BALL CENTER, DIRECTION OF MOVEMENT
C           /-RAD IS  RADIUS OF BALL
C           /- SIDE IS 1 IF RU X RV GIVES CUTTER SIDE OF SURF, -1 OTHERW
C           /- MAXREP IS MAXIMUM NUMBER OF REPETITIIONS OF NEWNTON METHO
C           /- TOL IS THE TOLERANCE SPECIFICATION FOR STOPPING ITERATION
C
C           /- INPUT-OUTPUT
C           /-A IS DISTANCE CUTTER SHOULD MOVE IN TD DIRECTION
C           /-U,V ARE SURFACE COORDINATES DESCRIBING CONTACT
C
      NITS=0
   10 CONTINUE
      NITS=NITS+1
      IF(NITS.GT.MAXREP) GO TO 999
C           /-EVALUATE QUANTITIES WHICH DEPEND ON CURRENT A,U,V
      HUSQ=U*U/2.
      UV=U*V
      HVSQ=V*V/2.
      DO 20 I=1,3
      PS(I)=TC(I)+A*TD(I)
     X     -(R(I)+U*R(I+4)+V*R(I+8)
     X     +HUSQ*R(I+12)+UV*R(I+16)+HVSQ*R(I+20))
      SU(I)=R(I+4)+U*R(I+12)+V*R(I+16)
      SV(I)=R(I+8)+U*R(I+16)+V*R(I+20)
   20 CONTINUE
C
C           /-USE SURFACE REPRESENTATION BY TAYLOR 2ND ORDER METHOD
C           /-S(U,V)=R+U*RU+V*RV+HUSQ*RUU+UV*RUV+HVSQ*RVV
C           /-NEWTON RHAPSON ITERATION IS USED TO SOLVE 3 EQNS IN 3 UNKN
C           /-F(A,U,V)=(TC+A*TD-S(U,V))**2-RAD**2=0
C           /-G(A,U,V)=(TC+A*TD-S(U,V),SU)=0
C           /-H(A,U,V)=(TC+A*TD-S(U,V),SV)=0
C           /-CHANGES IN A,U,V NAMELY DA,DU,DV ARE FOUND BY THE FOLLOWIN
C           /- 0-F=DA*FA+DU*FU+DV*FV
C           /- 0-G=DA*GA+DU*GU+DV*GV
C           /- 0-H=DA*HA+DU*HU+DV*HV
C           /- CA(1)=FA, CA(2)=GA, CA(3)=HA, CU(1)=FU ETC.
C           /- COEF(1)=-F, COEF(2)=-G, COEF(3)=-H
C
      CALL DOTF(CA(1),PS,TD)
      CA(1)=2.*CA(1)
      CALL DOTF(CU(1),PS,SU)
      CU(1)=-2.*CU(1)
      CALL DOTF(CV(1),PS,SV)
      CV(1)=-2.*CV(1)
C
      CALL DOTF(CA(2),TD,SU)
      CALL DOTF(SUSQ,SU,SU)
      CALL DOTF(CU(2),PS,R(13))
      CU(2)=-SUSQ+CU(2)
      CALL DOTF(SUV,SU,SV)
      CALL DOTF(CV(2),PS,R(17))
      CV(2)=-SUV+CV(2)
C
      CALL DOTF(CA(3),TD,SV)
      CU(3)=CV(2)
      CALL DOTF(SVSQ,SV,SV)
      CALL DOTF(CV(3),PS,R(21))
      CV(3)=CV(3)-SVSQ
C
      CALL DOTF(PSQ,PS,PS)
      COEF(1)=-(PSQ-RAD**2)
C----     CALL DOTF(COEF(2),PS,SU)
      COEF(2)=CU(1)/2.
C----     CALL DOTF(COEF(3),PS,SV)
      COEF(3)=CV(1)/2.
C           /-3X3 EQN IS READY, FIRST CHECK DISCRIMINANT
      DISCR=DET3(CA,CU,CV)
      IF(DABS(DISCR).GT.SMAL) GO TO 50
C           /-DISCRIMINANT TOO SMALL, CHANGE A,U,V AND TRY AGAIN
      A=.9*A+SMAL1
      U=.9*U+SMAL1
      V=.9*V+SMAL1
      GO TO 10
C
   50 CONTINUE
C           /-SOLVE FOR DA,DU,DV
      DA=DET3(COEF,CU,CV)/DISCR
      DU=DET3(CA,COEF,CV)/DISCR
      DV=DET3(CA,CU,COEF)/DISCR
      IF(IBUG.NE.11) GO TO 9991
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER BALTWO'
      CALL CPRINT(BADMSG)
      CALL BAD(-3,1,'COEF',COEF)
 9991 CONTINUE
      A=A+DA
      U=U+DU
      V=V+DV
      W=DABS(COEF(1))
      W=DSQRT(W)
      W=W+DABS(COEF(2))+DABS(COEF(3))
      IF(W.GT.TOL) GO TO 10
  100 CONTINUE
C
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001050.W01   ***
*
      SUBROUTINE CHKSET(IDTYPE,PDIR,PAR,IFIN)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
      DIMENSION PLIM(4),PAR(*)
      CHARACTER*20 BADMSG
      DATA ZERO,ONE,SMAL/0.0D0,1.0D0,1.0D-14/
C---PURPOSE IS TO CHECK WHETHER PARAMETER PAIR PAR(1-2) IS
C--- WITHIN LEGITIMATE BOUNDS.  THESE BOUNDS ARE SET WHEN
C--- IFIN=-121 ON INPUT.  OTHERWISE IFIN NON ZERO ON OUTPUT
C--- MEANS THAT P IS OUT OF BOUNDS.  P WILL ALSO BE TRUNCATED
C--- TO LIE WITHIN BOUNDS.
C
      IF(IFIN.NE.-121) GO TO 15
      DO 10 I=1,4
   10 PLIM(I)=PAR(I)
      GO TO 999
C
   15 CONTINUE
      IFIN=0
      ITYP=2
      IF(IDTYPE.LT.2) ITYP=1
      I=ITYP
      INDEX=2*I-1
      IF(PAR(I).GT.PLIM(INDEX)+SMAL) GO TO 20
      PAR(I)=PLIM(INDEX)
      IF(PDIR.GT.ZERO) GO TO 20
      IFIN=1
   20 CONTINUE
      INDEX=2*I
      IF(PAR(I).LT.PLIM(INDEX)-SMAL) GO TO 40
      PAR(I)=PLIM(INDEX)
      IF(PDIR.LT.ZERO) GO TO 40
      IFIN=1
   40 CONTINUE
C
  999 CONTINUE
      IF(IBUG.NE.11) GO TO 1999
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER CHKSET'
      CALL CPRINT(BADMSG)
      CALL BAD(1,1,'PDIR',PDIR)
      CALL BAD(1,0,'IFIN',IFIN)
      CALL BAD(-2,1,'PAR ',PAR)
 1999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001051.V01   ***
*
      SUBROUTINE CHKTOP(U,V,ITOP,IOK)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION ITOP(6,4)
      DATA ZERO,ONE/0.0D0,1.0D0/
      DIMENSION ICOMP(2,3,3)
      DATA ICOMP/ 1,2, 1,0, 1,3, 2,0, 0,0, 3,0, 2,4, 4,0, 4,3/
C           /-PURPOSE IS TO SEE IF U,V, VALUES OF PATCH WITH TOPOLOGY
C           /-TABLE ITOP ARE IN A VALID SECTOR FOR THIS SURFACE
C           /-IOK=0 MEANS SECTOR IS OKAY. OTHERWISE IOK POINTS TO INVALI
C           /-SECTOR
C           /-NOTE THAT UNIT SQUARE DIVIDES SPACE INTO 9 SECTORS
C
C           /-FIRST DETERMINE THE SECTOR OF U,V
      IU=2
      IF(U.LT.ZERO) IU=1
      IF(U.GT.ONE) IU=3
      IV=2
      IF(V.LT.ZERO) IV=1
      IF(V.GT.ONE) IV=3
C           /-NOW COMPARE THIS SECTOR FOR FREE BOUNDARIES
      IOK=0
      DO 10 J=1,2
      K=ICOMP(J,IU,IV)
      IF(K.EQ.0) GO TO 10
      IF(ITOP(2,K).NE.0) IOK=ITOP(2,K)
   10 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001052.V02   ***
*
      SUBROUTINE CLIFT(TE,CLRPLN,TX)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION TE(*),CLRPLN(*),TX(*)
C---PURPOSE IS TO LIFT TOOL END TE TO POSITION TX ON CLEARANCE
C---PLANE CLRPLN.  MOVE IS IN DIRECTION OF PLANE NORMAL.
C
      DATA ZERO/0.D0/
C
      SUM=ZERO
      DO 10 I=1,3
      SUM=(TE(I)-CLRPLN(4)*CLRPLN(I))*CLRPLN(I)+SUM
   10 CONTINUE
      DO 20 I=1,3
   20 TX(I)=TE(I)-SUM*CLRPLN(I)
      RETURN
      END
**** SOURCE FILE : M0001053.W02   ***
*
      SUBROUTINE CLPUT(ATEX,ATAX,MODE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      INCLUDE (TOTAL)    
      INCLUDE (FXCOR)    
      INCLUDE (IFXCOR)    
C
      CHARACTER*20 BADMSG
      DIMENSION ATEX(3),ATAX(3)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
      INCLUDE (SYMFIL)    
C
      INTEGER Z4E
      PARAMETER (Z4E=1308622848)
      INTEGER BCDF
      LOGICAL FIRST
      SAVE FIRST,KCLDAT
      DIMENSION KCLDAT(10)
      DATA KCLDAT/0,0,Z4E,0,Z4E,2,
     X            Z4E, 1,0,0/
      DATA FIRST/.TRUE./
C
C
      IF (FIRST)THEN
        KCLDAT(1) = BCDF('CLDA')
        KCLDAT(2) = BCDF('TA  ')
        KCLDAT(9) = BCDF('GOTO')
        KCLDAT(10) = BCDF('    ')
        FIRST=.FALSE.
      END IF
C
      CALL RECORD(ISEQNO)
      IF(MODE.GE.0) GO TO 100
      IF(MODE.LT.-1) GO TO 999
C--OUTPUT HEADER FOR A RECORD OF CL DATA
      KCLDAT(4)=ISEQNO
      NR=0
      CALL EWRITE(EXFILE,NR,KCLDAT,10,IR)
      GO TO 999
C
  100 CONTINUE
      ICL=0
      IF(MODE.EQ.0) ICL=2
      IF(MODE.EQ.1) ICL=3
      DO 110 I=1,3
      TE(I)=ATEX(I)
      TA(I)=ATAX(I)
  110 CONTINUE
      CALL ATAPE
      GO TO 999
C
  999 CONTINUE
      IF(IBUG.NE.11) GO TO 1999
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER CLPUT'
      CALL CPRINT(BADMSG)
      CALL BAD(-1,0,'MODE',MODE)
      CALL BAD(3,1,'ATEX',ATEX)
      CALL BAD(-3,1,'ATAX',ATAX)
 1999 CONTINUE
C
      RETURN
      END
**** SOURCE FILE : M0001062.V06   ***
*
      SUBROUTINE CUTREG(WORD,CDIR,UST,VST,PDIR,IDTYPE,IQUAL,
     X   TUL,PTOLI,PTOLO,DTOL,AMAXDP,ELMAX,MAXCL,ISKP,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---PURPOSE IS TO CALL PATH ROUTINE, SSPATH, TO GENERATE THE NECESSARY
C---CLRECORDS IN RESPONSE TO AN AREA CLEARANCE COMMAND
C
C
      COMMON/IBUGG/IBUG,I1,I2
      COMMON/XDS/DGEOM(4),DLIM(4),TLDIR(3),DOFSET,ITLDIR,IDTOOL,NDS
      COMMON/XPS/PGEOM(4),PSIDE,PTHICK,IPTOOL,NPS
      COMMON/XFEED/CLRPLN(4),FED(4),NCLRPL,NFEED
      COMMON/XSTEPO/SSTEP(4),NSTEPO
      COMMON/XAXIS/AXIS(3),IAXIS,NAXIS
C
      INCLUDE (BLANKCOM)    
C
      DIMENSION TUL(1),TE(3),TA(3),TD(3),PAR(2),PLIM(4)
      DIMENSION PSAVE(2),ALIM(4),ADIR(2)
      DIMENSION SVTE(3),SVTA(3),SVTD(3)
C
      DATA ZERO,ONE,SMAL/0.0D0,1.0D0,1.0D-14/
      DATA APICKF/166.D0/
      DATA AZIGZA/61.D0/
C
C---      COUNT OF MAXIMUM CALLS TO SSPATH
      IPATHK=0
C---      MAXIMUM NUMBER OF CALLS ALLOWED TO SSPATH
      MXPATH=SSTEP(4)
C---      MXPATH=0, MEANS ESSENTIALLY  NO LIMIT
      IF(MXPATH.LE.0) MXPATH=1000000
      IF(WORD.EQ.APICKF) GO TO 500
      IF(WORD.EQ.AZIGZA) GO TO 100
      GO TO 999
C
C---ZIGZAG PATTERN MACHINING
  100 CONTINUE
      IPASS=1
      IFIN=0
      ICLSKP=0
      IF(ISKP.EQ.1) ICLSKP=1
      IPART=PGEOM(4)
      IDRIV=DGEOM(4)
      PAR(1)=UST
      PAR(2)=VST
      DSTEP=ONE
      SCALHT=SSTEP(1)
      STEPMX=SSTEP(2)
      STEPOV=ZERO
C
  120 CONTINUE
C---COMMON ENTRY POINT FOR ALL PASSES IN MAIN DIRECTION
      IF(IBUG.NE.11) GO TO 105
      CALL BAD(-1,0,' ',0)
      CALL BAD(1,0,'PASS',IPASS)
      CALL BAD(-2,1,'PAR ',PAR)
  105 CONTINUE
C
      DO 110 I=1,4
  110 PLIM(I)=DLIM(I)
      TPDIR=PDIR
      IF(MOD(IPASS,2).EQ.0) TPDIR=-PDIR
      IRR=0
      CALL CLPUT(TE,TA,-1)
C
      UST=PAR(1)
      VST=PAR(2)
      CALL SSPATH( COM(IDRIV), IDTYPE, TPDIR, DTOL, DSTEP, DOFSET,
     X           PLIM, IDTOOL, IAXIS, AXIS, ITLDIR,
     X       TLDIR, COM(IPART), PSIDE, PTHICK, PTOLI, PTOLO, IPTOOL,
     X           TUL, UST,  VST, SCALHT, STEPOV, STEPMX,
     X           AMAXDP, ELMAX, MAXCL, ICLSKP, IQUAL,
     X           TE, TA, TD, PAR, IRR )
      IF(IRR.NE.0) GO TO 999
C
C---      INCREMENT COUNT OF CALLS TO SSPATH, QUIT WHEN OVER LIMIT
      IPATHK=IPATHK+1
      IF(IPATHK.GE.MXPATH) GO TO 999
C---IF FINAL FLAG HAS BEEN SET THEN QUIT NOW
      IF(IFIN.EQ.1) GO TO 999
C---NOW CALCULATE PARAMETERS NECESSARY FOR A SIDE STEP
      TPDIR=CDIR
      MIDTYP=3-IDTYPE
      ICR=2
      IF(IDTYPE.EQ.2) ICR=1
      ILC=2*ICR-1
      DO 210 I=1,2
  210 PSAVE(I)=PAR(I)
      CALL PCHG(PAR(ICR),CDIR,STEPOV)
      PAR(ICR)=PAR(ICR)+CDIR*STEPOV
      DO 220 I=1,4
  220 PLIM(I)=DLIM(I)
      IF(PAR(ICR).LT.DLIM(ILC)+SMAL.AND.CDIR.LT.ZERO) IFIN=1
      IF(PAR(ICR).LT.DLIM(ILC)+SMAL.AND.CDIR.LT.ZERO)PAR(ICR)=DLIM(ILC)
      IF(PAR(ICR).GT.DLIM(ILC+1)-SMAL.AND.CDIR.GT.ZERO) IFIN=1
      IF(PAR(ICR).GT.DLIM(ILC+1)-SMAL.AND.CDIR.GT.ZERO) PAR(ICR)=
     X   DLIM(ILC+1)
C---NOW TEMPORARILY LOAD NEW LIMITS FOR SIDE STEPPING
      IF(CDIR.LT.ZERO) GO TO 230
      PLIM(ILC)=PSAVE(ICR)
      PLIM(ILC+1)=PAR(ICR)
      GO TO 240
C
  230 CONTINUE
      PLIM(ILC)=PAR(ICR)
      PLIM(ILC+1)=PSAVE(ICR)
  240 CONTINUE
C
      TSCALH=ZERO
      TSTEPO=ZERO
      TSTEPM=ZERO
C---WHEN LIFTUP HAS NOT BEEN SPECIFIED, SKIP THE FIRST CUT VECTOR
      TPTHIC=SSTEP(3)+PTHICK
      MICLSK=1
      IF(SSTEP(3).GT.SMAL) MICLSK=0
C
      IF(FED(2).GT.SMAL) CALL FEDPUT(FED(2))
      CALL CLPUT(TE,TA,-1)
C
      IF(IBUG.NE.11) GO TO 250
      CALL BAD(-1,0,' ',0)
      CALL BAD(1,0,'STEP',IPASS)
      CALL BAD(2,1,'PSAV',PSAVE)
      CALL BAD(-2,1,'PAR ',PAR)
  250 CONTINUE
C---GENERATE THE SIDE MOTION TO THE NEXT POSITION
C
      CALL SSPATH( COM(IDRIV), MIDTYP, TPDIR, DTOL, DSTEP, DOFSET,
     X           PLIM, IDTOOL, IAXIS, AXIS, ITLDIR,
     X       TLDIR, COM(IPART), PSIDE, TPTHIC, PTOLI, PTOLO, IPTOOL,
     X           TUL, PSAVE(1), PSAVE(2), TSCALH,TSTEPO, TSTEPM,
     X           AMAXDP, ELMAX, MAXCL, MICLSK, IQUAL,
     X           TE, TA, TD, PAR, IRR)
      IF(IRR.NE.0) GO TO 999
C
C---      INCREMENT COUNT OF CALLS TO SSPATH, QUIT WHEN OVER LIMIT
      IPATHK=IPATHK+1
      IF(IPATHK.GE.MXPATH) GO TO 999
C---IF THE THIRD FEED RATE IS AVAILABLE AND LIFTUP SPECIFIED
C---THEN USE THE PLUNGE PROCEDURE
      IF(SSTEP(3).LT.SMAL) GO TO 260
      IF(FED(3).GT.SMAL) CALL FEDPUT(FED(3))
      MMAXCL=1
      MICLSK=0
      DO 270 I=1,4
  270 PLIM(I)=DLIM(I)
      CALL CLPUT(TE,TA,-1)
C---DROP BACK TO THE SURFACE AT THE PLUNGE FEED RATE
C
      UST=PAR(1)
      VST=PAR(2)
      CALL SSPATH( COM(IDRIV), MIDTYP, TPDIR, DTOL, DSTEP, DOFSET,
     X           PLIM, IDTOOL, IAXIS, AXIS, ITLDIR,
     X       TLDIR, COM(IPART),  PSIDE, PTHICK, PTOLI, PTOLO, IPTOOL,
     X            TUL, UST,  VST, TSCALH, TSTEPO, TSTEPM,
     X            AMAXDP, ELMAX, MMAXCL, MICLSK, IQUAL,
     X            TE, TA, TD, PAR, IRR)
      IF(IRR.NE.0) GO TO 999
C
C---      INCREMENT COUNT OF CALLS TO SSPATH, QUIT WHEN OVER LIMIT
      IPATHK=IPATHK+1
      IF(IPATHK.GE.MXPATH) GO TO 999
  260 CONTINUE
C
C--- NOW CONTINUE BY ZAGGING DOWN NEXT CUT PATH
  300 CONTINUE
      IPASS=IPASS+1
C---      MOD(IBUG,100) IS THE PASS NUMBER WHEN IBUG SHOULD BE RESET
      IBUGT=MOD(IBUG,100)
      IF(IBUG/100.EQ.IPASS) IBUG=IBUGT
      ICLSKP=1
      DO 310 I=1,4
  310 PLIM(I)=DLIM(I)
      DSTEP=ONE
      SCALHT=SSTEP(1)
      STEPMX=SSTEP(2)
      STEPOV=ZERO
C
C---GENERATE FEED RATE FOR PATH MOTION
      IF(FED(1).GT.SMAL) CALL FEDPUT(FED(1))
      GO TO 120
C
C
  500 CONTINUE
C---PICKFD PATTERN MACHINING
C---CUTTER ZIGS ALONG MAIN PATH COMPUTING SCALOP FOR NEXT PASS
C---IT THEN RETRACTS AT RAPID TO THE CLEARANCE PLANE
C---RETRACTS TO A POSITION OVER THE FIRST POINT
C---AND PLUNGES TO THE FIRST PATH POINT AT A REDUCED FEEDRATE
C---IT THEN STEPS OVER IN THE SAME MANNER AS THE ZIGZAG ROUTINE
C---AND PROCEEDS IN THE SAME DIRECTION DOWN THE NEXT PATH
      IPASS=1
      IFIN=0
      ICLSKP=0
      IF(ISKP.EQ.1) ICLSKP=1
      IPART=PGEOM(4)
      IDRIV=DGEOM(4)
      PAR(1)=UST
      PAR(2)=VST
      DSTEP=ONE
      SCALHT=SSTEP(1)
      STEPMX=SSTEP(2)
      STEPOV=ZERO
C---GENERATE LIMITS BASED ON A SECTOR OF THE BOUNDED REGION
      I=1
      IF(IDTYPE.EQ.2) I=2
      ADIR(I)=PDIR
      ADIR(3-I)=CDIR
      DO 750 I=1,2
      IF(ADIR(I).LT.ZERO) GO TO 720
      ALIM(2*I-1)=PAR(I)
      ALIM(2*I)=DLIM(2*I)
      GO TO 750
  720 CONTINUE
      ALIM(2*I-1)=DLIM(2*I-1)
      ALIM(2*I)=PAR(I)
  750 CONTINUE
      IF(IBUG.EQ.11) CALL BAD(-4,1,'ALIM',ALIM)
      IF(IBUG.EQ.11) CALL BAD(-2,1,'ADIR',ADIR)
C
  520 CONTINUE
C---COMMON ENTRY POINT FOR CONSECUTIVE PASSES IN MAIN DIRECTION.
      IF(IBUG.NE.11) GO TO 505
      CALL BAD(-1,0,' ',0)
      CALL BAD(1,0,'PASS',IPASS)
      CALL BAD(-2,1,'PAR ',PAR)
  505 CONTINUE
C
      DO 510 I=1,4
  510 PLIM(I)=ALIM(I)
      TPDIR=PDIR
      IRR=0
      CALL CLPUT(TE,TA,-1)
C
C---FIRST DO A STARTUP TO SAVE THE FIRST PATH POINT
      MICLSK=-1
      MMAXCL=1
C
      CALL SSPATH( COM(IDRIV), IDTYPE, TPDIR, DTOL, DSTEP, DOFSET,
     X           PLIM, IDTOOL, IAXIS, AXIS, ITLDIR,
     X       TLDIR, COM(IPART), PSIDE, PTHICK, PTOLI, PTOLO, IPTOOL,
     X           TUL, PAR(1), PAR(2), SCALHT, STEPOV, STEPMX,
     X           AMAXDP, ELMAX, MMAXCL, MICLSK, IQUAL,
     X          SVTE,SVTA,SVTD, PAR, IRR)
      IF(IRR.NE.0) GO TO 999
C---      INCREMENT COUNT OF CALLS TO SSPATH, QUIT WHEN OVER LIMIT
      IPATHK=IPATHK+1
      IF(IPATHK.GE.MXPATH) GO TO 999
C
C---NOW PROCEED DOWN PATH IN NORMAL FASHION
      ICLSKP=0
      IF(IPASS.EQ.1.AND.ISKP.GT.0) ICLSKP=1
C
      UST=PAR(1)
      VST=PAR(2)
      CALL SSPATH( COM(IDRIV), IDTYPE, TPDIR, DTOL, DSTEP, DOFSET,
     X           PLIM, IDTOOL, IAXIS, AXIS, ITLDIR,
     X       TLDIR, COM(IPART), PSIDE, PTHICK, PTOLI, PTOLO, IPTOOL,
     X           TUL, UST,  VST, SCALHT, STEPOV, STEPMX,
     X           AMAXDP, ELMAX, MAXCL, ICLSKP, IQUAL,
     X           TE, TA, TD, PAR, IRR )
C
      IF(IRR.NE.0) GO TO 999
C---      INCREMENT COUNT OF CALLS TO SSPATH, QUIT WHEN OVER LIMIT
      IPATHK=IPATHK+1
      IF(IPATHK.GE.MXPATH) GO TO 999
C---TERMINATE PROCESS WHEN IFIN IS NOT ZERO.
      IF(IFIN.EQ.1) GO TO 999
C---RESTORE THE PARAMETERS TO THEIR INITIAL VALUES
      PAR(1)=UST
      PAR(2)=VST
C---NOW RETRACT TO CLEARANCE PLANE AT RAPID
      IF(FED(4).GT.SMAL) CALL FEDPUT(FED(4))
C
      CALL CLPUT(TE,TA,-1)
      CALL CLIFT(TE,CLRPLN,TE)
      CALL CLPUT(TE,TA,0)
C---POSITION OVER BEGINNING CL POINT OF THIS PATH
      CALL CLIFT(SVTE,CLRPLN,TE)
      CALL CLPUT(TE,SVTA,1)
C---NOW ACTIVATE THE PLUNGE FEED RATE
      IF(FED(3).GT.SMAL) CALL FEDPUT(FED(3))
      CALL CLPUT(TE,TA,-1)
      CALL CLPUT(SVTE,SVTA,1)
C---NOW MAKE SIDE STEP MOVE FOR NEXT TOOL PASS
      TPDIR=CDIR
      MIDTYP=3-IDTYPE
      ICR=2
      IF(IDTYPE.EQ.2) ICR=1
      ILC=2*ICR-1
      DO 610 I=1,2
  610 PSAVE(I)=PAR(I)
      CALL PCHG(PAR(ICR),CDIR,STEPOV)
      PAR(ICR)=PAR(ICR)+CDIR*STEPOV
      DO 620 I=1,4
  620 PLIM(I)=ALIM(I)
      IF(PAR(ICR).LT.ALIM(ILC)+SMAL.AND.CDIR.LT.ZERO) IFIN=1
      IF(PAR(ICR).LT.ALIM(ILC)+SMAL.AND.CDIR.LT.ZERO)PAR(ICR)=ALIM(ILC)
      IF(PAR(ICR).GT.ALIM(ILC+1)-SMAL.AND.CDIR.GT.ZERO) IFIN=1
      IF(PAR(ICR).GT.ALIM(ILC+1)-SMAL.AND.CDIR.GT.ZERO)PAR(ICR)=
     X   ALIM(ILC+1)
C---NOW TEMPORARILY LOAD NEW LIMITS FOR SIDE STEPPING
      IF(CDIR.LT.ZERO) GO TO 630
      PLIM(ILC)=PSAVE(ICR)
      PLIM(ILC+1)=PAR(ICR)
      GO TO 640
C
  630 CONTINUE
      PLIM(ILC)=PAR(ICR)
      PLIM(ILC+1)=PSAVE(ICR)
  640 CONTINUE
C
      TSCALH=ZERO
      TSTEPO=ZERO
      TSTEPM=ZERO
      TPTHIC=SSTEP(3)+PTHICK
      MICLSK=1
      IF(SSTEP(3).GT.SMAL) MICLSK=0
C
      IF(FED(2).GT.SMAL) CALL FEDPUT(FED(2))
      CALL CLPUT(TE,TA,-1)
C
      IF(IBUG.NE.11) GO TO 650
      CALL BAD(-1,0,' ',0)
      CALL BAD(1,0,'STEP',IPASS)
      CALL BAD(2,1,'PSAV',PSAVE)
      CALL BAD(-2,1,'PAR ',PAR)
  650 CONTINUE
C
      CALL SSPATH( COM(IDRIV), MIDTYP, TPDIR, DTOL, DSTEP, DOFSET,
     X           PLIM, IDTOOL, IAXIS, AXIS, ITLDIR,
     X       TLDIR, COM(IPART), PSIDE, TPTHIC, PTOLI, PTOLO, IPTOOL,
     X           TUL, PSAVE(1), PSAVE(2), TSCALH,TSTEPO, TSTEPM,
     X           AMAXDP, ELMAX, MAXCL, MICLSK, IQUAL,
     X           TE, TA, TD, PAR, IRR)
      IF(IRR.NE.0) GO TO 999
C---      INCREMENT COUNT OF CALLS TO SSPATH, QUIT WHEN OVER LIMIT
      IPATHK=IPATHK+1
      IF(IPATHK.GE.MXPATH) GO TO 999
C
C---IF THE THIRD FEED RATE IS AVAILABLE AND LIFTUP SPECIFIED
C---THEN USE THE PLUNGE PROCEDURE
      IF(SSTEP(3).LT.SMAL) GO TO 660
      IF(FED(3).GT.SMAL) CALL FEDPUT(FED(3))
      MMAXCL=1
      MICLSK=0
      DO 670 I=1,4
  670 PLIM(I)=ALIM(I)
      CALL CLPUT(TE,TA,-1)
C
      UST=PAR(1)
      VST=PAR(2)
      CALL SSPATH( COM(IDRIV), MIDTYP, TPDIR, DTOL, DSTEP, DOFSET,
     X           PLIM, IDTOOL, IAXIS, AXIS, ITLDIR,
     X       TLDIR, COM(IPART),  PSIDE, PTHICK, PTOLI, PTOLO, IPTOOL,
     X            TUL, UST,  VST, TSCALH, TSTEPO, TSTEPM,
     X            AMAXDP, ELMAX, MMAXCL, MICLSK, IQUAL,
     X            TE, TA, TD, PAR, IRR)
      IF(IRR.NE.0) GO TO 999
C
C---      INCREMENT COUNT OF CALLS TO SSPATH, QUIT WHEN OVER LIMIT
      IPATHK=IPATHK+1
      IF(IPATHK.GE.MXPATH) GO TO 999
  660 CONTINUE
C
C---NOW RESET PARAMETERS FOR MOVING DOWN NEXT CUT PATH
  700 CONTINUE
      IPASS=IPASS+1
C---      MOD(IBUG,100) IS THE PASS NUMBER WHEN IBUG SHOULD BE RESET
      IBUGT=MOD(IBUG,100)
      IF(IBUG/100.EQ.IPASS) IBUG=IBUGT
      ICLSKP=1
      DO 710 I=1,4
  710 PLIM(I)=ALIM(I)
      DSTEP=ONE
      SCALHT=SSTEP(1)
      STEPMX=SSTEP(2)
      STEPOV=ZERO
C
      IF(FED(1).GT.SMAL) CALL FEDPUT(FED(1))
      GO TO 520
C
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001067.W02   ***
*
      SUBROUTINE DGEOM(DSURF,IDTYPE,U,V,IDAXIS,DAXIS,
     X      ITLDIR,TLDIR,DTOL,DR,U1,V1,NPAT,CX)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
C--PURPOSE IS TO GENERATE ALL NECESSARY INFORMATION AT CURRENT
C--POINT U,V OF DRIVE GEOMETRY.  INPUT PARAMETERS ALL EXPLAINED
C--IN PATH
C--OUTPUT
C--DR  ARRAY CONTAINING ALL RELEVANT CURVE INFORMATION AT POINT U,V
C-- DR(1-3) = DRIVE GEOMETRY POINT
C-- DR(5-7) = DRIVE GEOMETRY TANSPL VECTOR
C-- DR(9-11) = DRIVE GEOMETRY SECOND DERIVATIVE
C-- DR(13-15) = DRIVE GEOMETRY UNIT TANGENT VECTOR
C-- DR(17-19) = TOOL AXIS ORIENTATION
C-- DR(21-23) = TOOL DIRECTION TOWARD PART SURFACE
C-- DR(25,26)  CURVATURE AND STEP SIZE BASED ON DTOL
C--- DR(27) = MAXIMUM STEP IN THE DRIVE SURFACE DIRECTION.
C-- DR(29-31) = CRSSPL TANGENT(IF AVAILABLE)
C-- DR(33-35) = DRIVE GEOMETRY SURFACE NORMAL(IF AVAILABLE)
C
      DIMENSION DSURF(*),DAXIS(*),TLDIR(*),DR(*)
      DIMENSION CX(32)
      DIMENSION B(64),IFLAG(6),ITOP(6,4)
      DIMENSION VEC(3)
      CHARACTER*20 BADMSG
      DATA NLAST/0/
      DATA ZERO,ONE,SMAL,HSMAL/0.0D0,1.0D0,1.0D-38,1.D-19/
      DATA BIG/1.0D+10/
      DATA ARECSV/0.0D0/,QSMAL/1.0D-6/
C
      DO 5 I=1,36
    5 DR(I)=ZERO
C--SEPARATE CURVE AND SURFACE CASES IMMEDIATLY
      IF(IDTYPE.NE.0) GO TO 100
C--SCURV DRIVE GEOMETRY.  EVALUATE CROSS DERIVS ONLY IF VARIABLE
C--TOOL AXIS OR DIRECTION IS REQUESTED
      ICROS=1
      IF(ITLDIR.NE.0.OR.IDAXIS.NE.0) ICROS=2
      CALL CURFLO(U,DSURF,CX,ICROS,0)
      IF(IBUG.NE.11) GO TO 8809
      JLIM=ICROS*16
      CALL BAD(-JLIM,1,'CFLO',CX)
 8809 CONTINUE
      DO 10 I=1,16
   10 DR(I)=CX(I)
C--SET AXIS ACCORDING TO IDAXIS SETTING
      IF (ABS(IDAXIS).LE.1) THEN
      CALL AXSET(IDAXIS,DAXIS,CX(17),DR(17))
      ELSE
        CALL AXSET(IDAXIS,CX(13),CX(17),DR(17))
      ENDIF
C--SET THE TOOL DIRECTION NEXT
      CALL AXSET(ITLDIR,TLDIR,CX(17),DR(21))
      GO TO 200
C
  100 CONTINUE
C--CASE OF MESH STRUCTURED DRIVE SURFACE.
      CALL MESCON(DSURF,U,V,NPAT,U1,V1,1)
      IF(NLAST.NE.NPAT.OR.DSURF(1).NE.ARECSV)  CALL
     X      LODPCH(DSURF,B,IFLAG,ITOP,NPAT,3)
      NLAST=NPAT
      ARECSV=DSURF(1)
      CALL CNSURF(U1,V1,B,CX,IFLAG,1)
C--PICK UP TANSPL FIRST AND SECOND DERIVATIVES IF IDTYPE=1
C--PICK UP CRSSPL FIRST AND SECOND DERIVATIVES IF IDTYPE=2
      JTAN=4
      IF(IDTYPE.EQ.2) JTAN=8
      JACC=12
      IF(IDTYPE.EQ.2) JACC=20
      JCRS=8
      IF(IDTYPE.EQ.2) JCRS=4
      JNORM=28
      DO 110 I=1,4
      DR(I)=CX(I)
      DR(I+4)=CX(JTAN+I)
      DR(I+8)=CX(JACC+I)
      DR(I+28)=CX(I+JCRS)
      DR(I+32)=CX(I+JNORM)
  110 CONTINUE
      CALL DOTF(SIZ,DR(5),DR(5))
      IF(SIZ.LT.SMAL) GO TO 120
      SIZ=DSQRT(SIZ)
      DO 130 I=1,3
  130 DR(12+I)=DR(4+I)/SIZ
      DR(16)=ONE
  120 CONTINUE
C--SET THE TOOL AXIS FIRST
      IF (ABS(IDAXIS).LE.1) THEN
      CALL AXSET(IDAXIS,DAXIS,CX(29),DR(17))
      ELSE
        CALL AXSET(IDAXIS,DR(29),CX(29),DR(17))
      ENDIF
C--SET THE TOOL DIRECTION NEXT
      CALL AXSET(ITLDIR,TLDIR,CX(29),DR(21))
C
  200 CONTINUE
C--COMPUTE CURVATURE AND STEP SIZE OF CURVE AT THIS POINT
C
      CALL DOTF(TNSQ,DR(5),DR(5))
      IF(TNSQ.LT.HSMAL) GO TO 230
C
      CALL CROSS(DR(5),DR(9),VEC)
      CALL DOTF(VECSQ,VEC,VEC)
      IF(VECSQ.LT.SMAL) GO TO 230
      CK=DSQRT(VECSQ)/(DSQRT(TNSQ))**3
      IF(CK.GT.HSMAL) GO TO 240
  230 CONTINUE
C--CURVATURE IS VERY SLIGHT
      CK=ZERO
      STEP=BIG
      GO TO 300
C
  240 CONTINUE
      RAD=ONE/CK
      STEP=(RAD+RAD-DTOL)*DTOL
      IF(STEP.LT.QSMAL) GO TO 230
      STEP=2.*DSQRT(STEP)
C
  300 CONTINUE
      DR(25)=CK
      DR(26)=STEP
      DR(27)=ONE
      IF(TNSQ.GT.SMAL) DR(27)=STEP/DSQRT(TNSQ)
C
  999 CONTINUE
      IF(IBUG.NE.11) GO TO 1999
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER DGEOM'
      CALL CPRINT(BADMSG)
      CALL BAD(1,1,'U   ',U)
      CALL BAD(1,1,'V   ',V)
      CALL BAD(1,0,'IDTP',IDTYPE)
      CALL BAD(1,0,'IDAX',IDAXIS)
      CALL BAD(-1,0,'ITLD',ITLDIR)
      DO  1998 I=1,33,4
      CALL BAD(-4,1,'DR  ',DR(I))
 1998 CONTINUE
 1999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001068.V05   ***
*
      SUBROUTINE FEDPUT(FEED)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
      INTEGER ITEMP(2),BCDF
      EQUIVALENCE (FEDRAT,ITEMP(1))
C
C
      ITEMP(1) = BCDF('FEDR')
      ITEMP(2) = BCDF('AT  ')
      CALL APT299(1,FEDRAT,1,FEED)
      IF(IBUG.NE.11) GO TO 999
      CALL BAD(-1,0,' ',0)
      CALL BAD(-1,1,'FEED',FEED)
      CALL BAD(-1,0,' ',0)
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001070.W02   ***
*
      SUBROUTINE GETAPT(TUL,PTOLI,PTOLO,DTOL,AMAXDP,ZELMAX,INUM,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C--PURPOSE IS TO FETCH ADDITIONAL APT VARIABLES REQUIRED FOR
C--SMIL TOOL PATH GENERATION.
C
      INCLUDE (TOTAL)    
      INCLUDE (FXCOR)    
      INCLUDE (SV)    
      INCLUDE (IFXCOR)    
C
      DIMENSION TUL(7)
      COMMON/ADDCOM/ADDCOM(25)
      EQUIVALENCE (ADDCOM(1), ELMAX)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
C
      DATA SMAL/1.0D-14/
C
C--FETCH TOOL AND VERIFY THAT IT IS ACCEPTABLE
      TUL(1)=CUTDAT(2)
      TUL(2)=CUTDAT(1)
      TUL(3)=CUTDAT(3)
      IF(TUL(1)**2+TUL(3)**2.LT.SMAL) TUL(3)=TUL(2)
      TUL(4)=CUTDAT(4)-CUTDAT(2)
      TUL(5)=CUTDAT(5)
      TUL(6)=CUTDAT(6)
      TUL(7)=CUTDAT(7)
      IF(IBUG.EQ.11) CALL BAD(-7,1,'CUTD',CUTDAT)
C
      PTOLO=DABS(TAU1(IPS))
      PTOLI=DABS(TAU2(IPS))
      DTOL=DABS(TAU1(IDS))
      IF(DTOL.LT.SMAL) DTOL=DABS(TAU2(IDS))
      AMAXDP=DPMAX
      ZELMAX=ELMAX
      INUM=NMPNTS
      IRR=0
      GO TO 999
  998 CONTINUE
      IF(IBUG.EQ.11) CALL BAD(-7,1,'CUTD',CUTDAT)
C
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001072.W01   ***
*
      SUBROUTINE GFETCH(NBIG,MAXLDA,COM,DGEOM,PGEOM,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
      DIMENSION DUMREC(3)
      DIMENSION COM(*),DGEOM(*),PGEOM(*)
      LOGICAL CKDEF
      EQUIVALENCE (JJ,AA)
      CHARACTER*20 BADMSG
      DATA ZERO,ONE,ASCURV,ASSURF/0.0D0,1.0D0,30.0D0,29.0D0/
      DATA DUMREC/3*0.0D0/
C--PURPOSE IS TO LOAD PART AND DRIVE GEOMETRY BOTH INTO THE
C--ARRAY COM.  THE ADDRESS OF EACH IS THEN PLACED IN THE 4TH
C--LOCATIONS OF DGEOM AND PGEOM RESPECTIVELY
C
      NLO=41
      NHI=NLO+NBIG-1
      ILOC=NHI+1
      DO 10 I=NLO,NHI
   10 COM(I)=ZERO
      IRR=1
      N=PGEOM(2)+DGEOM(2)
      IF(PGEOM(1).EQ.DGEOM(1)) N=PGEOM(2)
      N=N+NBIG
      IF(N.GT.MAXLDA) GO TO 998
C---      WRITE A NULL RECORD TO LET APT094 KNOW THAT BLANK COMMON
C---      HAS BEEN ALTERED
      DUMREC(2)=0.0
      DUMREC(3)=NBIG
      JMODE=1
      CALL APT094(JMODE,DUMREC(2),COM(41))
      IRR=4
      IF(CKDEF(DUMREC)) GO TO 998
C--LOAD PART GEOMETRY FIRST
      JMODE=3
      CALL APT094(JMODE,PGEOM(1),JJ)
      IRR=2
      IF(CKDEF(PGEOM)) GO TO 998
      PGEOM(4)=JJ
C--CHECK WHETHER PART AND DRIVE GEOMETRY ARE THE SAME
      IF(DGEOM(1).NE.PGEOM(1)) GO TO 110
      DGEOM(4)=PGEOM(4)
      GO TO 200
C--LOAD DRIVE GEOMETRY INTO CORE
  110 CONTINUE
      JMODE=3
      CALL APT094(JMODE,DGEOM(1),JJ)
      IRR=3
      IF(CKDEF(DGEOM)) GO TO 998
      DGEOM(4)=JJ
  200 CONTINUE
      IRR=0
C
  998 CONTINUE
      IF(IBUG.NE.11) GO TO 999
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER  GFETCH'
      CALL CPRINT(BADMSG)
      CALL BAD(1,0,'IRR ',IRR)
      CALL BAD(1,0,'JMOD',JMODE)
      CALL BAD(-1,0,'ILOC',ILOC)
      CALL BAD(-4,1,'PGEM',PGEOM(1))
      CALL BAD(-4,1,'DGEM',DGEOM(1))
      CALL BAD(-3,1,'DREC',DUMREC)
C
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0011490.ORG   ***
*
      SUBROUTINE GOMILL
C
C      DUMMY ROUTINE.   SODO   M0009479               DESIGNATED
C      TO PROCESS THE START UP, THE SINGLE CUT AND THE MULTI CUT
C      SEQUENCE STATEMENT OF THE PROPOSED REGIONAL MILLING.
C
      RETURN
      END
**** SOURCE FILE : M0001074.V02   ***
*
      SUBROUTINE KURSRF(R,SIDE,CX)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C           /-INPUT
C           /-SURFACE POINT, FIRST AND SECOND DERIVATIVES IN R
C           /-SIDE(CUTTER SIDE) OF SURFACE =1 OR -1.
C           /-OUTPUT
C           /-SURFACE CURVATURE ANALYSIS, ALL DATA STORED IN CX
C
C           /-PURPOSE TO COMPUTE PRINCIPAL CURVATURES AND OTHER QUANTITI
C           /-RELATED TO SURFACE AT THIS POINT.
C
      COMMON/IBUGG/IBUG,IPCOMC,IPCOLC
      DIMENSION R(32),CX(24)
      DIMENSION DVEC(3)
      DATA DVEC/0.13D0,0.23D0,0.33D0/
      DATA ZERO,ONE/0.0D0,1.0D0/
      DATA SMAL/1.0D-19/
C
      DO 5 I=1,24
    5 CX(I)=ZERO
C
C           /-COMPUTE G11,G12,G22
      CALL DOTV(CX(13),R(5),R(5))
      CALL DOTV(CX(14),R(5),R(9))
      CALL DOTV(CX(15),R(9),R(9))
      CX(16)=ONE
C           /-COMPUTE L11,L12,L22
      CALL DOTV(CX(17),R(13),R(29))
      CALL DOTV(CX(18),R(17),R(29))
      CALL DOTV(CX(19),R(21),R(29))
      DO 10 I=17,19
   10 CX(I)=SIDE*CX(I)
      CX(20)=ONE
C           /-COMPUTE COEFFICIENTS OF CURVATURE EQUATION A.KSQ+B.K+C=0
C           /-A=DET(G),B=-(L11*G22-2*L12G12+L22*G11),C=DET(L)
      CX(21)=CX(13)*CX(15)-CX(14)**2
      CX(22)=-(CX(13)*CX(19)-2.*CX(14)*CX(18)+CX(15)*CX(17))
      CX(23)=CX(17)*CX(19)-CX(18)**2
      CX(24)=ONE
C           /-SOLVE THIS EQUATION TO OBTAIN TWO PRINCIPAL CURVATURES
      DISC=CX(22)**2-4.*CX(21)*CX(23)
      DISC=DMAX1(ZERO,DISC)
      DISC=DSQRT(DISC)
      DENOM=CX(21)+CX(21)
      CX(1)=(-CX(22)+DISC)/DENOM
      CX(2)=(-CX(22)-DISC)/DENOM
      CX(4)=ONE
C           /-FINALLY DETERMINE SPATIAL DIRECTIONS OF THESE CURVATURES
C           /- THE DIRECTION OF K IS ACHIEVED BY (-L12+KG12,L11-KG11)
C           /- IMISS IS THE COUNT OF THE NUMBER OF MISSES
      IMISS=0
      DO 20 I=1,2
      A=-(CX(18)-CX(I)*CX(14))
      B=CX(17)-CX(I)*CX(13)
      L=4*I
      IF(DABS(A)+DABS(B).GT.SMAL) GO TO 50
C            /-TRY AGAIN TO OBTAIN A NON ZERO A,B
      A=-(CX(19)-CX(I)*CX(15))
      B=CX(18)-CX(I)*CX(14)
      IF(DABS(A)+DABS(B).GT.SMAL) GO TO 50
      IMISS=IMISS+1
      GO TO 20
   50 CONTINUE
      DO 30 J=1,3
   30 CX(L+J)=A*R(J+4)+B*R(J+8)
      CALL VNORM(CX(L+1),CX(L+1))
      CX(L+4)=ONE
      GO TO 100
   20 CONTINUE
C
  100 CONTINUE
      IF(IMISS.EQ.2) GO TO 130
C-- A GOOD VECTOR WAS OBTAINED, COMPUTE THE OTHER BY CROSS PRODUCT
      LNXT=L+4
      IF(L.EQ.8) LNXT=L-4
      CALL CROSS(CX(L+1),R(29),CX(LNXT+1))
      CALL VNORM(CX(LNXT+1),CX(LNXT+1))
      CX(LNXT+4)=ONE
      GO TO 140
C-- NO GOOD VECTORS AVAILABLE, GENERATE ANY TWO NORMAL TO R(29)
  130 CONTINUE
      CALL CROSS(DVEC,R(29),CX(5))
      CALL VNORM(CX(5),CX(5))
      CALL CROSS(CX(5),R(29),CX(9))
      CALL VNORM(CX(9),CX(9))
      CX(8)=ONE
      CX(12)=ONE
C
  140 CONTINUE
C
      IF(IBUG.NE.11) GO TO 60
      DO 70 I=1,21,4
      CALL BAD(-4,1,'KRSF',R(I))
   70 CONTINUE
      DO 80 I=1,9,4
      CALL BAD(-4,1,'CX  ',CX(I))
   80 CONTINUE
C
   60 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001079.W01   ***
*
      SUBROUTINE MESCON(SURF,U,V,NPAT,U1,V1,MODE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
C--PURPOSE IS TO CONVERT GLOBAL MESH COORDINATES U,V
C--INTO LOCAL PATCH NUMBER(NPAT) AND LOCAL PATCH COORDINATES
C--U1,V1 IF MODE IS 1.  OTHERWISE THE REVERSE IF MODE IS 2
      DIMENSION SURF(*)
      CHARACTER*20 BADMSG
      DATA ONE/1.0D0/
      DATA TWO/2.D0/
C
      NUMSPL=SURF(9)
      NUMCRS=SURF(10)
      ACRS=SURF(10)-TWO
      ASPL=SURF(9)-TWO
C
      IF(MODE.GT.1) GO TO 100
C--CONVERT GLOBAL U,V TO LOCAL PATCH NUMBER NPAT AND LOCAL U1,V1
      IU=1
      IF(U.LT.ONE) GO TO 10
      IU=NUMCRS-1
      IF(U.GE.ACRS) GO TO 10
      IU=IDINT(U)+1
   10 CONTINUE
      BASE=IU-1
      U1=U-BASE
C
      IV=1
      IF(V.LT.ONE) GO TO 20
      IV=NUMSPL-1
      IF(V.GE.ASPL) GO TO 20
      IV=IDINT(V)+1
   20 CONTINUE
      BASE=IV-1
      V1=V-BASE
C
      NPAT=IU+(IV-1)*(NUMCRS-1)
      GO TO 999
C
  100 CONTINUE
C--CONVERT NPAT,U1,V1 TO GLOBAL U,V
      IU=MOD(NPAT-1,NUMCRS-1)+1
      IV=(NPAT-1)/(NUMCRS-1)+1
      U=U1+IU-1
      V=V1+IV-1
C
  999 CONTINUE
      IF(IBUG.NE.11) GO TO 1999
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER MESCON'
      CALL CPRINT(BADMSG)
      CALL BAD(1,1,'U   ',U)
      CALL BAD(1,1,'V   ',V)
      CALL BAD(1,0,'NPAT',NPAT)
      CALL BAD(1,1,'U1  ',U1)
      CALL BAD(-1,1,'V1  ',V1)
      CALL BAD(-1,0,'MODE',MODE)
 1999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001082.W01   ***
*
      SUBROUTINE PCHG(PCUR,PDIR,PDEL)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
      CHARACTER*20 BADMSG
      DATA ZERO,ONE,HALF,SMAL/0.D0,1.D0,0.5D0,1.D-14/
      DATA SMAL1/1.0D-10/
C--PURPOSE IS TO MODIFY THE PARAMETRIC CHANGE PDEL SO AS
C--TO HIT OR APPROACH A JUNCTION POINT SMOOTHLY.
C
      PIN=PDEL
      A=ZERO
      XX=PCUR
      I=IDINT(XX)
      A=I
      IF(DABS(A-PCUR).GT.SMAL) GO TO 10
      PDEL=DMIN1(HALF,PDEL)
      GO TO 999
C
   10 CONTINUE
      PTARG=ZERO
      XX=PDIR+PCUR
      I=IDINT(XX)
      PTARG=I
      PMAX=DABS(PTARG-PCUR)
      PDEL=DMIN1(PMAX,PDEL)
      PHALF=HALF*PMAX
      IF(PDEL.LT.PMAX.AND.PDEL.GT.PHALF) PDEL=PHALF
C
  999 CONTINUE
      PDEL=PDEL+SMAL1
      IF(IBUG.NE.11) GO TO 1999
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER PCHG'
      CALL CPRINT(BADMSG)
      CALL BAD(1,1,'PCUR',PCUR)
      CALL BAD(1,1,'PDIR',PDIR)
      CALL BAD(1,1,'PDEL',PDEL)
      CALL BAD(-1,1,'PIN ',PIN)
 1999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0002902.W03   ***
*
      SUBROUTINE SCON
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---PURPOSE IS TO PICK UP THE DATA STREAM FROM AN SCON/ COMMAND
C--- AND DEVELOP THE RELATED DATA INTO LABELLED COMMON.
C--- THE TRANSLATED DATA IS AVAILABLE IN BLANK COMMON STARTING
C---AT LOCATION ISTART(=42) .  THE FIRST VALUE IS A FLOATING
C---WORD WHICH GIVES THE NUMBER OF PERTINENT DATA ITEMS WHICH
C---FOLLOW.  EACH APT WORD OR VARIABLE IS PRECEEDED BY ITS
C---WORD WORD IDENTIFICATION
C
      INCLUDE (BLANKCOM)    
C
      LOGICAL CKDEF
C
      CHARACTER*6 WALL,WAT,WAXIS,WCLDAT,WCROSS,WCRSSP,WCS,WDS,WFEED,
     1 WIN,WINCR,WINIT,WMINUS,WNORMA,WNORMD,WNORMP,WOFF,WON,WOUT,
     2 WPARAM,WPATH,WPICKF,WPLANE,WPLUS,WPOINT,WPOSN,WPS,WSCALA,
     3 WSCURV,WSSURF,WSTEPO,WTANSP,WTO,WVECTO,WZIGZA
      CHARACTER*6 WATANG,WCUTAN,WLEAD,WLAG
      CHARACTER*6 CTEST
C
      COMMON/IBUGG/IBUG,I1,I2
      COMMON/XDS/DGEOM(4),DLIM(4),TLDIR(3),DOFSET,ITLDIR,IDTOOL,NDS
      COMMON/XPS/PGEOM(4),PSIDE,PTHICK,IPTOOL,NPS
      COMMON/XFEED/CLRPLN(4),FED(4),NCLRPL,NFEED
      COMMON/XSTEPO/SSTEP(4),NSTEPO
      COMMON/XAXIS/AXIS(3),IAXIS,NAXIS
      INCLUDE (TAC)    
      INCLUDE (ZNUMBR)    
C
C
C--WORD MODE VALUES IN REAL FORM AND HOLLERITH FORM.
C--THESE ARE WORDS USED IN SMIL AND SCON COMMANDS
C
      DATA AALL/50.D0/,WALL/'ALL   '/
      DATA AAT/66.D0/,WAT/'AT    '/
      DATA AAXIS/146.D0/,WAXIS/'AXIS  '/
      DATA ACLDAT/69.D0/,WCLDAT/'CLDATA'/
      DATA ACROSS/40.D0/,WCROSS/'CROSS '/
      DATA ACRSSP/137.D0/,WCRSSP/'CRSSPL'/
      DATA ACS/1.D0/,WCS/'CS    '/
      DATA ADS/1.D0/,WDS/'DS    '/
      DATA AFEED/163.D0/,WFEED/'FEED  '/
      DATA AIN/20.D0/,WIN/'IN    '/
      DATA AINCR/57.D0/,WINCR/'INCR  '/
      DATA AINIT/161.D0/,WINIT/'INIT  '/
      DATA AMINUS/41.D0/,WMINUS/'MINUS '/
      DATA ANORMA/13.D0/,WNORMA/'NORMAL'/
      DATA ANORMD/151.D0/,WNORMD/'NORMDS'/
      DATA ANORMP/152.D0/,WNORMP/'NORMPS'/
      DATA AOFF/50.D0/,WOFF/'OFF   '/
      DATA AON/3.D0/,WON/'ON    '/
      DATA AOUT/21.D0/,WOUT/'OUT   '/
      DATA APARAM/144.D0/,WPARAM/'PARAM '/
      DATA APATH/165.D0/,WPATH/'PATH  '/
      DATA APICKF/166.D0/,WPICKF/'PICKFD'/
      DATA APLANE/2.D0/,WPLANE/'PLANE '/
      DATA APLUS/42.D0/,WPLUS/'PLUS  '/
      DATA APOINT/19.D0/,WPOINT/'POINT '/
      DATA APOSN/164.D0/,WPOSN/'POSN  '/
      DATA APS/1.D0/,WPS/'PS    '/
      DATA ASCALA/21.D0/,WSCALA/'SCALAR'/
      DATA ASCURV/30.D0/,WSCURV/'SCURV '/
      DATA ASSURF/29.D0/,WSSURF/'SSURF '/
      DATA ASTEPO/162.D0/,WSTEPO/'STEPOV'/
      DATA ATANSP/136.D0/,WTANSP/'TANSPL'/
      DATA ATO/3.D0/,WTO/'TO    '/
      DATA AVECTO/20.D0/,WVECTO/'VECTOR'/
      DATA AZIGZA/61.D0/,WZIGZA/'ZIGZAG'/
      DATA AATANG/10.D0/,WATANG/'ATANGL'/
      DATA ACUTAN/71.D0/,WCUTAN/'CUTANG'/
      DATA ALEAD/74.D0/,WLEAD/'LEAD  '/
      DATA ALAG/75.D0/,WLAG/'LAG   '/
C
      DATA ZERO,ONE/0.D0,1.D0/
      DATA SMAL/1.D-38/
      DATA IBEGIN/42/,NOGOOD/-121/
      DATA NLAST/0/,NBIG/50/,IOK/121/
      DATA IRBASE/3520/
C
      IF(NCLRPL.NE.IOK) NCLRPL=NOGOOD
      ICUR=IBEGIN
      NLEN=COM(ICUR)
      NLAST=IBEGIN+NLEN-2
      COM(NLAST)=ZERO
      ICUR=ICUR+1
C****    INPUT FIELD MUST BE OF REASONABLE LENGTH
      IF(NLEN.LT.3.OR.NLEN.GT.NBIG) GO TO 995
C
   10 CONTINUE
      IF(ICUR.GE.NLAST) GO TO 998
C
      WORD=COM(ICUR)
      IF(WORD.EQ.AINIT) GO TO 100
      CALL HOLFRM(COM(ICUR+1),CTEST,1,6,NWD)
      IF(CTEST.EQ.WDS) GO TO 200
      IF(CTEST.EQ.WPS) GO TO 300
      IF(WORD.EQ.AFEED) GO TO 400
      IF(WORD.EQ.ASTEPO) GO TO 500
      IF(WORD.EQ.AAXIS) GO TO 600
C****    ERROR, WORD COMMAND WORD NOT RECOGNIZED
      GO TO 998
C
C---INIT COMMAND, FOR INTIALIZING DATA AREAS
  100 CONTINUE
      ICUR=ICUR+2
      WORD=COM(ICUR)
      IF(WORD.EQ.ADS) WORD=COM(ICUR+1)
      IALL=0
      IF(WORD.EQ.AALL) IALL=1
C
  110 CONTINUE
      CALL HOLFRM(WORD,CTEST,1,6,NWD)
      IF(CTEST.EQ.WDS .OR. IALL.EQ.1) GO TO 120
      IF(CTEST.EQ.WPS .OR. IALL.EQ.2) GO TO 130
      IF(WORD.EQ.AFEED.OR.IALL.EQ.3) GO TO 140
      IF(WORD.EQ.ASTEPO.OR.IALL.EQ.4) GO TO 150
      IF(WORD.EQ.AAXIS.OR.IALL.EQ.5) GO TO 160
      GO TO 998
  120 CONTINUE
      NDS=NOGOOD
      GO TO 190
  130 CONTINUE
      NPS=NOGOOD
      GO TO 190
  140 CONTINUE
      NFEED=NOGOOD
      GO TO 190
  150 CONTINUE
      NSTEPO=NOGOOD
      GO TO 190
  160 CONTINUE
      NAXIS=NOGOOD
      GO TO 190
C
  190 CONTINUE
      IF(IALL.NE.0) IALL=IALL+1
      IF(IALL.EQ.0) ICUR=ICUR+2
      WORD=COM(ICUR)
      IF(IALL.LT.5.AND.ICUR.LT.NLAST) GO TO 110
      IF(IALL.GT.0) ICUR=ICUR+2
      IF(ICUR.NE.NLAST) GO TO 995
C---PROCESSING FINISHED FOR INIT COMMAND
      GO TO 999
C
C---ENTRY POINT FOR DRIVE GEOMETRY INPUT
  200 CONTINUE
      NDS=NOGOOD
C---CHECK FOR NUMBER OF INPUT SCALARS TO DISTINGUISH CURV AND SURF
      ICUR=ICUR+2
      IF(COM(ICUR).EQ.ASCURV) GO TO 220
      IF(COM(ICUR).EQ.ASSURF) GO TO 260
      GO TO 998
C
C---CURVE DRIVE GEOMETRY
C-- SCON/DS,CURV,PARAM,UST,UEND,AT OR ON,CRSSPL OR VECTOR
  220 CONTINUE
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      DGEOM(1)=COM(ICUR+1)
      DGEOM(2)=COM(ICUR+2)
      DGEOM(4)=ZERO
      DGEOM(3)=ASCURV
      ICUR=ICUR+3
      IF(COM(ICUR).NE.APARAM) GO TO 998
      ICUR=ICUR+2
      IF(COM(ICUR).NE.ASCALA.OR.COM(ICUR+2).NE.ASCALA) GO TO 998
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      IF(CKDEF(COM(ICUR+3))) GO TO 997
      IF(COM(ICUR+1).GT.COM(ICUR+3)) GO TO 996
      DLIM(1)=COM(ICUR+1)
      DLIM(2)=COM(ICUR+3)
      DLIM(3)=ZERO
      DLIM(4)=ONE
      ICUR=ICUR+4
      CALL HOLFRM(COM(ICUR+1),CTEST,1,6,NWD)
      IF(COM(ICUR).NE.AAT .AND. CTEST.NE.WON) GO TO 998
      IDTOOL=0
      IF(COM(ICUR).EQ.AAT) IDTOOL=1
      ICUR=ICUR+2
      IF(COM(ICUR).NE.AVECTO.AND.COM(ICUR).NE.ACRSSP) GO TO 998
      IF(COM(ICUR).EQ.AVECTO) GO TO 230
      ITLDIR=1
      DO 240 I=1,3
  240 TLDIR(I)=ZERO
      ICUR=ICUR+2
      GO TO 290
  230 CONTINUE
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      CALL DOTF(VSQ,COM(ICUR+1),COM(ICUR+1))
      IF(VSQ.LT.SMAL) GO TO 998
      VSQ=DSQRT(VSQ)
      DO 250 I=1,3
  250 TLDIR(I)=COM(ICUR+I)/VSQ
      ITLDIR=0
      ICUR=ICUR+4
      GO TO 290
C
C--- SCON/DS,SURF,PARAM,ULO,UHI,VLO,VHI,AT OR ON, NORMAL OR VECTOR
  260 CONTINUE
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      DGEOM(1)=COM(ICUR+1)
      DGEOM(2)=COM(ICUR+2)
      DGEOM(3)=ASSURF
      DGEOM(4)=ZERO
      ICUR=ICUR+3
      IF(COM(ICUR).NE.APARAM) GO TO 998
      ICUR=ICUR+2
      DO 265 I=1,4
      JCUR=ICUR+2*I-2
      IF(COM(JCUR).NE.ASCALA) GO TO 998
      IF(CKDEF(COM(JCUR+1))) GO TO 997
      DLIM(I)=COM(JCUR+1)
  265 CONTINUE
      IF(DLIM(1).GT.DLIM(2).OR.DLIM(3).GT.DLIM(4)) GO TO 996
      ICUR=ICUR+8
C
      IDTOOL=-1
      IF(COM(ICUR).EQ.AAT) IDTOOL=1
      CALL HOLFRM(COM(ICUR+1),CTEST,1,6,NWD)
      IF(CTEST.EQ.WON) IDTOOL=0
      IF(IDTOOL.LT.0) GO TO 998
C
      ICUR=ICUR+2
      IF(COM(ICUR).EQ.ANORMA) GO TO 280
      IF(COM(ICUR).NE.AVECTO) GO TO 998
C-- VECTOR
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      ITLDIR=0
      CALL DOTF(VSQ,COM(ICUR+1),COM(ICUR+1))
      IF(VSQ.LT.SMAL) GO TO 996
      VSQ=DSQRT(VSQ)
      DO 270 I=1,3
  270 TLDIR(I)=COM(ICUR+I)/VSQ
      ICUR=ICUR+4
      GO TO 290
C
  280 CONTINUE
      ICUR=ICUR+2
C--NORMAL CASE
      ITLDIR=1
      DO 285 I=1,3
  285 TLDIR(I)=ZERO
      GO TO 290
C
  290 CONTINUE
C---      OPTIONAL DRIVE POINT OFFSET INSERTED HERE
      DOFSET=ZERO
      IF(ICUR.EQ.NLAST) GO TO 295
C---      LOOK FOR A SCALAR
      IF(COM(ICUR).NE.ASCALA) GO TO 998
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      DOFSET=COM(ICUR+1)
      ICUR=ICUR+2
      IF(ICUR.NE.NLAST) GO TO 995
  295 CONTINUE
      NDS=IOK
      GO TO 999
C
  300 CONTINUE
      NPS=NOGOOD
C---PART SURFACE SCON/PS,TO OR ON, SURF, PLUS OR MINUS, THICK
      ICUR=ICUR+2
      IPTOOL=-1
      CALL HOLFRM(COM(ICUR+1),CTEST,1,6,NWD)
      IF(CTEST.EQ.WON) IPTOOL=1
      IF(CTEST.EQ.WTO) IPTOOL=0
      IF(IPTOOL.LT.0) GO TO 998
      ICUR=ICUR+2
      IF(COM(ICUR).NE.ASSURF) GO TO 998
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      PGEOM(1)=COM(ICUR+1)
      PGEOM(2)=COM(ICUR+2)
      PGEOM(3)=ASSURF
      PGEOM(4)=ZERO
      ICUR=ICUR+3
      PSIDE=ZERO
      IF(COM(ICUR).EQ.APLUS) PSIDE=ONE
      IF(COM(ICUR).EQ.AMINUS) PSIDE=-ONE
      IF(PSIDE.EQ.ZERO) GO TO 998
      ICUR=ICUR+2
      IF(COM(ICUR).NE.ASCALA) GO TO 998
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      PTHICK=COM(ICUR+1)
      ICUR=ICUR+2
      GO TO 390
C
  390 CONTINUE
      IF(ICUR.NE.NLAST) GO TO 995
      NPS=IOK
      GO TO 999
C
  400 CONTINUE
C--- FEED RATE PROCESSING
      ICUR=ICUR+2
      IF(COM(ICUR).NE.APLANE) GO TO 430
C---SPECIAL ROUTE FOR PROCESSING PICKFD CLEARANCE PLANE
      NCLRPL=NOGOOD
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      DO 410 I=1,4
  410 CLRPLN(I)=COM(ICUR+I)
      ICUR=ICUR+5
      IF(ICUR.NE.NLAST) GO TO 995
      NCLRPL=IOK
      GO TO 999
C
  430 CONTINUE
      NFEED=NOGOOD
      DO 420 I=1,4
      NOW=ICUR+2*I-2
      IF(COM(NOW).NE.ASCALA) GO TO 998
      IF(CKDEF(COM(NOW+1))) GO TO 997
      FED(I)=COM(NOW+1)
  420 CONTINUE
      ICUR=ICUR+8
      GO TO 490
C
  490 CONTINUE
      IF(ICUR.NE.NLAST) GO TO 995
      NFEED=IOK
      GO TO 999
C
  500 CONTINUE
      NSTEPO=NOGOOD
C---STEPOVER PROCESSING
      ICUR=ICUR+2
      DO 510 I=1,4
      NOW=ICUR+2*I-2
      IF(COM(NOW).NE.ASCALA) GO TO 998
      IF(CKDEF(COM(NOW+1))) GO TO 997
      SSTEP(I)=COM(NOW+1)
  510 CONTINUE
      ICUR=ICUR+8
      GO TO 590
C
  590 CONTINUE
      IF(ICUR.NE.NLAST) GO TO 995
      NSTEPO=IOK
      GO TO 999
C
  600 CONTINUE
C---AXIS PROCESSING FOLLOWS
      NAXIS=NOGOOD
      ICUR=ICUR+2
      IF(COM(ICUR).EQ.ANORMD) GO TO 650
      IF(COM(ICUR).EQ.AVECTO) GO TO 610
      IF(COM(ICUR).EQ.AATANG) GO TO 680
      GO TO 998
  610 CONTINUE
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      CALL DOTF(VSQ,COM(ICUR+1),COM(ICUR+1))
      IF(VSQ.LT.SMAL) GO TO 996
      VSQ=DSQRT(VSQ)
      DO 620 I=1,3
  620 AXIS(I)=COM(ICUR+I)/VSQ
      IAXIS=0
      ITAC=0
      ICUR=ICUR+4
      IF(COM(ICUR).NE.APLUS.AND.COM(ICUR).NE.AMINUS) GO TO 690
      ICUR=ICUR+2
      IF(COM(ICUR-2).NE.AMINUS) GO TO 690
C---REVERSE THE VECTOR DIRECTION.
      DO 670 I=1,3
  670 AXIS(I)=-AXIS(I)
      GO TO 690
C
  650 CONTINUE
      ICUR=ICUR+2
      IAXIS=1
      ITAC=0
      DO 660 I=1,3
  660 AXIS(I)=ZERO
      IF(COM(ICUR).NE.APLUS.AND.COM(ICUR).NE.AMINUS) GO TO 690
      IF(COM(ICUR).EQ.AMINUS) IAXIS=-1
      ICUR=ICUR+2
      GO TO 690
C                 PS
C.... AXIS,ATANGL,DS,ALPHA,CUTANG,BETA
  680 ICUR=ICUR+2
      CALL HOLFRM(COM(ICUR+1),CTEST,1,6,NWD)
      IF (CTEST.EQ.WDS) THEN
        IAXIS=2
        ITAC=1
        DO 682 I=1,3
         AXIS(I)=ZERO
  682   CONTINUE
      ELSE IF (CTEST.EQ.WPS) THEN
        IAXIS=0
        ITAC=2
        AXIS(1)=ZERO
        AXIS(2)=ZERO
        AXIS(3)=ONE
      ELSE
        GOTO 998
      ENDIF
           
      ICUR=ICUR+2
      IF (COM(ICUR).EQ.ASCALA) THEN
        IF (CKDEF(COM(ICUR+1))) THEN
          GOTO 997
        ELSE
          ALPHA=COM(ICUR+1)*DEGRAD
          COSA=COS(ALPHA)
          SINA=SIN(ALPHA)
          IF (COSA.LT.0) THEN
            IAXIS=-IAXIS
          ENDIF
        ENDIF
      ELSE
        GOTO 998
      ENDIF
      ICUR=ICUR+2
      IF (COM(ICUR).EQ.ACUTAN) THEN
        ICUR=ICUR+2
        IF (COM(ICUR).EQ.ALEAD) THEN
         IFLG=1
         ICUR=ICUR+2
        ELSE IF (COM(ICUR).EQ.ALAG) THEN
         IFLG=-1
         ICUR=ICUR+2
        ELSE
         IFLG=1
        ENDIF
        IF (COM(ICUR).EQ.ASCALA) THEN
          IF (CKDEF(COM(ICUR+1))) THEN
            GOTO 997
          ELSE
            BETA=COM(ICUR+1)*DEGRAD*FLOAT(IFLG)
            COSB=COS(BETA)
            SINB=SIN(BETA)
            ICUR=ICUR+2
          ENDIF
        ELSE
          GOTO 998
        ENDIF
      ELSE
        GOTO 998
      ENDIF
C
  690 CONTINUE
      IF(ICUR.NE.NLAST) GO TO 995
      NAXIS=IOK
      GO TO 999
C
  995 CONTINUE
C---ERROR, INPUT DATA FIELD OF INCORRECT LENGTH
      IRR=4
      GO TO 990
C
  996 CONTINUE
C---ERROR, INPUT PARAMETER VALUES ARE NOT LEGAL
      IRR=3
      GO TO 990
  997 CONTINUE
C---ERROR, INPUT CANON FORM IS UNDEFINED
      IRR=2
      GO TO 990
  998 CONTINUE
C---ERROR, ILLEGAL ARGUMENT IN INPUT STREAM
      IRR=1
      GO TO 990
C
  990 CONTINUE
      IRR=IRBASE+IRR
      CALL ERROR(IRR,'SCON    ')
      CALL RECORD(ISQ)
      CALL BAD(1,0,'ISEQ',ISQ)
      CALL BAD(1,0,'NLST',NLAST)
      CALL BAD(1,0,'NLEN',NLEN)
      CALL BAD(1,0,'IRR ',IRR)
      CALL BAD(1,0,'ICUR',ICUR)
      CALL BAD(-1,0,'IRBS',IRBASE)
C
      GO TO 999
C
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001913.W04   ***
*
      SUBROUTINE SMIL
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---   PURPOSE OF THE ROUTINE IS TO DECODE SMIL/ COMMANDS
C---   AND CALL THE PATH ROUTINE, SSPATH, TO GENERATE CLDATA
C---   ERRORS FROM SSPATH OR UNINITIALIZED DATA AREAS ARE
C---   DETECTED HERE AND CALLS ARE MADE TO AERR.
C
      INCLUDE (BLANKCOM)    
C
      COMMON/MAXLDA/MAXLDA
C
      LOGICAL CKDEF
C
      CHARACTER*6 WALL,WAT,WAXIS,WCLDAT,WCROSS,WCRSSP,WCS,WDS,WFEED,
     1 WIN,WINCR,WINIT,WMINUS,WNORMA,WNORMD,WNORMP,WOFF,WON,WOUT,
     2 WPARAM,WPATH,WPICKF,WPLANE,WPLUS,WPOINT,WPOSN,WPS,WSCALA,
     3 WSCURV,WSSURF,WSTEPO,WTANSP,WTO,WVECTO,WZIGZA,WDISPL
      CHARACTER*8 RNAM1,RNAM2,RNAM3,RNAMA,RNAME
      CHARACTER*6 CTEST,HPOCKT*8
      CHARACTER*20 BADMSG
      INTEGER IPOCKT(2),BCDF
C
      INTEGER IZAL1(7),IZAL2(4)
C
      COMMON/IBUGG/IBUG,I1,I2
      COMMON/XDS/DGEOM(4),DLIM(4),TLDIR(3),DOFSET,ITLDIR,IDTOOL,NDS
      COMMON/XPS/PGEOM(4),PSIDE,PTHICK,IPTOOL,NPS
      COMMON/XFEED/CLRPLN(4),FED(4),NCLRPL,NFEED
      COMMON/XSTEPO/SSTEP(4),NSTEPO
      COMMON/XAXIS/AXIS(3),IAXIS,NAXIS
                                      
      INCLUDE (RMFLGS)    
                          
      DIMENSION TUL(7),VEC(3),VINC(4),TE(3),TA(3),TD(3)
      DIMENSION PTEM(2)
C
C
      DATA     RNAM1   /'SMIL    '/,RNAM2   /'SSPATH  '/,
     *           RNAM3   /'CUTREC  '/,RNAMA   /'SMIL  ??'/,
     *           RNAME   /'        '/
      DATA   IMAX1/ 7/, IZAL1
     *         /3561,3562,3563,3564,3565,3566,3567/
      DATA   IMAX2/ 4/, IZAL2
     *         /3551,3552,3553,3554/
C--WORD MODE VALUES IN REAL FORM AND HOLLERITH FORM.
C--THESE ARE WORDS USED IN SMIL AND SCON COMMANDS
C
      DATA AALL/50.D0/,WALL/'ALL   '/
      DATA AAT/66.D0/,WAT/'AT    '/
      DATA AAXIS/146.D0/,WAXIS/'AXIS  '/
      DATA ACLDAT/69.D0/,WCLDAT/'CLDATA'/
      DATA ACROSS/40.D0/,WCROSS/'CROSS '/
      DATA ACRSSP/137.D0/,WCRSSP/'CRSSPL'/
      DATA ACS/1.D0/,WCS/'CS    '/
      DATA ADS/1.D0/,WDS/'DS    '/
      DATA AFEED/163.D0/,WFEED/'FEED  '/
      DATA AIN/20.D0/,WIN/'IN    '/
      DATA AINCR/57.D0/,WINCR/'INCR  '/
      DATA AINIT/161.D0/,WINIT/'INIT  '/
      DATA AMINUS/41.D0/,WMINUS/'MINUS '/
      DATA ANORMA/13.D0/,WNORMA/'NORMAL'/
      DATA ANORMD/151.D0/,WNORMD/'NORMDS'/
      DATA ANORMP/152.D0/,WNORMP/'NORMPS'/
      DATA AOFF/50.D0/,WOFF/'OFF   '/
      DATA AON/3.D0/,WON/'ON    '/
      DATA AOUT/21.D0/,WOUT/'OUT   '/
      DATA APARAM/144.D0/,WPARAM/'PARAM '/
      DATA APATH/165.D0/,WPATH/'PATH  '/
      DATA APICKF/166.D0/,WPICKF/'PICKFD'/
      DATA APLANE/2.D0/,WPLANE/'PLANE '/
      DATA APLUS/42.D0/,WPLUS/'PLUS  '/
      DATA APOINT/19.D0/,WPOINT/'POINT '/
      DATA APOSN/164.D0/,WPOSN/'POSN  '/
      DATA APS/1.D0/,WPS/'PS    '/
      DATA ASCALA/21.D0/,WSCALA/'SCALAR'/
      DATA ASCURV/30.D0/,WSCURV/'SCURV '/
      DATA ASSURF/29.D0/,WSSURF/'SSURF '/
      DATA ASTEPO/162.D0/,WSTEPO/'STEPOV'/
      DATA ATANSP/136.D0/,WTANSP/'TANSPL'/
      DATA ATO/3.D0/,WTO/'TO    '/
      DATA AVECTO/20.D0/,WVECTO/'VECTOR'/
      DATA AZIGZA/61.D0/,WZIGZA/'ZIGZAG'/
      DATA ADISPL/0.0D0/,WDISPL/'DISPLY'/
C
      DATA ZERO,ONE/0.D0,1.D0/
      DATA SMAL/1.0D-14/
      DATA IBEGIN/42/,NOGOOD/-121/
      DATA NLAST/0/,NBIG/50/,IOK/121/
      DATA IRBASE/3550/
      DATA HPOCKT/'POCKET'/
C
      IPOCKT(1)=BCDF(HPOCKT(1:4))
      IPOCKT(2)=BCDF(HPOCKT(5:8))
      CALL APT299(0,IPOCKT,0,0)
      DO 10 I=1,3
      TE(I)=ZERO
   10 TA(I)=ZERO
      ICUR=IBEGIN
      NLEN=COM(ICUR)
      NLAST=IBEGIN+NLEN-2
      COM(NLAST)=ZERO
      ICUR=ICUR+1
      IF(NLEN.LT.3.OR.NLEN.GT.NBIG) GO TO 995
C
      WORD=COM(ICUR)
      CALL HOLFRM(COM(ICUR+1),CTEST,1,6,NWD)
      IF(CTEST.EQ.WDISPL) WORD=COM(ICUR+1)
      ICUR=ICUR+2
      IF(WORD.EQ.APOSN) GO TO 100
      IF(WORD.EQ.APATH) GO TO 200
      IF(WORD.EQ.AZIGZA) GO TO 300
      IF(WORD.EQ.APICKF) GO TO 300
      CALL HOLFRM(WORD,CTEST,1,6,NWD)
      IF(CTEST.EQ.WDISPL) GO TO 300
      GO TO 998
C
C--PROCESS THE SMIL/POSN COMMAND
  100 CONTINUE
      CALL CLPUT(TE,TA,-1)
      CALL HOLFRM(COM(ICUR+1),CTEST,1,6,NWD)
      IF(CTEST.NE.WDS) GO TO 998
      IF(COM(ICUR).NE.APARAM) GO TO 998
      ICUR=ICUR+2
      IF(COM(ICUR).NE.ASCALA) GO TO 998
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      UST=COM(ICUR+1)
      ICUR=ICUR+2
      IF(COM(ICUR).NE.ASCALA) GO TO 998
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      VST=COM(ICUR+1)
      ICUR=ICUR+2
      IF(COM(ICUR).NE.AINCR) GO TO 998
      ICUR=ICUR+2
      IF(COM(ICUR).EQ.ASCALA) GO TO 110
      IF(COM(ICUR).EQ.AVECTO) GO TO 130
      IF(COM(ICUR).EQ.APLANE) GO TO 150
      GO TO 998
C--SCALAR LIFT BACK PARAMETER
  110 CONTINUE
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      VINC(1)=COM(ICUR+1)
      ICUR=ICUR+2
      INCTYP=21
      GO TO 190
  130 CONTINUE
C--VECTOR LIFTBACK PARAMETER
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      DO 140 I=1,3
  140 VINC(I)=COM(ICUR+I)
      ICUR=ICUR+4
      INCTYP=20
      GO TO 190
  150 CONTINUE
C--CLEARANCE PLANE LIFTBACK
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      DO 160 I=1,4
  160 VINC(I)=COM(ICUR+I)
      INCTYP=2
      ICUR=ICUR+5
      GO TO 190
C
  190 CONTINUE
      IF(ICUR.NE.NLAST) GO TO 996
C--CHECK IF PROPER BLOCKS ARE INITIALIZED
      IF(NDS.EQ.NOGOOD) GO TO 994
      IF(NPS.EQ.NOGOOD) GO TO 994
      IF(NAXIS.EQ.NOGOOD) GO TO 994
C
C--GET OTHER NEEDED APT VARIABLES
      CALL GETAPT(TUL,PTOLI,PTOLO,DTOL,AMAXDP,ELMAX,MAXCL,IR)
      IF(IR.NE.0) GO TO 993
C--FETCH PART AND DRIVE SURFACES
      CALL GFETCH(NBIG,MAXLDA,COM,DGEOM,PGEOM,IR)
      IF(IR.NE.0) GO TO 992
C--SET APPROPRIATE STARTING VALUES FOR CALL TO SSPATH
C--ICLSKP NEGATIVE GUARANTEES NO CL OUTPUT UNTIL TE IS
C--COMPENSATED
      IF(UST.LT.DLIM(1)-SMAL.OR.UST.GT.DLIM(2)+SMAL) GO TO 996
      IF(VST.LT.DLIM(3)-SMAL.OR.VST.GT.DLIM(4)+SMAL) GO TO 996
      PDIR=ONE
      IDTYPE=1
      IF(DGEOM(3).EQ.ASCURV) IDTYPE=0
      SCALHT=ZERO
      STEPOV=ZERO
      MAXCL=1
      ICLSKP=-1
      IQUAL=0
      DO 170 I=1,3
      TE(I)=ZERO
      TA(I)=ZERO
      TD(I)=ZERO
  170 CONTINUE
C
      DSTEP=ONE
      IPART=PGEOM(4)
      IDRIV=DGEOM(4)
      STEPMX=ZERO
C
C.... PERFORM PRELIMINARY INTERFERENCE CHECKING CALCULATIONS IF REQD
      IF (LINTCK) CALL INEX(COM(IPART),PSIDE,PTOLI,PTOLO)
C
      CALL SSPATH(COM(IDRIV), IDTYPE, PDIR, DTOL, DSTEP, DOFSET,
     X           DLIM, IDTOOL, IAXIS, AXIS, ITLDIR,
     X       TLDIR, COM(IPART), PSIDE, PTHICK, PTOLI, PTOLO, IPTOOL,
     X           TUL, UST, VST, SCALHT, STEPOV, STEPMX,
     X           AMAXDP,ELMAX, MAXCL, ICLSKP, IQUAL,
     X           TE,  TA,  TD,  PTEM,  IRR)
      IF(IRR.NE.0) GO TO 990
C--POSN SUCESSFUL, NOW COMPENSATE TOOL END
      IF(INCTYP.EQ.20) GO TO 172
      IF(INCTYP.EQ.2) GO TO 174
      BACKUP=VINC(1)
      DO 181 I=1,3
  181 TE(I)=TE(I)-BACKUP*TD(I)
      GO TO 185
C
  174 CONTINUE
C---CLEARANCE PLANE CALCULATION
      CALL CLIFT(TE,VINC,TE)
      GO TO 185
C
  172 CONTINUE
C--VECTOR INCREMENT
      DO 183 I=1,3
  183 TE(I)=TE(I)+VINC(I)
      GO TO 185
C
  185 CONTINUE
      CALL CLPUT(TE,TA,1)
      GO TO 999
C
C--PROCESS PATH COMMAND
  200 CONTINUE
      CALL CLPUT(TE,TA,-1)
      CALL HOLFRM(COM(ICUR+1),CTEST,1,6,NWD)
      IF(CTEST.NE.WDS) GO TO 998
      ICUR=ICUR+2
      IF(COM(ICUR).NE.APARAM) GO TO 998
      ICUR=ICUR+2
      IF(COM(ICUR).NE.ASCALA) GO TO 998
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      UST=COM(ICUR+1)
      ICUR=ICUR+2
      IF(COM(ICUR).NE.ASCALA) GO TO 998
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      VST=COM(ICUR+1)
      ICUR=ICUR+2
      IF(COM(ICUR).NE.ATANSP.AND.COM(ICUR).NE.ACRSSP) GO TO 998
      IDTYPE=1
      IF(COM(ICUR).EQ.ACRSSP) IDTYPE=2
      IF(DGEOM(3).EQ.ASCURV) IDTYPE=0
      ICUR=ICUR+2
      IF(COM(ICUR).NE.APLUS.AND.COM(ICUR).NE.AMINUS) GO TO 998
      PDIR=ONE
      IF(COM(ICUR).EQ.AMINUS) PDIR=-ONE
      ICUR=ICUR+2
C---OPTIONAL PARAMETER TO INDICATE WHETHER TO SKIP FIRST RECORD
      ISKP=0
      IF(COM(ICUR).NE.ASCALA) GO TO 210
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      IF(COM(ICUR+1).GT.SMAL) ISKP=1
      ICUR=ICUR+2
      GO TO 210
C
  210 CONTINUE
      IF(ICUR.NE.NLAST) GO TO 995
      IF(NDS.EQ.NOGOOD) GO TO 994
      IF(NPS.EQ.NOGOOD) GO TO 994
      IF(NAXIS.EQ.NOGOOD) GO TO 994
C
C--GET OTHER NEEDED APT VARIABLES
      CALL GETAPT(TUL,PTOLI,PTOLO,DTOL,AMAXDP,ELMAX,MAXCL,IR)
      IF(IR.NE.0) GO TO 993
C--FETCH PART AND DRIVE SURFACES
      CALL GFETCH(NBIG,MAXLDA,COM,DGEOM,PGEOM,IR)
      IF(IR.NE.0) GO TO 992
C--SET APPROPRIATE STARTING VALUES FOR CALL TO SSPATH
C--ICLSKP NEGATIVE GUARANTEES NO CL OUTPUT UNTIL TE IS
C--COMPENSATED
      IF(UST.LT.DLIM(1)-SMAL.OR.UST.GT.DLIM(2)+SMAL) GO TO 996
      IF(VST.LT.DLIM(3)-SMAL.OR.VST.GT.DLIM(4)+SMAL) GO TO 996
      SCALHT=ZERO
      STEPOV=ZERO
      ICLSKP=ISKP
      IQUAL=0
      DO 220 I=1,3
      TE(I)=ZERO
      TA(I)=ZERO
      TD(I)=ZERO
  220 CONTINUE
C
      IPART=PGEOM(4)
      DSTEP=ONE
      IDRIV=DGEOM(4)
      STEPMX=ZERO
C
C.... PERFORM PRELIMINARY INTERFERENCE CHECKING CALCULATIONS IF REQD
      IF (LINTCK) CALL INEX(COM(IPART),PSIDE,PTOLI,PTOLO)
C
      CALL SSPATH(COM(IDRIV), IDTYPE, PDIR, DTOL, DSTEP, DOFSET,
     X           DLIM, IDTOOL, IAXIS, AXIS, ITLDIR,
     X       TLDIR, COM(IPART), PSIDE, PTHICK, PTOLI, PTOLO, IPTOOL,
     X           TUL, UST, VST, SCALHT, STEPOV, STEPMX,
     X           AMAXDP,ELMAX, MAXCL, ICLSKP, IQUAL,
     X           TE,  TA,  TD,  PTEM,  IRR)
      IF(IRR.NE.0) GO TO 990
      GO TO 999
C
C--PROCESS INPUT FOR ZIGZAG AND PICKFD
  300 CONTINUE
      CALL HOLFRM(COM(ICUR+1),CTEST,1,6,NWD)
      IF(CTEST.NE.WDS) GO TO 998
      ICUR=ICUR+2
      IF(COM(ICUR).NE.APARAM) GO TO 998
      ICUR=ICUR+2
      IF(COM(ICUR).NE.ASCALA) GO TO 998
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      UST=COM(ICUR+1)
      ICUR=ICUR+2
      IF(COM(ICUR).NE.ASCALA) GO TO 998
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      VST=COM(ICUR+1)
      ICUR=ICUR+2
      IF(COM(ICUR).NE.ATANSP.AND.COM(ICUR).NE.ACRSSP) GO TO 998
      IDTYPE=1
      IF(COM(ICUR).EQ.ACRSSP) IDTYPE=2
      IF(DGEOM(3).EQ.ASCURV) IDTYPE=0
      ICUR=ICUR+2
      IF(COM(ICUR).NE.APLUS.AND.COM(ICUR).NE.AMINUS) GO TO 998
      PDIR=ONE
      IF(COM(ICUR).EQ.AMINUS) PDIR=-ONE
      ICUR=ICUR+2
      IF(COM(ICUR).NE.ASTEPO) GO TO 998
      ICUR=ICUR+2
      IF(COM(ICUR).NE.APLUS.AND.COM(ICUR).NE.AMINUS) GO TO 998
      CDIR=ONE
      IF(COM(ICUR).EQ.AMINUS) CDIR=-ONE
      ICUR=ICUR+2
C---OPTIONAL PARAMETER TO INDICATE WHETHER TO SKIP FIRST RECORD
      ISKP=0
      IF(COM(ICUR).NE.ASCALA) GO TO 310
      IF(CKDEF(COM(ICUR+1))) GO TO 997
      IF(COM(ICUR+1).GT.SMAL) ISKP=1
      ICUR=ICUR+2
      GO TO 310
C
  310 CONTINUE
      IF(ICUR.NE.NLAST) GO TO 995
      IF(NDS.EQ.NOGOOD) GO TO 994
      IF(NPS.EQ.NOGOOD) GO TO 994
      IF(NAXIS.EQ.NOGOOD) GO TO 994
      IF(NFEED.EQ.NOGOOD) GO TO 994
      IF(NSTEPO.EQ.NOGOOD) GO TO 994
      IF(WORD.EQ.APICKF.AND.NCLRPL.EQ.NOGOOD) GO TO 994
C
C--GET OTHER NEEDED APT VARIABLES
      CALL GETAPT(TUL,PTOLI,PTOLO,DTOL,AMAXDP,ELMAX,MAXCL,IR)
      IF(IR.NE.0) GO TO 993
C--FETCH PART AND DRIVE SURFACES
      CALL GFETCH(NBIG,MAXLDA,COM,DGEOM,PGEOM,IR)
      IF(IR.NE.0) GO TO 992
C--SET APPROPRIATE STARTING VALUES FOR CALL TO SSPATH
      IF(UST.LT.DLIM(1)-SMAL.OR.UST.GT.DLIM(2)+SMAL) GO TO 996
      IF(VST.LT.DLIM(3)-SMAL.OR.VST.GT.DLIM(4)+SMAL) GO TO 996
C--CUTREG ROUTINE SEPARATED TO REDUCE SUBROUTINE SIZE
      IQUAL=0
C
C.... PERFORM PRELIMINARY INTERFERENCE CHECKING CALCULATIONS IF REQD
      IPART=PGEOM(4)
      IF (LINTCK) CALL INEX(COM(IPART),PSIDE,PTOLI,PTOLO)
C
      CALL CUTREG(WORD,CDIR,UST,VST,PDIR,IDTYPE,IQUAL,
     X   TUL,PTOLI,PTOLO,DTOL,AMAXDP,ELMAX,MAXCL,ISKP,IRR)
      IF(IRR.NE.0) GO TO 990
      GO TO 999
C
  992 CONTINUE
C---ERROR, PART OR DRIVE GEOMETRY COULD NOT BE FETCHED
      IRR=17
      GO TO 990
  993 CONTINUE
C---ERROR, GENERAL APT ARELEM VARIABLES INVALID
      IRR=16
      GO TO 990
  994 CONTINUE
C---ERROR,  SCON DATA AREA IS UNINITIALIZED
      IRR=15
      GO TO 990
  995 CONTINUE
C---ERROR, LENGTH OF SMIL INPUT FIELD INVALID
      IRR=14
      GO TO 990
  996 CONTINUE
C---ERROR, INPUT VALUES ARE INVALID
      IRR=13
      GO TO 990
  997 CONTINUE
C---ERROR, INPUT CANON FORM NOT DEFINED
      IRR=12
      GO TO 990
  998 CONTINUE
C---ERROR, INPUT VARIABLE WAS UNRECOGNIZED IN POSITION
      IRR=11
      GO TO 990
C
  990 CONTINUE
      IRR=IRBASE+IRR
      CALL RECORD(ISQ)
      CALL BAD(-1,0,' ',0)
      BADMSG=' END OF SMIL'
      CALL CPRINT(BADMSG)
      CALL BAD(1,0,'ISEQ',ISQ)
      CALL BAD(1,0,'NLST',NLAST)
      CALL BAD(1,0,'NLEN',NLEN)
      CALL BAD(1,0,'IRR ',IRR)
      CALL BAD(1,0,'ICUR',ICUR)
      CALL BAD(-1,0,'IRBS',IRBASE)
      CALL BAD(1,0,'DS  ',NDS)
      CALL BAD(1,0,'PS  ',NPS)
      CALL BAD(1,0,'FEED',NFEED)
      CALL BAD(1,0,'STOV',NSTEPO)
      CALL BAD(1,0,'AXIS',NAXIS)
      CALL BAD(-1,0,'CPLN',NCLRPL)
C
      RNAME=RNAMA
      DO 8001 IL1 = 1,IMAX1
 8001 IF (IRR.EQ.IZAL1(IL1)) RNAME=RNAM1
      DO 8002 IL2 = 1,IMAX2
 8002 IF (IRR.EQ.IZAL2(IL2)) RNAME=RNAM2
      CALL AERR(IRR,RNAME)
C
      GO TO 999
C
  999 CONTINUE
C
      RETURN
      END
**** SOURCE FILE : M0001094.V01   ***
*
      SUBROUTINE SQRBN(U0,V0,ZU1,ZV1,ZU2,ZV2,DUMMY,ICKBN)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------INPUT IS AN OLD POINT U0,V0 IN UV SPACE AND A TRIAL
C------ NEW POINT U1,V1.  IF THESE TWO PTS ARE IN THE SAME
C------ SECTOR OF SPACE( UNIT SQUARE DIVIDES SPACE INTO NINE
C------ SECTORS) THEN U,V IS SET EQUAL TO U1,V1 AND NO
C------ BOUNDARY CHECKING IS REQUIRED( I.E. SET ICKBN=0).
C------ OTHERWISE U,V IS SET EQUAL TO THE CLOSEST
C------ BOUNDARY POINT TO U0,V0 WHICH LIES BETWEEN U0,V0 AND
C------ U1,V1.  IN ADDITION THE ROUTINE DETERMINES WHICH
C------  BOUNDARY OF THE PATCH SHOULD BE CHECKED.
C
      DIMENSION IBCHK(4,4)
C---      ARRAY WHICH RECORDS BOUNDARY TO CHECK IN MOVING FROM SECTOR
C---      J TO SECTOR I (IBCHK(I,J)).
      DATA IBCHK/ 2,3,0,0,  1,0,4,0,  0,1,0,4,  0,0,2,3/
C
      DATA ZERO,ONE,TWO/0.0D0,1.0D0,2.0D0/
      DATA VSMAL/1.0D-25/
C---      FUNCTION F GIVES SQUARE OF DISTANCE FROM (A,B) TO (C,D)
      F(A,B,C,D)=(C-A)**2+(D-B)**2
C---      FUNCTION G IS POSITIVE WHEN C IS OUTSIDE THE A,B INTERVAL
      G(A,B,C)=(A-C)*(B-C)
C
      U1=U0+ZU1
      V1=V0+ZV1
      ICKBN=0
      U=U1
      V=V1
      IU=2
      IF(U0.LT.ZERO)IU=1
      IF(U0.GT.ONE) IU=3
      IV=3
      IF(V0.LT.ZERO)IV=0
      IF(V0.GT.ONE) IV=6
      IC0=IU+IV
      IU=2
      IF(U1.LT.ZERO)IU=1
      IF(U1.GT.ONE) IU=3
      IV=3
      IF(V1.LT.ZERO)IV=0
      IF(V1.GT.ONE) IV=6
      IC1=IU+IV
      IF(IC0.EQ.IC1) GO TO 999
C
C------DETERMINE THE BOUNDARY INTERCEPT CLOSEST TO U0,V0
C---      EQN OF LINE IS (U0-U1)*V+(V1-V0)*U+(V0*U1-U0*V1)=0
C---      EQN OF LINE IS      A1*V+     A2*U+     A3      =0
      A1=U0-U1
      A2=V1-V0
      A3=V0*U1-V1*U0
C---      SET U,V AND DISTANCE D TO DEFAULT VALUES
      U=U1
      V=V1
      D=F(U0,V0,U1,V1)
C---      SET INITIAL VALUES FOR SECOND POINT BETWEEN P0 AND P1.
      D2=D
      U2=U
      V2=V
C
C---      LINE IS HORIZONTAL, SKIP INTERCEPT CALCULATION WITH U=0 OR U=1
      IF(DABS(A1).LT.VSMAL) GO TO 100
      UT=ZERO
      VT=-A3/A1
      DT=F(U0,V0,UT,VT)
      IF(G(U0,U1,UT).GE.ZERO.OR.DT.GT.D) GO TO 10
      D=DT
      U=UT
      V=VT
   10 CONTINUE
      UT=ONE
      VT=-(A2+A3)/A1
      DT=F(U0,V0,UT,VT)
      IF(G(U0,U1,UT).GE.ZERO.OR.DT.GE.D2) GO TO 100
C---      SAVE THE SECOND CLOSEST INTERCEPT TO UO,VO FIRST
      IF(DT.LT.D) GO TO 20
C---      U2,V2 IS NEW SECOND CLOSEST INTERCEPT ( DT.GT.D)
      IF(DT.EQ.D) GO TO 100
      U2=UT
      V2=VT
      D2=DT
      GO TO 100
   20 CONTINUE
C---      U2,V2 TAKES ON THE OLD U,V VALUE OF CLOSEST INTERCEPT
      U2=U
      V2=V
      D2=D
C---      CLOSEST INTERCEPT U,V IS NOW UT,VT
      U=UT
      V=VT
      D=DT
C---      LINE IS VERTICAL, SKIP INTERCEPT CALC WITH V=0 OR V=1.
  100 IF(DABS(A2).LT.VSMAL) GO TO 200
      VT=ZERO
      UT=-A3/A2
      DT=F(U0,V0,UT,VT)
      IF(G(V0,V1,VT).GE.ZERO.OR.DT.GE.D2) GO TO 110
C---      SAVE THE SECOND CLOSEST INTERCEPT TO UO,VO FIRST
      IF(DT.LT.D) GO TO 40
C---      U2,V2 IS NEW SECOND CLOSEST INTERCEPT ( DT.GT.D)
      IF(DT.EQ.D) GO TO 110
      U2=UT
      V2=VT
      D2=DT
      GO TO 110
   40 CONTINUE
C---      U2,V2 TAKES ON THE OLD U,V VALUE OF CLOSEST INTERCEPT
      U2=U
      V2=V
      D2=D
C---      CLOSEST INTERCEPT U,V IS NOW UT,VT
      U=UT
      V=VT
      D=DT
  110 VT=ONE
      UT=-(A1+A3)/A2
      DT=F(U0,V0,UT,VT)
      IF(G(V0,V1,VT).GE.ZERO.OR.DT.GE.D2) GO TO 200
C---      SAVE THE SECOND CLOSEST INTERCEPT TO UO,VO FIRST
      IF(DT.LT.D) GO TO 60
C---      U2,V2 IS NEW SECOND CLOSEST INTERCEPT ( DT.GT.D)
      IF(DT.EQ.D) GO TO 200
      U2=UT
      V2=VT
      D2=DT
      GO TO 200
   60 CONTINUE
C---      U2,V2 TAKES ON THE OLD U,V VALUE OF CLOSEST INTERCEPT
      U2=U
      V2=V
      D2=D
C---      CLOSEST INTERCEPT U,V IS NOW UT,VT
      U=UT
      V=VT
      D=DT
  200 CONTINUE
C---      DETERMINE UT,VT JUST INSIDE THE SECTOR BEYOND U,V
C---      ICKBN IS SET TO ZERO IF NO ADJACENT PATCH NEED BE CHECKED
C---      OTHERWISE ICKBN SHOULD POINT TO THE PATCH BOUNDARY (1,2,3,OR 4
C---      WHICH SHOULD BE CHECKED.
      ICKBN=0
C---      NEXT DETERMINE THE SECTOR WHICH THE PATH FROM U0,V0 TO U,V
C---      IS ENTERING.
      UT=(U+U2)/TWO
      VT=(V+V2)/TWO
      IF(G(ZERO,ONE,U0).NE.ZERO.AND.G(ZERO,ONE,V0).NE.ZERO) GO TO 210
C---      STARTING POINT IS ON BOUNDARY, SO CUT UT,VT BACK
      UT=(U0+U)/TWO
      VT=(V0+V)/TWO
  210 CONTINUE
C
      IU=2
      IF(UT.LT.ZERO) IU=1
      IF(UT.GT.ONE)  IU=3
      IV=3
      IF(VT.LT.ZERO) IV=0
      IF(VT.GT.ONE)  IV=6
C---      IC2 IS THE SECTOR NUMBER ( 1 THRU 9) WHICH IS BEING ENTERED.
      IC2=IU+IV
C---      IF THE CENTER SQUARE IS BEING ENTERED, THEN CHECK NO BOUNDARY
      IF(IC2.EQ.5) GO TO 999
      IF(MOD(IC2,2).EQ.0) GO TO 310
      IF(MOD(IC2,2).EQ.1) GO TO 320
C
  310 CONTINUE
C---      AN EVEN-NUMBERED SECTOR IS BEING ENTERED -- BOUNDARY CALCULATI
C---      IS STRAIGHT FORWARD.
      ICKBN=IC2/2
      GO TO 999
C
  320 CONTINUE
C---      AN ODD SECTOR IS BEING ENTERED, BOUNDARY DEPENDS ON BOTH POINT
C---      (I.E. ON SECTOR OF UT,VT AND ON SECTOR OF U0,V0)
      I1=IC2/3+1
      IF(MOD(IC0,2).NE.0) GO TO 999
      I2=IC0/2
      ICKBN=IBCHK(I1,I2)
      GO TO 999
C
  999 CONTINUE
C
      ZU2=U-U0
      ZV2=V-V0
      RETURN
      END
**** SOURCE FILE : M0001097.W01   ***
*
      SUBROUTINE SRFDIR(DR,R,SIDE,PDIR,SX,SVEC,SK,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
C---PURPOSE IS TO COMPUTE SURFACE CURVATURE SK AND DIRECTION SVEC
C--IN DIRECTION OF MOVEMENT INDICATED BY DRIVE GEOMETRY ARRAY
C--DR.
      DIMENSION DR(*),R(*),SX(*),SVEC(*)
      CHARACTER*20 BADMSG
      DATA ZERO,SMAL/0.0D0,1.0D-38/
C
      DO 10 I=1,3
   10 SVEC(I)=ZERO
      SK=ZERO
C
      CALL KURSRF(R,SIDE,SX)
C--PROJECT DRIVE TANGENT VECTOR INTO SURFACE TANGENT PLANE
      CALL DOTF(FAC,R(29),DR(13))
      DO 20 I=1,3
   20 SVEC(I)=DR(12+I)-FAC*R(28+I)
      CALL DOTF(FAC,SVEC,SVEC)
      IF(FAC.LT.SMAL) GO TO 999
      FAC=DSQRT(FAC)*PDIR
      DO 30 I=1,3
   30 SVEC(I)=FAC*SVEC(I)
C--NOW COMPUTE THE CURVATURE OF THE SURFACE IN THE SVEC DIRECTION
      CALL DOTF(XCOS,SVEC,SX(5))
      CALL DOTF(XSIN,SVEC,SX(9))
      SK=SX(1)*XCOS**2+SX(2)*XSIN**2
C
  999 CONTINUE
      IF(IBUG.NE.11) GO TO 1999
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER SRFDIR'
      CALL CPRINT(BADMSG)
      CALL BAD(1,0,'IRR ',IRR)
      CALL BAD(1,1,'SK  ',SK)
      CALL BAD(-2,1,'SX  ',SX(1))
      CALL BAD(-3,1,'SVEC',SVEC)
 1999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001098.W02   ***
*
      SUBROUTINE SRFTOL(SKRV,TRAD,TOL,SSTEP,TSTEP)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
C--PURPOSE IS TO COMPUTE SURFACE STEP DISTANCE SSTEP AND
C--TOOL STEP DISTANCE TSTEP ALONG SURFACE BASED ON CURVATURE
C--SKRV AND TOOL RADIUS TRAD AND TOLERANCE BAND TOL
C
      CHARACTER*20 BADMSG
      DATA ZERO,ONE,SMAL,BIG/0.0D0,1.0D0,1.0D-9,1.0D+9/
C
      SSTEP=BIG
      TSTEP=SSTEP
      IF(DABS(SKRV).LT.SMAL) GO TO 999
      SRAD=1/SKRV
      W=DABS(SRAD-TRAD)
      IF(W.LT.SMAL) GO TO 999
C--COSINE OF HALF ANGLE OF MOVEMENT
      CHAF=ONE-TOL/W
      SHAF=ONE-CHAF**2
      SHAF=DMAX1(SMAL,SHAF)
      SHAF=DSQRT(SHAF)
      SSTEP=2.*DABS(SRAD)*SHAF
      TSTEP=2.*W*SHAF
C
  999 CONTINUE
      IF(IBUG.NE.11) GO TO 1999
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER SRFTOL'
      CALL CPRINT(BADMSG)
      CALL BAD(1,1,'SKRV',SKRV)
      CALL BAD(1,1,'TRAD',TRAD)
      CALL BAD(1,1,'TOL ',TOL)
      CALL BAD(1,1,'SSTP',SSTEP)
      CALL BAD(-1,1,'TSTP',TSTEP)
 1999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001081.W07   ***
*
      SUBROUTINE SSPATH( DSURF, IDTYPE,   PDIR,   DTOL,  DSTEP, DOFSET,
     X                  PLIM, IDTOOL, IDAXIS,  DAXIS, ITLDIR,
     X             TLDIR, PSURF, PSIDE, PTHICK,  PTOLI,  PTOLO, IPTOOL,
     X                   TUL,    UST,    VST, SCALHT, STEPOV, STEPMX,
     X                AMAXDP,  ELMAX,  MAXCL, ICLSKP, IQUAL,
     X                    TE,     TA,     TD,   PAR,    IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
C--PURPOSE IS TO MOVE CUTTER IN CONTACT WITH DRIVE CURVE
C--DSURF WHILE SIMULTANEOUSLY MOVING IN CONTACT WITH PART
C--SURFACE PSURF.  THE WEALTH OF INPUT PARAMETERS ARE FOR
C--CONTROLLING THE RANGE , STEPOUT AND AXIS OF THE CUTTER
C--INPUT PARAMETERS ARE DESCRIBED BELOW
C--DSURF CANONICAL FORM DEFINING THE DRIVE GEOMETRY(CURVE OR SURF)
C--IDTYPE TYPE OF DSURF  =0 SCURV, =1 MESH SURF U LINE CONTROL
C--       =2 MESH SURFACE CRSSPL CONTROL
C--PDIR   =1 OR -1 SETS THE DIRECTION OF PATH MOTION AS INCREASING
C--       PARAMETER DIRECTION OR OPPOSITE
C--DTOL   TOLERANCE TO BE MAINTAINED OF DRIVE CURVE
C--DSTEP  IF=0. IT IS IGNORED
C--       IF POSITIVE DPARAM STEP IS THE MAXIMUM PARAM STEP LENGTH ON CU
C--       IF NEGATIVE, DSTEP IS A FIXED PARAMETER INCREMENT ALONG
C--       DRIVE CURVE.  ITT OVERIDES ALL TOL AND STEP SPECS.
C--DOFSET IS A FIXED DISTANCE TO DROP THE CUTTER TIP PAST THE
C--       DRIVE POINT ALONG THE TOOL AXIS PRIOR TO A PROJECTION
C--       THE PART SURFACE.  IT IS APPICABLE IN MULTI AXIS WORK.
C--PLIM  1 AND 2 ARE THE LOWER AND UPPER LIMITS OF THE U PARAMETER
C--      OF THE DRIVE GEOMETRY.  3 AND 4 ARE THE LIMITS OF THE
C--      V PARAMETER(CRSSPL) OF THE DRIVE GEOMETRY( IF IT IS A
C--      MESH STRUCTURED SCULPTURED SURFACE)
C--IDTOOL IS 0 FOR ON TOOL CONTROL(CUTTER AXIS THRU CURVE)
C--       IS 1 FOR AT TOOL CONTROL(CUTTER OFFSET FROM POINT
C--       WHERE TOOL AXIS PIERCES SURFACE.
C--IDAXIS IS 0 FOR FIXED TOOL AXIS, TOOL AXIS IN DAXIS ARRAY
C--       IS 1 FOR VARIABLE AXIS.  AXIS COMES FROM SURFACE NORMAL
C--       OR FROM SCURV CRSSPL. SIGN OF IDAXIS ORIENTS THIS VECTOR
C--       PROPERLY.
C--DAXIS CONTAINS FIXED PERMANENT AXIS FOR TOOL IF FIXED
C--ITLDIR 0 IF TOOL IS PROJECTED IN FIXED DIRECTION TO PART SURF
C--       1 OR -1 IF TOOL IS PROJECTEDACCORDING TO VARIABLE
C--       VECTOR FROM DRIVE GEOMETRY.
C--TLDIR  IS THE VECTOR WHICH HOLDS THE FIXED TOOL DIRECTION
C--       WHEN ITLDIR IS 0.
C--PSURF  CANON FORM OF PART SURFACE.
C--       THIS IS A SLOPE CONTINUOUS SCULPTURED SURFACE
C--PSIDE  1 OR -1 TO ADJUST SURFACE NORMAL( RU X RV ) TO POINT
C--       TOWARD TOOL OPERATING SIDE OF SURFACE.
C--PTHICK THICKNESS OFFSET FROM SURFACE
C--PTOLI,PTOLO INSIDE/OUTSIDE TOLERANCE(TOOL SIDE IS INSIDE)
C--IPTOOL =0 TOOL IS TO PART SURFACE
C--       =1 TOOL TIP IS ON SURFACE
C--TUL  TOOL DESCRIPTION.  PRESENTLY TUL(1)=RADIUS OF BALL CUTTER.
C--SCALHT IF NOT ZERO, IS THE MAXIMUM ALLOWABLE SCALLOP HEIGHT
C--STEPOV IS THE MAXIMUM PARAMETRIC STEPOVER(OUTPUT) TO ACHIEVE
C--THE SCALLOP HEIGHT SPECIFIED.
C--STEPMX IS THE MAXIMUM STEPOVER DISTANCE ALLOWED.  IF NEGATIVE
C--     IT IS THE ACTUAL PARAMETRIC STEPOVER VALUE
C--AMAXDP IS THE MAXIMUM TOOL STEPOUT ALLOWED
C--ELMAX IS THE MAXIMUM PATH LENGTH WHICH CAN BE GENERATED BY
C--      A SINGLE CALL TO THE SSPATH ROUTINE
C--MAXCL IS THE MAXIMUM NUMBER OF CL POINTS TO BE GENERATED IN PATH
C--ICLSKP NEGATIVE MEANS GENERATE NO CL DATA THRU CLPUT
C--       ZERO MEANS GENERATE ALL CLDATA
C--       POSITIVE MEANS GENERATE ALL CLDATA EXCEPT THE FIRST POINT
C--IQUAL IS A QUALITY CONTROL OPTION TO EXACTLY TOUCH THE SURFACE
C--       AS OPPOSED TO PLACING WITHIN TOLERANCE SHELL OF LEAST
C--       CURVATURE
C--OUTPUT
C--TE,TA,TD LAST GOOD TOOL END,AXIS AND DIRECTION OF PROJECTION
C--PAR  LAST PARAMETRIC VALUES ON THE DRIVE GEOMETRY
C--IRR  ERROR FLAG. NON ZERO ON RETURN FROM SSPATH IF ERROR OCCURS
C
      DIMENSION DSURF(*),PSURF(*),TUL(*),DAXIS(*),TLDIR(*)
      DIMENSION PLIM(4)
      DIMENSION DR(36),R(32),RL(32),RX(32),RXL(32)
      DIMENSION RVEC(3),PAR(2),FWD(3)
      DIMENSION RDIF(3),TE(3),TEL(3),TAL(3),TA(3),TEX(3),TAX(3)
      DIMENSION TC(3),TD(3),TBEF(3),TBEFL(3),TBEFX(3)
      CHARACTER*20 BADMSG
C
C---      AKMXMN THE LARGEST POSITIVE AND NEGATIVE CURVATURES
C---      IN THIS CALL TO SSPATH
C---      AKDRV(2,2) THE DRIVE SURFACE PARAMETERS WHERE THEY OCCURRED
C---      AKPRT(2,2) THE PART SURFACE PARAMETERS WHERE THEY OCCURRED
      DIMENSION AKMXMN(2),AKDRV(2,2),AKPRT(3,2)
C
      INCLUDE (DARRAY)    
      INCLUDE (RMFLGS)    
      INCLUDE (TAC)    
C.... LRET - INTERFERENCE FLAG = .TRUE. IF TOOL PENETRATES PS
C.... LARET - AVOIDANCE FLAG = .TRUE. IF INTEFERENCE AVOIDED
      LOGICAL LRET,LARET
C.... INTLOC - LOCATION IN INTERFERENCE TABLE OF WORST PENETRATION
      INTEGER INTLOC
C
      DATA ZERO,ONE,SMAL/0.0D0,1.0D0,1.0D-38/
      DATA BIG/1.0D+10/
      DATA HALF/0.5D0/,ZEM5/0.00001D0/
      DATA ISEQLS,KPATH/0,0/
C
      IF(IBUG.EQ.11) THEN
        CALL BAD(-1,0,' ',0)
        BADMSG=' ENTRY TO SSPATH '
        CALL CPRINT(BADMSG)
      ELSE
        GO TO 1997
      END IF
      ASSIGN 1997 TO IRET
      GO TO 1999
 1997 CONTINUE
C---      COUNT OF PATH CALLS
      CALL RECORD(ISEQNO)
      IF(ISEQNO.NE.ISEQLS) KPATH=0
      KPATH=KPATH+1
      IPASS=1
C---TE,TA,TD ARE THE CURRENT TOOL END ,AXIS, AND DIRECTION
C---IF PATH IS SUCCESSFUL THEY RECORD THE LAST GOOD CL VALUES
C---ON RETURN TO THE CALLING ROUTINE.
C---NOTE THAT TBEF(TOOL-BALL END-EFFECTIVE) IS A SIMULATED BALL
C---CUTTER AT THE CORNER EDGE OF A GENERAL CUTTER.  THIS PROVIDES
C---THE CAPABILITY FOR A GENERAL APT CUTTER ALTHOUGH SSPATH HAS
C---BEEN IMPLEMENTED ONLY AS A BALL CUTTER ALGORITHM.
      DO 5 I=1,3
      TE(I)=ZERO
      TA(I)=ZERO
      TD(I)=ZERO
      TBEF(I)=ZERO
    5 CONTINUE
C--SET INITIAL PARAMETER VALUES
      PAR(1)=UST
      PAR(2)=VST
      MOD=-121
      CALL CHKSET(IDTYPE,PDIR,PLIM,MOD)
C--RADIUS OF BALL CUTTER
      BALRAD=TUL(1)
C--EFFECTIVE RADIUS FOR OFFSET OF TOOL CENTER
      EFRAD=BALRAD+PTHICK
C--EFFECTIVE RADIUS FOR PROJECTING DRIVE POINT TO PART SURFACE
      DRAD=EFRAD
      IF(IPTOOL.EQ.1.OR.IDTOOL.EQ.1) DRAD=PTHICK
C--TOOL AND PART SURFACE CONTACT PARAMETERS
      DIST=ZERO
      UP=HALF
      VP=HALF
      NPAT=1
      MXSTEP=20
C--STEPOUT RETRY COUNT AND TOTAL CL POINTS
      ISTEPK=0
      ICLCT=0
C--CURRENT PATH LENGTH(NOT TO EXCEED ELMAX)
      PLEN=ZERO
C--STEP OUT REDUCTION FACTORS FOR RETRIES
      STEPM=ONE
      FAC=0.75
C--SUGGESTED PARAMETRIC STEPOVER
      STEPOV=BIG
C--TOLERANCE BAND PREPARATION
      TOLMID=ZERO
      TOLRNG=ZERO
      IF(IQUAL.NE.0) GO TO 10
C--MID TOLERANCE BAND FROM SURFACE AND TOLERANCE RANGE
      TOLMID=(PTOLO-PTOLI)*HALF
      TOLRNG=(PTOLI+PTOLO)*0.45
      PTOL=(PTOLI+PTOLO)*0.9
      GO TO 20
   10 CONTINUE
C--FOR INSPECTION PURPOSES, TOOL MAY REST ON OR TOUCH SURFACE
      TOLMID=ZERO
      TOLRNG=ZERO
      PTOL=1.8*DMIN1(PTOLI,PTOLO)
   20 CONTINUE
C--TOLERANCE FOR SURFACE CALCULATION
C--IFIN IS SET TO NON ZERO WHEN PROCESSING THE LAST POINT
      IFIN=0
      TOL=PTOL*0.2
C--EMAX IS MAXIMUM STEP SIZE BASED ON THE PREVIOUS CUT VECTOR
      EMAX=BIG
C---    INITIAL STEPOUT VALUES
      SSTEP=BIG
      TSTEP=BIG
      XSTEP=BIG
C--SET INDEX FOR MOVING PARAMETRIC VALUES
      INDEX=1
      IF(IDTYPE.EQ.2) INDEX=2
      PARNSV=SMAL
C---      INITIALIZE VALUES FOR WORST CURVATURE ACCOUNTING
      DO 50 I=1,2
      DO 51 J=1,2
      AKDRV(I,J)=ZERO
      AKPRT(I,J)=ZERO
   51 CONTINUE
      AKPRT(3,I)=ZERO
   50 CONTINUE
      AKMXMN(1)=ZEM5
      AKMXMN(2)=-AKMXMN(1)
C---      SET FLAG FOR MODE TO SKIP SURFACE CALCULATION
      ISKBAL=0
      IF(PSURF(1).NE.DSURF(1)) GO TO 60
      IF(DABS(DOFSET).GT.SMAL) GO TO 60
      IF(IDTOOL.NE.1) GO TO 60
      ISKBAL=1
   60 CONTINUE
C
C.... SIZE OF PART SURFACE CANONICAL FORM
      IPSIZE=NINT(PSURF(8))
C
C--SURFACE CONTACT BLOCK.  DROP SURFACE FROM POINT ON DRIVE GEOMETRY
C--TO PART SURFACE
  100 CONTINUE
C--IF IFIN IS SET TO NON ZERO THEN THIS IS THE LAST POINT
      PARNSV=PAR(INDEX)
      CALL CHKSET(IDTYPE,PDIR,PAR,IFIN)
C
C--COMPUTE POINT AND VECTOR DATA FROM DRIVE GEOMETRY
      CALL DGEOM(DSURF,IDTYPE,PAR(1),PAR(2),IDAXIS,DAXIS,
     X           ITLDIR,TLDIR,DTOL,DR,UPX,VPX,NPATX,R)
C
C--COMPUTE THE TOOL CENTER AND DIRECTION AT THIS POINT
      DO 110 I=1,3
      TD(I)=DR(20+I)
      TC(I)=DR(I)+(DRAD-DOFSET)*DR(16+I)+DIST*TD(I)
  110 CONTINUE
      IF(IBUG.NE.11) GO TO 8804
      CALL BAD(3,1,'TC  ',TC)
      CALL BAD(-3,1,'TD  ',TD)
 8804 CONTINUE
      IF(ISKBAL.EQ.0) GO TO 120
C---      ISKBAL=1 MEANS SKIP BALSRF CALC - USE DRIVE SURFACE
      UP=UPX
      VP=VPX
      NPAT=NPATX
      DIST=ZERO
      IR=0
      GO TO 125
  120 CONTINUE
C
C--FROM THIS POSITION, DROP THE TOOL TO THE SURFACE
      CALL BALSRF(PSURF, PSIDE, TC, DRAD, TD, NPAT, UP, VP,
     X            DIST, R, TOL, IPASS, IR)
C
  125 CONTINUE
      IF(IBUG.NE.11) GO TO 8805
      CALL BAD(1,0,'BLSR',IR)
      CALL BAD(1,0,'NPAT',NPAT)
      CALL BAD(1,1,'UP  ',UP)
      CALL BAD(1,1,'VP  ',VP)
      CALL BAD(-1,1,'DIST',DIST)
      CALL BAD(3,1,'R   ',R)
      CALL BAD(-3,1,'RN  ',R(29))
 8805 CONTINUE
C****    ERROR
      IRR=1
      IF(IPASS.EQ.1.AND.IR.NE.0) GO TO 999
C--AFTER THE FIRST CUT VECTOR, MOVE TO REDUCED STEPOUT LOGIC
      IF(IPASS.EQ.0.AND.IR.NE.0) GO TO 230
C
C--COMPUTE WHETHER CUTTER DOES FIT THE SURFACE AT THIS POINT
      CALL SRFDIR(DR,R,PSIDE,PDIR,RX,RVEC,RK,IR)
C---      REJECT POINT BASED ON CURVATURE FIT SOMETIMES
      IREJ=0
C--TOOL MUST NOT VIOLATE EITHER OF TWO PRINCIPAL CURVATURES
      DO 140 I=1,2
C
C---      SAVE WORST CURVATURE VALUES AS ENCOUNTERED
      DO 145 J=1,2
C---      RX AND AKMXMN SHOULD HAVE THE SAME SIGN
      IF(RX(I)*AKMXMN(J).LE.ZERO) GO TO 145
C---      SAVE RX IF IT IS LARGER
      IF(DABS(RX(I)).LT.DABS(AKMXMN(J))) GO TO 145
C
      AKMXMN(J)=RX(I)
      IF(RX(I).GT.ZERO) AKDRV(1,J)=PAR(1)
      IF(RX(I).GT.ZERO) AKDRV(2,J)=PAR(2)
      AKPRT(1,J)=NPAT
      AKPRT(2,J)=UP
      AKPRT(3,J)=VP
  145 CONTINUE
C
C---      SKIP CURVATURE CHECK IF ISKBAL IS 1.
      IF(ISKBAL.EQ.1) GO TO 140
C---      IF TOOL IS ON PS, THEN SKIP CURVATURE CALCULATION
      IF(IPTOOL.EQ.1) GO TO 140
      IF(RX(I).LE.SMAL) GO TO 140
      SRAD=1/RX(I)
      IF(SRAD.LT.EFRAD) IREJ=1
  140 CONTINUE
C---      IF CONDITION IS REJECT, REATTEMPT STEPOUT
      IF(IREJ.EQ.1) GO TO 230
C
C--VERIFY STEPOUT VS TOLERANCE.  CUT BACK STEPOUT AND RETRY
C--IF NECESSARY
  200 CONTINUE
C--FOR FIRST POINT OR FIXED PARAMETER STEP, SKIP THIS
      IF(IPASS.EQ.1.OR.DSTEP.LT.ZERO) GO TO 400
C
      CALL TULPOS(R,PSIDE,DR,TUL,PTHICK,ZERO,IPTOOL,IDTOOL,
     X            TEX,TAX,TBEFX,PDIR)
C--NEW CANDIDATE TOOL END TOOL AXIS IS TEX,TAX
      DO 220 I=1,3
  220 TEX(I)=TBEFX(I)-TBEF(I)
      CALL DOTF(ESTEP,TEX,TEX)
      ESTEP=DSQRT(ESTEP)
C--CHECK WHETHER THIS TOOL STEP IS ACCEPTABLE
      CALL STEPCK(PSIDE,R,RX,RK,RL,RXL,RKL,EFRAD,PTOL,
     X            SSTEP,TSTEP)
      IF(ESTEP.LT.TSTEP.AND.ESTEP.LT.AMAXDP) GO TO 400
  230 CONTINUE
      STEPL=STEP
      STEP=STEP*FAC
C--CUT DOWN STEPOUT AND TRY AGAIN
  240 IFIN=0
      ISTEPK=ISTEPK+1
C****    ERROR
      IRR=2
      IF(ISTEPK.GT.MXSTEP) GO TO 999
      GO TO 610
C
C--ACCEPT THE CURRENT TOOL POSITION, TERMINATE IF IFIN NOT ZERO
  400 CONTINUE
C--PLACE CUTTER NEAR PROPER SHELL OF TOLERANCE BAND
      TOLCOM=TOLMID
      IF(RK.LT.ZERO) TOLCOM=TOLMID+TOLRNG
      IF(RK.GT.ZERO) TOLCOM=TOLMID-TOLRNG
      IF(DABS(RK).LT.SMAL) TOLCOM=TOLMID
      IF(IQUAL.EQ.1) TOLCOM=ZERO
      DO 410 I=1,3
      TBEFL(I)=TBEF(I)
      TEL(I)=TE(I)
  410 TAL(I)=TA(I)
C--FIND NEW TE,TA
      CALL TULPOS(R,PSIDE,DR,TUL,PTHICK,TOLCOM,IPTOOL,IDTOOL,
     X            TE,TA,TBEF,PDIR)
C--CARRYOUT GOUGE CHECKING IF REQUIRED
      IF ( LGCHK.AND.(IPASS.NE.1).AND.(IQUAL.NE.1)) THEN
        CALL GCHK(PSURF,PSIDE,R,TE,TA,NPAT,UP,VP,
     +            RL,TEL,TAL,NPATL,UPL,VPL,TOLCOM,PTOLI,PTOLO,GFAC,IRET)
        IF (IRET.NE.0) THEN
C--EITHER GOUGING OCCURS OR MATERIAL IS LEFT ON
C  REDUCE STEPOUT UNLESS FIXED PARAMETRIC STEP
          IF (DSTEP.LT.ZERO) THEN
            IF (IRET.GT.0) THEN
             CALL CFORM(' *** WARNING - GOUGING OCCURS ***',DARRAY,1,33)
            ELSE
             CALL CFORM(' *** WARNING - EXCESS MATERIAL LEFT ON ***',
     +                  DARRAY,1,42)
            ENDIF
            CALL CPRINT(DARRAY)
            CALL BAD(3,1,'TE  ',TE)
            CALL BAD(-3,1,'TEL ',TEL)
          ELSE
            STEPL=STEP
            STEP=STEP*GFAC
C.... RESTORE PREVIOUS VALUES OF TE,TA AND TBEF
            DO 415 I=1,3
              TE(I)=TEL(I)
              TA(I)=TAL(I)
              TBEF(I)=TBEFL(I)
  415       CONTINUE
            GOTO 240
          ENDIF
        ENDIF
      ENDIF
C
C.... CARRY OUT INTERFERENCE CHECKING IF REQUIRED
C
      IF (LINTCK) THEN
        CALL INTCHK(PSURF,IPSIZE,PSIDE,PTHICK,PTOLI,TUL,TE,TA,
     +              R,NPAT,UP,VP,LRET,INTLOC)
        IF (LRET) THEN
C.... INTEFERENCE HAS BEEN DETECTED - PRINT DETAILS OF INTEFERENCE
          CALL INTMSG(TE,TA,INTLOC)
          IF (LAVCTL) THEN
C.... AVOIDANCE CONTROL REQUESTED
C     COMPUTE GUIDE SURFACE FORWARD DIRECTION
            CALL VSCALE(PDIR,DR(13),FWD)
            CALL AVOID(PSURF,IPSIZE,PSIDE,PTHICK,PTOLI,PTOLO,TOLCOM,FWD,
     +                 TUL,TE,TA,R,NPAT,UP,VP,INTLOC,LARET)
            IF (LARET) THEN
              CALL OUTMSG('INTERFERENCE AVOIDED')
            ELSE
              CALL ERROR(-3555,'SSPATH  ')
            ENDIF
          ENDIF
        ENDIF
C.... RESET INTEFERENCE TABLE
        CALL RESET
      ENDIF
C--COMPUTE TOOL END DISTANCE
      TBEMAX=ZERO
      TEMOV=ZERO
      IF(IPASS.EQ.1) GO TO 430
      DO 420 I=1,3
  420 TEX(I)=TE(I)-TEL(I)
      CALL DOTF(TEMOV,TEX,TEX)
      DO 425 I=1,3
      TEX(I)=TBEF(I)-TBEFL(I)
  425 CONTINUE
      CALL DOTF(TBEMAX,TEX,TEX)
      TBEMAX=DSQRT(TBEMAX)
C
      TEMOV=DSQRT(TEMOV)
  430 CONTINUE
C--SAVE OLD SURFACE CONTACT DATA
      DO 440 I=1,32
      RL(I)=R(I)
      RXL(I)=RX(I)
  440 CONTINUE
      RKL=RK
C--SAVE PATCH NO, U,V OF THIS SURFACE POINT
      NPATL=NPAT
      UPL=UP
      VPL=VP
      IF(IBUG.NE.11) GO TO 8806
      CALL BAD(1,0,'ICLT',ICLCT)
      CALL BAD(1,0,'ISTK',ISTEPK)
      CALL BAD(1,1,'TEMV',TEMOV)
      CALL BAD(1,1,'ESTP',ESTEP)
      CALL BAD(-1,1,'PSTP',PSTEP)
 8806 CONTINUE
C.... IF AXIS/ATANGL,PS,.. TOOL AXIS CONTROL - SAVE CURRENT TA
C     AS INITIAL TA FOR NEXT CUTTER LOCATION
      IF (ITAC.EQ.2) THEN
        DO 445 I=1,3
          DAXIS(I)=TA(I)
  445   CONTINUE
      ENDIF
C--RESET COUNTERS AND CHECK PATH LIMITS
      ISTEPK=0
      ICLCT=ICLCT+1
C****    ERROR
      IRR=3
      IF(ICLCT.GT.MAXCL) GO TO 999
      PLEN=PLEN+TEMOV
C****    ERROR
      IRR=4
      IF(PLEN.GT.ELMAX) GO TO 999
C---IF ICLSKP IS NEGATIVE, THEN DO NOT RECORD CL VALUES
      IF(ICLSKP.LT.0) GO TO 450
      IF(MAXCL.EQ.1) IFIN=1
      IF(IPASS.NE.1.OR.ICLSKP.NE.1) CALL CLPUT(TE,TA,IFIN)
  450 CONTINUE
      IPASS=0
      EMAX=5.0D0*TBEMAX
      IF(ICLCT.EQ.1) EMAX=AMAXDP
C
C--SCALOP HEIGHT CALCULATION
C--SKIP SCALOP HEIGHT CALCULATION FOR CURVE DRIVE ELEMENT
      IF(IDTYPE.EQ.0) GO TO 510
C--PROCEED TO NORMAL SCALOP CALC IF SCALHT IS NOT SMALL
      IF(SCALHT.GT.SMAL) GO TO 530
C--SCALLOP HEIGHT SMALL, USE STEPMX TO DETERMINE STEPOVER
      SDIST=STEPMX
C--IF STEPMX IS POSITIVE, THEN STEPOVER BY THIS DISTANCE
      IF(STEPMX.GT.SMAL) GO TO 540
C--STEPMX NEGATIVE AND SIGNIFICANT MEANS A FIXED PARAMETRIC STEPOVER
      SDIST=DABS(STEPMX)
      STEPOV=SDIST
      IF(SDIST.GT.SMAL) GO TO 550
C****    ERROR IN SCALLOP HEIGHT CALCULATION
      SDIST=ONE
      STEPOV=SDIST
      GO TO 550
C
  530 CONTINUE
C--NORMAL SCALLOP HEIGHT CALCULATION
C--NEGATIVE STEPMX IS A LIMIT ON THE PARAMETRIC SIDE STEP.
      IF(STEPMX.LT.ZERO) STEPOV=DABS(STEPMX)
      SDIST=BALRAD**2-(BALRAD-SCALHT)**2
      SDIST=DMAX1(SMAL,SDIST)
C--SDIST IS THE PHYSICAL STEPOVER DISTANCE TO ACHIEVE SPECS.
      SDIST=2.*DSQRT(SDIST)
  540 CONTINUE
      IF(STEPMX.GT.ZERO) SDIST=DMIN1(STEPMX,SDIST)
C--CONVERT PHYSICAL SDIST INTO A PARAMETRIC SDIST FOR DRIVE SURFACE
      JCOMP=9
      IF(IDTYPE.EQ.2) JCOMP=5
      CALL DOTF(ANG,DR(33),R(29))
      ANG=DABS(ANG)
      ANG=DMAX1(SMAL,ANG)
      SDIST=SDIST/ANG
      CALL DOTF(W,R(JCOMP),R(JCOMP))
      W=DSQRT(W)
      W=DMAX1(SMAL,W)
      SDIST=SDIST/W
  550 CONTINUE
C--STEPOV IS A LIMIT ON THE PARAMETRIC STEPOVER
      STEPOV=DMIN1(STEPOV,SDIST)
  520 CONTINUE
      IF(IBUG.NE.11) GO TO 8811
      CALL BAD(1,1,'STOV',STEPOV)
      CALL BAD(1,1,'SDST',SDIST)
      CALL BAD(1,1,'SCLH',SCALHT)
      CALL BAD(-1,1,'BRAD',BALRAD)
 8811 CONTINUE
  510 CONTINUE
C
      IRR=0
      IF(MAXCL.EQ.1) GO TO 999
      IF(IFIN.NE.0) GO TO 999
C
C--IF IFIN IS ZERO, ESTIMATE NEXT STEPOUT DISTANCE AND THEN
C--OBTAIN PARAMETRIC STEP CHANGE TO ESTIMATE THIS.
      CALL SRFTOL(RK,EFRAD,PTOL,XSTEP,ESTEP)
C
  600 CONTINUE
C--COMPUTE THE NEW PARAMETRIC STEPSIZE PAR(1-2)
C--PAR SHOULD GENERATE A NEW DRIVE POINT SO THAT THE DESIRED
C--TOOL END STEP ESTEP IS ACHIEVED
C--IF DTOL IS GT ZERO, DTOL IS TOLERANCE OF DRIVE GEOM
C--DSTEP GT ZERO LIMITS THE MAXIMUM PARAMETRIC STEP SIZE
C--IF DSTEP GT ZERO AND DTOL=0 THEN DSTEP IS THE STEP
C--FOR GENERAL TOLERANCE CALCULATIONS AN ATTEMPT IS MADE
C--TO APPROACH EACH ARC JUNCTION WITHOUT EXTREME MOVES
C
      IFIN=0
      IF(ISTEPK.EQ.0) STEP=.95*XSTEP*TSTEP/SSTEP
      IF(ISTEPK.GT.0) STEP=.95*ESTEP
      IF(EMAX.GT.0.1D0) STEP=DMIN1(STEP,EMAX)
      STEP=DMIN1(AMAXDP,STEP)
  610 CONTINUE
C--ADJUST PSTEP IF PAR HAD BEEN CUT BACK BY CHKSTEP
      DIF=PARNSV-PAR(INDEX)
      IF(DABS(DIF).GT.SMAL) PSTEP=PSTEP-DABS(DIF)
C--CUT BACK PARAMETER VALUE IF THE LAST STEP SIZE WAS NG
      IF(ISTEPK.GT.0) PAR(INDEX)=PAR(INDEX)-PDIR*PSTEP
      PCUR=PAR(INDEX)
      PLO=PLIM(2*INDEX-1)
      PHI=PLIM(2*INDEX)
      PSTEP=DABS(DSTEP)
      IF(DTOL.EQ.ZERO.AND.DSTEP.NE.ZERO) GO TO 640
C
C--STEP IS THE PHYSICAL SURFACE MOVE DESIRED ACROSS THE PART SURFACE
C--THIS MUST BE CONVERTED INTO PSTEP - THE CORRESPONDING PARAMETRIC
C--MOVE ALONG THE DRIVE CURVE. STEP IS LIMITED BY DSTEP(GT.0) AND
C--PSTEP IS LIMITED BY DR(27) AND DSTEP(LT.0).
      CALL DOTF(W1,DR(13),RVEC)
      CALL DOTF(W2,DR(5),DR(5))
      W2=DSQRT(W2)
      W1=DABS(W1*W2)
      W1=DMAX1(SMAL,W1)
C
      PSTEP=STEP/W1
      IF(DR(27).GT.SMAL) PSTEP=DMIN1(PSTEP,DR(27))
      WW=DABS(DSTEP)
      IF(DSTEP.GT.ZERO) PSTEP=DMIN1(PSTEP,WW)
      PNEXT=PCUR+PDIR*PSTEP
C--CUT BACK THE SUGGESTED PARAMETER CHANGE SO THAT ALL CURVE
C--ARC JUNCTIONS ARE USED AND APPROACHED SMOOTHLY
      CALL PCHG(PCUR,PDIR,PSTEP)
  640 CONTINUE
      PAR(INDEX)=PAR(INDEX)+PDIR*PSTEP
      IF(IBUG.NE.11) GO TO 8807
      CALL BAD(1,1,'STEP',STEP)
      CALL BAD(1,1,'PSTP',PSTEP)
      CALL BAD(-2,1,'PAR ',PAR)
 8807 CONTINUE
      GO TO 100
C
C--   END OF PROCESSING
C
  999 CONTINUE
C---      WRITE OUT SUMMARY OF CURVATURE ETC FOR THIS PATH CALL
      CALL RECORD(ISEQNO)
      IF(ISEQNO.EQ.ISEQLS) GO TO 1995
C---      WRITE HEADER FOR DATA
      ISEQLS=ISEQNO
      CALL BAD(-1,0,'PATH',ISEQNO)
      ICOL=1
      CALL CFORM(' NO. ERRNO.',DARRAY,ICOL,11)
      ICOL=13
      CALL CFORM('CLCT PATH LEN.',DARRAY,ICOL,14)
      ICOL=29
      CALL CFORM('RADIUS/SURF   PATCH',DARRAY,ICOL,19)
      ICOL=48
      CALL CFORM('  U-SRF   V-SRF',DARRAY,ICOL,15)
      ICOL=64
      CALL CFORM(' U-DRV   V-DRV',DARRAY,ICOL,14)
      ICOL=80
      CALL CFORM('RADIUS/SURF   PATCH',DARRAY,ICOL,19)
      ICOL=99
      CALL CFORM('  U-SRF   V-SRF',DARRAY,ICOL,15)
C
      CALL CPRINT(DARRAY)
 1995 CONTINUE
      ICOL=2
      CALL ICONV(KPATH,DARRAY,ICOL,4)
      ICOL=ICOL+5
      CALL ICONV(IRR,DARRAY,ICOL,5)
      ICOL=ICOL+6
      CALL ICONV(ICLCT,DARRAY,ICOL,4)
      ICOL=ICOL+5
      CALL FCONV(PLEN,DARRAY,ICOL,10,3)
      ICOL=ICOL+11
      DO 1994 J=1,2
      RAD=DABS(AKMXMN(J))
      RAD=DMAX1(ZEM5,RAD)
      RAD=DMIN1(BIG,RAD)
      IF(AKMXMN(J).LT.ZERO) RAD=-RAD
      RAD=1/RAD
      CALL FCONV(RAD,DARRAY,ICOL,13,4)
      ICOL=ICOL+14
      NPAT=AKPRT(1,J)
      CALL ICONV(NPAT,DARRAY,ICOL,4)
      ICOL=ICOL+5
      CALL FCONV(AKPRT(2,J),DARRAY,ICOL,7,3)
      ICOL=ICOL+8
      CALL FCONV(AKPRT(3,J),DARRAY,ICOL,7,3)
      ICOL=ICOL+8
      IF(J.GT.1) GO TO 1994
      CALL FCONV(AKDRV(1,1),DARRAY,ICOL,7,3)
      ICOL=ICOL+8
      CALL FCONV(AKDRV(2,1),DARRAY,ICOL,7,3)
      ICOL=ICOL+8
 1994 CONTINUE
C
      CALL CPRINT(DARRAY)
      IF(IBUG.NE.11) GO TO 1998
      ASSIGN 1998 TO IRET
      GO TO 1999
 1998 CONTINUE
      RETURN
C
C--INPUT/OUTPUT PRINT AREA
 1999 CONTINUE
      CALL BAD(-1,0,' ',0)
      CALL BAD(-6,1,'DSRF',DSURF)
      CALL BAD(1,0,'IDTY',IDTYPE)
      CALL BAD(1,1,'PDIR',PDIR)
      CALL BAD(1,1,'DTOL',DTOL)
      CALL BAD(1,1,'DSTP',DSTEP)
      CALL BAD(-1,1,'DOFS',DOFSET)
      CALL BAD(-4,1,'PLIM',PLIM)
      CALL BAD(1,0,'IDTL',IDTOOL)
      CALL BAD(1,0,'IDAX',IDAXIS)
      CALL BAD(-4,1,'DAXI',DAXIS)
      CALL BAD(1,0,'ITLD',ITLDIR)
      CALL BAD(-3,1,'TLDR',TLDIR)
      CALL BAD(-6,1,'PSRF',PSURF)
      CALL BAD(1,1,'SIDE',PSIDE)
      CALL BAD(1,1,'THCK',PTHICK)
      CALL BAD(1,1,'PTLI',PTOLI)
      CALL BAD(1,1,'PTLO',PTOLO)
      CALL BAD(1,1,'TUL ',TUL)
      CALL BAD(-1,1,'UST ',UST)
      CALL BAD(1,1,'VST ',VST)
      CALL BAD(1,1,'SCHT',SCALHT)
      CALL BAD(1,1,'STOV',STEPOV)
      CALL BAD(1,1,'STMX',STEPMX)
      CALL BAD(1,1,'MXDP',AMAXDP)
      CALL BAD(-1,1,'ELMX',ELMAX)
      CALL BAD(1,0,'MXCL',MAXCL)
      CALL BAD(1,0,'ISKP',ICLSKP)
      CALL BAD(1,0,'QUAL',IQUAL)
      CALL BAD(-3,1,'TD  ',TD)
      CALL BAD(3,1,'TE  ',TE)
      CALL BAD(-3,1,'TA  ',TA)
      CALL BAD(1,0,'IPTL',IPTOOL)
      CALL BAD(2,1,'PAR ',PAR)
      CALL BAD(-1,0,'IRR ',IRR)
      GO TO IRET,(1997,1998)
      END
**** SOURCE FILE : M0001113.W01   ***
*
      SUBROUTINE STEPCK(SIDE,R,RX,RK,RL,RXL,RKL,EFRAD,TOL,
     X                  SRMIN,TLMIN)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
      DIMENSION R(*),RX(1),RL(*),RXL(1)
      DIMENSION RDIF(3)
      CHARACTER*20 BADMSG
      DATA SMAL,BIG/1.0D-38,1.0D+10/
C--PURPOSE IS TO COMPUTE MINIMUM SURFACE (SRMIN) AND TOOL STEPS
C--(TLMIN) BASED ON CURRENT AND LAST CONTACT POINTS
C
      SRMIN=BIG
      TLMIN=BIG
      DO 10 I=1,3
   10 RDIF(I)=R(I)-RL(I)
      CALL DOTF(RSQ,RDIF,RDIF)
C
      CALL SRFTOL(RK,EFRAD,TOL,SMIN,TMIN)
      SRMIN=DMIN1(SRMIN,SMIN)
      TLMIN=DMIN1(TLMIN,TMIN)
C
      CALL SRFTOL(RKL,EFRAD,TOL,SMIN,TMIN)
      SRMIN=DMIN1(SRMIN,SMIN)
      TLMIN=DMIN1(TLMIN,TMIN)
C
      IF(RSQ.LT.SMAL) GO TO 999
      CALL DOTF(W,R(29),RDIF)
      W=-2.*W*SIDE/RSQ
      CALL SRFTOL(W,EFRAD,TOL,SMIN,TMIN)
      SRMIN=DMIN1(SRMIN,SMIN)
      TLMIN=DMIN1(TLMIN,TMIN)
C
      CALL DOTF(W,RL(29),RDIF)
      W=2.*W*SIDE/RSQ
      CALL SRFTOL(W,EFRAD,TOL,SMIN,TMIN)
      SRMIN=DMIN1(SRMIN,SMIN)
      TLMIN=DMIN1(TLMIN,TMIN)
C
  999 CONTINUE
      IF(IBUG.NE.11) GO TO 1999
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER STEPCK'
      CALL CPRINT(BADMSG)
      CALL BAD(1,1,'SIDE',SIDE)
      CALL BAD(1,1,'RK  ',RK)
      CALL BAD(1,1,'RKL ',RKL)
      CALL BAD(1,1,'ERAD',EFRAD)
      CALL BAD(-1,1,'TOL ',TOL)
      CALL BAD(1,1,'SRMN',SRMIN)
      CALL BAD(-1,1,'TLMN',TLMIN)
 1999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001126.W07   ***
*
      SUBROUTINE TULPOS(R,SIDE,DR,TUL,PTHICK,TOLCOM,IPTOOL,IDTOOL,
     X                  TE, TA,TBEF,PDIR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
C-- R     INPUT SURFACE CONTACT POINT/DERIVATIVES(SEE CNSURF)
C-- SIDE  INPUT 1 OR -1, DEFINES CUTTER SIDE OF SURFACE
C-- DR    DRIVE ELEMENT POINT/DERIVATIVES(SEE DGEOM)
C-- TUL   CUTTER PARAMETERS
C-- PTHICK PART GEOMETRY THICK SPECIFICATION
C-- TOLCOM TOLERANCE BAND COMPENSATION
C-- IPTOOL PART SURFACE CONTROL FLAG( 0 FOR ON, 1 FOR TO)
C-- IDTOOL DRIVE ELEMENT CONTROL FLAG
C-- TE   OUTPUT TOOL END
C-- TA   OUTPUT TOOL AXIS
C-- TBEF OUTPUT EFFECTIVE TOOL END BASED ON SPHERICAL CUTTER
C-- PDIR DIRECTION OF MOTION WRT INCREASING PARAMETER (+1 OR -1)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
      DIMENSION VEC(3)
C--PURPOSE IS TO COMPUTE TOOL END AND TOOL AXIS WHEN AN A
C--ACCEPTABLE SURFACE CONTACT POINT HAS BEEN FOUND
      DIMENSION R(32),DR(36),TUL(4),TE(3),TA(3),TBEF(3)
      CHARACTER*20 BADMSG
      CHARACTER*120 DARRAY
      DIMENSION VECL(3),V(3),VN(3)
      DOUBLE PRECISION NPS
      DIMENSION FWD(3),NPS(3),ROLL(3),PITCH(3)
C--TOOL CANONICAL DATA
      INCLUDE (TLLDAT)    
C--TOOL AXIS CONTROL DATA
      INCLUDE (TAC)    
C--INITIALZE VECL AND FIRST CALL FLAG
      LOGICAL LFIRST
C--SAVE LAST DIRECTION FROM SP TOWARDS TOOL AXIS,AND FLAG LFIRST
      SAVE VECL,LFIRST
C
      DATA VECL/3*0.D0/,LFIRST/.TRUE./
C
C--FOR FIRST CALL (LFIRST=.TRUE.) SET VECL TO REV. MOTION DIRECTION
      IF (LFIRST) THEN
        DO 5 I=1,3
          VECL(I)=-1.0*PDIR*DR(12+I)
   5    CONTINUE
        LFIRST=.FALSE.
      ENDIF
C.... IF TOOL AXIS CONTROL WRT PS - COMPUTE LOCAL PITCH AND ROLL AXES
      IF (ITAC.EQ.2) THEN
C.... GUIDE SURFACE FORWARD DIRECTION - PDIR*(DRIVE TANGENT VECTOR)
        CALL VSCALE(PDIR,DR(13),FWD)
C.... CUTTER SIDE OF PART SURFACE
        CALL VSCALE(SIDE,R(29),NPS)
C.... COMPUTE UNIT VECTOR PERPENDICULAR TO GUIDE SURFACE FORWARD AND
C     PROJECTION VECTORS
        CALL CROSSV(FWD,DR(21),V)
C.... COMPUTE LOCAL FORWARD MOTION DIRECTION IN PS TANGENT PLANE
C           (ROLL AXIS)
       CALL CROSSV(NPS,V,ROLL)
C.... COMPUTE LOCAL AXIS ORTHOGONAL WITH ROLL AXIS AND PS NORMAL
C           (PITCH AXIS)
        CALL CROSSV(NPS,ROLL,PITCH)
C.... DETERMINE DIRECTION IN WHICH ROLL ANGLE IS TO BE APPLIED
C     POSITIVE IN STEPOVER DIRECTION
        CALL DOTV(SGN,PITCH,DR(29))
        SGN=SIGN(1.D0,SGN)
      ENDIF
C-- TWO MAIN CASES, TOOL ON PS OR NOT ON.
      IF(IPTOOL.NE.0) GO TO 50
C--GENERAL CASE, TOOL OFFSET FROM SURFACE
      OFFSET=SIDE*(PTHICK+TOLCOM+TUL(1))
      DO 10 I=1,3
       IF (ITAC.EQ.1) THEN
C.... APPLY CUTANG BETA TO TA IN DIRECTION OF MOTION
        TA(I)=COSB*DR(16+I) + PDIR*SINB*DR(12+I)
       ELSE IF (ITAC.EQ.2) THEN
C.... APPLY BETA WRT TO PS NORMAL IN MOTION DIRECTION
C     AND ALPHA IN PLANE PERPENDICULAR TO MOTION DIRECTION
        TA(I)=COSA*COSB*NPS(I) + SINB*ROLL(I)
     +       + SGN*SINA*COSB*PITCH(I)
       ELSE
        TA(I)=DR(16+I)
       ENDIF
       TBEF(I)=R(I)+OFFSET*R(I+28)-TUL(1)*TA(I)
   10 CONTINUE
C--GENERAL CUTTER CALCULATION.
      CALL CROSS(TA,R(29),VEC)
C...IF TA IS PARALLEL TO SN USE PREVIOUS VALUE OF VEC INSTEAD OF SN
      VLEN2=VEC(1)*VEC(1)+VEC(2)*VEC(2)+VEC(3)*VEC(3)
      IF (VLEN2.LT.1.0D-12) THEN
        CALL CROSS(TA,VECL,VEC)
      ENDIF
      DO 20 I=1,3
   20 VEC(I)=SIDE*VEC(I)
      CALL CROSS(VEC,TA,VEC)
      CALL VNORM(VEC,VEC)
C...MODIFY OFFSET FOR 7 SEGMENT CUTTER CALCULATION
      OFFSET=OFFSET-SIDE*TUL(1)
        DO 32 I=1,3
         VECL(I)=VEC(I)
   32   CONTINUE
C...COMPUTE TANGENT OF ANGLE BETWEEN TOOL NORMAL AND TOOL RADIAL AXIS
      CALL DOTV(CANG,VEC,R(29))
      CALL CROSS(VEC,R(29),V)
      CALL VNORM(V,VN)
      CALL DOTV(SANG,V,VN)
      IF (ABS(CANG).GT.1.D-15) THEN
        TANG=SANG/CANG
      ELSE
        TANG=SIGN(1.D0,SANG)*1.D15
      ENDIF
C...IS ANGLE VALID FOR SEGMENTS 3,4,5 OF CUTTER
C   I.E. CORNER RADIUS AND ADJACENT POINT CIRCLE SEGMENTS
      DO 35 I=3,5
        IF ((TCONT(I).GT.0).AND.
     1     ((TANG-TANLO(I))*(TANG-TANHI(I)).LE.0.D0)) THEN
C...COMPUTE TOOL END COORDS
          DO 34 K=1,3
            TE(K)=R(K)+(OFFSET+SIDE*CORRAD(I))*R(28+K)
     1           +RI(I)*VEC(K)-TLHITE(I)*TA(K)
   34     CONTINUE
          GOTO 999
        ENDIF
   35 CONTINUE
C...NO - IS ANGLE VALID FOR TOOL TIP
      IF ( (TCONT(1).GT.0).AND.
     1   ( (TANG-TANLO(1))*(TANG-TANHI(1)).LE.0.D0) ) THEN
C...YES - OUTPUT WARNING
        CALL CFORM(' *** WARNING - CUTTING ON TOOL TIP ***',DARRAY,1,38)
        CALL CPRINT(DARRAY)
        DO 40 K=1,3
          TE(K)=R(K)+OFFSET*R(28+K)
   40   CONTINUE
C...NO - IS ANGLE VALID FOR TOP OF UPPER LINE SEGMENT
      ELSE IF ( (TCONT(7).GT.0).AND.
     1        ( (TANG-TANLO(7))*(TANG-TANHI(7)).LE.0.D0) ) THEN
C...YES - OUTPUT WARNING
        CALL CFORM(' *** WARNING - CUTTING ON POINT CIRCLE AT TOP OF UPP
     1ER LINE SEGMENT ***',DARRAY,1,71)
        CALL CPRINT(DARRAY)
        DO 42 K=1,3
          TE(K)=R(K)+OFFSET*R(28+K)+RI(7)*VEC(K)-TLHITE(7)*TA(K)
   42   CONTINUE
C...NO - INVALID ANGLE FOR THIS CUTTER
      ELSE
        CALL CFORM(' *** WARNING - UNABLE TO POSITION 7 SEGMENT CUTTER A
     1T CURRENT SURFACE POINT - SPHERICAL CUTTER ASSUMED',DARRAY,1,101)
        CALL CPRINT(DARRAY)
C
        DO 45 K=1,3
          TE(K)=TBEF(K)
   45   CONTINUE
      ENDIF
C...PRINT USEFUL DIAGNOSTIC INFORMATION WHEN WARNINGS OCCUR
      CALL BAD(3,1,'SP  ',R(1))
      CALL BAD(-3,1,'SN  ',R(29))
      CALL BAD(3,1,'TE  ',TE)
      CALL BAD(-3,1,'TA  ',TA)
      CALL BAD(3,1,'VEC ',VEC)
      CALL BAD(-3,1,'VECL',VECL)
      CALL BAD(-1,1,'TANG',TANG)
      GO TO 999
   50 CONTINUE
C--TOOL TIP ON PART SURFACE
      DO 60 I=1,3
       IF (ITAC.EQ.1) THEN
C.... APPLY CUTANG BETA TO TA IN DIRECTION OF MOTION
        TA(I)=COSB*DR(16+I) + PDIR*SINB*DR(12+I)
       ELSE
        TA(I)=DR(16+I)
       ENDIF
      TE(I)=R(I)+SIDE*TOLCOM*R(I+28)
      TBEF(I)=TE(I)
   60 CONTINUE
C
  999 CONTINUE
      IF(IBUG.NE.11) GO TO 1999
      CALL BAD(-1,0,' ',0)
      BADMSG=' AFTER TULPOS'
      CALL CPRINT(BADMSG)
      CALL BAD(-1,1,'TCOM',TOLCOM)
      CALL BAD(3,1,'TE  ',TE)
      CALL BAD(-3,1,'TA  ',TA)
      CALL BAD(-3,1,'TBEF',TBEF)
 1999 CONTINUE
C
      RETURN
      END
