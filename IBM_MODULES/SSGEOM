**** SOURCE FILE : M0001869.W01   ***
*
      SUBROUTINE APT107(A,ARG1,ARG2,ARG3)
C---     MAIN ROUTINE FOR DEFINITION OF SCULPTURED SURFACES
C---     INPUT CONSISTS OF THREE ARGUMENTS ARG1,ARG2,ARG3
C---     ARG1 CONTAINS THE FIRST MINOR WORD IN THE SSURF DEFINITION
C---     THAT IS, ARG1 CONTAINS HOLLERITH SMESH IN SSURF/SMESH STATEMENT
C---     ARG2 IS CURRENTLY UNUSED
C---     ARG3 CONTAINS THE SURFACE SUB-TYPE. FOR EXAMPLE,
C---     FOR SSURF/SMESH,XYPLAN, ARG3 CONTAINS HOLLERITH FOR XYPLAN.
C---     THE REMAINING ARGUMENTS ARE PASSED IN BLANK COMMON BEGINNING
C---     FROM LOCATION 41 ON.  THE FIRST 8 WORDS CONTAIN SUMMARY
C---     DATA AND LOCATIONS 49 ON CONTAIN A CODED STREAM OF NUMBERS
C---     REPRESENTING THE PART PROGRAMMERS INPUT.  MOST DATA IS
C---     IN COUPLET FORM - PRECEEDED BY ITS APT4 CODE VALUE AND
C---     THEN ITS NUMBERICAL CANON FORM.  FOR EXAMPLE, THE MINOR
C---     WORD CLW IS REPRESENTED BY THE INTEGER CODE 58. AND THEN
C---     BY ITS HOLLERITH FORM.  A POINT WOULD BE REPRESENTED BY
C---     ITS GEOMETRIC CLASS CODE (19.) AND THEN BY ITS THREE NUMERICAL
C---     VALUES.  ONE EXCEPTION IS THE WORD SPLINE WHICH IS CURRENTLY
C---     PASSED IN A SINGLE WORD AS HOLLERITH DATA.
C---     WITH THE HELP OF THE AUXILIARY BUFFER ARRAY SSPAD, THIS
C---     INPUT DATA IS REPLACED BY A PROCESSED SSURF CANON FORM IN
C---     BLANK COMMON FROM LOCATION 41 ON.  THIS FORM IS SAVED
C---     ON AN EXTERNAL FILE BY MEANS OF A CALL TO APT094
C---     AN INTERNAL TWO-WORD CANON FORM CONTAINING THE SURFACE
C---     SEQUENTIAL IDENTIFICATION NUMBER AND SIZE IS INSERTED
C---     IN THE ARRAY A WHICH IS THE FIRST INPUT ARGUMENT.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      INCLUDE (TOTAL)    
      INCLUDE (LDEF)    
C
      LOGICAL CKDEF
      COMMON/ADDCOM/ADDCOM
      DIMENSION ADDCOM(25)
      EQUIVALENCE (ADDCOM(1),ELMAX),(ADDCOM(25),KDYNFL)
      INCLUDE (SSPAD)    
C
      INCLUDE (BLANKCOM)    
C
      DIMENSION A(*),SNN(49),SOUT(48),TY(3),KTY(5),KTW(5)
      EQUIVALENCE (SNN(1),SCAN(1)), (SOUT(1),SCAN(50))
C
      COMMON/MAXLDA/MAXLDA
C
      DIMENSION PA(3),PB(3),XMATRX(12)
      CHARACTER*6 IMESH,IPLUS,IMINUS,IXYZ,IXY,IYZ,IZX,ISPLIN,IPNVE,
     C   IPLGN,IPNSON,GENCUR,RULED,REVOL
      CHARACTER*6 CTRAN(5)
      CHARACTER*6 COMBIN,TRAF,CROS
      COMMON/SSPRT/SSPRT,SSTEST
      LOGICAL SSPRT,SSTEST
      INTEGER IZAL1(12),IZAL2(3),IZAL3(3),IZAL4(13),IZAL5(4),
     1 IZAL6(8),IZAL7(20),IZAL8(4),IZAL9(1),IZA10(10),IZA11(6)
      CHARACTER*16 SSNAME
      CHARACTER*8 RNAM1,RNAM2,RNAM3,RNAM4,RNAM5,RNAM6,RNAM7,
     1 RNAM8,RNAM9,RNA10,RNA11,RNAMA,RNAME
      CHARACTER*6 TEST1,TEST2,TEST3,TEST
C
C---     SAVE AREA FOR HEADER OF INPUT CANON FORM
      DIMENSION ASAV(10)
C
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
C
C---  SOME MINOR WORD CODE NUMBERS FOLLOW
      DATA VAXIS/146./
      DATA VPOINT/19./
      DATA VVECTO/20./
      DATA VSCALA/21./
      DATA VCLW/58./
      DATA VCCLW/59./
      DATA VMINUS/41./
      DATA VPLUS/42./
      DATA RULED,REVOL/'RULED ','REVOLV'/
      DATA IMESH/'SMESH '/
      DATA IPLUS/'PLUS  '/
      DATA IMINUS/'MINUS '/
      DATA IXYZ/'XYZ   '/
      DATA IXY/'XYPLAN'/
      DATA IYZ/'YZPLAN'/
      DATA IZX/'ZXPLAN'/
      DATA ISPLIN/'SPLINE'/
      DATA IPNVE/'PNTVEC'/
      DATA IPLGN/'POLYGN'/
      DATA IPNSON/'PNTSON'/
      DATA GENCUR/'GENCUR'/
      DATA COMBIN/'COMBIN'/
      DATA TRAF/'TRFORM'/
      DATA SMAL,ZERO/1.0D-10,0.0D0/
      DATA CTRAN/'TRANSL','XYROT ','YZROT ','ZXROT ','SCALE '/
      DATA NCTRAN/5/
      DATA CROS/'CROSS '/
      DATA SSNAME/'        '/
      DATA    RNAM1   /'APT107  '/, RNAM2   /'PNTSON  '/,
     *          RNAM3   /'CTRANS  '/, RNAM4   /'MESH    '/,
     *          RNAM5   /'REVOLV  '/, RNAM6   /'SRFCOM  '/,
     *          RNAM7   /'GENCRV  '/, RNAM8   /'DISEG   '/,
     *          RNAM9   /'COMPTW  '/, RNA10   /'SSPLIN  '/,
     *          RNA11   /'SMOOTH  '/,
     *          RNAMA   /'APT107??'/, RNAME   /'        '/
      DATA   IMAX1 /12/, IZAL1
     *                    / 5001, 5002, 5003, 5004, 5005, 5006,
     *                      5007, 5371, 5373, 5374, 5375, 5376/
      DATA   IMAX2 / 3/, IZAL2
     *                    / 5391, 5392, 5393/
      DATA   IMAX3 / 3/, IZAL3
     *                    / 5377, 5378, 5379/
      DATA   IMAX4 /13/, IZAL4
     *                    / 5210, 5211, 5212, 5213, 5214, 5215,
     *                      5216, 5217, 5218, 5219, 5220, 5222,
     *                      5300/
      DATA   IMAX5 / 4/, IZAL5
     *                    / 5352, 5354, 5355, 5356/
      DATA   IMAX6 / 8/, IZAL6
     *                    / 5011, 5012, 5013, 5014,
     *                      5015, 5016, 5017,-5019/
      DATA   IMAX7 /20/, IZAL7
     *                    / 5025, 5026, 5027, 5028, 5029,
     *                      5030, 5031, 5032, 5033, 5034,
     *                      5035, 5036, 5037, 5038, 5039,
     *                      5040, 5041, 5043, 5044, 5045/
      DATA   IMAX8 / 4/, IZAL8
     *                    / 5021, 5022, 5023, 5024/
      DATA   IMAX9 / 1/, IZAL9
     *                    / 5396/
      DATA   IMA10 /10/, IZA10
     *                    / 5901, 5902, 5903, 5904, 5905,
     *                      5906, 5907, 5908, 5909, 5910/
      DATA   IMA11 / 6/, IZA11
     *                    / 5921, 5922, 5923, 5924, 5925,
     *                      5934/
C
C---     FIRST PRESERVE THE INPUT HEADER TABLE
      DO  1050 I=1,10
 1050 ASAV(I)=SSCAN(I)
C
C---     SET TEST1, TEST2 & TEST3 TO BE CHARACTER EQUIVALENTS OF ARG1,
C---     ARG2 & ARG3 (WHICH DO NOT CHANGE)
      CALL HOLFRM(ARG1,TEST1,1,6,NWD)
      CALL HOLFRM(ARG2,TEST2,1,6,NWD)
      CALL HOLFRM(ARG3,TEST3,1,6,NWD)
C
C---     SET AUXILIARY FLAG FOR LEVEL OF PRINT
      ISPRNT=2
      IF(SSTEST) ISPRNT=1
      IF(.NOT.SSPRT) ISPRNT=0
      IF(TEST2.NE.TRAF) GO TO 9
      L=SSCAN(5)-12-1
      DO 7 I=1,12
      XMATRX(I)=SSCAN(L+I)
 7    CONTINUE
      ASAV(5)=ASAV(5)-14.
      SSCAN(5)=SSCAN(5)-14.
  9    CONTINUE
C---
      IER=0
      IRULE=0
      IERROR=0
C---     HEADER  * PATCH *
      CALL HOLFRM(A(3),SSNAME,1,8,NWD)
      CALL CFORM('        ',SSNAME,8,8)
      CALL UNPACK(A(1),MODE,ISIZE,ISUB)
      IF(ISUB.LT.1) GOTO 8
      CALL HOLFRM(A(ISUB*ISIZE+ISUB),SSNAME,1,8,NWD)
      CALL CFORM(' (     )',SSNAME,8,8)
      CALL ICONV(ISUB,SSNAME,10,4)
    8 CONTINUE
C---     CHECK FOR SURFACE TYPE
      IF(TEST1.EQ.GENCUR) GO TO 4000
      IF(TEST1.EQ.COMBIN) GO TO 5000
      SSCAN(5)=1.0
      IF(TEST1.EQ.RULED.OR.TEST1.EQ.REVOL) GO TO 2500
C---     CHECK IF DEFN IS CURVE BY CURVE GENERAL TRANSFORM
      DO 6 I=1,NCTRAN
      KCTRX=I
      IF(TEST1.EQ.CTRAN(I)) GO TO 2600
    6 CONTINUE
C---      KCTRX=0 MEANS TRANSFORM IS NOT CURVE BY CURVE TYPE.
      KCTRX=0
      IF(TEST1.EQ.IMESH) GO TO 1000
      IF(TEST3.EQ.IPNVE) SSCAN(6)=1.0
      IF(TEST3.EQ.IPLGN) SSCAN(6)=2.0
      IF(TEST3.EQ.IPNSON) SSCAN(6)=3.0
      IF((TEST3.EQ.IPLUS).OR.(TEST3.EQ.IMINUS)) SSCAN(6)=1.0
      SSCAN(7)=1.0
      CALL HOLFRM(SSCAN(9),TEST,1,6,NWD)
      IF(TEST.EQ.IMINUS) SSCAN(7)=-1.0
      IF (TEST.EQ.IMINUS) SSCAN(9)=VMINUS
      IF (TEST.EQ.IPLUS) SSCAN(9)=VPLUS
      SSCAN(4)=SSCAN(3)
      NPH=SSCAN(4)
      SS2=49.0*SSCAN(4)
      SSCAN(3)=4.0*SSCAN(4)
      SSCAN(8)=10.+SS2+SSCAN(3)+SSCAN(4)*6.0
      NN=NPH*6+10
      IF(SSCAN(6).NE.1.0) GO TO 200
      GO TO 100
C
C---     POINTER TABLE   * PATCH *
   10 CONTINUE
      NN=NPH*6+10
      TEMP=NN+1.0
      AK=0.
      DO 20 I=11,NN,6
      SSCAN(I)=4.0
      SSCAN(I+1)=4.0
      SSCAN(I+2)=4.0
      SSCAN(I+3)=1.0
      SSCAN(I+4)=TEMP+49.0*AK
      SSCAN(I+5)=TEMP+SS2+4.0*AK
      AK=AK+1.
   20 CONTINUE
      GO TO 3000
C
C---      VALUE TABLE   * PATCH *
C---      *  PNTVEC *
  100 CONTINUE
      K=0
      M=10
      J1=9
      DO 120 L=1,NPH
      DO 110 I=1,16
      J=M+3*K
      SNN(I)=SSCAN(J)
      SNN(I+16)=SSCAN(J+1)
      SNN(I+32)=SSCAN(J+2)
      K=K+1
  110 CONTINUE
      M=M+1
      DO 111 JA=1,48
      JJ=J1+JA
      SSCAN(JJ)=SNN(JA)
  111 CONTINUE
      J1=J1+49
      SSCAN(J1)=1.0
  120 CONTINUE
  121 NN=NPH*6+10
      LNGTH=49*NPH+NN
      KLNGTH=49*NPH+9
      DO 125 L=1,NPH
      KBEGIN=KLNGTH-49*L
      LBEGIN=LNGTH-49*L
      DO 123 I=1,49
      IB=KBEGIN+I
  123 SNN(I)=SSCAN(IB)
      DO 124 I=1,49
      IA=LBEGIN+I
      NN=NN+1
      SSCAN(IA)=SNN(I)
  124 CONTINUE
  125 CONTINUE
      GO TO 10
C---      * BEZIER POLYGN * PONTSON *
  200 J=0
      II=9
      DO 230 N=1,NPH
      DO 210 I=1,48
      SNN(I)=SSCAN(II+I)
  210 CONTINUE
      IF(SSCAN(6).EQ.2.0) CALL BEZIER(SNN,SOUT,IER)
      IF(SSCAN(6).EQ.3.0) CALL PNTSON(SNN,SOUT,KTY,KTW,IER)
      IF(IER.NE.0) GO TO 9996
      DO 220 J=1,48
      I1=II+J
      SSCAN(I1)=SOUT(J)
  220 CONTINUE
      II=II+49
      SSCAN(II)=1.0
  230 CONTINUE
      GO TO 121
C---      HEADER  * MESH *
 1000 CONTINUE
      SSCAN(5)=2.0
      SSCAN(7)=1.0
      SSCAN(9)=SSCAN(3)
      SSCAN(10)=SSCAN(4)
      IF((SSCAN(9).EQ.2.0).OR.(SSCAN(10).EQ.2.0)) IRULE=1
      SSCAN(4)=(SSCAN(9)-1.0)*(SSCAN(10)-1.0)
      NPH=SSCAN(4)
      SSCAN(3)=SSCAN(4)*4.0
      IF((TEST3.EQ.IXYZ).OR.(TEST3.EQ.ISPLIN)) GO TO 1010
      VL=21.
      IF (IRULE.EQ.1) VL=25.
      SS2=SSCAN(4)*VL
      IF(TEST3.EQ.IXY) GO TO 1001
      IF(TEST3.EQ.IYZ) GO TO 1002
      IF(TEST3.EQ.IZX) GO TO 1003
      IERROR=5001
      GO TO 9996
 1001 SSCAN(6)=1.0
      TY(1)=2.0
      TY(2)=2.0
      TY(3)=3.0
      IF(IRULE.EQ.1) TY(3)=4.0
      GO TO 1020
 1002 SSCAN(6)=2.0
      TY(1)=3.0
      IF(IRULE.EQ.1) TY(1)=4.0
      TY(2)=2.0
      TY(3)=2.0
      GO TO 1020
 1003 SSCAN(6)=3.0
      TY(1)=2.0
      TY(2)=3.0
      IF(IRULE.EQ.1) TY(2)=4.0
      TY(3)=2.0
      GO TO 1020
 1010 SSCAN(6)=4.0
      TY(1)=3.0
      TY(2)=3.0
      TY(3)=3.0
      VL=37.
      IF(IRULE.EQ.1) GO TO 1011
      SS2=NPH*VL
      GO TO 1020
 1011 TY(1)=4.0
      TY(2)=4.0
      TY(3)=4.0
      VL=49.
      SS2=SSCAN(4)*VL
 1020 SSCAN(8)=10.+SS2+SSCAN(3)+NPH*6.0
C
      CALL MESH(IERROR,IER,ITW,SSNAME,ASAV)
      IF(IERROR.GT.0) GO TO 9996
      IF (ITW .NE. 0 .OR.  IRULE .NE.1) GO TO 2200
      IRULE=0
      IF (TY(1).EQ.4.) TY(1)=3.
      IF (TY(2).EQ.4.) TY(2)=3.
      IF (TY(3).EQ.4.) TY(3)=3.
      IF (VL.EQ.49.) VL=37.
      IF (VL.EQ.25.) VL=21.
      SS2=SSCAN(4)*VL
      SSCAN(8)=10.+SS2+SSCAN(3)+SSCAN(4)*6.
 2200 CONTINUE
C---      POINTER TABLE  *  MESH *
      NN=NPH*6+10
      AK=0.
      TEMP=NN+1.0
      DO 1030 I=11,NN,6
      SSCAN(I)=TY(1)
      SSCAN(I+1)=TY(2)
      SSCAN(I+2)=TY(3)
      SSCAN(I+3)=1.0
      SSCAN(I+4)=TEMP+VL*AK
      SSCAN(I+5)=TEMP+SS2+4.0*AK
      AK=AK+1.
 1030 CONTINUE
      M=SSCAN(8)
      GO TO 3000
C
C---  REVOLV AND RULED PROCESSING FOLLOWS
 2500 CONTINUE
      NBASE=40
      NSIZE=CANON(NBASE+5)
      NCUR=NBASE+10
C---     CHECK FOR AVAILABLE SPACE FOR THIS SYNTHETIC CURVE
      N=CANON(NCUR+1)
C****    NOT ENOUGH SPACE IN BUFFER TO LOAD THIS CURVE
      IRR=1
      IF(N.GT.NSCNMX) GO TO 9997
C
      JMODE=2
      IF(CKDEF(CANON(NCUR))) GO TO 9997
      CALL APT094(JMODE,CANON(NCUR),SCAN)
C****     HAS THE CURVE BEEN SUCCESSFULLY RETRIEVED
      IRR=2
      IF(CKDEF(CANON(NCUR))) GO TO 9997
      NCUR=NCUR+2
C****     THE WORD AXIS MUST BE NEXT
      IRR=3
      IF(CANON(NCUR).NE.VAXIS) GO TO 9997
      NCUR=NCUR+2
      IF(TEST1.EQ.RULED) GO TO 2540
C****     CHECK FOR CORRECT GEOMETRIC DEFINITION OF AXIS
      IRR=4
      IF(CANON(NCUR).NE.VPOINT) GO TO 9997
      IF(CANON(NCUR+4).NE.VPOINT.AND.CANON(NCUR+4).NE.VVECTO) GO TO 9997
      DUM=0.
      IF(CANON(NCUR+4).EQ.VVECTO) DUM=1.
      DO 2510 I=1,3
      PA(I)=CANON(NCUR+I)
 2510 PB(I)=DUM*PA(I)+CANON(NCUR+4+I)
      NCUR=NCUR+8
C****     THE NEXT INPUT SHOULD BE ANGULAR SPAN
      IRR=5
      IF(CANON(NCUR).NE.VCLW.AND.CANON(NCUR).NE.VCCLW) GO TO 9997
      IF(CANON(NCUR).EQ.VCLW) ICCLW=1
      IF(CANON(NCUR).EQ.VCCLW) ICCLW=-1
      NCUR=NCUR+2
C****     TWO ANGLES SHOULD FOLLOW
      IRR=6
      IF(CANON(NCUR).NE.VSCALA.OR.CANON(NCUR+2).NE.VSCALA) GO TO 9997
      ANGA=CANON(NCUR+1)
      ANGB=CANON(NCUR+3)
      GO TO 2550
C--- CYLINDRICAL PROCESSING
 2540 CONTINUE
      IF(CANON(NCUR).EQ.VVECTO) GO TO 2560
C****     ARGUMENTS MUST BE ONE VECTOR OR TWO POINTS
      IRR=7
      IF(CANON(NCUR).NE.VPOINT. OR.CANON(NCUR+4).NE.VPOINT) GO TO 9997
      DO 2570 I=1,3
      PA(I)=CANON(NCUR+I)
 2570 PB(I)=CANON(NCUR+4+I)
      GO TO 2580
 2560 CONTINUE
      DO 2590 I=1,3
      PA(I)=0.0
 2590 PB(I)=CANON(NCUR+I)
C---    SET SPECIAL VALUES FOR CCLW INPUT
 2580 CONTINUE
      ICCLW=0
      ANGA=0.
      ANGB=90.
 2550 CONTINUE
C
C---   CONDUCT MAIN ANALYTIC PROCESSING FOR SURFACE
      CALL REVOLV(SCAN,PA,PB,ANGA,ANGB,ICCLW,IRR,SSCAN)
      IF(IRR.EQ.0) GO TO 3000
C
      IRR=IRR+350
      GO TO 9997
C
C---      CURVE BY CURVE TRANSFORM TYPE
 2600 CONTINUE
C---      FIRST FETCH BOTH CURVES AND LOAD INTO SCAN ARRAY
      NBASE=40
      NCUR=NBASE+10
      N=CANON(NCUR+1)
C****    NOT ENOUGH SPACE TO FETCH CURVE
      IRR=1
      IF(N.GT.NSCNMX) GO TO 2699
      JMODE=2
C****    CURVE NOT DEFINED
      IF(CKDEF(CANON(NCUR))) GO TO 2699
      JMODE=2
      CALL APT094(JMODE,CANON(NCUR),SCAN(1))
C****    CURVE COULD NOT BE FETCHED
      IRR=3
      IF(JMODE.NE.2) GO TO 2699
C****    THE WORD CROSS MUST BE NEXT
      CALL HOLFRM(CANON(NCUR+3),TEST,1,6,NWD)
      IF(TEST.NE.CROS) GO TO 2699
C---     LOAD THE CROSS CURVE NEXT
      LOCC=SCAN(12)+1.
C****    THERE IS NOT ENOUGH SPACE TO LOAD THE CROSS CURVE
      N=CANON(NCUR+5)
      IRR=4
      IF(N+LOCC.GT.NSCNMX) GO TO 2699
C****    CURVE NOT DEFINED
      IRR=5
      IF(CKDEF(CANON(NCUR+4))) GO TO 2699
      JMODE=2
      CALL APT094(JMODE,CANON(NCUR+4),SCAN(LOCC))
C****    FAILURE IN ATTEMPT TO FETCH CROSS CURVE
      IRR=6
      IF(JMODE.NE.2) GO TO 2699
C---      CURVES ARE READY, CALL TO GENERATE SURFACE
      CALL CTRANS(SCAN(1),SCAN(LOCC),KCTRX,MAXLDA,SSCAN(1),IRR)
      IF(IRR.EQ.0) GO TO 3000
      IRR=IRR+6
C---     COMMON ERROR JUNCTION FOR CURVE BY CURVE TRANSFORMS
 2699 IRR=IRR+370
      GO TO 9997
C
C
C---     PROCESSING FOR GENCUR TYPE SURFACE FOLLOWS.
C
 4000 CONTINUE
      CALL GENCRV(A,ARG1,ARG2,ARG3,IERROR)
C---     FILL IN UNDETERMINED HEADER ITEMS
C---     SIZE OF THE TOPOLOGY TABLE IS 4*NUMBER OF PATCHES
      SSCAN(3)=4.*SSCAN(4)
C---     SET SUBCLASS TO GENCUR SURFACE
      SSCAN(6)=6.
C---     TOTAL SIZE OF SURFACE IS SUM OF HEADER, POINTERS,
C---     VALUE TABLE AND TOPOLOGY TABLE
      SSCAN(8)=SSCAN(2)+SSCAN(3)+10.+6.*SSCAN(4)
      IF(IERROR.NE.0) GO TO 9996
      GO TO 3000
C
C---     PROCESS SSURF/COMBIN
 5000 CONTINUE
      CALL SRFCOM(ISPRNT,IRR)
      IF(IRR.NE.0) GO TO 9995
      A(2)=SSCAN(8)
C---     BYPASS CALL TO TOPGEN, SINCE TOPOLOGY TABLE HAS BEEN GENERATED
      GO TO 3002
C
C---     FINAL PROCESSING FOR ALL SURFACE TYPES
 3000 CONTINUE
      A(2)=SSCAN(8)
      NTOT=SSCAN(8)
      DO 3001 I=1,NTOT
      IF(DABS(SSCAN(I)).LT.SMAL) SSCAN(I)=ZERO
 3001 CONTINUE
C
      CALL TOPGEN(SSCAN(1))
C---     ADJUST TYPE POINTER FOR GENCUR CASE
C--- IN THE REVOLV,RULED CASE THE SURFACE IS TREATED AS A PATCH TYPE
C--- FOR TOPOLOGY TABLE GENERATION AND SUBSEQUENTLY AS A SIMPLE MESH
      IF(TEST1.NE.REVOL.AND.TEST1.NE.RULED.AND.KCTRX.EQ.0)
     X      GO TO 3006
      SSCAN(5)=2.0
      GO TO 3007
 3006 CONTINUE
      IF(TEST1.NE.GENCUR) SSCAN(2)=SS2
 3007 CONTINUE
C
      IF(.NOT.SSPRT) GO TO 3002
      IF(TEST1.EQ.GENCUR) GO TO 3002
      IF(TEST2.EQ.TRAF) GO TO 3002
      CALL SSPICT(SSCAN(1),SSNAME,ISPRNT)
C
 3002  IF(TEST2.EQ.TRAF) GO TO 3004
 3005  JMODE=1
      CALL APT094(JMODE,A(1),SSCAN(1))
      IRR=0
      IF(JMODE.NE.1) GO TO 9997
C
C----
      IF(TEST1.NE.GENCUR) GO TO 3003
      IF(.NOT.SSPRT) GO TO 3003
      CALL SSPICT(SSCAN(1),SSNAME,ISPRNT)
       GO TO 3003
 3004  CALL SSTRA(XMATRX(1),A(1),SSCAN(1),ISPRNT)
      IF(TEST1.EQ.GENCUR) GO TO 3003
       GO TO 3005
 3003 CONTINUE
C
      IF(IBUG.NE.11) GO TO 5011
C---     LIST SURFACE CANON FORM FOR DEBUGGING PURPOSES
      NTOT=SSCAN(8)
      CALL BAD(-NTOT,1,'CAN ',SSCAN)
 5011 CONTINUE
      GO TO 9999
C ERROR JUNCTION OF SRFCOM, NO WARNING POSSIBLE !!!!
 9995 IRR=IABS(IRR)+10
 9997 IERROR=5000+IRR
 9996 RNAME=RNAMA
      DO 8001 IL1=1,IMAX1
 8001 IF (IERROR.EQ.IZAL1(IL1)) RNAME=RNAM1
      DO 8002 IL2=1,IMAX2
 8002 IF (IERROR.EQ.IZAL2(IL2)) RNAME=RNAM2
      DO 8003 IL3=1,IMAX3
 8003 IF (IERROR.EQ.IZAL3(IL3)) RNAME=RNAM3
      DO 8004 IL4=1,IMAX4
 8004 IF (IERROR.EQ.IZAL4(IL4)) RNAME=RNAM4
      DO 8005 IL5=1,IMAX5
 8005 IF (IERROR.EQ.IZAL5(IL5)) RNAME=RNAM5
      DO 8006 IL6=1,IMAX6
 8006 IF (IERROR.EQ.IZAL6(IL6)) RNAME=RNAM6
      DO 8007 IL7=1,IMAX7
 8007 IF (IERROR.EQ.IZAL7(IL7)) RNAME=RNAM7
      DO 8008 IL8=1,IMAX8
 8008 IF (IERROR.EQ.IZAL8(IL8)) RNAME=RNAM8
      DO 8009 IL9=1,IMAX9
 8009 IF (IERROR.EQ.IZAL9(IL9)) RNAME=RNAM9
      DO 8010 I10=1,IMA10
 8010 IF (IERROR.EQ.IZA10(I10)) RNAME=RNA10
      DO 8011 I11=1,IMA11
 8011 IF (IERROR.EQ.IZA11(I11)) RNAME=RNA11
      CALL ERROR(IERROR,RNAME)
 9998 CONTINUE
      CALL UNDEF(A(1))
C
 9999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0004345.V14   ***
*
      SUBROUTINE APT108(A,A1,A2,A3)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---  PURPOSE  IS TO ACCEPT PART PROGRAMMERS INPUT FOR THE DEFINITION
C---  OF A SYNTHETIC CURVE AND PROCESS THIS  INTO  COONS RATIONAL
C---   PARAMETRIC CUBIC SEGMENTS.  THE PROCESSED DATA BASE IS THEN
C---   DISPLAYED ON THE VLFILE(SPRINT) AND SAVED(APT094) AS A LARGE DATA
C---  DATA ARRAY.
C---   A(3) INPUT  CONTAINS 1 AND 2 THE INTERNAL CANON FORM OF THE
C---               SYNTHETIC CURVE .  A(3) IS THE PP NAME
C---   BLANK COMMON CANON(41 THRU ... ) CONTAINS THE PART PROGRAMMERS
C---           INPUT STREAM
C---  SC IS THE WORK ARRAY WHICH IS USED TO BUILD UP THE ANALYTIC DEFIN
C---               ITION OF THE CURVE
C
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
C
      INCLUDE (TOTAL)    
C
C
      DIMENSION A(*)
C
      INCLUDE (BLANKCOM)    
C
C---     SC(4,6,31) HOLDS BASIC CURVE, REST HOLDS FLOW EDITED INPUT
C
      INCLUDE (SSPAD)    
      DIMENSION SC(4,6,32)
      EQUIVALENCE (SCAN(1),SC(1,1,1))
C
      DIMENSION XMATRX(12)
C
      DIMENSION SCI(72),SCB(24),SCV0(24),SCV1(24),SCV2(24)
      EQUIVALENCE (SCI(1),SC(1,1,1)),(SCB(1),SC(1,1,4)),
     * (SCV0(1),SC(1,1,5)),(SCV1(1),SC(1,1,6)),(SCV2(1),SC(1,1,7))
C
      LOGICAL CKDEF
      INCLUDE (SYMFIL)    
      COMMON/SSPRT/SSPRT,SSTEST
      LOGICAL SSPRT,SSTEST
      INTEGER IZAL1(9),IZAL2(5),IZAL3(10),IZAL4(6)
      CHARACTER*8 RNAM1,RNAM2,RNAM3,RNAM4,RNAMA,RNAME,BLA,SUBSC
      CHARACTER*6 CURSEG,SPLINE,COMBIN,END,TRAF,TEST,TEST1,TEST2
      CHARACTER*16 SCNAME
C
      DOUBLE PRECISION LENGTH,LIMIT,NORMAL
C
C---     THE FOLLOWING ARRAY IS SHARED FOR PRINTING
      INCLUDE (DARRAY)    
C
      DATA MAXNOP/30/
      DATA NHD/1/
      DATA POINT /19./
      DATA VECTOR/20./
      DATA AREAL /21./
      DATA TANSPL/136./
      DATA CRSSPL/137./
      DATA NORMAL/013./
      DATA WEIGHT/138./
      DATA LIMIT /139./
      DATA CURSEG/'CURSEG'/
      DATA SPLINE/'SPLINE'/
      DATA COMBIN/'COMBIN'/
      DATA END/'END   '/
      DATA TRAF/'TRFORM'/
      DATA ZERO,ONE,SMAL,BIG/0.0D0, 1.0D0, 1.0D-7, 99999999.0D0/
      DATA SMAL1,SMAL2/1.D-5,1.D-3/
      DATA SUBSC/' (     )'/
C
      DATA BLA/'        '/
C
      DATA    RNAM1   /'APT108  '/,RNAM2   /'SCURV   '/,
     *          RNAM3   /'SSPLIN  '/,RNAM4   /'SMOOTH  '/,
     *          RNAMA   /'APT108??'/,RNAME   /'        '/
      DATA IMAX1/ 9/, IZAL1
     *                    / 5121, 5122, 5123, 5124, 5125,
     *                      5126, 5127, 5128, 5129/
      DATA IMAX2/ 5/, IZAL2
     *                    / 5751, 5752, 5760, 5770, 5771/
      DATA IMAX3/10/, IZAL3
     *                    / 5901, 5902, 5903, 5904, 5905,
     *                      5906, 5907, 5908, 5909, 5910/
      DATA IMAX4/ 6/, IZAL4
     *                    / 5921, 5922, 5923, 5924, 5925,
     *                      5926/
C
      CALL HOLFRM(A(3),SCNAME,1,8,NWD)
      SCNAME(9:16)=BLA
C---     IF SUBSCRIPT IS BIGGER  THAN ONE, ONLY SUBCRIPT IS SHOWN
      CALL UNPACK(A(1),MODE,ISIZE,ISUB)
      IF(ISUB.LT.1)GOTO 8
      SCNAME(9:16)=SUBSC
      CALL ICONV(ISUB,SCNAME,10,4)
      CALL HOLFRM(A(ISUB*ISIZE+ISUB),SCNAME,1,8,NWD)
    8 CONTINUE
      NP=0
      NH=41
      NHD1=NHD+1
      NSIZE=CANON(NH+4)+39
      NSZSAV=NSIZE
      M1=MAXNOP+NHD
      NS=NH+8
C
C...SET TEST1 & TEST2 TO BE CHARACTER EQUIVALENTS OF A1 & A2.
      CALL HOLFRM(A1,TEST1,1,6,NWD)
      CALL HOLFRM(A2,TEST2,1,6,NWD)
C
C---      FETCH THE TRFORM MATRIX IF PRESENT AND THEN TRUNCATE
C---      THE LENGTH OF INPUT DATA TO IGNORE THE TRAILING MATRIX
      IF(TEST2.NE.TRAF) GO TO 9
      L=CANON(45)-12-1+40
      DO 7 I=1,12
      XMATRX(I)=CANON(L+I)
    7 CONTINUE
      NSIZE=NSIZE-14
      NSZSAV=NSIZE
    9 CONTINUE
C
C---      SCAN INPUT STREAM FOR FLOW/SEG DATA.  IF FOUND IFLSEG=1 ELSE 0
      CALL FLOSEG(NSIZE,NSZSAV,1,IFLSEG,IRR)
      IF(IRR.NE.0) GO TO 995
C
C
C---    NOW REDUCE SIZE PARAMETER SINCE ALL FLOW/SEGMENT
C---     INFORMATION HAS BEEN STORED IN THE STEMP BUFFER
      NSIZE=NSZSAV
C
C
C---     NORMAL PHYSICAL SHAPE OF CURVE IS PROCESSED NOW
C--------------------------------------------------------
C---     BRANCH TO SPECIAL PROCESSING FOR MODE COMBINE.
      IF(TEST1.EQ.COMBIN) GO TO 3000
C
C----     SCAN AND ORGANIZE INPUT DATA FOR SPLINE OR CURSEG DEFN.
C--- INITIALIZE THE SCRATCH PAD AREA FOR A CURVE
      DO 1 L=1,M1
      DO 2 K=1,6
      DO 2 J=1,4
    2 SC(J,K,L)=ZERO
      IF(L.GT.NHD) SC(1,5,L)=ONE
      IF(L.GT.NHD) SC(2,5,L)=ZERO
    1 CONTINUE
C****  FIRST WORD MUST BE SPLINE OR CURSEG
      SC(2,1,1)=NHD
      IRR=1
      CALL HOLFRM(CANON(NS),TEST,1,6,NWD)
      IF(TEST.NE.SPLINE.AND.TEST.NE.CURSEG) GO TO 998
      IF(TEST.EQ.SPLINE) SC(3,1,1)=2.0
      IF(TEST.EQ.CURSEG) SC(3,1,1)=3.0
      NS=NS+1
C
   10 CONTINUE
      T=CANON(NS)
      CALL HOLFRM(T,TEST,1,6,NWD)
      IF(TEST.EQ.END.OR.NS.GT.NSIZE) GO TO 1000
      IF(T.EQ.POINT) GO TO 100
      IF(T.EQ.TANSPL.OR.T.EQ.CRSSPL.OR.T.EQ.NORMAL) GO TO 200
      IF(T.EQ.WEIGHT) GO TO 300
      IF(T.EQ.LIMIT) GO TO 400
C****  ILLEGAL TERM IN INPUT STREAM
      IRR=2
      GO TO 998
C---   PROCESS AN INPUT POINT
  100 CONTINUE
      NP=NP+1
      IRR=3
      IF(NP.GT.MAXNOP) GO TO 998
      DO 110 L=1,3
  110 SC(L,1,NP+NHD)=CANON(NS+L)
      NS=NS+4
C
      GO TO 10
C---  PROCESS VECTOR CONSTRAINTS
  200 CONTINUE
C****  IF NO POINTS HAVE BEEN ENTERED, QUIT
      IRR=4
      IF(NP.EQ.0) GO TO 998
      K=2
      IF(T.EQ.CRSSPL) K=3
      IF(T.EQ.NORMAL) K=4
C***   GEOMETRIC ENTRY SHOULD BE A VECTOR
      IRR=5
      IF(CANON(NS+2).NE.VECTOR) GO TO 998
      DO 210 L=1,3
  210 SC(L,K,NP+NHD)=CANON(NS+L+2)
      SC(4,K,NP+NHD)=ONE
      NS=NS+6
C
      GO TO 10
  300 CONTINUE
C****  GEOMETRIC ARGUMENT MUST BE REAL
      IRR=6
      IF(CANON(NS+2).NE.AREAL) GO TO 998
      WT=DMAX1(SMAL,CANON(NS+3))
      WT=DMIN1(ONE,WT)
      SC(1,5,NP+NHD)=WT
      NS=NS+4
C
      IF(NP.GT.0) GO TO 10
C---   IF WEIGHT COMES BEFORE THE FIRST POINT, THIS WEIGHT IS APPLIED
C---  TO ALL POINTS
      DO 350 I=NHD1,M1
  350 SC(1,5,I)=WT
C
      GO TO 10
C---  PROCESS INPUT LIMIT CONSTRAINT
  400 CONTINUE
C****  GEOMETRIC ARGUMENT MUST BE REAL
      IRR=6
      IF(CANON(NS+2).NE.AREAL) GO TO 998
      AL=DMAX1(ZERO,CANON(NS+3))
      AL=DMIN1(BIG,AL)
      SC(2,5,NHD+NP)=AL
      NS=NS+4
C
      IF(NP.GT.0) GO TO 10
      DO 450 I=NHD1,M1
  450 SC(2,5,I)=AL
C
      GO TO 10
C---   INPUT HAS BEEN FORMALLY LOADED INTO THE SC ARRAY
C---  NOW CALL FOR ANALYTIC PROCESSING
 1000 CONTINUE
      SC(4,1,1)=NP
C
      IF(SSPRT.AND.SSTEST) CALL SCPICT(SC,SCNAME,0)
C
      CALL SCURV(SC,IRR)
      IF(IRR.NE.0) IERROR=IRR
      IF(IRR.NE.0) GO TO 996
C
C---   MOVE THE CURVE DATA FROM THE SCRATCH AREA TO BLANK COMMON
      KKC=40
      NPPLUS=NP+SC(2,1,1)
      DO 9020 K=1,NPPLUS
      DO 9020 J=1,6
      DO 9020 I=1,4
      KKC=KKC+1
 9020 CANON(KKC)=SC(I,J,K)
C
      GO TO 9000
C
C---      FETCH ALL CURVES FROM A SCURV/COMBIN COMMAND
C---      NOTE LOGIC FOR TREATMENT OF CONFLICTING CRSSPL AND NORMAL
C---      CONSTRAINT VECTORS AT CURVE JUNCTIONS.
 3000 NP=CANON(NH+3)
      K=0
      DO 3100 I=NS,NSIZE
      K=K+1
 3100 SCI(K)=CANON(I)
      NS=NH
      I=1
      NBLK=0
 4000 II=2*I-1
      JMODE=2
      IRR=7
      IF(CKDEF(SCI(II))) GO TO 998
C
C---     READ IN THE NEXT CURVE FROM THE INPUT STREAM.
C
      CALL APT094(JMODE,SCI(II),CANON(NS))
C****
C****    CURVES WITH A FLOW RATE CANNOT BE COMBINED YET
C***      AT MOST ONE FLOW CURVE CAN BE COMBINED AT PRESENT
      IF(I.GT.1.AND.CANON(NS+2).GT.9.0) GO TO 998
      NS1=NS
      NS2=NS+24
      NBLK1=CANON(NS+3)
      NBLK=NBLK+NBLK1
      NS=NBLK1*24+NS
      IF(I.EQ.1) GO TO 3200
C
      CALL CNCURV(ZERO,CANON(NS2),SCV1,1)
      SCV2(1)=DABS(SCV1(1)-SCV0(1))
      SCV2(2)=DABS(SCV1(2)-SCV0(2))
      SCV2(3)=DABS(SCV1(3)-SCV0(3))
      DDMAX=DMAX1(SCV2(1),SCV2(2),SCV2(3))
C****
      IRR=8
      IF(DDMAX.GT.SMAL1) GO TO 998
      IF(DDMAX.LT.SMAL) GO TO 3300
      DDMAX=CANON(NS2+12)
      CANON(NS2)=SCV0(1)*DDMAX
      CANON(NS2+4)=SCV0(2)*DDMAX
      CANON(NS2+8)=SCV0(3)*DDMAX
 3300 DDMAX=DABS(SCV0(13)*SCV1(13)+SCV0(14)*SCV1(14)
     *   +SCV0(15)*SCV1(15)-ONE)
C****
      IRR=9
      IF(DDMAX.GT.SMAL2) GO TO 998
C
 3400 DO 3600 J=20,24,4
      IF(DABS(SCB(J)).GT.SMAL) GO TO 3600
      IF(DABS(CANON(NS1+J-1)).LT.SMAL) GO TO 3600
      DO 3500 K=1,4
 3500 SCB(J+K-4)=CANON(NS1+J+K-5)
 3600 CONTINUE
      DO 3700 K=1,24
 3700 CANON(NS1+K-1)=SCB(K)
 3200 I=I+1
      IF(I.GT.NP) GO TO 3800
      DO 3900 K=1,24
 3900 SCB(K)=CANON(NS+K-1)
      CALL CNCURV(ONE,SCB,SCV0,1)
      GO TO 4000
C
 3800 CANON(NH+3)=NBLK
      CANON(NH+2)=4.
C
C---     NORMAL PHYSICAL SHAPE OF CURVE HAS NOW BEEN GENERATED
C---     FLOW/SEGMENTATION PROCESSING NOW FOLLOWS.
C
 9000 CONTINUE
      CANON(NH+4)=CANON(NH+1)*24.+ONE
C---     NOW ZERO OUT PART OF THE HEADER TABLE CAREFULLY
      NN=10
      DO 1005 I=1,NN
      CANON(NH+I+5)=ZERO
 1005 CONTINUE
C
C---     IF NO FLOW INPUT IS AVAILABLE, SAVE THE CURVE DATA
C---     ON AN EXTERNAL FILE
      IF(IFLSEG.EQ.0) GO TO 9010
C
      CALL FLOSEG(NSIZE,NSZSAV,2,IFLSEG,IRR)
      IF(IRR.NE.0) GO TO 995
C
C
 9010 CONTINUE
C---     SAVE SURFACE ON EXTERNAL FILE
C---      FIRST SAVE THE SIZE OF THE ARRAY IN THE INTERNAL FORM
C
      CANON(NH+4)=CANON(NH+1)*24.+ONE
      IF(CANON(NH+7).LT.SMAL) CANON(NH+11)=(CANON(NH+1)+CANON(NH+3))*24.
      IF(CANON(NH+7).LT.SMAL) CANON(NH+12)=ONE
C
      A(2)=CANON(NH+11)
 6100 CONTINUE
C
C   BESTIMMUNG DER APT-RECORD-NR.
      IREC=-5
      CALL TAPOP(AXFILE,IREC)
      CANON(NH)=IREC
      ISPRNT=2
      IF(SSTEST) ISPRNT=3
      IF(SSPRT) CALL SCPICT(CANON(NH),SCNAME,ISPRNT)
      IF(TEST2.EQ.TRAF)CALL SCTRA(XMATRX(1),A(1),CANON(NH),ISPRNT)
      KKMODE=1
      CALL APT094(KKMODE,A,CANON(NH))
      IRR=0
C
C---     SET THE MODE FOR LEVEL OF VERIFICATION PRINT
      GO TO 9999
C
C****    AREA OF CODE TO HANDLE MOST ERROR MESSAGES AND TERMINATIONS
  998 CONTINUE
      IERROR=5120+IRR
  996 RNAME=RNAMA
      DO 7001 IL1=1,IMAX1
 7001 IF (IERROR.EQ.IZAL1(IL1)) RNAME=RNAM1
      DO 7002 IL2=1,IMAX2
 7002 IF (IERROR.EQ.IZAL2(IL2)) RNAME=RNAM2
      DO 7003 IL3=1,IMAX3
 7003 IF (IERROR.EQ.IZAL3(IL3)) RNAME=RNAM3
      DO 7004 IL4=1,IMAX4
 7004 IF (IERROR.EQ.IZAL4(IL4)) RNAME=RNAM4
      CALL ERROR(IERROR,RNAME)
      IF(IRR.EQ.9) GOTO 3400
      IF(TEST1.EQ.COMBIN) GO TO  995
C
      IF(SSPRT.AND.SSTEST) CALL SCPICT(SC,SCNAME,1)
  995 CONTINUE
      CALL UNDEF(A(1))
C
C****    TERMINATION OF ERROR HANDLING CODE
C
C---    QUIT PROCESSING HERE
 9999 CONTINUE
C
      IF(IBUG.NE.11) GO TO 9711
C---      DUMP THE ENTIRE SCURV ARRAY
      NTOP=CANON(NH+11)+NH-1
      NBOT=NH
      DO 9712 I=NBOT,NTOP,4
      IF(MOD(I-NBOT,24).EQ.0) CALL BAD(-1,0,' ',0)
      CALL BAD(-4,1,'CANN',CANON(I))
 9712 CONTINUE
 9711 CONTINUE
C
      RETURN
      END
**** SOURCE FILE : M0001030.V01   ***
*
      SUBROUTINE ADER(DIF,TA,TB,A,B,U,MODE,AREA)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---      PURPOSE IS TO COMPUTE TENSION AND FIRST AND SECOND
C---      PARTIAL DERIVATIVES OF TENSION WITH RESPECT TO A AND B
C---      INPUT CONSISTS OF THE FOLLOWING
C---      CHORD VECTOR DIF OF PARAMETRIC CUBIC
C---      FIRST TANGENT A*TA AND LAST TANGENT VECTOR B*TB
C---      U=PARAMETRIC VALUE AT WHICH TO EVALUATE TENSION
C---      MODE=1 ON FIRST ENTRY -- SETUP SOME INVARIANT VALUES
C---      MODE=0 ON SUBSEQUENT ENTRIES.
C---      OUTPUT IS PLACED IN AREA (1 - 6) AS FOLLOWS.
C---      AREA(1) = K*K*DS WHERE K=CURVATURE AND DS=RATE OF CHANGE
C---      OF ARC LENGTH WITH RESPECT TO COONS PARAMETER U.
C---      AREA(2)= PARTIAL WRT A OF AREA(1)
C---      AREA(3)= PARTIAL WRT B OF AREA(1)
C---      AREA(4)= PARTIAL WRT TO A TWICE OF AREA(1)
C---      AREA(5)= PARTIAL WRT TO A AND B OF AREA(1)
C---      AREA(6)= PARTIAL WRT TO B TWICE OF AREA(1)
C
      DIMENSION AREA(6),DIF(3),TA(3),TB(3)
      DIMENSION TAB(3),TAD(3),TBD(3),CA(3),CB(3)
      DIMENSION CV(16),CURV(16)
C
      DATA ZERO,ONE,BIG,SMAL/0.0D0,1.0D0,1.0D+8,1.0D-8/
C
      IF(MODE.EQ.0) GO TO 100
C---IF MODE IS 1 THIS IS FIRST PASS THRU ADER
C---COMPUTE INVARIANT DATA FOR THIS AND SUBSEQUENT CALLS
C---SET UP COONS CANNON FORM OF CURV
      DO 10 I=1,3
      I1=4*(I-1)+1
      CURV(I1)=ZERO
      CURV(I1+1)=DIF(I)
      CURV(I1+2)=A*TA(I)
      CURV(I1+3)=B*TB(I)
   10 CONTINUE
      DO 20 I=1,2
      CURV(12+I)=ONE
   20 CURV(14+I)=ZERO
      CALL CROSS(TA,TB,TAB)
      CALL CROSS(TA,DIF,TAD)
      CALL CROSS(TB,DIF,TBD)
C
  100 CONTINUE
C---COMPUTE COEFFICIENTS OF DR X DDR WHERE DR X DDR=
C---  XG*A*B*TAB + XH * A * TAD + XK * B * TBD
      XG=-2.+6.*U-6.*U**2
      XH=6.*(ONE-U)**2
      XK=-6.*U**2
C---COMPUTE CURVE COEFFICIENTS
      CALL CNCURV(U,CURV,CV,2)
C
      CALL CROSS(CV(5),CV(9),CV(13))
C---COMPUTE DERIVATIVE FRAGMENTS OF DR X DDR
      DO 120 I=1,3
      CA(I)=B*TB(I)*XG+DIF(I)*XH
      CB(I)=-A*TA(I)*XG+DIF(I)*XK
  120 CONTINUE
      CALL CROSS(TA,CA,CA)
      CALL CROSS(TB,CB,CB)
C---COMPUTE ALL PARTIAL DERIVATIVES OF (DR X DDR )**2 WRT A NND B
      X=VDOTF(CV(13),CV(13))
      XA=2.*VDOTF(CV(13),CA)
      XB=2.*VDOTF(CV(13),CB)
      XAA=2.*VDOTF(CA,CA)
      XAB=2.*(VDOTF(CA,CB)+VDOTF(CV(13),TAB)*XG)
      XBB=2.*VDOTF(CB,CB)
C
C---NEXT COMPUTE ALL PARTIAL DERIVATIVES OF (DR**2)**(-5/2)
      DRSQ=VDOTF(CV(5),CV(5))
      DRSQ=DMIN1(BIG,DRSQ)
      DRSQ=DMAX1(SMAL,DRSQ)
      RECIP=1./DSQRT(DRSQ)
      Y=RECIP**5
      FAC=5.*RECIP**7
      QA=1.-4.*U+3.*U**2
      QB=-2.*U+3.*U**2
      DO 130 I=1,3
      CA(I)=TA(I)*QA
      CB(I)=TB(I)*QB
  130 CONTINUE
C---COMPUTE INPUT DOT PRODUCTS
      CALL DOTF(RPRA,CV(5),CA)
      CALL DOTF(RPRB,CV(5),CB)
      CALL DOTF(RARB,CA,CB)
      CALL DOTF(RASQ,CA,CA)
      CALL DOTF(RBSQ,CB,CB)
      YA=-FAC*RPRA
      YB=-FAC*RPRB
C---COMPUTE SECOND ORDER PARTIALS OF Y WRT A AND B
      YAA=FAC*(7.*RPRA**2/DRSQ-RASQ)
      YBB=FAC*(7.*RPRB**2/DRSQ-RBSQ)
      YAB=FAC*(7.*RPRA*RPRB/DRSQ-RARB)
C
C---COMPUTE PARTIALS OF X*Y WRT TO A AND B AND RETURN
      AREA(1)=X*Y
      AREA(2)=XA*Y+X*YA
      AREA(3)=XB*Y+X*YB
      AREA(4)=XAA*Y+2.*XA*YA+2.*X*YAA
      AREA(6)=XBB*Y+2.*XB*YB+2.*X*YBB
      AREA(5)=XAB*Y+XA*YB+XB*YA+X*YAB
C
      RETURN
      END
**** SOURCE FILE : M0002659.V03   ***
*
      SUBROUTINE ANGDER(CV,P,AN,DER,MODE,IRR)
C---     PURPOSE IS TO CALCULATE RATES OF CHANGE OF ANGLE FROM
C---     POINT P TO CURVE AT POINT CV.
C     INPUT CV POINT, FIRST DERIVATIVE, SECOND DERIVATIVE OF CURVE
C     INPUT P=CENTRAL POINT FROM WHICH ANGLE IS CALCULATED
C     INPUT AN(OPTIONAL) IS A PLANAR NORMAL IN CASE ANGLE IS
C            TO BE MEASURED IN A PLANE.
C     INPUT MODE IS 0 ON FIRST CALL, NON-ZERO ON OTHER CALLS.
C     OUTPUT DER ARRAY CONTAINING CURRENT ANGLE AND RATES OF CHANGE
C     OUTPUT IRR NON ZERO ON OUTPUT INDICATES AN ERROR.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION CV(16),P(3),AN(3),DER(3)
      DIMENSION T(3),V(3),VP(3),VPP(3)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
      DATA ZERO,ONE,SMAL,VSMAL/0.0D0,1.0D0,1.0D-6,1.0D-20/
C
      IF(MODE.NE.0) GO TO 100
C---     FIRST CHECK AN - NORMALIZE IF NOT ZERO.
      W=DSQRT(AN(1)*AN(1)+AN(2)*AN(2)+AN(3)*AN(3))
      IF(W.GT.SMAL) GO TO 20
C---     ZERO OUT AN COMPLETELY
      AN(1)=ZERO
      AN(2)=ZERO
      AN(3)=ZERO
      WN=ZERO
      GO TO 30
   20 CONTINUE
C---     NORMALIZE AN
      AN(1)=AN(1)/W
      AN(2)=AN(2)/W
      AN(3)=AN(3)/W
      WN=(CV(1)-P(1))*AN(1)+(CV(2)-P(2))*AN(2)+(CV(3)-P(3))*AN(3)
   30 CONTINUE
      W=ZERO
      DO 25 I=1,3
      W=W+(CV(I)-P(I))**2
   25 CONTINUE
      W=DSQRT(W)
      IRR=19
      IF(W.LT.SMAL) GO TO 999
      W=ZERO
      DO 40 I=1,3
      T(I)=(CV(I)-P(I))-WN*AN(I)
      W=W+T(I)*T(I)
   40 CONTINUE
      W=DSQRT(W)
      IRR=11
      IF(W.LT.SMAL) GO TO 999
C---      T IS THE BASE VECTOR FOR MEASURING ANGLE
      T(1)=T(1)/W
      T(2)=T(2)/W
      T(3)=T(3)/W
  100 CONTINUE
C
C---     NOW COMPUTE ANGLE W AND DERIVATIVES FROM GENERAL FORMULA
C---     COS(ANGLE)=(V,T)/DSQRT(V,V) WHERE V=CV-(CV-P,AN)AN.
C
      C=ZERO
      CP=ZERO
      CPP=ZERO
      DO 110 I=1,3
      C=C+(CV(I)-P(I))*AN(I)
      CP=CP+CV(I+4)*AN(I)
      CPP=CPP+CV(I+8)*AN(I)
  110 CONTINUE
      DO 120 I=1,3
      V(I)=CV(I)-P(I)-C*AN(I)
      VP(I)=CV(I+4)-CP*AN(I)
      VPP(I)=CV(I+8)-CPP*AN(I)
  120 CONTINUE
C---     CALCULATE NECESSARY INNER PRODUCTS
      VV=ZERO
      VT=ZERO
      VVP=ZERO
      VVPP=ZERO
      VPT=ZERO
      VPPT=ZERO
      VPVP=ZERO
C
      DO 130 I=1,3
      VV=VV+V(I)*V(I)
      VVP=VVP+V(I)*VP(I)
      VVPP=VVPP+V(I)*VPP(I)
      VT=VT+V(I)*T(I)
      VPT=VPT+VP(I)*T(I)
      VPPT=VPPT+VPP(I)*T(I)
      VPVP=VPVP+VP(I)*VP(I)
  130 CONTINUE
C---     NOW CALCULATE RATES OF CHANGE OF W=1/DSQRT(V,V)
      W=DSQRT(VV)
      IRR=12
      IF(W.LT.SMAL) GO TO 999
      W=ONE/W
      W3=W*W*W
      WP=-VVP*W3
      WPP=3.*W3*W*W*VVP*VVP
      WPP=WPP-W3*(VPVP+VVPP)
      C=VT*W
      C=DMIN1(C,ONE)
      C=DMAX1(C,-ONE)
      DER(1)=DARCOS(C)
      SS=DSIN(DER(1))+VSMAL
      IF(DABS(SS).GT.SMAL) GO TO 140
C---      DEGENERATE CASE, USE LHOSPITALS RULE.
      DER(2)=-(VPPT*W+2.0*VPT*WP+VT*WPP)/C
      DER(2)=DABS(DER(2))
      DER(2)=DSQRT(DER(2))
C---      THE FOLLOWING IS A ROUGH CUT AT SECOND DERIVATIVE.
      DER(3)=3.0*(VPPT*WP+VPT*WPP)
      DER(3)=(SS*DER(2)**3-DER(3))/(2.*C*(DER(2)+VSMAL))
      GO TO 150
  140 CONTINUE
      DER(2)=-(VPT*W+VT*WP)/SS+VSMAL
      DER(3)=VPPT*W+2.0*VPT*WP+VT*WPP+VT*W*(DER(2))**2
      DER(3)=-(DER(3))/SS
  150 CONTINUE
      IRR=0
  999 CONTINUE
      IF(IBUG.NE.11) GO TO 997
      CALL BAD(-3,1,'DER ',DER)
  997 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001031.V03   ***
*
      SUBROUTINE ANGSEG(C,FL,TOLR,NUM,NUMAX,IRR,P,AN)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C---     PURPOSE IS TO REPARAMETERIZE A COONS RATIONAL CUBIC ARC
C---     C BASED ON PROPORTION OF ANGLE FROM A CENTRAL POINT P.
C---     THE ANGLE WILL BE MEASURED IN A PLANE THRU P WITH NORMAL
C---     VECTOR AN IF AN IS NON-ZERO.
C---     INPUT C=COONS RATIONAL PARAMETRIC COEFFICIENTS
C---     INPUT TOLR=TOLERANCE FACTOR FOR FLOW RATE FIT(DEFAULT=.001)
C---     INPUT P=CENTRAL POINT FOR CALCULATION OF ANGULAR FLOW
C---     INPUT AN=OPTIONAL NORMAL VECTOR FOR MEASUREMENT OF ANGLE
C---           IN A SPECIFIED PLANE. AN=(0,0,0) FOR NO PLANE.
C---     OUTPUT FL=STRING OF CUBICS REPRESENTING NEW FLOW RATE
C---            THESE CUBICS EXPRESS COONS PARAMETER AS A FUNCTION OF AN
C---     OUTPUT NUM=NUMBER OF CUBICS+1 WHICH DETERMINE FLOW RATE.
C---     OUTPUT IRR=0 FOR NO ERROR, NON-ZERO FOR ERROR
C---     INPUT NUMAX=MAXIMUM NUMBER OF CUBICS PERMITTED IN FL ARRAY.
C
      DIMENSION C(16),FL(4,1),P(3),AN(3)
      DIMENSION CV(16),DER(3)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
      DATA ZERO,ONE,SMAL,VSMAL,HALF/0.0D0,1.0D0,1.0D-6,1.0D-30,0.5D0/
      NOW=1
      ANGLEN=ZERO
      UNOW=ZERO
      CALL CNCURV(UNOW,C,CV,1)
C---     COMPUTE RATES OF CHANGE OF ANGLE WRT COONS AND INVERT.
      CALL ANGDER(CV,P,AN,DER,0,IRR)
      IF(IRR.NE.0) GO TO 999
      FL(1,NOW)=DER(1)+VSMAL
      FL(2,NOW)=UNOW
      FL(3,NOW)=ONE/DER(2)
      FL(4,NOW)=-DER(3)/DER(2)**3
C
      CNOW=FL(1,NOW)
      UNX=.76
   40 CONTINUE
      ICHK=1
   50 CONTINUE
      CALL CNCURV(UNX,C,CV,1)
      NX=NOW+1
C---     COMPUTE RATES OF CHANGE OF ANGLE WRT COONS AND INVERT.
      CALL ANGDER(CV,P,AN,DER,1,IRR)
      IF(IRR.NE.0) GO TO 999
      FL(1,NX)=DER(1)+VSMAL
      FL(2,NX)=UNX
      FL(3,NX)=ONE/DER(2)
      FL(4,NX)=-DER(3)/DER(2)**3
C
C---     FIRST CHECK ACCURACY OF SPLINE REPRESENTATION
      DEL1=FL(1,NX)-CNOW
      DEL2=3.*(FL(2,NX)-FL(2,NOW))*(FL(4,NX)+FL(4,NOW))
      DV=FL(4,NX)*(2.*FL(3,NOW)+FL(3,NX))+FL(4,NOW)*(FL(3,NOW)+2.*
     X   FL(3,NX))
      IF(DABS(DV).LT.VSMAL) GO TO 59
      DEL2=DEL2/DV
C---     IF SECOND DERIVATIVES VANISH, ANOTHER FORMULA IS NEEDED
      GO TO 60
   59 CONTINUE
      DEL2=ZERO
      IF(DABS(FL(3,NOW)).GT.VSMAL*SMAL) DEL2=ONE/FL(3,NOW)
      IF(DABS(FL(3,NX)).GT.VSMAL*SMAL) DEL2=DEL2+ONE/FL(3,NX)
      IRR=10
      IF(DEL2.EQ.ZERO) GO TO 999
   60 CONTINUE
C
C---     COMPARE ACCURACY OF ACTUAL AND ESTIMATED CHORD LENGTH.
      DIF=(DEL2-DEL1)/DEL1
      IF(IBUG.NE.11) GO TO 22
      CALL BAD(-4,1,'FLNW',FL(1,NOW))
      CALL BAD(-4,1,'FLNX',FL(1,NX))
      CALL BAD(1,1,'DEL1',DEL1)
      CALL BAD(1,1,'DEL2',DEL2)
      CALL BAD(-1,1,'DIF ',DIF)
   22 CONTINUE
      IF(DABS(DIF).GT.TOLR) GO TO 100
C---     ACCURACY IS ACCEPTABLE, IS SPLINE ALSO INCREASING THO.
      IF(FL(2,NX).LE.FL(2,NOW)) GO TO 100
      IF(FL(3,NOW).LT.ZERO) GO TO 100
      IF(FL(3,NX).LT.ZERO) GO TO 100
C---     NOW CHECK FOR A MAX OR MIN WITHIN THE INTERVAL
      A=FL(3,NOW)*DEL1
      B=FL(3,NX)*DEL1
      AA=3.*(B+A-2.*(FL(2,NX)-FL(2,NOW)))+VSMAL
      BB=2.*(3.*(FL(2,NX)-FL(2,NOW))-2.*A-B)
      CC=A
      DISC=BB*BB-4.*AA*CC
      IF(IBUG.NE.11) GO TO 33
      CALL BAD(-1,0,' ',0)
      CALL BAD(1,1,'AA  ',AA)
      CALL BAD(1,1,'BB  ',BB)
      CALL BAD(1,1,'CC  ',CC)
      CALL BAD(-1,1,'DISC',DISC)
   33 CONTINUE
      IF(DISC.LT.ZERO) GO TO 90
      DISC=DSQRT(DISC)
      R=(-BB-DISC)/(2.*AA)
      IF(DABS(R-HALF).LT.HALF) GO TO 100
      R=(-BB+DISC)/(2.*AA)
      IF(DABS(R-HALF).LT.HALF) GO TO 100
   90 CONTINUE
C---     FUNCTION MEETS ALL CRITERIA, SO GO AFTER THE NXT ARC
      NOW=NOW+1
      CNOW=FL(1,NOW)
      FL(1,NOW)=DEL2+ANGLEN
      ANGLEN=ANGLEN+DEL2
      UDEL=UNX-UNOW
      UNOW=UNX
      UNX=UNOW+4.0*UDEL
      UNX=DMIN1(ONE,UNX)
      IF(UNOW.GT.ONE-SMAL) GO TO 500
      IRR=8
      IF(NOW.GT.NUMAX-2) GO TO 999
      GO TO 40
C---     DECREASE UNX AND TRY AGAIN
  100 CONTINUE
C---      RECOVER SECOND DERIVATIVE FOR FIRST POINT
      IF(UNOW.GT.SMAL) GO TO 110
      HDEL=(FL(1,NX)-FL(1,NOW))/2.0
      HDEL2=(HDEL*HDEL)/2.0
      FL(4,NOW)=(FL(2,NX)-FL(2,NOW)-HDEL*(FL(3,NOW)+FL(3,NX))
     X           +HDEL2*FL(4,NX))/HDEL2
  110 CONTINUE
      UNX=(UNOW+UNX)*HALF
      ICHK=ICHK+1
      IRR=9
      IF(ICHK.GT.10) GO TO 999
      GO TO 50
C
  500 CONTINUE
      IRR=0
      FL(2,NOW)=ONE
C---     TRANSLATE FLOW RATES TO ORIGIN
      NUM=NOW
      DIF=FL(1,1)
      DO 510 I=1,NUM
      FL(1,I)=FL(1,I)-DIF
  510 CONTINUE
  999 CONTINUE
      NUM=NOW
      RETURN
      END
**** SOURCE FILE : M0004508.W01   ***
*
      SUBROUTINE APT109(A1,II,A2,A3,A4,A5,A6,A7)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C---- THIS ROUTINE HANDLES THE GEOMETRIC CONSTRUCTION RELATED WITH
C---- SCULPTURED SURFACE AND CURVE
C---- ARGUMENTS LIST APT109(A1,II,A2,A3,A4,A5,A6,A7)
C----    AUFRUFPARAMETER:
C----   II    A2    A3    A4     A5     A6    A7
C=====================================================
C----   PUNKT/VEKTOR MITTELS PARAMETER AUF SYNTHETISCHER KURVE
C----             PNT
C----             TANSPL   FLOW              NOUNIT
C----   2, SCURV ,CRSSPL ,PARAM,  T   ,  S  , UNIT
C----             NORMAL
C----             BINORM
C=====================================================
C----   PUNKT/VECTOR ALS SCHNITTPUNKT ZWISCHEN EBENE UND KURVE
C----             PNT
C----             TANSPL        LINE         NOUNIT
C----   3, SCURV ,CRSSPL ,-----,PLANE ,POINT, UNIT
C----             NORMAL
C----             BINORM
C=====================================================
C----   PUNKT/VECTOR MITTELS PARAMETER AUF SKULPTURIERTER FLAECHE
C----             PNT
C----             TANSPL                     NOUNIT
C----   4, SSURF ,CRSSPL ,  U  ,  V   ,  P  , UNIT
C----             NORMAL
C=====================================================
C----   PUNKT/VECTOR IN DER NAEHE EINES PUNKTES AUF S.-FLAECHE
C----             PNT
C----             TANSPL                     NOUNIT
C----   5, SSURF ,CRSSPL ,POINT,------,-----, UNIT
C----             NORMAL
C=====================================================
C----   PUNKT/VECTOR  AM SCHNITTP. ZWISCHEN DER GERADEN DURCH DIE BEIDEN
C----   PUNKTE UND DER S.-FLAECHE,NAECHSTLIEGEND ZUM 1. PUNKT
C----             PNT
C----             TANSPL                     NOUNIT
C----   6, SSURF ,CRSSPL ,POINT,------,POINT, UNIT
C----             NORMAL
C=====================================================
C---- PUNKT/VECTOR  AM SCHNITTP. ZWISCHEN DER GERADEN DURCH PUNKT
C---- ENTLANG VEKTOR UND DER S.-FLAECHE,NAECHSTLIEGEND ZUM PUNKT
C----             PNT
C----             TANSPL                     NOUNIT
C----   7, SSURF ,CRSSPL ,POINT,VECTOR,-----, UNIT
C----             NORMAL
C=====================================================
C---- PUNKT/VECTOR  AM SCHNITTP. ZWISCHEN DER GERADEN DURCH 1. PUNKT
C---- ENTLANG VEKTOR UND DER S.-FLAECHE,NAECHSTLIEGEND ZUM PUNKT,
C---- DER DURCH PROJEKTION DES 2. PUNKTES AUF DIEGERADE ENTSTEHT
C----             PNT
C----             TANSPL                     NOUNIT
C----   8, SSURF ,CRSSPL ,POINT,VECTOR,POINT, UNIT
C----             NORMAL
C=====================================================
C
C  DIE AUFRUF-PARAMETER HABEN SOWEIT SIE SICH NICHT SELBST ERKLAEREN
C  FOLGENDE BEDEUTUNG:
C
C
C    PNT    : IST EQUIVALENT MIT 0.0D0 UND SOLL SIGNALISIEREN,
C              DASS DAS ERGEBNIS EIN PUNKT SEIN SOLL
C    NOUNIT : IST EQUIVALENT MIT 0.0D0 UND BEDEUTET, DASS DAS ERGEBNIS
C              NICHT NORMALISIERT WERDEN SOLL
C    T      : KURVENPARAMETER
C    S      : KURVENSEGMENTNUMMER
C    U,V    : FLAECHENPARAMETER
C    P      : FLAECHEN-BLATT-NUMMER
C    -------: PARAMETER OHNE RELEVANZ
C
C
C
      INCLUDE (TOTAL)    
      INCLUDE (DEF)    
      INCLUDE (DSHAR3)    
      INCLUDE (ZNUMBR)    
      INCLUDE (LDEF)    
      INCLUDE (IDEF)    
      INCLUDE (ISHR16)    
      INCLUDE (KNUMBR)    
C
      DIMENSION A1(*),A2(4),A3(2),A4(2),A5(2),A6(2),A7(2)
      DIMENSION A4I(3),A5I(4),A6I(3)
      DIMENSION EA(3),FA(4),FB(4),ROOT(2,30),TPP(3)
      DIMENSION SSDUM(3),SPV(32),IFLAG(4),PATCH(64),ITOP(6,4)
       DIMENSION TP(3),TN(3),SP(32),SN(3),SLX(3),JJJ(2),I2(2)
      CHARACTER*8 TANSPL,CRSSPL,BINORM,FLOW,XNORM,UNIT,PARAM,TEST
      LOGICAL CKDEF
C
      INCLUDE (BLANKCOM)    
C
      EQUIVALENCE (SMAL1,Z1EM3), (AA,JJJ(1))
      INTEGER IXNORM(2)
      EQUIVALENCE (IXNORM(1),XNORM1)
C
C    SPEICHERINDEX (KK) FUER ENTSPRECHENDEN ERGEBNISPLATZ
C IN SPV BEI SCURV UND SSURF
      INTEGER ISPVC(5),ISPVS(4)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
C  UEBERGABECOMMON FUER --PARMF--
      COMMON/PARMFC/UA,VA,PNUM,UT,US,FNAM
      DATA TANSPL,CRSSPL,BINORM/'TANSPL  ','CRSSPL  ','BINORM  '/
      DATA FLOW,XNORM/'FLOW    ','NORMAL  '/
      DATA IXNORM/2,0/
      DATA UNIT,PARAM/'UNIT    ','PARAM   '/
      DATA ISPVC/1,5,17,29,0/,ISPVS/1,5,9,25/
C
      FNAM=0.D0
      GOTO (400,400,401,400,401,401,401,401),II
      GOTO 400
  401 CALL UNPACK(A2(1),MOD1,ISIZE,ISUB)
      FNAM=A2(ISIZE+1)
      IF(ISUB.GE.1)FNAM=A2(ISUB*ISIZE+ISUB)
  400 CONTINUE
C
C   KONTROLL OB GEOMETRIEDEFINITIONEN IN ORDNUNG
C
      GOTO (5158,510,510,510,501,501,501,501),II
      GOTO 5158
  501 IF(CKDEF(A4))GOTO 5157
      CALL TRANSF(A4I,A4,2,3,0)
  510 GOTO (5158,520,511,520,520,520,511,511),II
  511 IF(CKDEF(A5))GOTO 5157
      MO=3
      IF(II.EQ.3)MO=4
      CALL TRANSF(A5I,A5,MO,MO,0)
  520 GOTO (5158,530,521,530,530,521,530,521),II
  521 IF(CKDEF(A6))GOTO 5157
      CALL TRANSF(A6I,A6,2,3,0)
C    KONTROLLE DER SYNTHETISCHEN OBERFLAECHE
  530 IF(CKDEF(A2))GOTO 5157
C
C    ABFRAGE DER ERGEBNISART (PUNKT/TANSPL/CRSSPL/NORMAL/BINORM)
C
      IA=1
      IF(A3(1).EQ.0.0D0 )GOTO 540
      IA=2
      CALL HOLFRM(A3(1),TEST,1,8,NWD)
      IF(TEST.EQ.TANSPL)GOTO 540
      IA=3
      IF(TEST.EQ.CRSSPL)GOTO 540
      IA=4
      IF(A3(1).EQ.XNORM1)GOTO 540
      IF(ABS(A3(1)-2.D0).LE.Z1EM6)GOTO 540
      IF(TEST.EQ.XNORM )GOTO 540
      IA=5
      IF(TEST.EQ.BINORM)GOTO 540
      GOTO 5158
C
C   ABFRAGE AUF PARAM ODER FLOW
C
  540 IP=0
      IF(II.NE.2)GOTO 550
      IP=1
      CALL HOLFRM(A4(1),TEST,1,8,NWD)
      IF(TEST.EQ.PARAM)GOTO 550
      IP=2
      IF(TEST.EQ.FLOW )GOTO 550
      GOTO 5158
C
C    ABFRAGE AUF UNIT
C
  550 IU=0
      IF(A7(1).EQ.0.0D0 )GOTO 560
      IU=1
      CALL HOLFRM(A7(1),TEST,1,8,NWD)
      IF(TEST.EQ.UNIT  )GOTO 560
      GOTO 5158
C
C     FEHLERAUSGAENGE
C
C     FEHLER 5153 : BLATTNUMMER DER SSURF IST FALSCH
 5153 IERROR=5153
 5150 UNFLAG=.TRUE.
      CALL DEFEXT(A1)
      RETURN
C     FEHLER 5154 : PARAMETERANGABE IST NICHT KORREKT
C5154 IERROR=5154
C     GOTO 5150
C     FEHLER 5155 : VEKTORLAENGE IST FUER DIE NORMALISIERUNG ZU KLEIN
 5155 IERROR=5155
      GOTO 5150
C     FEHLER 5156 : SCHNITTPUNKT KANN NICHT DEFINIERT WERDEN
 5156 IERROR=5156
      GOTO 5150
C     FEHLER 5157 : EINGEGEBENE GEOMETRIE IST NICHT VORHER DEFINIERT
 5157 IERROR=5157
      GOTO 5150
C     FEHLER 5158 : DEFINITIONSFEHLER
 5158 IERROR=5158
      GOTO 5150
C     FEHLER 5159 : SPEZIFIZIERTER VEKTOR ODER PUNKT EXISTIERT NICHT
 5159 IERROR=5159
      GOTO 5150
C
  560 CONTINUE
C    SCURV ODER SSURF  WIRD GEHOLT
C
      SSDUM(1)=A2(1)
      SSDUM(2)=A2(2)
      SSDUM(3)=A2(3)
      IMODE=3
      CALL APT094(IMODE,SSDUM,J11)
      IF(CKDEF(SSDUM(1))) GOTO 5157
      J11=J11-41
C
C  PARAMETER-UEBERTRAGUNG IN ABHAENGIGKEIT VON DER AUFGABE
C
      GOTO( 5158,572,573,574,575,576,577,578),II
C
C PUNKT/VECTOR MITTELS PARAMETER AUS SCURV
C
  572 U=A5(1)
      I=A6(1)
C   UMSPEICHERINDEX FUER SPV
  581 KK=ISPVC(IA)
C   STEUERUNG FUER ROUTINE CURFLO
      MM=1
      IF(IA.LT.3)GOTO 580
      MM=2
      GOTO 580
C
C  PUNKT/VEKTOR AM DURCHSTOSSPUNKT SCURV/EBENE
C
  573 DO 301 MN=1,3
      EA(MN)=A6I(MN)
  301 FA(MN)=A5I(MN)
      FA(4)=-A5I(4)
      GOTO 581
C
C  PUNKT/VECTOR MITTELS PARAMETER AUS SSURF
C
  574 PA01=A4(1)
      PB01=A5(1)
      PC01=A6(1)
      MPATCH=CAN(J11+4)
      MESH=CAN(J11+5)
      IF(DABS(PC01).GT.SMAL1) GOTO 2250
      NSPL=CAN(J11+9)-1.
      NPNT=CAN(J11+10)-1.
      IPA01=PA01
      IPB01=PB01
      IF(IPA01.LT.NPNT) GOTO 2110
      IPA01=NPNT-1
 2130 PU01=PA01-IPA01
 2140 IF(IPB01.LT.NSPL) GOTO 2120
      IPB01=NSPL-1
 2150 PV01=PB01-IPB01
 2160 NPATCH=IPB01*NPNT+IPA01+1
      GOTO 2310
 2110 IF(IPA01.GE.0) GOTO 2130
      IPA01=0
      PU01=PA01
      GOTO 2140
 2120 IF(IPB01.GE.0) GOTO 2150
      IPB01=0
      PV01=PB01
      GOTO 2160
 2250 IF(PC01.LT.0.D0) GOTO 5153
      IPC01=PC01
      IF((IPC01.GT.MPATCH).OR.(IPC01.LE.0)) GOTO 5153
      PU01=PA01
      PV01=PB01
      NPATCH=IPC01
 2310 CONTINUE
      CALL LODPCH(CAN(J11+1),PATCH,IFLAG,ITOP,NPATCH,1)
C
      KK=ISPVS(IA)
C       STEUERUNG FUER ROUTINE CNSURF
      MM=0
      IF(IA.EQ.1)GOTO 580
      MM=1
      GOTO 580
C
C    PUNKT/VEKTOR IN DER NAEHE EINES PUNKTES AUF DER SSURF
C
  575 TP(1)=A4I(1)
      TP(2)=A4I(2)
      TP(3)=A4I(3)
      TN(1)=0.0
      TN(2)=0.0
      TN(3)=1.0
      MODE=0
  585 KK=ISPVS(IA)
      GOTO 580
C
C   PUNKT/VEKTOR AUF GERADEN (DURCH 2 PUNKTE) UND SSURF
C
  576 DO  584 MN=1,3
      TP(MN)=A4I(MN)
      TN(MN)=A6I(MN)-A4I(MN)
  584 CONTINUE
      MODE=-1
      GOTO 585
C
C    PUNKT/VECTOR AUF GERADEN (DURCH PUNKT,ENTLANG VEKTOR) UND SSURF
C
  577 DO  583 MN=1,3
      TP(MN)=A4I(MN)
      TN(MN)=A5I(MN)
  583 CONTINUE
      MODE=-1
      GOTO 585
C
C    PUNKT/VEKTOR AUF GERADEN (PUNKT,VECTOR),NAHE EINEM PUNKT,AUF SSURF
C
  578 DO  582 MN=1,3
      TN(MN)=A5I(MN)
      TP(MN)=A6I(MN)
      TPP(MN)=A4I(MN)
      TP(MN)=TP(MN)-TPP(MN)
  582 CONTINUE
      DD=DSQRT(TN(1)*TN(1)+TN(2)*TN(2)+TN(3)*TN(3))
      IF(DD.LT.SMAL1)GOTO 5155
      DDD=(TP(1)*TN(1)+TP(2)*TN(2)+TN(3)*TP(3))
      DDD=DDD/DD
      TP(1)=DDD*(TN(1)/DD)+TPP(1)
      TP(2)=DDD*(TN(2)/DD)+TPP(2)
      TP(3)=DDD*(TN(3)/DD)+TPP(3)
      MODE=-1
      GOTO 585
C
C===================================================================
C    DURCHFUEHRUNG DER AUFGABEN
C===================================================================
C
  580 GOTO(5158,2000,3000,4000,6000,6000,6000,6000),II
C
C  PUNKT/VEKTOR MITTELS PARAMETER AUS SCURV
 2000 CONTINUE
C  AUF ALLE FAELLE AUSSPEICHERN DER 'ANZAHL FLOW-SEGMENTE'
      NMAX=CAN(J11+8)
      IF(IP.EQ.2)GOTO 2100
C  BEI PARAM-INTERPOLATION WIRD CAN(J11+8) VORUEBERGEHEND 0.0D0
      CAN(J11+8)=0.0D0
 2100 CALL CURFLO(U,CAN(J11+1),SPV,MM,I)
C  NMAX WIRD WIEDER EINGESETZT
      CAN(J11+8)=NMAX
C   VERZWEIGUN NACH ERGEBNISART
      GOTO(2200,2200,2300,2300,2400),IA
 2200 A1(1)=SPV(KK)
      A1(2)=SPV(KK+1)
      A1(3)=SPV(KK+2)
      IF(IA.EQ.1)GOTO 9100
      GOTO 9200
C   GUELTIGKEITS ABFRAGE BEI CRSSPL U. NORMAL
 2300 IF(SPV(20).NE.1.0D0)GOTO 5159
      GOTO 2200
C   BERECHNUNG DER BINORMALEN
 2400 CALL CROSS(SPV(5),SPV(9),A1(1))
      GOTO 9200
C
C   PUNKT/VECTOR AUF EBENE UND SCURV  (DURCHSTOSSGEOMETRIE)
C
 3000 MBLK=CAN(J11+4)
      KK1=0
      NBLK=1
C   BERECHNUNG BEI DER ANFANGSTANGENTE (AUSSERHALB LIEGENDER PUNKT)
      CALL CNCURV(0.D0,CAN(J11+25),SPV,1)
      AB=FA(1)*SPV(1)+FA(2)*SPV(2)+FA(3)*SPV(3)+FA(4)
      AC=FA(1)*SPV(5)+FA(2)*SPV(6)+FA(3)*SPV(7)
      IF(DABS(AC).LT.1.D-6) GOTO 370
      XYZ=-AB/AC
      IF(XYZ.GT.1.D-5) GOTO 370
C   PUNKT GEFUNDEN
      KK1=KK1+1
      ROOT(1,KK1)=J11+25
      ROOT(2,KK1)=XYZ
  370 NBLK01=NBLK*24+J11+1
      DO 320 NSPL=1,4
  320 SPV(NSPL)=0.
      DO 330 NPNT=1,4
      MN=(NPNT-1)*4
      DO 331 NSPL=1,4
  331 FB(NSPL)=CAN(NBLK01+MN+NSPL-1)
      SPV(1)=SPV(1)+FA(NPNT)*(2*FB(1)-2*FB(2)+FB(3)+FB(4))
      SPV(2)=SPV(2)+FA(NPNT)*(-3*FB(1)+3*FB(2)-2*FB(3)-FB(4))
      SPV(3)=SPV(3)+FA(NPNT)*FB(3)
  330 SPV(4)=SPV(4)+FA(NPNT)*FB(1)
      CALL GCUBIC(SPV(1),SPV(2),SPV(3),SPV(4),FB,MN)
      IF(MN.EQ.0) GOTO 380
      DO 340 NSPL=1,MN
      XYZ=FB(NSPL)
      IF((XYZ.GE.-1.D-5).AND.(XYZ.LT.1.00001D0)) THEN
        KK1=KK1+1
        ROOT(1,KK1)=NBLK01
        ROOT(2,KK1)=FB(NSPL)
      END IF
C
C
C
  340 CONTINUE
  380 NBLK=NBLK+1
      IF(NBLK.GT.MBLK) GOTO 360
      GOTO 370
C   BERECHNUNG BEI DER ENDTANGENTE (AUSSERHALB LIEGENDER PUNKT)
  360 CALL CNCURV(1.D0,CAN(NBLK01),SPV,1)
      AB=FA(1)*SPV(1)+FA(2)*SPV(2)+FA(3)*SPV(3)+FA(4)
      AC=FA(1)*SPV(5)+FA(2)*SPV(6)+FA(3)*SPV(7)
      IF(DABS(AC).LT.1.D-6) GOTO 361
      XYZ=-AB/AC+1.D0
      IF(XYZ.LT..99999D0) GOTO 361
C   PUNKT GEFUNDEN
      KK1=KK1+1
      ROOT(1,KK1)=NBLK01
      ROOT(2,KK1)=XYZ
  361 IF(KK1.EQ.0) GOTO 5156
      MN=1
  335 NBLK01=ROOT(1,MN)
      CALL CNCURV(ROOT(2,MN),CAN(NBLK01),SPV,1)
      DDIST1=(SPV(1)-EA(1))**2+(SPV(2)-EA(2))**2+(SPV(3)-EA(3))**2
      IF(MN.NE.1) GOTO 315
  325 A1(1)=SPV(1)
      A1(2)=SPV(2)
      A1(3)=SPV(3)
      UT=ROOT(2,MN)
      IS=(ROOT(1,MN)-J11)/24.D0
      US=IS
      DDIST=DDIST1
  345 MN=MN+1
      IF(MN.GT.KK1) GOTO 3100
      GOTO 335
  315 IF(DDIST.GT.DDIST1) GOTO 325
      GOTO 345
C  DURCHSTOSSPUNKT GEFUNDEN
 3100 IF(IA.EQ.1)GOTO 9100
C VEKTOR WIRD GEWUENSCHT:INTERPOLATION DES VEKTORS WIRD VORBEREITET
      IP=1
      U=UT
      NBLK01=US*24.D0+1.D0+J11
      I=US
      GOTO 2000
C
C  PUNKT/VEKTOR MITTELS PARAMETER AUS SSURF
C
 4000 CALL CNSURF(PU01,PV01,PATCH,SPV,IFLAG,MM)
      GOTO 2200
C
C   PUNKT/VEKTOR AM ANNAEHERUNGS- O. DURCHSTOSS-PUNKT AUF SSURF
C
 6000 DD=DSQRT(TN(1)*TN(1)+TN(2)*TN(2)+TN(3)*TN(3))
      IF(DD.LT.SMAL1)GOTO 5155
      TN(1)=TN(1)/DD
      TN(2)=TN(2)/DD
      TN(3)=TN(3)/DD
      IFLG=0
 5489 IDEBUG=IBUG
      CALL LODINT(CAN(J11+1),PATCH,UST,VST,TP,TN,IFLAG,
     1   ITOP,IPNUM,MODE)
      IF(IDEBUG.LE.0) GO TO 5487
      CALL BAD(1,0,'A109',IPNUM)
      CALL BAD(1,1,'UST ',UST)
      CALL BAD(-1,1,'VST ',VST)
 5487 CALL SQRCUT(Z5EM1,Z5EM1,UST,VST,UU,VV,ICKBN)
      UST=Z5EM1+0.9999D0*(UU-Z5EM1)
      VST=Z5EM1+0.9999D0*(VV-Z5EM1)
C...CALL PCHPRC WITH LAST PARAMETER .TRUE. FOR GEOMETRIC CONSTRUCTION
      CALL PCHPRC(CAN(J11+1),PATCH,UST,VST,TP,TN,UA,VA,
     1  SPV,SN,SLX,IFLAG,ITOP,IPNUM,MODE,IDEBUG,IRR,.TRUE.)
      PNUM=IPNUM
      IF(SPV(KK+3).EQ.0.0D0)GOTO 5159
      IF(IFLG.NE.0) GO TO 5494
      IFLG=1
      DO 5490 MN=1,3
 5490 TPP(MN)=SPV(MN)-TP(MN)
      CALL DOTV(DDD,TPP,TPP)
      DDD=DDD-.1D0
      CALL DOTV(DD,TPP,TN)
      IF(DD.LT.0.0) GO TO 5492
C---      POINT IS SAME DIRECTION AS VECTOR
      DO 5491 MN=1,3
 5491 TP(MN)=TP(MN)+DDD*TN(MN)
      GO TO 5489
 5492 DO 5493 MN=1,3
 5493 TP(MN)=TP(MN)-DDD*TN(MN)
      GO TO 5489
 5494 CONTINUE
      GOTO 2200
C
C=======================================================================
C
C    ABGESANG
 9100 CALL TRANSF(P,A1,K2,K3,KM1)
      CALL DEFEXT(A1)
      RETURN
 9200 IF(IU.EQ.0)GOTO 9250
      DISTAN=DSQRT(A1(1)*A1(1)+A1(2)*A1(2)+A1(3)*A1(3))
      IF(DISTAN.LT.SMAL1) GO TO 5155
      A1(1)=A1(1)/DISTAN
      A1(2)=A1(2)/DISTAN
      A1(3)=A1(3)/DISTAN
C    FALLS NOTWENDIG TRANSFORMIEREN UND ZURUECK
 9250 CALL APT078(A1,KM1)
      CALL DEFEXT(A1)
      RETURN
      END
**** SOURCE FILE : M0001909.W01   ***
*
      SUBROUTINE ARCSEG(C,FL,TOLR,NUM,NUMAX,IRR)
C---     INPUT  C A RATIONAL PARAMETRIC CUBIC CURVE SEGMENT
C---     INPUT  NUMAX THE MAXIMUM NUMBER OF FLO RATE SPLINES ALLWD
C---    INPUT  TOLR THE TOLERANCE TO BE USED IN FITTING(.001 NORMAL)
C---    OUTPUT IRR ERROR FLAG, ZERO IS CORRECT, NONZERO IS ERROR.
C---     OUTPUT NUM  NUMBER OF FLOW SPLINES GENERATED
C---     OUTPUT FL(4,NUM) 4-POSITION FLOW FUNCTIONS CREATED.
C---            FL(1,I) IS THE ACCUMULATED ARC LENGTH
C---            FL(2,I) IS THE CORRESPONDING COONS PARAMETER
C---            FL(3,I) IS THE RATE OF CHANGE OF COONS PARAM
C---            FL(4,I) IS THE SECOND DERIVATIVE OF COON'S PARAMETER
C
C---     PURPOSE IS GENERATE A CUBIC SEGMENT WITH ARC AS FLOW RATE.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION C(16),FL(4,NUMAX),CV(16),SARC(3)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
C   HILFSSPEICHER FUER 5 ZWISCHENPUNKTE
      DOUBLE PRECISION CVV(4,5)
      DATA ZERO,ONE,HALF,SMAL,VSMAL/0.0D0,1.0D0,0.5D0,1.0D-6,1.0D-30/
C---     NOW=CURRENT ACCEPTED POINT, NX=NEXT CADIDATE POINT
C---     ALGORITHM PROCEEDS BY SUBDIVIDING REMAINING ARC BY TWO
C---     UNTIL A SATISFACTORY PARAMETERIZATION OF A SUBARC IS OBTAINED
      NOW=1
      ARCLEN=ZERO
      UNOW=ZERO
      CALL CNCURV(UNOW,C,CV,1)
C---     DETERMINE RATES OF CHANGE AT THIS POINT
      A=DSQRT(CV(5)**2+CV(6)**2+CV(7)**2)+VSMAL
      B=(CV(5)*CV(9)+CV(6)*CV(10)+CV(7)*CV(11))/A
C---     LOAD THE KEY VALUES FOR THE STARTING POINT
      FL(1,NOW)=ARCLEN
      FL(2,NOW)=UNOW
      FL(3,NOW)=ONE/A
      FL(4,NOW)=-B/(A**3)
      UNX=.76
C   'FLOW,ARC,...'  KORREKTOR BEI GERADEN 'SPLINE/CURSEG'-BOEGEN
      IF(C(13).NE.ONE.OR.C(14).NE.ONE.OR.C(15).NE.ZERO.
     *   OR.C(16).NE.ZERO)GOTO 45
      IF(DABS(C( 2)-C( 1)-C( 3)).GT.SMAL.OR.
     *               DABS(C( 3)-C( 4)).GT.SMAL)GOTO 45
      IF(DABS(C( 6)-C( 5)-C( 7)).GT.SMAL.OR.
     *               DABS(C( 7)-C( 8)).GT.SMAL)GOTO 45
      IF(DABS(C(10)-C( 9)-C(11)).GT.SMAL.OR.
     *               DABS(C(11)-C(12)).GT.SMAL)GOTO 45
      GOTO 49
C   UNTERSUCHUNG AUF ANNAEHERND GERADEN BOEGEN
   45 DO 46 J=1,5
      U=J
      U=(U-1.D0)/4.D0
   46 CALL CNCURV(U,C,CVV(1,J),0)
C BERECHNUNG DER DISTANZEN
      DO 47 J=1,5
      J1=J
      J2=J+1
      IF(J.NE.5)GOTO 48
      J1=1
      J2=5
   48 CVV(4,J)=DSQRT((CVV(1,J2)-CVV(1,J1))**2
     *              +(CVV(2,J2)-CVV(2,J1))**2
     *              +(CVV(3,J2)-CVV(3,J1))**2)
   47 CONTINUE
      A1=CVV(4,1)+CVV(4,2)+CVV(4,3)+CVV(4,4)
      TOLRI=(A1-CVV(4,5))/CVV(4,5)
      IF(DABS(TOLRI).GT.TOLR)GO TO 50
      A2=CVV(4,5)/4.D0
      DO 42 J=1,4
      IF(DABS((CVV(4,J)-A2)/A2).GT.TOLR) GOTO 50
   42 CONTINUE
C    TESTDRUCKE  ***************
      CALL BAD(-1,1,'TOLI',TOLRI)
      CALL BAD( 1,1,'TOLR',TOLR)
      CALL BAD( 1,1,'A   ',A   )
      CALL BAD( 1,1,'A1  ',A1  )
      CALL BAD(-1,1,'B   ',B   )
      A=A1
   49 IRR=22
      NOW=2
      FL(1,2)=A-VSMAL
      FL(2,2)=ONE
      FL(3,1)=ONE/FL(1,2)
      FL(3,2)=FL(3,1)
      FL(4,1)=ZERO
      FL(4,2)=FL(4,1)
      IF(NOW.GT.NUMAX-2)GOTO 999
      GOTO 500
C---
   50 CONTINUE
      ICHK=1
   60 CONTINUE
      CALL CNCURV(UNX,C,CV,1)
      NX=NOW+1
C---     DETERMINE RATES OF CHANGE AT THIS POINT
      A=DSQRT(CV(5)**2+CV(6)**2+CV(7)**2)+VSMAL
      B=(CV(5)*CV(9)+CV(6)*CV(10)+CV(7)*CV(11))/A
C---     LOAD THE KEY VALUES
      FL(1,NX)=ARCLEN
      FL(3,NX)=ONE/A
      FL(4,NX)=-B/(A**3)
C
C---     CALCULATE THE MID PT BETWEEN UNOW AND UNX AND CHECK FOR
C---     TOLERANCE BETWEEN TOTAL ARC AND SUM OF SUBARCS.
  100 CONTINUE
      UCHECK=(UNOW+UNX)*HALF
      CALL CNCURV(UCHECK,C,CV,1)
C---     DETERMINE RATES OF CHANGE AT THIS POINT
      A=DSQRT(CV(5)**2+CV(6)**2+CV(7)**2)+VSMAL
      B=(CV(5)*CV(9)+CV(6)*CV(10)+CV(7)*CV(11))/A
C---     LOAD THE KEY VALUES
      FL(2,NX+1)=UCHECK
      FL(3,NX+1)=ONE/A
      FL(4,NX+1)=-B/(A**3)
C---     COMPARE UNOW,UNX  UNOW,UCHECK  UCHECK,UNX
      DO 110 I=1,3
      IA=NOW
      IB=NX
      IF(I.EQ.3) IA=IA+2
      IF(I.EQ.2) IB=IB+1
C---     COMPUTE ARC LENGTH BY SPECIAL SPLINE FUNCTION FORMULA.
      SARC(I)=3.*(FL(2,IB)-FL(2,IA))*(FL(4,IB)+FL(4,IA))
      A=FL(4,IB)*(2.*FL(3,IA)+FL(3,IB))+FL(4,IA)*(FL(3,IA)+2.*FL(3,IB))
      IF(DABS(A).LT.VSMAL) GOTO 109
      SARC(I)=SARC(I)/A
      GOTO 110
C---     SPECIAL PATH WHEN SECOND DERIVATIVE IS ZERO
  109 CONTINUE
      D1=ZERO
      IF(DABS(FL(3,IA)).GT.VSMAL*SMAL) D1=ONE/FL(3,IA)
      IF(DABS(FL(3,IB)).GT.VSMAL*SMAL) D1=D1+ONE/FL(3,IB)
      IRR=23
      IF(D1.EQ.ZERO) GOTO 999
      SARC(I)=(FL(2,IB)-FL(2,IA))*D1/2.D0
  110 CONTINUE
C
      ERR=(SARC(1)-SARC(2)-SARC(3))/(SARC(1)+VSMAL)
      IF(IBUG.NE.11) GO TO 23
      CALL BAD(-1,0,' ',0)
      NX1=NX+1
      DO 24 III=NOW,NX1
      CALL BAD(-4,1,'FL  ',FL(1,III))
   24 CONTINUE
      CALL BAD(3,1,'SARC',SARC)
      CALL BAD(-1,1,'ERR ',ERR)
   23 CONTINUE
      IF(DABS(ERR).GT.TOLR) GO TO 150
C---     ACCURACY IS OKAY, NOW CHECK IF SPLINE IS INCREASING
      IF(FL(2,NOW).GE.FL(2,NOW+1)) GO TO 150
      IF(FL(3,NOW).LE.ZERO) GO TO 150
      IF(FL(3,NX).LE.ZERO) GO TO 150
C---     NOW CHECK FOR A MAX OR MIN WITHIN THE INTERVAL
      A=FL(3,NOW)*SARC(1)
      B=FL(3,NX)*SARC(1)
      AA=3.D0*(B+A-2.D0*(FL(2,NX)-FL(2,NOW)))
      IF(DABS(AA).LT.VSMAL) AA=VSMAL
      BB=2.*(3.*(FL(2,NX)-FL(2,NOW))-2.*A-B)
      CC=A
      DISC=BB*BB-4.*AA*CC
      IF(DISC.LT.ZERO) GO TO 140
      DISC=DSQRT(DISC)
      R=(-BB-DISC)/(2.*AA)
      IF(DABS(R-HALF).LT.HALF) GO TO 150
      R=(-BB+DISC)/(2.*AA)
      IF(DABS(R-HALF).LT.HALF) GO TO 150
  140 CONTINUE
C---     FUNCTION MEETS ALL CONDITIONS, NOW CONSOLIDATE AND TRY
C---     TO FIT NEXT SUBARC.
      FL(1,NX)=SARC(1)+ARCLEN
      ARCLEN=ARCLEN+SARC(1)
C---     UPDATE POINTER AND TRY TO FIT NEXT SUBARC
      NOW=NOW+1
      UDEL=UNX-UNOW
      UNOW=UNX
      UNX=UNOW+4.0*UDEL
      UNX=DMIN1(ONE,UNX)
      IF(UNOW.GE.ONE-VSMAL) GO TO 500
      IRR=22
      IF(NOW.GT.NUMAX-2) GOTO 999
      GO TO 50
C---     CUT SUBARC IN HALF AND TRY TO FIT AGAIN
  150 CONTINUE
      UNX=UCHECK
      ICHK=ICHK+1
      IRR=1
      IF(ICHK.GT.10) GO TO 999
      GO TO 60
C---     PROPER END OF PROCESSING
  500 CONTINUE
      IRR=0
  999 CONTINUE
      NUM=NOW
      RETURN
      END
**** SOURCE FILE : M0000600.V02   ***
*
C
      SUBROUTINE BEZIER(BIN,OUT,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION BIN(3,4,4),OUT(49),BOUT(3,4,4)
      IRR=0
      DATA SMAL/1.0D-10/
      DATA ZERO/0.0D0/
      ICASE=1
C------ BEZIER INPUT IS FOUR PARALLEL STRINGS OF FOUR POINTS EACH
C-----EACH OF THESE FOUR POINT STRING DEFINES A CHARACTERISTIC POLYGON
C------ UNDER CERTAIN CONDITIONS, THIS INPUT WILL DEFAULT TO A ZERO
C------ TWIST PATCH (ICASE=2) OR A RULED PATCH(ICASE=3)
      ICASE=1
C------ FIRST CHECK INPUT TO DETECT A ZERO TWIST DEFAULT
      DO 10 IA=2,3
      DO 10 IB=2,3
      DO 10 JA=2,3
      DO 10 JB=2,3
      D=0.
      DO 20 K=1,3
   20 D=D+(BIN(K,IA,IB)-BIN(K,JA,JB))**2
C------ IF THE FOUR INTERIOR POINTS ARE IDENTICAL, SETUP ZERO TWISTS
      IF(D.GT.SMAL) GO TO 100
   10 CONTINUE
      ICASE=2
C------CHECK FURTHER FOR A RULED CONDITION
      DO 30 IA=1,4,3
      DO 30 IB=2,3
      DO 30 JA=1,4,3
      DO 30 JB=2,3
      D=0.0
      DO 40 K=1,3
   40 D=D+(BIN(K,IA,IB)-BIN(K,JA,JB))**2
      IF(D.GT.SMAL) GO TO 100
   30 CONTINUE
C------ 5TH THRY 12TH POINTS ARE IDENTICAL HENCE PATCG IS RULED
      ICASE=3
  100 CONTINUE
C------ NOW CREATE COONS CANONICAL FORM FOR PATCH
      DO 120 I=1,3
C------ FIRST LOAD CORNER POINTS INTO COONS MATRIX (BOUT)
      BOUT(I,1,1)=BIN(I,1,1)
      BOUT(I,2,1)=BIN(I,4,1)
      BOUT(I,1,2)=BIN(I,1,4)
      BOUT(I,2,2)=BIN(I,4,4)
C------ NOW LOAD FIRST DIRECTION (FD) TANGENTS INTO BOUT
      BOUT(I,3,1)=3.0*(BIN(I,2,1)-BIN(I,1,1))
      BOUT(I,4,1)=3.0*(BIN(I,4,1)-BIN(I,3,1))
      BOUT(I,3,2)=3.0*(BIN(I,2,4)-BIN(I,1,4))
      BOUT(I,4,2)=3.0*(BIN(I,4,4)-BIN(I,3,4))
      IF(ICASE.EQ.3) GO TO 200
C------ SETUP SECOND DIRECTION TANGENTS (SD) INTO COONS MATRIX(BOUT)
      BOUT(I,1,3)=3.0*(BIN(I,1,2)-BIN(I,1,1))
      BOUT(I,2,3)=3.0*(BIN(I,4,2)-BIN(I,4,1))
      BOUT(I,1,4)=3.0*(BIN(I,1,4)-BIN(I,1,3))
      BOUT(I,2,4)=3.0*(BIN(I,4,4)-BIN(I,4,3))
      IF(ICASE.EQ.2) GO TO 130
C------ FINALLY LOAD TWIST VECTORS
      BOUT(I,3,3)=9.0*(BIN(I,2,2)-BIN(I,1,2)-BIN(I,2,1)+BIN(I,1,1))
      BOUT(I,4,3)=9.0*(BIN(I,4,2)-BIN(I,3,2)-BIN(I,4,1)+BIN(I,3,1))
      BOUT(I,3,4)=9.0*(BIN(I,2,4)-BIN(I,1,4)-BIN(I,2,3)+BIN(I,1,3))
      BOUT(I,4,4)=9.0*(BIN(I,4,4)-BIN(I,3,4)-BIN(I,4,3)+BIN(I,3,3))
      GO TO 120
C------ THE CASE OF ZERO TWISTS
  130 DO 140 J=3,4
      DO 140 K=3,4
  140 BOUT(I,J,K)=0.0
      GO TO 120
  200 BOUT(I,1,3)=BIN(I,1,4)-BIN(I,1,1)
      BOUT(I,1,4)=BOUT(I,1,3)
      BOUT(I,2,3)=BIN(I,4,4)-BIN(I,4,1)
      BOUT(I,2,4)=BOUT(I,2,3)
      BOUT(I,3,3)=BOUT(I,3,2)-BOUT(I,3,1)
      BOUT(I,3,4)=BOUT(I,3,3)
      BOUT(I,4,3)=BOUT(I,4,2)-BOUT(I,4,1)
      BOUT(I,4,4)=BOUT(I,4,3)
  120 CONTINUE
      DO 220 I=1,3
      DO 220 K=1,4
      DO 220 J=1,4
      IN=(I-1)*16+(K-1)*4+J
      OUT(IN)=BOUT(I,J,K)
      W=OUT(IN)
      W=DABS(W)
      IF(W.LT.SMAL) OUT(IN)=ZERO
  220 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0000601.V01   ***
*
      SUBROUTINE BIQUAD(A,B,C,D,E,RTS,NZ)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------THIS PROGRAM SOLVES FOR THE REAL ROOTS OF A BIQUADRATIC
C------A*X**4+B*X**3+C*X**2+D*X+E=0.  THE ROOTS ARE THEN LOADED
C------INTO THE ARRAY RTS.  NZ GIVES THE TOTAL NUMBER OF ROOTS.
      DIMENSION RTS(4),TEMP(3)
      DATA ZERO,SMAL/0.0D0,1.0D-14/
      RTS(1)=9999.0
      RTS(2)=9999.0
      RTS(3)=9999.0
      RTS(4)=9999.0
      IF(DABS(A).LT.SMAL) GO TO 100
C------ TRANSFORM THE POLYNOM BY THE EQUATION X=Y-B/4A TO ELIM-
C------ INATE THE CUBIC TERM.  THEN UNITIZE THE COEFFICIENT
C------ OF THE RESULTING QUARTIC EQUATION
      TR=B/(4.0*A)
      TRSQ=TR*TR
      TRCB=TR*TRSQ
      A1=1.0
      B1=0.0
      C1=6.0*TRSQ+(-3.0*B*TR+C)/A
      D1=-4.0*TRCB+(3.0*B*TRSQ-2.0*C*TR+D)/A
      E1=TRSQ*TRSQ+(-B*TRCB+C*TRSQ-D*TR+E)/A
C------ SETUP AND SOLVE THE RESOLVENT CUBIC(HALL KNIGHT,SEC 583)
      P=1.0
      Q=C1+C1
      R=C1*C1-4.0*E1
      S=-D1*D1
      CALL GCUBIC(P,Q,R,S,TEMP,NTEM)
      RES=-1.0
      DO 20 I=1,NTEM
      RES=TEMP(I)
      IF(RES.GT.ZERO) GO TO 30
   20 CONTINUE
      NZ=0
      RETURN
   30 AK=DSQRT(RES)
      AM=0.5*(RES+C1+D1/AK)
      AL=0.5*(RES+C1-D1/AK)
C------ NOW THE BIQUADRATIC RESOLVES INTO TWO QUADRATICS
C------THE FIRST QUADRATIC IS Y**2+AK*Y+AL=0  OTHER IS Y**2-AK*Y+AM=0
      DISC=AK*AK-4.0*AL
      NZ=0
      IF(DISC.LT.ZERO) GO TO 40
      NZ=2
      DD=DSQRT(DISC)
      RTS(1)=(-AK+DD)/2.0-TR
      RTS(2)=(-AK-DD)/2.0-TR
   40 DISC=AK*AK-4.0*AM
      IF(DISC.LT.ZERO) GO TO 50
      DD=DSQRT(DISC)
      RTS(NZ+1)=(AK+DD)/2.0-TR
      RTS(NZ+2)=(AK-DD)/2.0-TR
      NZ=NZ+2
   50 CONTINUE
      RETURN
  100 CONTINUE
      CALL GCUBIC(B,C,D,E,RTS,NZ)
      RETURN
      END
**** SOURCE FILE : M0001049.V04   ***
*
      SUBROUTINE CHDSEG(C,FL,TOLR,NUM,NUMAX,IRR,P,D,V)
C---     SUBROUTINE PURPOSE IS TO PARAMETERIZE A RATIONAL CUBIC
C---     ARC IN TERMS OF A PROJECTION IN DIRECTION V UPON AN
C---     ARBITRARY LINE IN SPACE DETERMINED BY A POINT P AND
C---      A DIRECTION VECTOR D
C---     INPUT  C IS A RATIONAL PARAMETRIC CUBIC CURVE C
C---     INPUT  NUMAX IS THE MAXIMUM NUMBER OF ARCS WHICH CAN
C---            BE GENERATED(DUE TO BUFFER SPACE)
C---    INPUT  TOLR THE TOLERANCE TO BE USED IN FITTING(.001 NORMAL)
C---    OUTPUT IRR ERROR FLAG, ZERO IS CORRECT, NONZERO IS ERROR.
C---     OUTPUT IS A SET OF FLOW FUNCTIONS FL(4,NUM) WHERE
C---     FL(1,) IS ACCUMULATED CHORD LENGTH
C---     FL(2,) IS CORRESPONDING COONS PARAMETER
C---     FL(3,) IS RATE OF CHANGE OF PARAMETER
C---     FL(4,) IS SECOND DERIVATIVE.
C---  OUTPUT  NUM IS USUALLY NUMBER OF SEGMENTS, NEGATIVE IS ERROR.
C
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION C(16),FL(4,1),P(3),V(3),D(3)
      DIMENSION T(3),CV(16)
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
      DATA ZERO,ONE,SMAL,VSMAL,HALF/0.0D0,1.0D0,1.0D-6,1.0D-30,0.5D0/
C
C---     METHOD IS TO SPLIT ARC INTO SMALLER AND SMALLER SUBARCS
C---     UNTIL WHOLE ARC HAS BEEN FIT TO ACCEPTABLE ACCURACY.
C---     BEGIN BY DEVELOPING VECTOR CONSTANTS
C
      A=DSQRT(V(1)*V(1)+V(2)*V(2)+V(3)*V(3))
      IRR=2
      IF(A.LT.VSMAL) GO TO 999
      T(1)=V(1)/A
      T(2)=V(2)/A
      T(3)=V(3)/A
C
      IF(IBUG.NE.11) GO TO 2
      CALL BAD(3,1,'P   ',P)
      CALL BAD(3,1,'D   ',D)
      CALL BAD(3,1,'V   ',V)
      CALL BAD(-3,1,'T   ',T)
    2 CONTINUE
C
      IRR=3
      DT=D(1)*T(1)+D(2)*T(2)+D(3)*T(3)
      IF(DABS(DT).LT.VSMAL) GO TO 999
      NOW=1
      CHDLEN=ZERO
      UNOW=ZERO
      CALL CNCURV(UNOW,C,CV,1)
C---     CHECK FOR VALIDITY OF PROJECTION
      TEMP=CV(13)*T(1)+CV(14)*T(2)+CV(15)*T(3)
      IF(TEMP.GT.SMAL) GO TO 5
      IRR=4
      IF(DABS(TEMP).LT.SMAL) GO TO 999
C---     REVERSE THE DIRECTION OF T
      DO 6 I=1,3
    6 T(I)=-T(I)
      DT=-DT
    5 CONTINUE
      IF(DT.GT.ZERO) GO TO 8
      DO 7 I=1,3
    7 D(I)=-D(I)
      DT=-DT
    8 CONTINUE
C
C---     DETERMINE PROJECTION VALUE AND DERIVATIVES
      FL(1,NOW)=(CV(1)-P(1))*T(1)+(CV(2)-P(2))*T(2)+(CV(3)-P(3))*T(3)
      FL(1,NOW)=FL(1,NOW)/DT
      A=(CV(5)*T(1)+CV(6)*T(2)+CV(7)*T(3))/DT+VSMAL
      B=(CV(9)*T(1)+CV(10)*T(2)+CV(11)*T(3))/DT
      FL(2,NOW)=UNOW
      FL(3,NOW)=ONE/A
      FL(4,NOW)=-B/(A**3)
      CNOW=FL(1,NOW)
      UNX=.76
C
   40 CONTINUE
      ICHK=1
   50 CONTINUE
      CALL CNCURV(UNX,C,CV,1)
      NX=NOW+1
C---     CHECK FOR VALIDITY OF PROJECTION
      TEMP=CV(13)*T(1)+CV(14)*T(2)+CV(15)*T(3)
C---     ERROR IF CURVE IS MOVING IN OPPOSITE DIRECTION TO CHORD
      IRR=5
      IF(TEMP.LT.SMAL) GO TO 999
C---     DETERMINE PROJECTION VALUE AND DERIVATIVES
      FL(1,NX)=((CV(1)-P(1))*T(1)+(CV(2)-P(2))*T(2)+(CV(3)-P(3))*T(3))
      FL(1,NX)=FL(1,NX)/DT
      A=(CV(5)*T(1)+CV(6)*T(2)+CV(7)*T(3))/DT+VSMAL
      B=(CV(9)*T(1)+CV(10)*T(2)+CV(11)*T(3))/DT
      FL(2,NX)=UNX
      FL(3,NX)=ONE/A
      FL(4,NX)=-B/(A**3)
C---     FIRST CHECK ACCURACY OF SPLINE REPRESENTATION
      DEL1=FL(1,NX)-CNOW
      DEL2=3.*(FL(2,NX)-FL(2,NOW))*(FL(4,NX)+FL(4,NOW))
      DV=FL(4,NX)*(2.*FL(3,NOW)+FL(3,NX))+FL(4,NOW)*(FL(3,NOW)+2.*
     X   FL(3,NX))
      IF(DABS(DV).LT.VSMAL) GO TO 59
      DEL2=DEL2/DV
C---     IF SECOND DERIVATIVES VANISH, ANOTHER FORMULA IS NEEDED
      GO TO 60
   59 CONTINUE
      DEL2=ZERO
      IF(DABS(FL(3,NOW)).GT.VSMAL*SMAL) DEL2=ONE/FL(3,NOW)
      IF(DABS(FL(3,NX)).GT.VSMAL*SMAL) DEL2=DEL2+ONE/FL(3,NX)
      IRR=4
      IF(DEL2.EQ.ZERO) GO TO 999
   60 CONTINUE
C
C---     COMPARE ACCURACY OF ACTUAL AND ESTIMATED CHORD LENGTH.
C
      DIF=(DEL2-DEL1)/DEL1
      IF(IBUG.NE.11) GO TO 22
      CALL BAD(-4,1,'FLNW',FL(1,NOW))
      CALL BAD(-4,1,'FLNX',FL(1,NX))
      CALL BAD(1,1,'DEL1',DEL1)
      CALL BAD(1,1,'DEL2',DEL2)
      CALL BAD(-1,1,'DIF ',DIF)
   22 CONTINUE
      IF(DABS(DIF).GT.TOLR) GO TO 100
C---     ACCURACY IS ACCEPTABLE, IS SPLINE ALSO INCREASING THO.
      IF(FL(2,NX).LE.FL(2,NOW)) GO TO 100
      IF(FL(3,NOW).LT.ZERO) GO TO 100
      IF(FL(3,NX).LT.ZERO) GO TO 100
C---     NOW CHECK FOR A MAX OR MIN WITHIN THE INTERVAL
      A=FL(3,NOW)*DEL1
      B=FL(3,NX)*DEL1
      AA=3.*(B+A-2.*(FL(2,NX)-FL(2,NOW)))+VSMAL
      BB=2.*(3.*(FL(2,NX)-FL(2,NOW))-2.*A-B)
      CC=A
      DISC=BB*BB-4.*AA*CC
      IF(IBUG.NE.11) GO TO 33
      CALL BAD(-1,0,' ',0)
      CALL BAD(1,1,'AA  ',AA)
      CALL BAD(1,1,'BB  ',BB)
      CALL BAD(1,1,'CC  ',CC)
      CALL BAD(-1,1,'DISC',DISC)
   33 CONTINUE
      IF(DISC.LT.ZERO) GO TO 90
      DISC=DSQRT(DISC)
      R=(-BB-DISC)/(2.*AA)
      IF(DABS(R-HALF).LT.HALF) GO TO 100
      R=(-BB+DISC)/(2.*AA)
      IF(DABS(R-HALF).LT.HALF) GO TO 100
   90 CONTINUE
C---     FUNCTION MEETS ALL CRITERIA, SO GO AFTER THE NXT ARC
      NOW=NOW+1
      CNOW=FL(1,NOW)
      FL(1,NOW)=DEL2+CHDLEN
      CHDLEN=CHDLEN+DEL2
      UDEL=UNX-UNOW
      UNOW=UNX
      UNX=UNOW+4.0*UDEL
      UNX=DMIN1(ONE,UNX)
      IF(UNOW.GT.ONE-SMAL) GO TO 500
      IRR=6
      IF(NOW.GT.NUMAX-2) GO TO 999
      GO TO 40
C
C---     DECREASE UNX AND TRY AGAIN
  100 CONTINUE
      UNX=(UNOW+UNX)*HALF
      ICHK=ICHK+1
      IRR=7
      IF(ICHK.GT.10) GO TO 999
      GO TO 50
C
  500 CONTINUE
      IRR=0
      FL(2,NOW)=ONE
C---     TRANSLATE FLOW RATES TO ORIGIN
      FL(1,1)=ZERO
  999 CONTINUE
      NUM=NOW
      RETURN
      END
**** SOURCE FILE : M0000613.V01   ***
*
      SUBROUTINE CLOCUB(AX,AY,BX,BY,GX,GY,HX,HY,CA,CB,ALPH,BETA,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------THIS SUBROUTINE ACCEPTS AS INPUT TWO END POINTS AX,AY $ BX,BY
C------TWO END DIRECTION VECTORS GX,GY $ HX,HY AND TWO END CURVATURES
C------CA,CB(SIGNED BY DR X DDR).  GX,GY AND HX,HY ARE CONVERTED TO
C------UNIT TANGENT VECTORS FOR THE PLANAR PARAMETRIC CUBIC
C------ OUTPUT CONSISTS OF SCALARS ALPH AND BETA WHICH ARE MULTIPLIERS
C------SATISFIES END CONDITIONS OF POINTS,DIRECTION AND CURVATURE
      DIMENSION RTS(4)
      IDIAG=19000
      Z1EM7=0.0000001
      ZERO=0.0
      ONE=1.0
      W=GX*GX+GY*GY
      IRR=IDIAG+1
      IF(W.LT.Z1EM7) RETURN
      GX=GX/DSQRT(W)
      GY=GY/DSQRT(W)
      W=HX*HX+HY*HY
      IRR=IDIAG+2
      IF(W.LT.Z1EM7) RETURN
      HX=HX/DSQRT(W)
      HY=HY/DSQRT(W)
      DX=BX-AX
      DY=BY-AY
      P=GX*DY-GY*DX
      Q=GX*HY-GY*HX
      R=DX*HY-DY*HX
C------THE FOLLOWING SETS UP A SOLUTION TO TWO SIMULTANEOUS IN ALPH,
C------BETA WHICH ARE THE DESIRED TANGENT MULTIPLIERS
C------3GXD-BETAGXH=SGN(ALPH)*ALPH**2*CA/2
C------3DXH-ALPH*GXH=SGN(BETA)*BETA**2*CB/2
      NCT=0
      ICHK=0
      HCA=CA/2
      HCB=CB/2
      A=HCA*HCB**2
      B=0.
      C=-6*HCA*HCB*R
      D=Q**3
      E=-3*P*Q**2 + 9*HCA*R**2
      CALL BIQUAD(A,B,C,D,E,RTS,NZ)
      IF(NZ.EQ.0) IRR=1
      IF(IRR.NE.0) GO TO 200
C------ NOW CHECK FOR A VALID ALPH,BETA PAIR
      DO 10 L=1,NZ
      BETA=RTS(L)
      IF ( BETA.LT.0.0 ) GO TO 10
      ALPH=(3*R-HCB*BETA**2)/Q
      IF ( ALPH.LT.0.0 ) GO TO 10
      RPP0X = 2*( 3*DX - 2*GX*ALPH - BETA*HX )
      RPP0Y = 2*( 3*DY - 2*GY*ALPH - BETA*HY )
      RPP1X = 2*( -3*DX + GX*ALPH + 2*BETA*HX )
      RPP1Y = 2*( -3*DY + GY*ALPH + 2*BETA*HY )
      E = ( GX*RPP0Y - GY*RPP0X )/ALPH**2
      F = ( HX*RPP1Y - HY*RPP1X )/BETA**2
      E1= E-CA
      F1= F-CB
      E1=E1/CA
      F1=F1/CB
      IF(DABS(E1).GT.0.01D0.OR.DABS(F1).GT.0.01D0) GO TO 10
      ICHK=1
      AT=ALPH
      BT=BETA
   10 CONTINUE
  200 CONTINUE
      IRR=IDIAG+3
      IF(ICHK.EQ.0) RETURN
      ALPH=AT
      BETA=BT
      IRR=0
      RETURN
      END
**** SOURCE FILE : M0004285.V01   ***
*
C
      SUBROUTINE COMPTW(BCN,P,U,V,IRR)
        IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------THIS SUBROUTINE ACCEPTS AS INPUT A PARTIALLY DEFINED COONS
C------MATRIX ( TWIST VECTORS ARE STILL UNKNOWN ) AND FOUR SPACE
C------POINTS P(4,) EACH WITH ASSOCIATED U,V VALUES.
C------AFTER EXECUTION THE ROUTINE RETURNS WITH FOUR TWIST VECTORS
C------WHICH ARE LOADED INTO APPROPRIATE POSITIONS OF THE BCN MATRIX
C------ THE COONS MATRIX PASSES THRU THE FOUR INPUT POINTS
C------AT THE INPUT U,V PARAMETER VALUES
      DIMENSION BCN(3,4,4),P(4,3),U(4),V(4)
      DIMENSION RH(4,3), AM(4,4)
      IDIAG=5395
C------SET UP A 4 X 4 SYSTEM OF EQUATIONS AND SOLVE BY CALL TO GELG
      DO 100 I=1,4
C------EVALUATE COONS BLENDING FUNCTIONS FOR U(I) AND V(I)
      A2 = U(I)**2
      A3 = A2*U(I)
      D  = A3 - A2
      A  = D + D - A2 + 1
      B  = -A + 1
      C  = D - A2 + U(I)
      A2 = V(I)**2
      A3 = A2*V(I)
      H  = A3 - A2
      E  = H + H - A2 + 1
      F  = -E + 1
      G  = H - A2 + V(I)
C------NOW GENERATE THE I TH COEFFICIENT ROW
      AM(I,1) = C*G
      AM(I,2) = C*H
      AM(I,3) = D*G
      AM(I,4) = D*H
C------NOW GENERATE THE VECTOR COMPONENTS OF THE RIGHT HAND SIDE
      DO 100 L = 1, 3
      WA = ( BCN(L,1,1)*E + BCN(L,1,2)*F + BCN(L,1,3)*G
     1     + BCN(L,1,4)*H )*A
      WB = ( BCN(L,2,1)*E + BCN(L,2,2)*F + BCN(L,2,3)*G
     1     + BCN(L,2,4)*H )*B
      WC = ( BCN(L,3,1)*E + BCN(L,3,2)*F )*C
      WD = ( BCN(L,4,1)*E + BCN(L,4,2)*F )*D
C------RH IS THE DESIRED COEEFICIENT
      RH(I,L) = P(I,L) - WA - WB - WC - WD
  100 CONTINUE
      EPS=1.0D-13
      CALL GELG(RH,AM,EPS,4,3,IER)
      IRR = IDIAG + 1
      IF (IER .NE. 0) RETURN
C------RH NOW CONTAINS THE VECTOR SOLUTION SET (TWIST VECTORS)
C------FINALLY LOAD THESE INTO BCN MATRIX
      DO 200 I = 1, 4
      IR = 3
      IC = 3
      IF ( MOD(I,2) .EQ. 0 ) IC = 4
      IF ( I .GT. 2 ) IR = 4
      DO 200 L = 1, 3
      BCN(L,IR,IC) = RH(I,L)
  200 CONTINUE
      IRR = 0
      RETURN
      END
**** SOURCE FILE : M0001014.W01   ***
*
      BLOCK DATA BDIZEL
      COMMON/IZEILL/IZEIL
      INTEGER IZEIL
      DATA IZEIL/1/
      END
C   ROUTINES FOR ASA CARRIAGE CONTROLLED OUTPUT OF VERIFICATION LISTINGS
C    FROM ZSCPICT AND ZSSPICT
      SUBROUTINE CPRIN1 (A)
      COMMON/IZEILL/IZEIL
      CHARACTER A*120,SV,EZ,ZZ
      INTEGER IZEIL
      DATA SV/'1'/,EZ/' '/,ZZ/'0'/
C
      IF(A(1:1).NE.SV)GOTO 1
      IZEIL=1
      GOTO 5
    1 IF(A(1:1).NE.EZ)GOTO 2
      IZEIL=IZEIL+1
      GOTO5
    2 IF(A(1:1).NE.ZZ) GOTO 5
      IZEIL=IZEIL+2
    5 CALL CPRINT(A)
      RETURN
      END
C
C
      SUBROUTINE VORSCH (I,A)
      COMMON/IZEILL/IZEIL
      INTEGER IZEIL,I,J
      CHARACTER A*120,B*120,SV
      DATA SV/'1'/
C
      IF(IZEIL+I.LT.67)RETURN
      DO 6 J=1,120
    6 B(J:J)=A(J:J)
      B(1:1)=SV
      IZEIL=1
      CALL CPRINT(B)
      RETURN
      END
**** SOURCE FILE : M0000621.V02   ***
*
      SUBROUTINE CRSFIT(SA,SB,SC,SD,IERROR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---     PURPOSE IS TO FILL OUT ALL CROSS SLOPE VECTORS IN
C---     THE CURVES SA,SB GIVEN THAT SA,SB  AND SC,SD FORM
C---     OPPOSITE PAIRS OF A FOUR SIDED PATCH.  ALL CURVES
C---     ARE SINGLE SEGMENT FLOW CURVES.
C---     IF AN ERROR IS ENCOUNTERED, IERROR IS NOT ZERO ON RETURN
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
      DIMENSION SA(*),SB(*),SC(*),SD(*)
      DIMENSION VEC(3),VA(3),VB(3),CV(16)
      DATA ZERO,ONE,SMAL/0.0D0,1.0D0,1.0D-10/
C
C---     MAKE TWO PASSES, ONE FOR THE CURVE SA, THE OTHER FOR SB
C
      DATA ICT/0/
C
      IENT=IERROR
      IERROR=0
C
      ICT=ICT+10
      IF(IBUG.EQ.11) CALL SCDUMP(ICT,SA)
      IF(IBUG.EQ.11) CALL SCDUMP(2,SB)
      IF(IBUG.EQ.11) CALL SCDUMP(3,SC)
      IF(IBUG.EQ.11) CALL SCDUMP(4,SD)
      DO 10 IPASS=1,2
      U=IPASS-1
C---     PICK UP CROSS VECTORS AT ENDS FROM SC AND SD
      CALL CURFLO(U,SC,CV,1,1)
      DO 20 L=1,3
   20 VA(L)=CV(L+4)
      CALL CURFLO(U,SD,CV,1,1)
      DO 30 L=1,3
   30 VB(L)=CV(L+4)
C
C---     STORE THESE VECTORS INTO THE ENDS OF CURVE SA OR SB
      IF(IPASS.EQ.2) GO TO 350
C
      N1=16
      N2=(SA(2)+SA(4)-ONE)*24.+16.
      DO 310 L=1,3
      SA(N1+L)=VA(L)
  310 SA(N2+L)=VB(L)
      SA(N1+4)=ONE
      SA(N2+4)=ONE
      GO TO 390
C
  350 CONTINUE
      N1=16
      N2=(SB(2)+SB(4)-ONE)*24.+16.
      DO 320 L=1,3
      SB(N1+L)=VA(L)
  320 SB(N2+L)=VB(L)
      SB(N1+4)=ONE
      SB(N2+4)=ONE
  390 CONTINUE
C
C---      SKIP OTHER CALCULATIONS IF IENT IS -11
      IF(IENT.EQ.-11) GO TO 10
C
C---     DETERMINE N1,N2 THE STARTING AND ENDING ARC JUNCTIONS
      N1=0
      IF(IPASS.EQ.2) GO TO 40
      NARCRW=SA(7)
      NSEGRW=SA(9)
      N2=SA(NSEGRW+1)+N1
      GO TO 50
   40 CONTINUE
      NARCRW=SB(7)
      NSEGRW=SB(9)
      N2=SB(NSEGRW+1)+N1
   50 CONTINUE
C
C---     NLO,NHI REPRESENT JUNCTION PT LIMITS TO BE TESTED AND
C---     IF NECESSARY TO RECEIVE CROSS SLOPE VECTORS
      NLO=N1+1
      NHI=N2-1
      IF(NHI.LT.NLO) GO TO 10
C
      DO 60 K=NLO,NHI
      NROW=NARCRW+K*4
C
C---     DETERMINE FLOW VALUE OF THIS JUNCTION POINT
      IF(IPASS.EQ.2) GO TO 70
      NROW=SA(NROW)
      FLOVAL=SA(NROW)
      GO TO 80
   70 CONTINUE
      NROW=SB(NROW)
      FLOVAL=SB(NROW)
   80 CONTINUE
C---     DETERMINE THE BLEND OF END VECTORS BASED ON FLOVAL
      CALL BLENDF(FLOVAL,CV)
      DO 90 L=1,3
   90 VEC(L)=CV(1)*VA(L)+CV(2)*VB(L)
      WA=DSQRT(VEC(1)*VEC(1)+VEC(2)*VEC(2)+VEC(3)*VEC(3))
C
C---     NOW CHECK THIS JUNCTION FOR CONSTRAINT DATA ALREADY THERE
      J=K*24+16
      IF(IPASS.EQ.1) TEMP=SA(J+4)
      IF(IPASS.EQ.2) TEMP=SB(J+4)
      IF(DABS(TEMP-ONE).GT.SMAL) GO TO 100
C
C---     A CROSS VECTOR IS ALREADY PRESENT, MODIFY ITS LENGTH TO WA
      IF(IPASS.EQ.2) GO TO 110
      WB=DSQRT(SA(J+1)**2+SA(J+2)**2+SA(J+3)**2)
      IF(WB.LT.SMAL) GO TO 140
      WB=WA/WB
      DO 120 L=1,3
  120 SA(J+L)=WB*SA(J+L)
      GO TO 60
  110 CONTINUE
      WB=DSQRT(SB(J+1)**2+SB(J+2)**2+SB(J+3)**2)
      IF(WB.LT.SMAL) GO TO 140
      WB=WA/WB
      DO 130 L=1,3
  130 SB(J+L)=WB*SB(J+L)
      GO TO 60
C
  100 CONTINUE
      IF(IPASS.EQ.1) TEMP=SA(J+8)
      IF(IPASS.EQ.2) TEMP=SB(J+8)
      IF(DABS(TEMP-ONE).GT.SMAL) GO TO 140
C
C---     A SURFACE NORMAL CONSTRAINT IS PRESENT, PROJECT VEC
C---     INTO THE PLANE OF THIS NORMAL AND ASSIGN WA AS LENGTH
      IF(IPASS.EQ.2) GO TO 150
      WB=DSQRT(SA(J+5)**2+SA(J+6)**2+SA(J+7)**2)
      IF(WB.LT.SMAL) GO TO 140
      PROJ=(VEC(1)*SA(J+5)+VEC(2)*SA(J+6)+VEC(3)*SA(J+7))/WB
      SUM=ZERO
      DO 160 L=1,3
      VEC(L)=VEC(L)-PROJ*SA(J+4+L)/WB
  160 SUM=SUM+VEC(L)**2
      SUM=DSQRT(SUM)
      IF(SUM.LT.SMAL) GO TO 140
      WB=WA/SUM
      DO 170 L=1,3
  170 SA(J+L)=WB*VEC(L)
      GO TO 60
C
  150 CONTINUE
      WB=DSQRT(SB(J+5)**2+SB(J+6)**2+SB(J+7)**2)
      IF(WB.LT.SMAL) GO TO 140
      PROJ=(VEC(1)*SB(J+5)+VEC(2)*SB(J+6)+VEC(3)*SB(J+7))/WB
      SUM=ZERO
      DO 180 L=1,3
      VEC(L)=VEC(L)-PROJ*SB(J+4+L)/WB
  180 SUM=SUM+VEC(L)**2
      SUM=DSQRT(SUM)
      IF(SUM.LT.SMAL) GO TO 140
      WB=WA/SUM
      DO 190 L=1,3
  190 SB(J+L)=WB*VEC(L)
      GO TO 60
C
  140 CONTINUE
C---     USE VEC TO DETERMINE THE CROSS CONSTRAINT AT JUNCTION J
      IF(IPASS.EQ.2) GO TO 200
      DO 210 L=1,3
  210 SA(J+L)=VEC(L)
      SA(J+4)=ONE
      GO TO 60
  200 CONTINUE
      DO 220 L=1,3
  220 SB(J+L)=VEC(L)
      SB(J+4)=ONE
C
   60 CONTINUE
C
   10 CONTINUE
C
      IF(IBUG.EQ.11) CALL SCDUMP(5,SA)
      IF(IBUG.EQ.11) CALL SCDUMP(6,SB)
C
      IERROR=0
      RETURN
      END
**** SOURCE FILE : M0004287.V03   ***
*
      SUBROUTINE CRVLEN(PA,PB,TA,TB,A,B,NUMINT,MXCT,CTOLR,ILEVEL)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---MAIN ROUTINE TO DETERMINE OPTIMUM VECTOR LENGTHS FOR TANGENT
C---VECTORS OF A CUBIC.  INPUT CONSTRAINTS INCLUDE
C--- PA,PB  START AND END POINTS OF PARAMETRIC CUBIC
C--- TA,TB  START AND END UNIT TANGENT VECTORS
C--- NUMINT IS NUMBER OF SIMPSON INTERVALS FOR DETERMINING AREA
C--- MXCT IS THE MAXIMUM NUMBER OF NEWTON-RHAPSON ITERATIONS
C--- CTOLR IS THE RATIO OF CHANGE FOR TERMINATION OF ITERATIONS
C--- ILEVEL CONTROLS THE LEVEL OF CALCULATION FOR A,B
C--- =1 CHORD LENGTH, =2 MINIMIZE DDR, =3 NEWTON RHAPSON
C--- A,B ARE THE OUTPUT LENGTHS OF TANGENTS.
C--- A,B ARE SELECTED TO MINIMZE INTEGRAL OF K*K*DS OVER 0,1
C--- METHOD IS NEWTON-RHAPSON WITH ITERATIONS AND
C--- SIMPSONS RULE TO DETERMINE APPROXIMATE AREA
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
      DIMENSION PA(3),PB(3),TA(3),TB(3)
      DIMENSION SUM(6),AREA(6),DIF(3)
      CHARACTER*20 BADMSG
C
      DATA ZERO,ONE,SMAL/0.0D0,1.0D0,1.0D-15/
C
      DO 5 I=1,3
    5 DIF(I)=PB(I)-PA(I)
      CALL VNORM(TA,TA)
      CALL VNORM(TB,TB)
      ISTART=1
      IEND=2*NUMINT+1
      H=1./(2.*NUMINT)
      H3=H/3.
      W=H+H
C
C---      INITIAL ESTIMATE OF A,B IS FROM CHORD LENGTH
      CALL DOTF(A,DIF,DIF)
      A=DSQRT(A)
      B=A
      IF(ILEVEL.LE.1) GO TO 70
C---      A SECOND INITIAL ESTIMATE IS FROM MINIMIZE DDR AT ENDS
      CALL DOTF(X1,TA,DIF)
      CALL DOTF(X2,TB,DIF)
      CALL DOTF(X3,TA,TB)
      TEMP=3./(4.-X3**2)
      A1=(2.*X1-X3*X2)*TEMP
      B1=(2.*X2-X3*X1)*TEMP
C---      IF A1 OR B1 IS NEGATIVE, IGNORE THESE VALUES
      IF(A1.LT.SMAL.OR.B1.LT.SMAL) GO TO 7
      A=A1
      B=B1
    7 CONTINUE
C---      NOW SAVE THESE A,B ESTIMATES AS A BACKUP
      ASAVE=A
      BSAVE=B
C
      IF(ILEVEL.LE.2) GO TO 70
      ICT=0
C
   10 CONTINUE
C---      ICT IS THE COUNT OF THE NUMBER OF NEWTON RHAPSON ITERATIONS
      IF(ICT.GT.MXCT) GO TO 70
      DO 20 I=1,6
   20 AREA(I)=ZERO
C
C---      PERFORM INTEGRATION TO OBTAIN ESTIMATES OF TENSION AND DERIVS.
      DO 30 I=ISTART,IEND
      SIMFAC=4.
      IF(MOD(I,2).EQ.1) SIMFAC=2.
      IF(I.EQ.ISTART.OR.I.EQ.IEND) SIMFAC=1.
      SIMFAC=SIMFAC*H3
      MODE=0
      IF(I.EQ.ISTART) MODE=1
      U=(I-1.)*H
C
      CALL ADER(DIF,TA,TB,A,B,U,MODE,SUM)
C
      IF(IBUG.EQ.11) CALL BAD(-6,1,'SUM ',SUM)
      DO 40 J=1,6
   40 AREA(J)=SIMFAC*SUM(J)+AREA(J)
C
   30 CONTINUE
C
      IF(IBUG.EQ.11) CALL BAD(-6,1,'AREA',AREA)
C
C---      ESTIMATE CHANGE DA,DB IN A,B TO REDUCE TENSION IN CURVE
      DET=AREA(4)*AREA(6)-AREA(5)**2
      IF(DABS(DET).GT.SMAL) GO TO 50
C---      USE THE PREVIOUS VALUES FOR A,B
      A=ASAVE
      B=BSAVE
      GO TO 70
C
   50 CONTINUE
C
      DA=(-AREA(2)*AREA(6)+AREA(3)*AREA(5))/DET
      DB=(-AREA(4)*AREA(3)+AREA(5)*AREA(2))/DET
C
      RATIO=DSQRT(DA**2+DB**2)/DSQRT(A**2+B**2)
      IF(IBUG.NE.11) GO TO 93
      CALL BAD(-1,0,' ',0)
      BADMSG=' ENTRY TO CRVLEN'
      CALL CPRINT(BADMSG)
      CALL BAD(1,1,'A   ',A)
      CALL BAD(1,1,'B   ',B)
      CALL BAD(1,1,'DA  ',DA)
      CALL BAD(1,1,'DB  ',DB)
      CALL BAD(-1,1,'RATI',RATIO)
   93 CONTINUE
      A=A+DA
      B=B+DB
      IF(RATIO.LT.CTOLR) GO TO 70
C
      ICT=ICT+1
      GO TO 10
C
   70 CONTINUE
C---      A NEGATIVE A OR B IS NOT ACCEPTABLE SO USE THE BACKUP
C---      VALUES IF A OR B ARE NEGATIVE
      IF(A.GT.ZERO.AND.B.GT.ZERO) GO TO 999
      A=ASAVE
      B=BSAVE
  999 CONTINUE
      IF(IBUG.NE.11) GO TO 998
      CALL BAD(-1,0,' ',0)
      BADMSG=' EXIT FROM CRVLEN'
      CALL CPRINT(BADMSG)
      CALL BAD(1,1,'A   ',A)
      CALL BAD(1,1,'B   ',B)
      CALL BAD(1,1,'ASAV',ASAVE)
      CALL BAD(-1,1,'BSAV',BSAVE)
      CALL BAD(-1,0,' ',0)
  998 CONTINUE
C
      RETURN
      END
**** SOURCE FILE : M0001059.V06   ***
*
      SUBROUTINE CTRANS(PROFIL,CROS,KCASE,MAXSRF,SURF,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---      PROFIL =INPUT SYNTHETIC PROFILE CURVE
C---      CROS = INPUT SYNTHETIC CROSS COMMAND CURVE
C---      KCASE =INPUT  TYPE OF CROSS TRANSFORMATION TO USE
C---         =1 GIVES TRANSL, =2 GIVES XYROT, =3 GIVES YZROT
C---         =4 GIVES ZXROT, =5 GIVES SCALE
C---      MAXSRF =INPUT IS THE MAXIMUM SPACE AVAILABLE FOR SURF
C---      SURF IS THE OUTPUT ARRAY WHICH CONTAINS THE SURFACE
C---      (LESS TOPOLOGY TABLE)
C---      IRR =OUTPUT, IF NON ZERO ON RETURN INDICATES ERROR.
C---      THIS SUBROUTINE ACCEPTS AN INPUT OF A PROFILE CURVE
C---      PROFIL OF N ARCS AND A CROSS CURVE CROS OF K ARCS.
C---      A MESH-LIKE SURFACE OF N*K RATIONAL BICUBIC PATCHES
C---      IS CONSTRUCTED BY TRANSFORMING EACH OF THE PROFILE ARCS
C---      BY THE CROSS COMMAND CURVE ARCS.  THE IMPLIED SPLINE
C---      DIRECTION IS DETERMINED BY THE PROFILE CURVE AND
C---      THE CROSS DIRECTION BY THE CROSS COMMAND CURVE.
C
      DIMENSION PROFIL(*),CROS(*),SURF(*)
C
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
C
C---      THE FOLLOWING ARRAYS ARE USED TO HOLD THE SELECTOR
C---      MATRIX BSEL AND BOTH INTERIM AND FINAL RATIONAL BICUBIC
C---      PATCH MATRICES BMAT.
      DIMENSION BSEL(16,4),BMAT(16,4),TRN(16)
C---
C---      THE FOLLOWING ARRAYS HOLD INFORMATION NECESSARY TO
C---      GENERATE SELECTOR MATRICES BASED ON THE CASE(KCASE)
      DIMENSION IB(89),BX(2)
      DATA IB/
     X 101,4,1,13,1,102,8,1,14,1,103,12,1,15,1,104,16,1,9999,
     X 201,1,1,6,2,202,2,1,5,1,203,12,1,15,1,204,16,1,9999,
     X 301,4,1,13,1,302,6,1,11,1,303,7,1,10,1,304,16,1,9999,
     X 401,3,2,9,1,402,8,1,14,1,403,1,1,11,1,404,16,1,9999,
     X 501,1,1,502,6,1,503,11,1,504,16,1,9999/
      DATA IBMAX/89/
      DATA IEND/9999/
C---     THE FOLLOWING ARRAY HOLDS REAL VALUES WHICH IB POINTS TO.
      DATA NBX/2/
      DATA BX/1.0D0,-1.0D0/
      DATA ZERO,ONE/0.0D0,1.0D0/
C
C---     THE SIZE OF THE HEADER TABLE AND NUMBER OF ARCS FOR BOTH CURVES
      NHDPRO=PROFIL(2)
      NARCP=PROFIL(4)
      NHDCRS=CROS(2)
      NARCC=CROS(4)
C***      CHECK FOR ENOUGH ROOM FOR SURFACE
      IRR=1
      NPAT=NARCP*NARCC
      IF(10+NPAT*74.GT.MAXSRF) GO TO 990
C---     SET UP THE BSEL MATRIX FOR THIS KCASE(LOGIC IS USED
C---     TO PREVENT STORING MANY COMPLETE BSEL-S)
      DO 101 L=1,4
      DO 101 K=1,16
  101 BSEL(K,L)=ZERO
C---      NOW SKIM THRU THE IB ARRAY TO PICK UP NONZERO BSEL VALUES
      I=1
  201 CONTINUE
C***     ERROR IN IB SET-UP
      IRR=2
      IF(I.GT.IBMAX) GO TO 990
      IF(IB(I)/100.EQ.KCASE) GO TO 203
      I=I+1
      GO TO 201
  203 CONTINUE
      IF(IB(I).EQ.IEND) GO TO 210
      IF(IB(I).LT.100) GO TO 205
      JMAT=MOD(IB(I),100)
      I=I+1
      GO TO 203
  205 CONTINUE
      JVAL=IB(I+1)
      IVAL=IB(I)
C***     INVALID INDEX, SYSTEM ERROR
      IRR=3
      IF(IVAL.LT.1.OR.IVAL.GT.16) GO TO 990
      IF(JMAT.LT.1.OR.JMAT.GT.4) GO TO 990
      IF(JVAL.LT.1.OR.JVAL.GT.NBX) GO TO 990
C
      BSEL(IVAL,JMAT)=BX(JVAL)
      I=I+2
      GO TO 203
  210 CONTINUE
C
      IF(IBUG.NE.11) GO TO 212
      DO 213 L=1,4
      DO 213 K=1,4
      KK=(K-1)*4+1
      CALL BAD(-4,1,'BSEL',BSEL(KK,L))
  213 CONTINUE
  212 CONTINUE
C
C---      FIRST INITIALIZE SURFACE HEADER DATA
      SURF(1)=ZERO
      APAT=NPAT
      SURF(2)=APAT*64.
      SURF(3)=APAT*4.
      SURF(4)=APAT
      SURF(5)=2.
      SURF(6)=5.
      SURF(7)=ONE
      SURF(8)=APAT*74.+10.
      SURF(9)=NARCC+1
      SURF(10)=NARCP+1
C---     SET UP PATCH HEADER TABLE
      AFX=10.+APAT*6.+1.
      ILOC=10
      DO 310 L=1,NPAT
      DO 320 K=1,4
  320 SURF(ILOC+K)=4.
      SURF(ILOC+5)=AFX
      SURF(ILOC+6)=ZERO
      ILOC=ILOC+6
      AFX=AFX+64.
  310 CONTINUE
C
C---     MAIN LOOP  COMPUTE EACH RATIONAL PATCH AND PLACE IN SURF
      DO 301 IC=1,NARCC
      LOCC=(NHDCRS+IC-1)*24+1
      IF(IBUG.EQ.11) CALL BAD(-16,1,'CROS',CROS(LOCC))
      DO 301 IP=1,NARCP
      LOCP=(NHDPRO+IP-1)*24+1
C
C---     TRANSPOSE THE PROFILE MATRIX
      IF(IBUG.EQ.11) CALL BAD(-16,1,'PROF',PROFIL(LOCP))
      CALL TRANSP(PROFIL(LOCP),TRN,4)
      IF(IBUG.EQ.11) CALL BAD(-16,1,'TRN ',TRN)
C
      DO 302 J=1,4
C---     NOTE THAT SMMULT(A,B,C) GIVES C=B*A
      CALL SMMULT(4,4,4,3,CROS(LOCC),BSEL(1,J),BMAT(1,J))
C---      BMAT=BSEL*CROS, THEN BMAT=BMAT*TRN
      CALL SMMULT(4,4,4,3,BMAT(1,J),TRN,BMAT(1,J))
C---     NOW BACK TRANSPOSE THE BMAT RESULT
      CALL TRANSP(BMAT(1,J),BMAT(1,J),4)
      IF(IBUG.NE.11) GO TO 314
      DO 315 L=1,4
      LL=(L-1)*4+1
      CALL BAD(-4,1,'BMAT',BMAT(LL,J))
  315 CONTINUE
  314 CONTINUE
  302 CONTINUE
C---      NOW TRANSFER THE RATIONAL MATRIX BMAT TO SURF
      IPAT=(IC-1)*NARCP+IP
      LOC=10+IPAT*6-1
      LOC=SURF(LOC)
      DO 303 JJ=1,4
      DO 303 KK=1,16
      SURF(LOC)=BMAT(KK,JJ)
      LOC=LOC+1
  303 CONTINUE
C
  301 CONTINUE
C
  980 CONTINUE
      IRR=0
      GO TO 999
C
  990 CONTINUE
      CALL BAD(-1,0,'CTRN',IRR)
      GO TO 999
C
  999 CONTINUE
C
      IF(IBUG.NE.11) GO TO 998
      NN=NPAT*74+10
      CALL BAD(-NN,1,'SURF',SURF)
  998 CONTINUE
C
      RETURN
      END
**** SOURCE FILE : M0000623.V01   ***
*
      SUBROUTINE CURFIT( PA, PB, PC, PD, TA, TD, KTYP, IRR )
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION PA(3),PB(3),PC(3),PD(3),TA(3),TD(3)
      DIMENSION CCOEF(3,4), RP(3), RDN(3)
      IDIAG = 27000
      IRR = 0
C------INPUT IS FOUR POINTS PA,PB,PC,PD IN LINEAR ORDER
C------OUTPUT IS TANGENT VECTORS TA,TD OF A SMOOTH CUBIC CURVE
C------WHICH PASSES THRU THE INPUT POINTS.  IF IRR.NE.0 , THEN
C------THERE IS POTENTIAL TROUBLE IN THE INPUT POINTS
C------THE FIRST STEP IS A CHECK FOR EQUALITY OF PB AND PC
C------KTYP IS OUTPUT CURVE TYPE. 1=NULL CURVE,
C------2=STRAIGHT SEGMENT, 3= THREE POINT CURVE, 4= FOUR PT CURVE
      D1=DSQRT((PB(1)-PA(1))**2+(PB(2)-PA(2))**2+(PB(3)-PA(3))**2)
      D2=DSQRT((PC(1)-PB(1))**2+(PC(2)-PB(2))**2+(PC(3)-PB(3))**2)
      D3=DSQRT((PD(1)-PC(1))**2+(PD(2)-PC(2))**2+(PD(3)-PC(3))**2)
      DT = D1 + D2 + D3
C------VARIOUS CHECKS ARE MADE ON THE INPUT TO DETECT DEGENERATE CASES
C------FOR EXAMPLE PA=PB=PC.NE.PD WILL INDICATE A SRAIGHT LINE THRU
C------PA AND PD.
      CRIT = 0.00001
      IF( DT .GT. CRIT ) GO TO 100
C------THIS IS CASE OF A ZERO CURVE
      DO 10 I = 1, 3
      TA(I) = 0.
   10 TD(I) = 0.
      KTYP = 1
      GO TO 999
  100 CONTINUE
      IF ( D1 .GT. CRIT .AND. D2 .GT. CRIT ) GO TO 200
      IF ( D1 .GT. CRIT .AND. D3 .GT. CRIT ) GO TO 200
      IF ( D2 .GT. CRIT .AND. D3 .GT. CRIT ) GO TO 200
C------THE STRAIGHT LINE CASE
      DO 120 I = 1, 3
      TA(I) = PD(I) - PA(I)
  120 TD(I) = TA(I)
      KTYP = 2
      GO TO 999
C------FINALLY CHECK FOR THREE POINT DEGENERACY
  200 CONTINUE
      IF ( D1 .LT. CRIT ) GO TO 400
      IF ( D2 .LT. CRIT ) GO TO 400
      IF ( D3 .LT. CRIT ) GO TO 400
C------THE NON TRIVIAL FOUR POINT CURVE FOLLOWS
      CALL FORCUB ( PA, PB, PC, PD, TA, TD, IRR )
      IF ( IRR .EQ. 0 ) GO TO 310
C------TRY A MORE RUDIMENTARY ESTIMATE OF TA AND TD
      DO 320 I = 1, 3
      TA(I) = ( PB(I) - PA(I) )*DT/D1
      TD(I) = ( PD(I) - PC(I) )*DT/D3
  320 CONTINUE
  310 CONTINUE
C------NOW PROJECT PB AND PC ONTO THE INITIAL ESTIMATED CURVE
      DO 330 I = 1, 3
      CCOEF(I,1) = PA(I)
      CCOEF(I,2) = PD(I)
      CCOEF(I,3) = TA(I)
  330 CCOEF(I,4) = TD(I)
      DF1=PD(1)-PA(1)
      DF2=PD(2)-PA(2)
      DF3=PD(3)-PA(3)
      DDF=DF1*DF1+DF2*DF2+DF3*DF3+1.0D-30
      B=((PB(1)-PA(1))*DF1+(PB(2)-PA(2))*DF2+(PB(3)-PA(3))*DF3)/DDF
      C=((PC(1)-PA(1))*DF1+(PC(2)-PA(2))*DF2+(PC(3)-PA(3))*DF3)/DDF
      CALL PARMPT ( PA, PD, PB, B, PC, C, TA, TD, IRR)
      KTYP = 4
      GO TO 999
C------THE THREE POINT DEGENERATE CASE FOLLOWS
  400 CONTINUE
C------PB SHOULD BE THE NONTRIVIAL THIRD POINT
      IF ( D1 .GT. CRIT ) GO TO 410
      DO 420 I = 1, 3
  420 PB(I) = PC(I)
  410 CONTINUE
      CALL PARINT ( PA, PB, PD, TA, R, 1, IRR)
      IF ( IRR .NE. 0) GO TO 430
      CALL PARINT ( PA, PB, PD, TD, R, 3, IRR)
      GO TO 450
  430 CONTINUE
      IRR=0
      DO 440 I = 1, 3
      TA(I) = ( PB(I) - PA(I) )/DMAX1(D1,D2)
      TD(I) = ( PD(I) - PB(I) )/DMAX1(D2,D3)
  440 CONTINUE
  450 CONTINUE
C------NOW PROJECT THE PB ONTO THE INITIAL CURVE
      DF1=PD(1)-PA(1)
      DF2=PD(2)-PA(2)
      DF3=PD(3)-PA(3)
      DDF=DF1*DF1+DF2*DF2+DF3*DF3+1.0D-12
      B=((PB(1)-PA(1))*DF1+(PB(2)-PA(2))*DF2+(PB(3)-PA(3))*DF3)/DDF
C------DETERMINE A SCALAR X SUCH THAT THE VECTORS X*TA AND X*TD
C------MAKE A CLOSEST APPROACH TO THE POINT PB AT THE PARAMETER
C------VALUE B.
      BSQ  = B*B
      BCB  = B*BSQ
      SUMA = 0.
      SUMB = 0.
      DO 470 I = 1, 3
      DEL = PD(I) - PA(I)
      R   = PA(I) + DEL*( 3*BSQ - 2*BCB )
      S   = TA(I)*( B - BSQ - BSQ + BCB ) + TD(I)*( -BSQ + BCB )
C------MINIMIZE THE FORM (R+ X*S - PB)**2 WITH RESPECT TO X
      R   = R - PB(I)
      SUMA = SUMA + R*S
      SUMB = SUMB + S*S
  470 CONTINUE
      IF ( DABS(SUMB) .LT. 1.0D-8 ) X = 1.0
      IF ( DABS(SUMB) .GE. 1.0D-8 ) X = -SUMA/SUMB
      DO 480 I = 1, 3
      TA(I) = X*TA(I)
  480 TD(I) = X*TD(I)
      KTYP = 3
      IRR = 0
  999 RETURN
      END
**** SOURCE FILE : M0000626.V02   ***
*
      SUBROUTINE DISEG(ISEG,CIN,COUT,MXOUT,IERROR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---     PURPOSE IS TO EXTRACT A SINGLE SEGMENT FROM AN S-CURV
C---     AND TO CONVERT IT INTO A COMPLETE SYNTHETIC CURVE WITH
C---     A SINGLE FLOW SEGMENT
C---     INPUT ISEG REFERS TO A VALID CURVE SEGMENT FOR A FLOW
C---     TYPE ARC.  IF THE ARC IS A SIMPLE NON FLOW TYPE ISEG
C---     DEFAULTS TO AN ARC REFERENCE.  FINALLY A NEGATIVE ISEG
C---     ALWAYS REFERS TO AN ARC.
C---     CIN IS THE INPUT CURVE STRUCTURE
C---     COUT IS THE OUTPUT SINGLE SEGMENT STRUCTURE
C---     MXOUT IS THE MAXIMUM SPACE AVAILABLE FOR AN OUTPUT CURVE
C---     IERROR NOT ZERO ON RETURN INDICATES AN ERROR
C
      DIMENSION CIN(*),COUT(*)
      DATA ONE,ZERO,SMAL/1.0D0,0.0D0,1.0D-7/
C
C---     BRANCH TO ARC CALCULATION IF ISEG IS NEGATIVE
      IF(ISEG.LT.0) GO TO 300
      NSEG=CIN(8)
      IF(NSEG.EQ.0) GO TO 300
C****    INPUT SEGMENT NUMBER IS INVALID
C---    DETERMINE ARCS WHICH MAKE UP THIS SEGMENT REFERENCE
      IERROR=01
      IF(ISEG.LT.1.OR.ISEG.GT.NSEG) GO TO 9998
      NSEGRW=CIN(9)+(ISEG-1)*4
      NARC1=CIN(NSEGRW)*4.+CIN(7)
      NARC2=NARC1+(CIN(NSEGRW+1)-ONE)*4.
      NFLOW1=CIN(NARC1)
      NFLOW2=CIN(NARC2)+CIN(NARC2+1)*4.-ONE
C---     ARC NUMBERS
      N1=CIN(NSEGRW)+ONE
      N2=N1+CIN(NSEGRW+1)-ONE
C---     SET UP HEADER TABLE FIRST
      COUT( 1)=ZERO
      COUT( 2)=ONE
      COUT( 3)=10.
      COUT( 4)=(NARC2-NARC1)/4+1
      COUT( 5)=COUT(2)*24.+ONE
      COUT( 6)=COUT(4)
      COUT( 7)=COUT(5)+COUT(4)*24.
      COUT( 8)=ONE
      COUT( 9)=COUT(7)+COUT(6)*4.
      COUT(10)=(NFLOW2-NFLOW1+1)/4
      COUT(11)=COUT(9)+4.*COUT(8)
      COUT(12)=COUT(11)+COUT(10)*4.-ONE
      COUT(13)=ONE
      NARC=COUT(4)
      NSIZE=COUT(12)
C****    CURVE TOO LARGE FOR BUFFER AREA
      IERROR=02
      IF(NSIZE.GT.MXOUT) GO TO 9998
C---     ZERO OUT REMAINDER OF CANON AREA
      DO 100 I=14,NSIZE
  100 COUT(I)=ZERO
      NARC=COUT(4)
C---     NOW MOVE CUBIC ARC DATA
      KO=COUT(5)-9.
      KI=CIN(5)-8.+(N1-1)*24
      NN=KI+COUT(4)*24.+7
      DO 110 I=KI,NN
      KO=KO+1
      COUT(KO)=CIN(I)
  110 CONTINUE
C
C---     NOW MOVE ARC FLOW SUMMARY BLOCKS
      KO=COUT(7)-ONE
      KI=NARC1-1
      ABIAS=CIN(KI+1)-COUT(11)
      DO 140 I=1,NARC
      KOX=KO+(I-1)*4
      KIX=KI+(I-1)*4
      DO 150 J=2,4
  150 COUT(KOX+J)=CIN(KIX+J)
      COUT(KOX+1)=CIN(KIX+1)-ABIAS
  140 CONTINUE
C---     MOVE SEGMENT DATA
      KI=CIN(9)-ONE+(ISEG-1)*4
      KO=COUT(9)-ONE
      COUT(KO+1)=ZERO
      COUT(KO+2)=CIN(KI+2)
      COUT(KO+3)=CIN(KI+3)
      COUT(KO+4)=CIN(KI+4)
C---    FINALLY TRANSFER ALL PERTINENT FLOW BLOCKS
      KI=CIN(NSEGRW)*4.+CIN(7)
      KI=CIN(KI)-ONE
      KO=COUT(11)-ONE
      NFLOW=COUT(10)*4.
      DO 160 I=1,NFLOW
  160 COUT(KO+I)=CIN(KI+I)
C---
      GO TO 9997
C
C
C---     SURFACE IS OF SIMPLE NON-FLOW TYPE. ISEG IS THEN AN
C---     ARC-TYPE REFERENCE
  300 CONTINUE
      IARC=IABS(ISEG)
      NSIZE=48
C****    THERE IS NOT ENOUGH ROOM TO DECOMPOSE ARC
      IERROR=03
      IF(NSIZE.GT.MXOUT) GO TO 9998
      DO 310 I=1,48
  310 COUT(I)=ZERO
      COUT(2)=ONE
      COUT(3)=2.
      COUT(4)=ONE
      COUT(12)=48.
      NSEG=CIN(4)
C****    ARC REFERENCE IS OUT OF RANGE
      IERROR=04
      IF(IARC.LT.1.OR.IARC.GT.NSEG) GO TO 9998
      NBASI=CIN(2)*24.+(IARC-1)*24-8.
      NBASO=COUT(2)*24.-8.
      DO 320 I=1,32
  320 COUT(I+NBASO)=CIN(I+NBASI)
      GO TO 9997
C
 9997 CONTINUE
      IERROR=0
      GO TO 9999
 9998 CONTINUE
C---    ERROR EXIT PATH
      GO TO 9999
C
 9999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0000627.V02   ***
*
      SUBROUTINE FLOINV(U,SC,FLO,ISEG)
C---     PURPOSE IS TO CONVERT A COONS PARAMETER U
C---     INTO A FLOW VALUE FLO AND SEGMENT NUMBER ISEG
C---     ON A GIVEN FLOW CURVE SC.
C---     PRESENT ROUTINE ONLY WORKS FOR INTEGRAL U
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION SC(*)
C
      NUMSEG=SC(8)
      IF(NUMSEG.GT.0) GO TO 10
C---     CURVE HAS NO FLOW STRUCTURE, SET FLO TO U
      U=FLO
      ISEG=0
      GO TO 999
C
   10 CONTINUE
      LOCSEG=SC(9)-5.
C---     FIRST SEARCH FOR A SEGMENT NUMBER
      ISEG=1
   20 CONTINUE
      IF(ISEG.GE.NUMSEG)GO TO 40
      LOCSEG=LOCSEG+4
      IF(U.LT.SC(LOCSEG+1)) GO TO 40
      IF(U.LE.SC(LOCSEG+2)) GO TO 40
      ISEG=ISEG+1
      GO TO 20
C
   40 CONTINUE
C---     NOW DETERMINE THE FLOW VALUE WITHIN THIS SEGMENT
      JUNC=U
      NUMARC=SC(4)
      IARC=JUNC+1
      IF(JUNC.GE.NUMARC) IARC=NUMARC
      LOCARC=SC(7)+(IARC-1)*4
      NN=1
      LOCFLO=SC(LOCARC)
      IF(JUNC.GE.NUMARC) NN=SC(LOCARC+1)
      LOCFLO=LOCFLO+(NN-1)*4
      FLO=SC(LOCFLO)
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0004340.V09   ***
*
      SUBROUTINE FLOSEG(NSIZE,NSZSAV,MODE,IFLSEG,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      INCLUDE (BLANKCOM)    
C
      INCLUDE (SSPAD)    
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
      DIMENSION ST(4,ISCN/4)
      EQUIVALENCE (SCAN(1),ST(1,1))
      LOGICAL IFLOW,ISEG
      DIMENSION STEMP(4,100)
      DIMENSION PP(4,3)
C
      DOUBLE PRECISION LIMIT,NORMAL
C---     THE FOLLOWING ARRAY, DARRAY, IS SHARED FOR PRINTING
      INCLUDE (DARRAY)    
      INTEGER IZAL2(3),IZAL3(6),IZAL4(3),IZAL5(3)
      CHARACTER*8 RNAM1,RNAM2,RNAM3,RNAM4,RNAM5,RNAMA,RNAME
      CHARACTER*8 SEG,ARC,PARAM,CHORD,FLOW,LENGTH,ANGLE,TEST
C
      DATA MAXNOP/30/
      DATA NHD/1/
      DATA POINT /19./
      DATA VECTOR/20./
      DATA AREAL /21./
      DATA AFLOW,ASEG/149.0D0,150.0D0/
C---      LSTEMX IS THE MAXIMUM NUMBER OF ROWS IN STEMP
      DATA MAXSC,LSTEMX/96,100/
      DATA SEG/'SEG     '/
      DATA ARC/'ARC     '/
      DATA PARAM/'PARAM   '/
      DATA CHORD/'CHORD   '/
      DATA FLOW/'FLOW    '/
      DATA LENGTH/'LENGTH  '/
      DATA ANGLE/'ANGLE   '/
      DATA ZERO,ONE,SMAL,BIG/0.0D0, 1.0D0, 1.0D-7, 99999999.0D0/
      DATA TOLR/0.005D0/
      DATA    RNAM1   /'FLOSEG  '/,RNAM2   /'ANGSEG  '/,
     *          RNAM3   /'CHDSEG  '/,RNAM4   /'ARCSEG  '/,
     *          RNAM5   /'ANGDER  '/,
     *          RNAMA   /'FLOSEG??'/,RNAME   /'        '/
      DATA IMAX2/ 3/,IZAL2
     *                  / 5508, 5509, 5510/
      DATA IMAX3/ 6/,IZAL3
     *                  / 5502, 5503, 5504, 5505, 5506, 5507/
      DATA IMAX4/ 3/,IZAL4
     *                  / 5501, 5522, 5523/
      DATA IMAX5/ 3/,IZAL5
     *                  / 5519, 5511, 5512/
C
C
      NP=0
      NH=41
      ANH=NH
      NHD1=NHD+1
      NS=NH+8
C--- MODE=2 MEANS PROCESS FLOW COMMANDS PREVIOUSLY STORED
C---      IN STEMP
C--- MODE=1 MEANS PERFORM PRELIMINARY SCAN OF SCURV INPUT-STREAM
C---      AND STORE FLOW DATA, IF ANY, IN STEMP.
      IF(MODE.EQ.2) GO TO 2000
C
C---     PERFORM A PRELIMINARY SCAN OF DATA TO LOCATE FLOW
C---     AND SEGMENT INFORMATION IN THE DEFINITION
C---     LSTEMP IS THE POINTER TO THE LAST USED ROW IN STEMP
C---     IFLOW IS TRUE ONLY WHILE PROCESSING FLOW BLOCKS
C---     ISEG IS TRUE ONLY WHILE PROCESSING SEGMENT BLOCKS
C---     NSEGST POINTS TO THE STARTING ROW FOR SEGMENT INFORMATION
C---     NFLOST POINTS TO THE STARTING ROW FOR FLOW INFORMATION
      IFLOW=.FALSE.
      ISEG=.FALSE.
      NFLOST=0
      NSEGST=0
      LSTEMP=0
      NUMSEG=0
      IFLSEG=0
C
C---     SEARCH FOR FLOW AND SEGMENT BLOCKS AND TRANSFER
C---     INFORMATION IN EDITED FORM INTO THE STEMP ARRAY
C
      NLOC=NS
   34 CONTINUE
      IF(NLOC.GE.NSIZE) GO TO 1034
C
C---     NLOC POINTS TO THE STARTING LOCATION OF THE CURRENT
C---     SUBSTRING BEING EXAMINED. IT IS UPDATED TO THE NEXT SUBSTRING
C---     AT THE TERMINATION OF CODE FOR EACH SUBSTRING.
      T=CANON(NLOC)
      CALL HOLFRM(T,TEST,1,8,NWD)
      IF(TEST.EQ.FLOW) GO TO 40
      IF(TEST.EQ.SEG) GO TO 50
      CALL HOLFRM(CANON(NLOC+1),TEST,1,8,NWD)
      IF(TEST.EQ.SEG) GO TO 51
C---     IF FLOW OR SEG HAVE NOT BEEN FOUND, CONTINUE SEARCH
      IF(.NOT.IFLOW.AND..NOT.ISEG) NLOC=NLOC+1
      IF(.NOT.IFLOW.AND..NOT.ISEG) GO TO 31
      IF(IFLOW) GO TO 60
C---     ISEG MUST BE TRUE SO CHECK FOR SEGMENT BLOCKS
      T=CANON(NLOC+1)
      CALL HOLFRM(T,TEST,1,8,NWD)
      IF(TEST.EQ.LENGTH.OR.TEST.EQ.PARAM) GO TO 35
C****    PROPER MINOR WORD DID NOT FOLLOW HERE.
      IRR=1
      GO TO 30
   35 CONTINUE
      LSTEMP=LSTEMP+1
      IF(LSTEMP.LE.LSTEMX) GO TO 36
C****    NO ROOM AVAILABLE IN BUFFER FOR FLOW/SEG DATA
      IRR=2
      GO TO 30
   36 CONTINUE
      STEMP(1,LSTEMP)=T
      IF(CANON(NLOC+2).EQ.AREAL.AND.CANON(NLOC+4).EQ.AREAL) GO TO 38
C****    AT LEAST TWO SCALARS SHOULD FOLLOW
      IRR=3
      GO TO 30
   38 CONTINUE
      STEMP(2,LSTEMP)=CANON(NLOC+3)
      STEMP(3,LSTEMP)=CANON(NLOC+5)
      STEMP(4,LSTEMP)=ONE
      NLOC=NLOC+6
      NUMSEG=NUMSEG+1
      GO TO 31
C
C---     CHECK FOR PROPER WORDS FOR FLOW INFORMATION
   60 CONTINUE
      T=CANON(NLOC+1)
      MSIZE=1
      CALL HOLFRM(T,TEST,1,8,NWD)
      IF(TEST.EQ.ARC.OR.TEST.EQ.PARAM) GO TO 65
      MSIZE=4
      IF(TEST.EQ.CHORD) GO TO 65
      MSIZE=4
      IF(TEST.EQ.ANGLE) GO TO 65
C****   NONE OF THE REQUIRED KEYWORDS HAS FOLLOWED
      MSIZE=0
      IRR=4
      GO TO 30
C
   65 CONTINUE
      ASIZE=MSIZE
      IF(CANON(NLOC+2).EQ.AREAL.AND.CANON(NLOC+4).EQ.AREAL) GO TO 70
C****    AT LEAST TWO SCALARS SHOULD FOLLOW
      IRR=5
      GO TO 30
   70 CONTINUE
      LSTEMP=LSTEMP+1
      IF(LSTEMP+MSIZE-1.LE.LSTEMX) GO TO 75
C****    NO ROOM TO BUFFER ARC/FLOW DATA
      IRR=6
      GO TO 30
   75 CONTINUE
      STEMP(1,LSTEMP)=T
      STEMP(2,LSTEMP)=CANON(NLOC+3)
      STEMP(3,LSTEMP)=CANON(NLOC+5)
      STEMP(4,LSTEMP)=ASIZE+TOLR
      NLOC=NLOC+6
      IF(CANON(NLOC).NE.AREAL) GO TO 76
C---     LOAD A USER SUPPLIED TOLERANCE , IF ACCEPTABLE
      T=CANON(NLOC+1)
      IF(T.GT.SMAL.AND.T.LT.ONE) STEMP(4,LSTEMP)=ASIZE+T
      NLOC=NLOC+2
   76 CONTINUE
      IF(MSIZE.LT.2) GO TO 89
C---     SCAN FOR MODIFYING POINTS AND VECTORS FOR FLOW SPECIFICATION
      MM=MSIZE-1
      DO 80 L=1,MM
      DO 80 K=1,4
      STEMP(K,L+LSTEMP)=ZERO
   80 CONTINUE
      T=CANON(NLOC)
      IF(T.NE.POINT.OR.MSIZE.LT.2) GO TO 83
      DO 81 L=1,3
      STEMP(L,LSTEMP+1)=CANON(NLOC+L)
   81 CONTINUE
      STEMP(4,LSTEMP+1)=ONE
      NLOC=NLOC+4
      T=CANON(NLOC)
   83 CONTINUE
      IF(T.NE.POINT.OR.MSIZE.LT.3) GO TO 87
      DO 86 L=1,3
      STEMP(L,LSTEMP+2)=CANON(NLOC+L)
   86 CONTINUE
      STEMP(4,LSTEMP+2)=ONE
      NLOC=NLOC+4
      T=CANON(NLOC)
   87 CONTINUE
      IF(T.NE.VECTOR.OR.MSIZE.LT.4) GO TO 89
      DO 88 L=1,3
      STEMP(L,LSTEMP+3)=CANON(NLOC+L)
   88 CONTINUE
      STEMP(4,LSTEMP+3)=ONE
      NLOC=NLOC+4
   89 CONTINUE
C---     UPDATE FLOW BLOCK POINTER TO NEXT AVAILABLE SPACE.
C---     NSEGST FINALLY POINTS TO START OF SEGMENT INFORMATION
      LSTEMP=LSTEMP+MSIZE-1
      GO TO 31
C
C---     INITIALIZE DATA FOR FLOW INFORMATION
   40 CONTINUE
      IRR=7
C****    NEITHER FLOW NOR SEG SHOULD HAVE BEEN ENCOUNTERED
      NLOC=NLOC+1
      IF(CANON(NLOC-2).NE.AFLOW) GO TO 31
      IF(IFLOW.OR.ISEG) GO TO 30
      IF(NSEGST.GT.0.OR.NFLOST.GT.0) GO TO 30
      IFLOW=.TRUE.
      NFLOST=1
C---     STORE THE DATA SIZE OF INPUT UP TO THE FIRST FLOW COMMAND
      NSZSAV=NLOC-3
      GO TO 31
C---     INITIALIZE DATA FOR SEGMENT INFORMATION.
   51 CONTINUE
      NLOC=NLOC+1
   50 CONTINUE
      NLOC=NLOC+1
      IRR=8
C****    FLOW SHOULD HAVE BEEN ENCOUNTERED BUT NOT SEG
      IF(CANON(NLOC-2).NE.ASEG) GO TO 31
      IF(.NOT.IFLOW.OR.ISEG) GO TO 30
      IF(NSEGST.GT.0.OR.NFLOST.LE.0) GO TO 30
      IFLOW=.FALSE.
      ISEG=.TRUE.
      NSEGST=LSTEMP+1
      GO TO 31
C
   31 CONTINUE
C
      IRR=0
   32 CONTINUE
C---     END OF LOOP TO SCAN FOR SEGMENT/FLOW BLOCKS
      GO TO 34
C
 1034 CONTINUE
C
C
      IF(IBUG.NE.11) GO TO 33
      CALL BAD(-54,1,'STEM',STEMP)
   33 CONTINUE
C
      IF (IRR.EQ.0) GO TO 90
C
C---     ERROR PATH, UNDEFINE CANON FORM AND QUIT
   30 CONTINUE
C---     WRITE OUT INFORMATION FOR DIAGNOSING PROBLEM
      NDIF=NSIZE-NS+1
      CALL BAD(-NDIF,1,'CAN ',CANON(NS))
      NLOC=NLOC-NS+1
      CALL BAD(-1,0,'NLOC',NLOC)
      CALL BAD(1,0,'NSEG',NSEGST)
      CALL BAD(1,0,'I   ',I)
      CALL BAD(1,0,'M   ',M)
      CALL BAD(1,1,'AN1 ',AN1)
      CALL BAD(1,1,'AN2 ',AN2)
      CALL BAD(-1,1,'BPNT',BPNTS)
C
      IERROR=5500+IABS(IRR)
      CALL ERROR(IERROR,RNAM1)
C
   90 CONTINUE
      IF(IFLOW.OR.ISEG) IFLSEG=1
      GO TO 999
C
C----------------------------------------------------------
 2000 CONTINUE
C
C
C---     FLOW INFORMATION IS AVAILABLE, SO START FLOW PROCESSING
C---     FIRST SCAN THE FLOW AND SEGMENT BLOCKS AND CHECK FOR
C---     INPUT CONSISTENCY.
C
      ANPTS=CANON(NH+3)+ONE
      NPTS=ANPTS
      BPNTS=ANPTS-ONE
C---     INCREMENT CURVE TYPE BY 10 TO INDICATE FLOW PRESENCE.
      CANON(NH+2)=CANON(NH+2)+10.
C
C---     I IS CURRENT ROW, M INCREMENT TO NEXT, N2 LAST POINT
      I=0
      M=1
      AN2=ZERO
 1010 I=I+M
      IF(I.GE.NSEGST) GO TO 1080
      AN1=STEMP(2,I)
      IF(DABS(AN2-AN1).LT.SMAL) GO TO 1020
C****    PREVIOUS POINT AND PRESENT SHOULD BE EQUAL
      IRR=13
      GO TO 30
 1020 CONTINUE
      AN2=STEMP(3,I)
      M=STEMP(4,I)
      IF(AN1+SMAL.LT.AN2.AND.AN2.LT.BPNTS+SMAL) GO TO 1010
C****    REFERENCES TO CURVE POINTS ARE INVALID.
      IRR=14
      GO TO 30
 1080 CONTINUE
      IF(DABS(AN2-BPNTS).LT.SMAL) GO TO 1090
C****    LAST POINT REFERENCE SHOULD EQUAL LAST PT OF CURVE
      IRR=15
      GO TO 30
 1090 CONTINUE
C
C---    NOW SCAN SEGMENT DATA AND CHECK FOR CONSISTENCY
C
      I=NSEGST-1
      M=1
      AN2=ZERO
 1110 I=I+M
      IF(I.GT.LSTEMP) GO TO 1180
      AN1=STEMP(2,I)
      IF(DABS(AN1-AN2).LT.SMAL) GO TO 1120
C****    AN1,AN2 HAVE INVALID RELATION
      IRR=16
      GO TO 30
 1120 CONTINUE
      AN2=STEMP(3,I)
      IF(AN1.LT.AN2+SMAL.AND.AN2.LT.BPNTS+SMAL) GO TO 1110
C****    CURRENT TWO SCALARS HAVE INCONSISTENT RELATION
      IRR=17
      GO TO 30
 1180 IF(DABS(AN2-BPNTS).LT.SMAL) GO TO 1190
C****    LAST SEGMENT MUST TERMINATE IN LAST POINT
      IRR=18
      GO TO 30
 1190 CONTINUE
C------------------------------------------------
C---     CONSISTENCY CHECKING COMPLETED ON FLOW/SEGMENT INPUT
C
C---     MAJOR FLOW PROCESSING, ALL FLOW COMMAND INFORMATION
C---     IS STORED IN THE STEMP ARRAY WHOSE ROWS WILL BE INDEXED
C---     BY IST.  FLOW INFORMATION, INCLUDING ARC SUMMARY BLOCKS
C---     AND FLOW RATE SPLINES ARE CONTAINED IN THE ARRAY ST
C---     SUMMARY INFORMATION IS INDEXED BY IST AND SPLINE
C---     FUNCTIONS ARE INDEXED BY IFLAVL
C
C---     SAVE STARTING VALUES FOR  FLOW AND SEGMENT SUMMARY
C---     BLOCKS
      IFLOST=1
      ISEGST=NPTS
      ISPLST=ISEGST+NUMSEG
C---     INITIALIZE INDICES TO AVAILABLE SPACE
      IST=IFLOST
      ISPL=ISPLST
      ISTMAX=MAXSC*6
C---     ARRAY ST (=SC) WILL BE USED TO BUFFER AND ACCUMULATE
C---     FLOW AND SEGMENT SUMMARY INFORMATION.  THIS DATA
C---     WILL THEN BE EXAMINED FOR ERRORS AND LATER BE
C---     CONSOLIDATED WITH THE REMAINING DEFINED CURVE CANON
C---     FORM, PROVIDED NO ERRORS HAVE OCCURRED.
C
      ISTEM=0
      INCTEM=1
      IRCT=0
C
 1200 CONTINUE
      ISTEM=ISTEM+INCTEM
      IF(ISTEM.GE.NSEGST) GO TO 1300
      I1=STEMP(2,ISTEM)+ONE
      I2=STEMP(3,ISTEM)
      INCTEM=STEMP(4,ISTEM)
      TOL=STEMP(4,ISTEM)-INCTEM
C---     EXECUTE THIS FLOW PROCESSING FOR EACH CURVE FROM I1 TO I2
C
      DO 1210 J=I1,I2
      ST(1,IST)=ISPL
      ISPMX=ISTMAX-ISPL
      ST(3,IST)=STEMP(1,IST)
C---     COMPUTE INDEX TO CURRENT CURVE
      NCURV=(CANON(NH+1)+J-1)*24+NH
C
      IF(IBUG.NE.11) GO TO 1219
      CALL BAD(1,0,'NCUR',NCURV)
      CALL BAD(-1,0,'J   ',J)
      CALL BAD(24,1,'CAN ',CANON(NCURV))
      CALL BAD(1,1,'TOL ',TOL)
      CALL BAD(-1,0,'ISPM',ISPMX)
 1219 CONTINUE
C
C---     BRANCH TO AREA FOR INDIVIDUAL FLOW PROCESSING
      CALL HOLFRM(STEMP(1,ISTEM),TEST,1,8,NWD)
      IF(TEST.EQ.ARC) GO TO 1320
      IF(TEST.EQ.ANGLE) GO TO 1340
      IF(TEST.EQ.CHORD) GO TO 1360
      IF(TEST.EQ.PARAM) GO TO 1380
C****    INVALID SPECIFICATION FOR FLOW
      IR=20
      GO TO 1290
C
C---     FLOW PROCESSING FOR ONE CUBIC ARC BY ARC LENGTH.
 1320 CONTINUE
      CALL ARCSEG(CANON(NCURV),ST(1,ISPL),TOL,NUM,ISPMX,IR)
      GO TO 1290
C---     FLOW PROCESSING FOR ONE CUBIC ARC BY ANGLE.
 1340 CONTINUE
      CALL ANGSEG(CANON(NCURV),ST(1,ISPL),TOL,NUM,ISPMX,IR,
     X STEMP(1,ISTEM+1),STEMP(1,ISTEM+3))
      GO TO 1290
C---     FLOW PROCESSING FOR ONE CUBIC ARC BY CHORD PROJECTION
 1360 CONTINUE
C
C---     THE SET UP OF CHORDAL PARAMETERS MAY BE IMPLIED
C---     SO BEGIN BY SETTING THEM UP FIRST.
      DO 1361 II=1,3
      DO 1361 JJ=1,3
      PP(II,JJ)=STEMP(II,ISTEM+JJ)
 1361 CONTINUE
C---     DEFAULT, CHORD IS DEFINED BY END POINTS OF COMBINED SEGMENT
      IF(STEMP(4,ISTEM+1).GT.SMAL) GO TO 1362
C
      NN=(CANON(NH+1)+I1-1)*24+NH
      CALL CNCURV(ZERO,CANON(NN),PP(1,1),0)
 1362 CONTINUE
      IF(STEMP(4,ISTEM+2).GT.SMAL) GO TO 1363
      NN=(CANON(NH+1)+I2-1)*24+NH
      CALL CNCURV(ONE,CANON(NN),PP(1,2),0)
 1363 CONTINUE
      SZ=ZERO
      DO 1364 JJ=1,3
      PP(JJ,2)=PP(JJ,2)-PP(JJ,1)
      SZ=SZ+PP(JJ,2)**2
 1364 CONTINUE
      SZ=DSQRT(SZ)
C****    TWO POINTS TOO CLOSE FOR PROPER CHORD
      IR=21
      IF(SZ.LT.SMAL) GO TO 1290
      IR=0
      DO 1365 JJ=1,3
      PP(JJ,2)=PP(JJ,2)/SZ
 1365 CONTINUE
      IF(STEMP(4,ISTEM+3).GT.SMAL) GO TO 1366
 1370 CONTINUE
C---     IF A VECTOR NORMAL TO THE PROJECTION PLANES HAS NOT BENN
C---     SUPPLIED BY THE USER, THEN THE AXIS OF THE CHORD IS CHOSEN
C---     AS A DEFAULT NORMAL VECTOR TO THESE PLANES
      PP(1,3)=PP(1,2)
      PP(2,3)=PP(2,2)
      PP(3,3)=PP(3,2)
 1366 CONTINUE
      CALL CHDSEG(CANON(NCURV),ST(1,ISPL),TOL,NUM,ISPMX,IR,
     X            PP(1,1),PP(1,2),PP(1,3))
      GO TO 1290
C---     DIRECT IDENTITY PARAMETERIZATION
 1380 CONTINUE
      IR=22
      NUM=2
      IF(ISPL+NUM.GT.ISPMX) GO TO 1290
      IR=0
C---     SET UP A SPLINE IDENTITY FUNCTION
      ST(1,ISPL)=ZERO
      ST(2,ISPL)=ZERO
      ST(3,ISPL)=ONE
      ST(4,ISPL)=ZERO
      ST(1,ISPL+1)=ONE
      ST(2,ISPL+1)=ONE
      ST(3,ISPL+1)=ONE
      ST(4,ISPL+1)=ZERO
      GO TO 1290
C
 1290 CONTINUE
      IF(IR.EQ.0) GO TO 1220
C****    ERROR PATH, INCREMENT ERROR COUNT AND RESET VALUES
      IRCT=IRCT+1
      ST(1,IST)=-IR
      ST(2,IST)=NUM
      ST(4,IST)=ZERO
      IR=0
      NUM=0
      IF(IBUG.EQ.11) CALL BAD(-4,1,'ERR=',ST(1,IST))
      IST=IST+1
      GO TO 1210
C---     NORMAL COMPLETION OF FLOW RATE FOR ONE ARC.
 1220 CONTINUE
C---     STORE SUMMARY DATA FOR FLOW SPLINES LOCATION,NUMBER,
C---     TYPE OF FLOW AND TOTAL SPAN
      ST(1,IST)=ISPL
      ST(2,IST)=NUM
C---     SAVE TYPE FLOW AND TOLERANCE IN 3RD LOCATION
      CALL HOLFRM(STEMP(1,ISTEM),TEST,1,8,NWD)
      IF(TEST.EQ.ARC)   ST(3,IST)=1.+TOL
      IF(TEST.EQ.ANGLE) ST(3,IST)=2.+TOL
      IF(TEST.EQ.CHORD) ST(3,IST)=3.+TOL
      IF(TEST.EQ.PARAM) ST(3,IST)=4.+TOL
      ST(4,IST)=ST(1,ISPL+NUM-1)-ST(1,ISPL)
      ISPL=ISPL+NUM
      IST=IST+1
      NUM=0
 1210 CONTINUE
C
      GO TO 1200
 1300 CONTINUE
C
      IF(IRCT.EQ.0.AND.IBUG.NE.11) GO TO 1401
C****    DUMP CURV INFORMATION TO DOCUMENT FAILURES
      CALL CFORM('0 ***ERRORS WHILE PROCESSING FLOW DATA FOR CURVE',
     X DARRAY,1,48)
      CALL CPRINT (DARRAY)
      JTOP=ISPL-1
      DO 1310 JJ=1,JTOP
      JJ1=IFLOST+JJ-1
      IF(JJ1.GE.IST)GO TO 1305
      IF(ST(1,JJ1).GE.0.D0)GO TO 1305
      IR=-ST(1,JJ1)
      CALL BAD(-1,0,'IRR ',IR+5500)
 1305 CONTINUE
      CALL BAD(-4,1,'CURV',ST(1,IFLOST+JJ-1))
 1310 CONTINUE
      IF(IRCT.EQ.0) GO TO 1401
C****    ERROR IN FLOW PROCESSING
      IRR=IR+5500
      RNAME=RNAMA
      DO 8002 IL2=1,IMAX2
 8002 IF (IRR.EQ.IZAL2(IL2)) RNAME=RNAM2
      DO 8003 IL3=1,IMAX3
 8003 IF (IRR.EQ.IZAL3(IL3)) RNAME=RNAM3
      DO 8004 IL4=1,IMAX4
 8004 IF (IRR.EQ.IZAL4(IL4)) RNAME=RNAM4
      DO 8005 IL5=1,IMAX5
 8005 IF (IRR.EQ.IZAL5(IL5)) RNAME=RNAM5
      CALL ERROR(IRR,RNAME)
      GO TO 999
C
C---------------------------------------------------------
C---    FLOW SPLINES HAVE BEEN CREATED FOR EACH ARC, NOW
C---     SET UP SEGMENT DATA.
 1401 CONTINUE
C---    NOW PROCESS CURVE SEGMENT INFORMATION
      ISTEM=NSEGST-1
      INCTEM=1
 1400 CONTINUE
      ISTEM=ISTEM+INCTEM
      IF(ISTEM.GT.LSTEMP) GO TO 1490
C---    PROCESS CURVE SEGMENTS, ONE AT A TIME
      ST(3,IST)=STEMP(1,ISTEM)
      ST(1,IST)=STEMP(2,ISTEM)
      ST(2,IST)=STEMP(3,ISTEM)
      ST(4,IST)=ZERO
      IF(DABS(ST(1,IST)-ST(2,IST)).LT.SMAL) GO TO 1410
C---    IN CASE OF LENGTH TOTAL SPAN IS BASED ON TOTAL FLOW LENGTH
      I1=ST(1,IST)+ONE
      I2=ST(2,IST)
      TOTLEN=ZERO
      DO 1440 II=I1,I2
      TOTLEN=TOTLEN+ST(4,II)
 1440 CONTINUE
C---    STORE TOTAL LENGTH IN SEGMENT BLOCK
      ST(4,IST)=TOTLEN
C---     TOTLEN=NUMBER OF ARCS IN SEGMENT IN CASE OF PARAM
      CALL HOLFRM(ST(3,IST),TEST,1,8,NWD)
      IF(TEST.EQ.PARAM) TOTLEN=ST(2,IST)-ST(1,IST)
C---     NOW CHANGE PARAMETER FLOW ON EACH SEGMENT, ARC BY ARC,
C---     SO THAT THE TOTAL FLOW IS FROM ZERO TO ONE FOR THE
C---     COMPLETE SEGMENT
      SUM=ZERO
      DO 1450 J=I1,I2
C---     DETERMINE THE FACTOR FOR RESETTING FLOW FOR ARC J
      SPAN=ST(4,J)
      FACTOR=ONE/TOTLEN
      CALL HOLFRM(ST(3,IST),TEST,1,8,NWD)
      IF(TEST.EQ.PARAM) FACTOR=ONE/(TOTLEN*SPAN)
C---     NOW MODIFY ALL FLOW SPLINE FUNCTIONS FOR ARC J TO
C---     CHANGE THE FLOW SCALE
      NLOC=ST(1,J)
      NN=ST(1,J)+ST(2,J)-ONE
      DO 1460 JJ=NLOC,NN
      ST(1,JJ)=ST(1,JJ)*FACTOR+SUM
      ST(3,JJ)=ST(3,JJ)/FACTOR
 1460 CONTINUE
C
      ST(4,NLOC)=SUM
      TSUM=SUM+SUM
      NLOC1=NLOC+1
      DO 1465 JJ=NLOC1,NN
      ST(4,JJ)=ST(1,JJ)-ST(1,JJ-1)+TSUM
 1465 CONTINUE
C
      CALL HOLFRM(ST(3,IST),TEST,1,8,NWD)
      IF(TEST.EQ.PARAM) SUM=SUM+ONE/TOTLEN
      IF(TEST.EQ.LENGTH) SUM=SUM+SPAN*FACTOR
 1450 CONTINUE
C
      ST(2,IST)=ST(2,IST)-ST(1,IST)
C---     CONVERT ALPHANUMERIC DATA TO NUMBER CODE
      CALL HOLFRM(ST(3,IST),TEST,1,8,NWD)
      IF(TEST.EQ.PARAM) ST(3,IST)=1.0
      IF(TEST.EQ.LENGTH) ST(3,IST)=2.0
 1410 CONTINUE
C
      IF(IBUG.NE.11) GO TO 1413
      CALL BAD(1,0,'IST ',IST)
      CALL BAD(4,1,'ST  ',ST(1,IST))
 1413 CONTINUE
C
      IST=IST+1
      GO TO 1400
C---     PROCESSING OF SEGMENT DATA FINISHED
 1490 CONTINUE
C
C-----------------------------------------------------------
C---     NOW MERGE THE ST ARRAY AND FLOW/SEGMENT INFORMATION
C---     AND RECORD REQUIRED POINTERS IN THE SCURV HEADER
C---     TABLE
C---     NLOC POINTS JUST TO THE END OF THE CUBIC CURVE BLOCKS
      ANST=(CANON(NH+1)+ANPTS-ONE)*24.+ONE
      NCT=ANST-ONE+ANH-ONE
      DO 1500 II=1,ISPL
      DO 1500 JJ=1,4
      NCT=NCT+1
C---     CONVERT ADDRESSES FROM ROW NOTATION TO SEQUENTIAL NOTATION
      IF(II.LT.NPTS) ST(1,II)=(ST(1,II)-ONE)*4.+ANST
      CANON(NCT)=ST(JJ,II)
 1500 CONTINUE
C---     NOW PLACE LOCATION POINTERS IN TO HEADER TABLE
C---     LOCATION OF POINT BLOCKS
      CANON(NH+4)=CANON(NH+1)*24.+ONE
C---     NUMBER OF FLOW BLOCKS (IF ANY) AND LOCATION
      CANON(NH+5)=CANON(NH+3)
      CANON(NH+6)=CANON(NH+4)+(ANPTS-ONE)*24.
C---     NUMBER OF SEGMENT BLOCKS AND STARTING LOCATION
      CANON(NH+7)=NUMSEG
      CANON(NH+8)=CANON(NH+6)+CANON(NH+5)*4.0
C---     NUMBER OF FLOW BLOCKS AND STARTING LOCATION
      CANON(NH+9)=ISPL-NUMSEG-NPTS
      CANON(NH+10)=CANON(NH+8)+CANON(NH+7)*4.0
C---     FINALLY SETUP THE TOTAL SIZE OF THE STRUCTURE
      CANON(NH+11)=CANON(NH+10)+4.*CANON(NH+9)-ONE
      CANON(NH+12)=ONE
C
      IF(IBUG.NE.11) GO TO 4322
      NNNN=CANON(NH+11)/4.+.1
      MMMM=-3
      DO 4321 KKK=1,NNNN
      MMMM=MMMM+4
      CALL BAD(4,1,'FCAN',CANON(NH-1+MMMM))
      CALL BAD(-1,0,'INDX',MMMM)
 4321 CONTINUE
 4322 CONTINUE
      IRR=0
C
C-------------------------------------------------
C---     THE PROCESSING OF FLOW FUNCTIONS ACROSS THE CURVE IS COMPLETE.
C
  999 CONTINUE
C
      RETURN
      END
**** SOURCE FILE : M0000629.V01   ***
*
      SUBROUTINE FORCUB(PA,PB,PC,PD,TA,TD,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------INPUT IS FOUR SPACE POINTS PA,PB,PC,PD.   OUTPUT TA, TD DEFINES
C------A PARAMETRIC CUBIC CURVE WITH END POINTS PA,PD AND END TANGENT
C------VECTORS TA,TD  WHICH APPROXIMATES SMOOTHLY THE POINTS PB AND PC
C------THIS IS A COMPLETELY MODULAR APT SCULPTURED SURFACE ROUTINE
C------ WRITTEN AT IITRI APRIL 1970 --- JKH
      DIMENSION TA(3),TD(3),PA(3),PB(3),PC(3),PD(3),QA(3),QB(3),QC(3),
     1 QD(3),T1(3),T2(3),PAV(3),CN(3),DX(3),DY(3),DIF(3),VNULL(3)
      ONE=1.0
      IDIAG=18000
C------AVERAGE INTERIOR POINTS PB,PC INTO PAV
      DO 10 I=1,3
      DIF(I)=PD(I)-PA(I)
   10 PAV(I)=(PB(I) + PC(I))/2.0
      DIFL=DSQRT(DIF(1)**2+DIF(2)**2+DIF(3)**2)
      IRR=IDIAG+1
      IF(DIFL.LT.1.0D-10) RETURN
C------CONSTRUCT THE AVERAGED NORMAL TO PA,PAV,PD
      CALL NORML3(PA,PAV,PD,CN,IRR)
      IF(IRR.NE.0) CALL NORML3(PA,PB,PD,CN,IRR)
      IF(IRR.NE.0) CALL NORML3(PA,PC,PD,CN,IRR)
      IF(IRR.EQ.0) GO TO 20
C------STRAIGHT LINE CASE
      DO 30 I=1,3
      TA(I)=DIF(I)
   30 TD(I)=DIF(I)
      IRR=0
      RETURN
   20 CONTINUE
C------CONSIDER THE COMMON PLANE THROUGH PA,PB WITH NORMAL CN
C------CONSTRUCT ORTHOGONAL COORDINATE VECTORS DX AND DY IN THIS PLANE
      DO 40 I=1,3
   40 DX(I)=DIF(I)/DIFL
      DO 50 I=1,3
   50 VNULL(I)=0.0
      CALL NORML3(VNULL,CN,DX,DY,IRR)
C------NOW PROJECT ALL POINTS PA,PB,PC,PD ONTO THE AVERAGED PLANE.
C------CALL THE PROJECTIONS BY QA,QB,QC,QD
      QA(1)=0.
      QA(2)=0.
      QA(3)=0.
      QD(1)=DIFL
      QD(2)=0.
      QD(3)=0.
      DO 300 J=1,3
      QB(J)=0.
  300 QC(J)=0.
      DO 310 I=1,3
      QB(1)=QB(1) + (PB(I)-PA(I))*DX(I)
      QB(2)=QB(2) + (PB(I)-PA(I))*DY(I)
      QC(1)=QC(1) + (PC(I)-PA(I))*DX(I)
      QC(2)=QC(2) + (PC(I)-PA(I))*DY(I)
  310 CONTINUE
C------NOW INTERPOLATE TANGENT VECTORS AND RADII AT EACH END OF THE
C------CURVE (USING A PARABOLIC APPROXIMATION)
      CALL PARINT(PA,PB,PC,T1,RA,1,IRR)
C------ADJUST THE SIGN OF THE RADIUS
      TEMP=QB(1)*QC(2)-QB(2)*QC(1)
      RA=DABS(RA)*DSIGN(ONE,TEMP)
C------CONVERT FROM RADIUS TO CURVATURE
      IF(RA.GT.1.0D+8) RA=1.0D-8
      IF(RA.LE.1.0D+8) RA=1.0/RA
      CALL PARINT(PD,PC,PB,T2,RD,1,IRR)
      DO 60 I=1,3
   60 T2(I)=-T2(I)
      TEMP=TEMP-DIFL*(QC(2)-QB(2))
      RD=DABS(RD)*DSIGN(ONE,TEMP)
C------CONVERT FROM RADIUS TO CURVATURE
      IF(RD.LE.1.0D+8) RD=1.0/RD
      IF(RD.GT.1.0D+8) RD=1.0D-8
C------NOW END TANGENTS AND END RADII HAVE BEEN APPROXIMATED IN THE
C------AVERAGED PLANE
C------NOW OBTAIN COMPONENTS OF THE INTERPOLATED TANGENTS T1 AND T2 IN
C------THE AVERAGED PLANE
      GX=T1(1)*DX(1) + T1(2)*DX(2) + T1(3)*DX(3)
      GY=T1(1)*DY(1) + T1(2)*DY(2) + T1(3)*DY(3)
      HX=T2(1)*DX(1) + T2(2)*DX(2) + T2(3)*DX(3)
      HY=T2(1)*DY(1) + T2(2)*DY(2) + T2(3)*DY(3)
      GL=DSQRT(GX*GX + GY*GY)
      HL=DSQRT(HX*HX + HY*HY)
C------MODIFY THE SPACE CURVATURES RA AND RD BY THEIR PROJECTIONS ON THE
C------AVERAGED PLANE
      COSA=CN(1)*T1(1) + CN(2)*T1(2) + CN(3)*T1(3)
      TEMP=DABS(ONE-COSA*COSA)
      SINA=DSQRT(TEMP)
      COSD=CN(1)*T2(1) + CN(2)*T2(2) + CN(3)*T2(3)
      TEMP=DABS(ONE-COSD*COSD)
      SIND=DSQRT(TEMP)
      RA=RA/SINA
      RD=RD/SIND
C------NOW SOLVE IN THE AVERAGED PLANE FOR A PARAMETRIC PLANAR CUBIC
C------WITH END POINTS QA,QD AND END TANGENTS GX,GY AND HX,HY , AND
C------WITH END CURVATURE RA AND RB
C------THE OUTPUT ALPH,BETA GIVES THE SIGNED MULTIPLIERS OF THE INPUT
C------VECTORS GX ,GY AND HX,HY.
      CALL CLOCUB(QA(1),QA(2),QD(1),QD(2),GX,GY,HX,HY,RA,RD,ALPH,BETA,
     1 IRR)
      IF(IRR.NE.0) RETURN
C------PROJECT THE PLANAR SOLUTIONS ONTO THE INTERPOLATED SPACE
C------TANGENTS FOR A FINAL ANSWER
      DO 200 I=1,3
      TA(I)=ALPH*T1(I)/GL
  200 TD(I)=BETA*T2(I)/HL
      IRR=0
      RETURN
      END
**** SOURCE FILE : M0000631.V02   ***
*
      SUBROUTINE GELG(R,A,EPS,M,N,IER)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(*),R(*)
      IF(M) 230,230,10
   10 IER=0
      PIV=0.
      MM=M*M
      NM=N*M
      DO 30  L=1,MM
      TB=DABS(A(L))
      IF(TB-PIV) 30,30,20
   20 PIV=TB
      I=L
   30 CONTINUE
      TOL=EPS*PIV
      LST=1
      DO 170 K=1,M
      IF(PIV)   230,230,40
   40 IF(IER) 70,50,70
   50 IF(PIV-TOL)  60,60,70
   60 IER=K-1
   70 PIVI=1./A(I)
      J=(I-1)/M
      I=I-J*M-K
      J=J+1-K
      DO 80 L=K,NM,M
      LL=L+I
      TB=PIVI*R(LL)
      R(LL)=R(L)
   80  R(L)=TB
      IF (K-M)  90,180,180
   90 LEND=LST+M-K
      IF(J)  120,120,100
  100 II=J*M
      DO 110 L=LST,LEND
      TB=A(L)
      LL=L+II
      A(L)=A(LL)
  110 A(LL)=TB
  120 DO 130 L=LST,MM,M
      LL=L+I
      TB=PIVI*A(LL)
      A(LL)=A(L)
  130 A(L)=TB
      A(LST)=J
      PIV=0.
      LST=LST+1
      J=0
      DO 160 II=LST,LEND
      PIVI=-A(II)
      IST=II+M
      J=J+1
      DO 150 LX=IST,MM,M
      LL=LX-J
      A(LX)=A(LX)+PIVI*A(LL)
      TB=DABS(A(LX))
      IF(TB-PIV) 150,150,140
  140 PIV=TB
      I=LX
  150 CONTINUE
      DO 165 L=K,NM,M
      LL=L+J
  165 R(LL)=R(LL)+PIVI*R(L)
  160 CONTINUE
  170 LST=LST+M
  180 IF(M-1)  230,220,190
  190 IST=MM+M
      LST=M+1
      DO 210 I=2,M
      II=LST-I
      IST=IST-LST
      L=IST-M
      L=A(L)+.5
      DO  210  J=II,NM,M
      TB=R(J)
      LL=J
      DO 200 K=IST,MM,M
      LL=LL+1
  200 TB=TB-A(K)*R(LL)
      K=J+L
      R(J)=R(K)
  210 R(K)=TB
  220 GO TO 240
  230 IER=-1
  240 RETURN
      END
**** SOURCE FILE : M0001505.V08   ***
*
      SUBROUTINE GENCRV(A,CONCHK,AVERG,TYPE,IERROR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---     MAIN SUBROUTINE FOR CREATING GENCUR SURFACE
C---     INPUT CANONICAL FORM A(2) FOR SURFACE TO BE DEFINED
C---     CONCHK,AVERG,TYPE ARE 3 ARGUMENTS PASSED TO APT107
C---     PART PROGRAMMER INPUT STREAM IS IN CANON(41 ON)
C---     SURFACE UP TO BUT NOT INCLUDING TOPOLOGY TABLE IS
C---     DEFINED IN CANON(41) ON.  SSPAD IS USED AS A SCRATCH
C---     AREA FOR READING CURVES AND MANIPULATING THEM.
C---     OUTPUT IERROR IS NOT ZERO FOR AN ERROR
C---     MAIN OUTPUT IS IN CANON(41 ON)
C
C---     BLANK COMMON CAN CONTAINS THE PART PROGRAMMERS INPUT
C---     THIS IS TRANSFERRED TO THE ARRAY SCAN AND THEN CAN IS
C---     USED TO BUILD UP THE CANON FORM OF THE GENCUR SURFACE
C---     THE AVAILABLE SIZE OF CAN IS HELD IN MAXLDA
C
      INCLUDE (BLANKCOM)    
C
      COMMON/MAXLDA/MAXLDA
C
C---     THE SCAN ARRAY IS USED AS A WORKING BUFFER OF TEMPORARY
C---     DATA.  IT HOLDS THE PP INPUT AND VARIOUS INPUT CURVES.
C---     NSCNMX IS THE MAXIMUM SPACE IN SCAN AND ISCAN POINTS
C---     TO THE LAST USED LOCATION IN SCAN.
      INCLUDE (SSPAD)    
C
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
      LOGICAL CKDEF
      LOGICAL CR
      CHARACTER*8 CRASS
      CHARACTER*8 TEST
      DIMENSION NLOC(100)
      DIMENSION VECA(3),VECB(3),PP(3),CV(32)
C---     NLOC HOLDS POINTERS TO THE LOCATIONS OF SPLINE AND
C---     CROSS CURVES HELD IN THE SCAN ARRAY. NC IS THE LAST
C---     USED LOCATION IN NLOC AND NCMAX IS THE SIZE OF NLOC
      DATA NLOC/100*0/,NCMAX/100/
      DATA CRASS/'CROSS   '/
C
C
      DATA ZERO,ONE,SMAL/0.0D0,1.0D0,0.000001D0/
C
C---     INITIALIZE VARIOUS POINTERS AND COUNTERS
C---     CR IS TRUE IF CROSS SPLINE CURVES ARE ENTERED
      CR=.FALSE.
C---     NUMSPL IS THE TOTAL NUMBER OF INPUT SPLINE CURVES
      NUMSPL=0
C---     NUMCRS IS THE TOTAL NUMBER OF INPUT CROSS CURVES
      NUMCRS=0
C---     ISCAN IS THE POINTER TO THE LAST USED SPACE IN SCAN ARRAY
      ISCAN=0
C---     NSEG IS THE TOTAL NUMBER OF SEGMENTS PER INPUT CURVE
      NSEG=0
C---     NC IS THE POINTER TO THE LAST USED SPACE IN NLOC
      NC=0
C---     NLEN IS THE TOTAL LENGTH OF PART PROGRAMMER INPUT DATA
      NLEN=CAN(5)
C---     TRANSFER PART PROGRAMMERS INPUT TO THE SCAN ARRAY
      DO 10 I=1,NLEN
      SCAN(I)=CAN(I)
      CAN(I)=ZERO
   10 CONTINUE
      ISCAN=NLEN
C
C---     ISX WILL BE AN INDEX FOR SEARCHING THE SCAN ARRAY
      ISX=9
  100 CONTINUE
      IF(ISX.GE.NLEN) GO TO 199
C---     DATA SHOULD REPRESENT EITHER AN SCURV OR THE WORD CROSS
      CALL HOLFRM(SCAN(ISX+1),TEST,1,8,NWD)
      IF(TEST.NE.CRASS) GO TO 110
C---     THE WORD CROSS HAS BEEN ENCOUNTERED
C****    THE WORD CROSS WAS ENCOUNTERED TWICE
      IERROR=05
      IF(CR) GO TO 9998
C****    LESS THAN TWO SPLINE CURVES WERE INPUT BEFORE CROSS
      IERROR=06
      IF(NUMSPL.LT.2) GO TO 9998
C---     SAVE THE STARTING INDEX TO CROSS CURVE DATA
      ISXSAV=ISX+2
      CR=.TRUE.
      GO TO 198
C
C---     A CURVE HAS BEEN ENCOUNTERED
  110 CONTINUE
      IF(.NOT.CKDEF(SCAN(ISX))) GO TO 120
C****    INPUT CURVE HAS NOT BEEN DEFINED CORRECTLY
      IERROR=07
      GO TO 9998
  120 CONTINUE
      IF(NUMSPL.GT.0) GO TO 130
C---     LOAD THE FIRST CURVE ONLY
      JMODE=2
      CALL APT094(JMODE,SCAN(ISX),SCAN(ISCAN+1))
C****    CURVE COULD NOT BE SUCCESSFULLY RETRIEVED
      IERROR=08
      IF(JMODE.NE.2) GO TO 9998
C---     ENTER CURVE LOCATION INTO DIRECTORY TABLE
      NC=NC+1
      NLOC(NC)=ISCAN+1
C---     OBTAIN SEGMENT COUNT FROM THIS CURVE
      NSEG=SCAN(ISCAN+8)
      ISCAN=ISCAN+SCAN(ISCAN+12)
C****    FIRST INPUT CURVE WAS NOT OF THE FLOW TYPE
      IERROR=09
      IF(NSEG.LT.1) GO TO 9998
  130 CONTINUE
      IF(.NOT.CR) NUMSPL=NUMSPL+1
      IF(CR) NUMCRS=NUMCRS+1
  198 CONTINUE
      ISX=ISX+2
      GO TO 100
  199 CONTINUE
C
C---     NOW BEGIN PREPARATION OF THE SURFACE CANON FORM IN CAN
C---     ALL INPUT CURVES MUST BE LOADED INTO THE SCAN ARRAY
      NUMPAT=(NUMSPL-1)*NSEG
      J=10+NUMPAT*6
      DO 210 I=1,J
  210 CAN(I)=ZERO
      CAN(3)=NUMPAT*4
      CAN(4)=NUMPAT
      CAN(5)=2.
      CAN(6)=5.
      CAN(7)=ONE
      CAN(9)=NUMSPL
      CAN(10)=NSEG+1
C
C---     THIRD PHASE, LOAD ALL OF THE SPLINE CURVES INTO THE SCAN ARRAY
C---     SKIP THE FIRST CURVE, SINCE IT HAS ALREADY BEEN LOADED
      ISX=9+2
  300 CONTINUE
      CALL HOLFRM(SCAN(ISX+1),TEST,1,8,NWD)
      IF(TEST.EQ.CRASS.OR.ISX.GE.NLEN) GO TO 399
C****    THE CURVE DIRECTORY TABLE SIZE HAS BEEN EXCEEDED
      IERROR=10
      IF(NC+1.GT.NCMAX) GO TO 9998
C---     CONSIDER THE ANTICIPATED SIZE OF THIS CURVE
      ISIZE=SCAN(ISX+1)
C****    THERE IS NOT ENOUGH BUFFER SPACE TO HOLD THIS SPLINE CURVE
      IERROR=11
      IF(ISIZE+ISCAN.GT.NSCNMX) GO TO 9998
      JMODE=2
      CALL APT094(JMODE,SCAN(ISX),SCAN(ISCAN+1))
C****    INPUT SPLINE CURVE COULD NOT BE FETCHED
      IERROR=12
      IF(JMODE.NE.2) GO TO 9998
      ISEG=SCAN(ISCAN+8)
C****    THE NUMBER OF SEGMENTS IN TWO INPUT SPLINE CURVES WAS UNEQUAL
      IERROR=13
      IF(ISEG.NE.NSEG) GO TO 9998
C---     UPDATE DIRECTORY TABLE OF CURVE LOCATION
      NC=NC+1
      NLOC(NC)=ISCAN+1
      ISCAN=ISCAN+SCAN(ISCAN+12)
  390 CONTINUE
      ISX=ISX+2
      GO TO 300
C
  399 CONTINUE
C
C---     PHASE 4.  ONE-BY-ONE LOAD CROSS CURVES INTO SCAN ARRAY
C---     AND COMPARE THEM TO SPLINE JUNCTIONS TO DETERMINE
C---     THEIR RELATIVE LOCATION.
C---     FIRST, ZERO OUT THIS PART OF THE DIRECTORY TABLE
C****    THERE IS NOT ENOUGH ROOM IN THE DIRECTORY FOR CROSS CURVES
      IERROR=14
      IF(NC+NSEG+1.GT.NCMAX) GO TO 9998
C---     ZERO OUT THE CROSS PORTION OF THE DIRECTORY TABLE
      NSEG1=NSEG+1
      DO 401 I=1,NSEG1
      NLOC(I+NUMSPL)=0
  401 CONTINUE
C---     THE NEXT SECTION IS TO READ IN CROSS CURVES
C---     IF THERE ARE NO CROSS CURVES, SKIP THIS SECTION
      IF(.NOT.CR.OR.NUMCRS.LT.1) GO TO 500
C
C---     BEGIN LOADING CROSS CURVES (FROM THE PREVIOUS SAVE POINT)
      ISX=ISXSAV
C
  420 CONTINUE
      IF(ISX.GE.NLEN) GO TO 499
      ISIZE=SCAN(ISX+1)
C****    THERE IS NOT ENOUGH BUFFER SPACE TO LOAD A CROSS CURVE
      IERROR=15
      IF(ISIZE+ISCAN.GT.NSCNMX) GO TO 9998
      JMODE=2
      CALL APT094(JMODE,SCAN(ISX),SCAN(ISCAN+1))
C****    CROSS CURVE COULD NOT BE FETCHED
      IERROR=16
      IF(JMODE.NE.2) GO TO 9998
      ISEG=SCAN(ISCAN+8)
C****    NUMBER OF SEGMENTS IN CROSS CURVE DID NOT MATCH NO. SPLINES
      IERROR=17
      IF(ISEG+1.NE.NUMSPL) GO TO 9998
C
C---     A MAJOR TASK- IDENTIFY WHICH CROSS CURVE THIS IS.
C---     ISPL IS THE PREVIOUS SPLINE POINT WHICH MATCHED A
C---     CROSS CURVE POINT
      ISPL=1
  429 CONTINUE
C---     ICRS IS THE PRESENT POINT ON THE CROSS CURVE BEING EXAMINED
      ICRS=1
  430 CONTINUE
      IF(ICRS.GT.NUMSPL) GO TO 469
C---     CALCULATE THE CURVE POINT
      U=ICRS-1
      CALL CURFLO(U,SCAN(ISCAN+1),CV,0,0)
      DO 431 I=1,3
  431 PP(I)=CV(I)
C---     NOW SCAN THRU THE ICR-TH SPLINE FOR A MATCH ON PP
      NL=NLOC(ICRS)
      NSP=ISPL
  440 CONTINUE
      IF(NSP.GT.NSEG1) GO TO 459
      U=NSP-1
      CALL CURFLO(U,SCAN(NL),CV,0,0)
      W=DABS(CV(1)-PP(1))+DABS(CV(2)-PP(2))+DABS(CV(3)-PP(3))
      IF(W.GT.0.0001) GO TO 458
C---     JUNCTION POINTS OF CROSS CURVE AND SPLINE MATCH HERE
      IF(NSP.EQ.ISPL) GO TO 468
C---     UPDATE ISPL AND RESTART
      ISPL=NSP
      GO TO 429
C
  458 CONTINUE
      NSP=NSP+1
      GO TO 440
C
  459 CONTINUE
C****    THERE IS NO MATCH AT A JUNCTION PT BETWEEN A SPLINE AND CROSS
      IERROR=18
      GO TO 9998
C
  468 CONTINUE
      ICRS=ICRS+1
      GO TO 430
  469 CONTINUE
C---     MATCH HAS BEEN ACHIEVED, CROSS CURVE IS NUMBER ICRS
C****    ERROR, ANOTHER CROSS CURVE WAS ENTERED THRU SAME POINTS
      IERROR=19
      IF(NLOC(NUMSPL+ISPL).NE.0) GO TO 9998
      NLOC(NUMSPL+ISPL)=ISCAN+1
      ISCAN=ISCAN+SCAN(ISCAN+12)
      ISX=ISX+2
      GO TO 420
C
  499 CONTINUE
C
  500 CONTINUE
C---     ALL CROSS CURVES HAVE BEEN SAVED , NOW GENERATE
C---     ALL  CROSS CURVES NOT INPUT BY USER
C
C---     FIRST CHECK WHETHER A RULED SURFACE IS INDICATED
      IF(NUMSPL.NE.2.OR.NUMCRS.GT.0) GO TO 600
C
C---     PHASE 5.  DEFINTION OF A RULED SURFACE.
C---     THE SURFACE IS RULED PROVIDED THAT NO CROSS SPLINE
C---     OR NORMAL CONSTRAINTS EXIST
      DO 510 I=1,NUMSPL
      NL=NLOC(I)-1
      NLOC1=SCAN(NL+2)*24.-4.+NL
      NLOC2=NLOC1+24.*SCAN(NL+4)
      DO 520 J=NLOC1,NLOC2,24
      W=DABS(SCAN(J)-ONE)
      IF(W.LT.SMAL) GO TO 600
      W=DABS(SCAN(J+4)-ONE)
      IF(W.LT.SMAL) GO TO 600
  520 CONTINUE
  510 CONTINUE
C
C---     ALL CONDITIONS FOR A RULED SURFACE HAVE BEEN MET
C---     FINISH THE DEFINITION OF THE RULED SURFACE NOW
      NUMPAT=NSEG
      ICAN=6*NSEG+10
C
C---     DISSECT CURVES INTO SEGMENT CURVES AND SET UP RULED PATCHES
      DO 530 I=1,NSEG
      ILOC=10+6*(I-1)
      DO 540 J=1,NUMSPL
      NL=NLOC(J)
      ICANMX=MAXLDA-ICAN
      CALL DISEG(I,SCAN(NL),CAN(ICAN+1),ICANMX,IERROR)
C****    ERROR IN DISSEGMENTING CURVE
      IF(IERROR.NE.0) GO TO 9998
      ILOC=ILOC+1
      CAN(ILOC)=ICAN+1
      ICAN=ICAN+CAN(ICAN+12)
  540 CONTINUE
C---     TYPE FLAG INDICATES A BLEND BETWEEN TWO SPLINES
      CAN (ILOC+3)=-1.
      CAN(ILOC+4)=ZERO
  530 CONTINUE
      CAN(2)=ICAN-(6*NSEG+11)
      CAN(8)=CAN(2)+CAN(3)+(6*NUMPAT+10)
C
C
      GO TO 9997
C
C---     CROSS FIT LIKE SEGMENT JUNCTION POINTS TO OBTAIN GOOD
C---     CROSS SLOPE CONSTRAINTS
  600 CONTINUE
      I=1
  610 CONTINUE
      IF(I.GT.NSEG1) GO TO 699
C---     IF A CROSS CURVE HAS ALREADY BEEN ENTERED, SKIP TO NEXT JNCT.
      IF(NLOC(NUMSPL+I).NE.0) GO TO 690
C---     CHECK FOR AVAILABLE SPACE TO FIT CROSS CURVE
      NSIZE=(NUMSPL+1)*24
C****    THERE IS NOT ENOUGH ROOM IN THE BUFFER TO FIT THIS CROSS CURVE
      IERROR=20
      IF(NSIZE+ISCAN.GT.NSCNMX) GO TO 9998
      U=ZERO
      ISEG=I
      IF(I.GT.NSEG) U=ONE
      ISEG=MIN0(NSEG,I)
      J=1
C---     PREPARE THE INPUT CURVE HEADER TABLE
      DO 615 L=1,24
  615 SCAN(ISCAN+L)=ZERO
      SCAN(ISCAN+2)=ONE
      SCAN(ISCAN+3)=2.
      SCAN(ISCAN+4)=NUMSPL
  620 CONTINUE
C---     LOAD SPLINE CURVES ONE AT A  TIME TO OBTAIN POINT OR
C---     VECTOR DATA AT JUNCTION POINTS I
      IF(J.GT.NUMSPL) GO TO 650
C---     SET ADDRESS OF SPLINE J
      NL=NLOC(J)-1
      CALL CURFLO(U,SCAN(NL+1),CV,2,ISEG)
C---     MOVE RELEVANT POINTS AND VECTOR CONSTRAINTS INTO BUFFER
      NBASE=J*24+ISCAN
C---     ZERO OUT THE J-TH POINT BLOCK FIRST
      DO 630 L=1,24
  630 SCAN(NBASE+L)=ZERO
      DO 640 L=1,3
      SCAN(NBASE+L)=CV(L)
      IF(DABS(CV(20)-ONE).LT.SMAL) SCAN(NBASE+4+L)=CV(L+16)
      IF(DABS(CV(32)-ONE).LT.SMAL) SCAN(NBASE+12+L)=CV(L+28)
      SCAN(NBASE+8+L)=CV(L+4)
  640 CONTINUE
      IF(DABS(CV(20)-ONE).LT.SMAL) SCAN(NBASE+8)=ONE
      IF(DABS(CV(32)-ONE).LT.SMAL) SCAN(NBASE+16)=ONE
      SCAN(NBASE+12)=ONE
      SCAN(NBASE+17)=ONE
C
      J=J+1
      GO TO 620
C---
  650 CONTINUE
      IF(IBUG.EQ.11) CALL SCDUMP(650,SCAN(ISCAN+1))
C---     NOW DEFINE A SYNTHETIC CURVE IN THE CROSS DIRECTION
      IRR=0
      CALL SCURV(SCAN(ISCAN+1),IRR)
C****    ERROR IN TRYING TO DEFINE A CROSS CURVE
      IERROR=21
      IF(IRR.NE.0) GO TO 9998
C
      SCAN(ISCAN+5)=SCAN(ISCAN+2)*24.+ONE
      SCAN(ISCAN+12)=NUMSPL*24.
C---     IF CROSS CURVES HAVE BEEN INPUT BY THE USER, THEN INTERNALLY
C---     GENERATED CROSS CURVES MUST HAVE A FLOW STRUCTURE APPENDED
C
      IF(NUMCRS.LT.1) GO TO 680
C
C---     NOW APPEND AN IDENTITY-TYPE FLOW STRUCTURE
      NSIZE=ISCAN+NUMSPL*40
C****    THERE IS NOT ENOUGH ROOM FOR FLOW STRUCTURE OF A CROSS CURVE
      IERROR=23
      IF(NSIZE.GT.ICANMX) GO TO 9998
C
C---     NOW SETUP THE COMPLETE HEADER TABLE FOR A FLOW CURVE
      SCAN(ISCAN+5)=25+ISCAN
      SCAN(ISCAN+6)=NUMSPL-1
      SCAN(ISCAN+7)=NUMSPL*24+1
      SCAN(ISCAN+8)=SCAN(ISCAN+6)
      SCAN(ISCAN+9)=SCAN(ISCAN+7)+(NUMSPL-1)*4
      SCAN(ISCAN+10)=2*(NUMSPL-1)
      SCAN(ISCAN+11)=SCAN(ISCAN+9)+(NUMSPL-1)*4
      SCAN(ISCAN+12)=SCAN(ISCAN+11)+(NUMSPL-1)*8
      SCAN(ISCAN+13)=ONE
C---     NOW FILL IN FLOW, SEGMENT, AND FLOW SPLINE DATA
C---     KEEP TRACK OF EACH TYPE OF DATA WITH ITS OWN POINTER.
      NFLOWR=SCAN(ISCAN+7)-5.
      NSEGR=SCAN(ISCAN+9)-5.
      NSPLR=SCAN(ISCAN+11)-9.
C---     LOOP THRU SEGMENT BY SEGMENT AND FILL IN FLOW DATA
      NN=NUMSPL-1
      DO 660 L=1,NN
C---     INCREMENT SEGMENT POINTERS
      NFLOWR=NFLOWR+4
      NSEGR=NSEGR+4
      NSPLR=NSPLR+8
C---     FILL IN FLOW DATA FOR THE L-TH ARC
      SCAN(NFLOWR+1)=NSPLR
      SCAN(NFLOWR+2)=2.
      SCAN(NFLOWR+3)=4.0001
      SCAN(NFLOWR+4)=ONE
C---     FILL IN SEGMENT SUMMARY DATA
      SCAN(NSEGR+1)=L-1
      SCAN(NSEGR+2)=L
      SCAN(NSEGR+3)=ONE
      SCAN(NSEGR+4)=ONE
C---     FIRST SET UP AN IDENTITY FLOW SPLINE
      SCAN(NSPLR+1)=ZERO
      SCAN(NSPLR+2)=ZERO
      SCAN(NSPLR+3)=ONE
      SCAN(NSPLR+4)=ZERO
      SCAN(NSPLR+5)=ONE
      SCAN(NSPLR+6)=ONE
      SCAN(NSPLR+7)=ONE
      SCAN(NSPLR+8)=ZERO
  660 CONTINUE
C
  680 CONTINUE
C
C---     CONSOLIDATE THIS CROSS CURVE INTO THE BUFFER AREA
      NLOC(NUMSPL+I)=ISCAN+1
C
      IF(NUMCRS.LT.1) ISCAN=ISCAN+24*NUMSPL
      IF(NUMCRS.GT.0) ISCAN=ISCAN+SCAN(ISCAN+12)
C
  690 CONTINUE
      I=I+1
      GO TO 610
C
  699 CONTINUE
C---     NOW ADD CROSS VECTORS AT ALL UNSPECIFIED POINTS
C---    THIS IS ACCOMPLISHED BY CROSS SPLINING THE SURFACE FOR
C---    FOR EACH AND EVERY USER INPUT POINT.
C
C---    FIRST CHECK FOR STORAGE SPACE
      NSIZE=ISCAN+(NUMSPL+1)*24
C****    THERE IS NOT ENOUGH ROOM TO DETERMINE CROSS VECTOR BY SPLINING
      IERROR=24
      IF(NSIZE.GT.NSCNMX) GO TO 9998
C
C---     MAJOR LOOP, DETERMINE UNSPECIFIED POINTS ON EACH SPLINE
C---     SKIP THIS LOOP IF THERE ARE ONLY TWO SPLINES
      IF(NUMSPL.LE.2) GO TO 709
C
      DO 710 I=1,NUMSPL
      NL=NLOC(I)-1
C---     EXAMINE EACH JUNCTION POINT OF THE ITH SPLINE
      NJ=SCAN(NL+4)
      IF(NJ.EQ.1) GO TO 721
C
C---     SET UP PARAMETERS FOR DETECTING FLOW JUNCTIONS
      NJFLO=SCAN(NL+6)*4.+ONE
      NJST=SCAN(NL+7)
C
      DO 720 NK=1,NJ
      JUNC=NK
C---     SKIP CROSS CALCULATIONS FOR SEGMENT JUNCTION POINTS
      DO 722 II=1,NJFLO,4
      JUNCLO=SCAN(NL+NJST+II-1)
      JUNCHI=JUNCLO+SCAN(NL+NJST+II)
C---     SKIP CALCULATION IF JUNC EQUALS ONE OF THESE
      IF(JUNC.EQ.JUNCLO.OR.JUNC.EQ.JUNCHI) GO TO 720
C---     TERMINATE SEARCH AND CONTINUE WHEN JUNC IS BIG
      IF(JUNC.GT.JUNCHI) GO TO 723
  722 CONTINUE
C
  723 CONTINUE
C
      LOC=JUNC*24+16
C---     SKIP IF A CROSS VECTOR IS ALREADY THERE
      IF(DABS(SCAN(NL+LOC+4)-ONE).LT.SMAL) GO TO 720
C---     NOW PREPARE THE HEADER TABLE FOR SPLINING
      DO 730 NN=5,24
  730 SCAN(ISCAN+NN)=ZERO
      SCAN(ISCAN+2)=ONE
      SCAN(ISCAN+3)=2.
      SCAN(ISCAN+4)=NUMSPL
C---     FIND THE SEGMENT NUMBER AND FLOW VALUE AT ARC JUNCTIONS
      U=JUNC
      CALL FLOINV(U,SCAN(NL+1),FLO,ISEG)
C---     PICK A POINT OFF OF EACH SPLINE CURVE WITH THIS FLOW
C---     AND SEGMENT VALUE AND PLACE IT INTO A POINT BLOCK OF
C---     THE BUFFERED SCAN ARRAY
C
      DO 740 K=1,NUMSPL
      JSC1=K*24+1
      JSC2=JSC1+23
      DO 750 J=JSC1,JSC2
      SCAN(J+ISCAN)=ZERO
  750 CONTINUE
      SCAN(JSC1+ISCAN+16)=ONE
C---     NOW RETRIEVE A POINT FROM THE K-TH SPLINE
      NKS=NLOC(K)
      CALL CURFLO(FLO,SCAN(NKS),CV,0,ISEG)
      DO 760 J=1,3
  760 SCAN(ISCAN+JSC1+J-1)=CV(J)
  740 CONTINUE
C
C---     NOW FIT A SPLINE THRU THESE POINTS
      CALL SCURV(SCAN(ISCAN+1),IRR)
C****    CROSS FITTING FAILED AT A SEGMENT INTERIOR POINT
      IERROR=25
      IF(IRR.NE.0) GO TO 9998
C---     RETRIEVE AND STORE BOTH THE ENTERING AND EXITING TANGENTS
C---     FIRST STORE THE EXITING VECTOR
      NN=I*24
      U=ZERO
      IF(I.EQ.NUMSPL) NN=NN-24
      IF(I.EQ.NUMSPL) U=ONE
      CALL CNCURV(U,SCAN(ISCAN+1+NN),CV,1)
C---     STORE THIS VECTOR AS A CROSS CONSTRAINT OF THE SPLINE
      DO 770 L=1,3
  770 SCAN(NL+LOC+L)=CV(L+4)
      SCAN(NL+LOC+4)=ONE
C---     NEXT RETRIEVE AND STORE THE ENTERING VECTOR
      U=ONE
      NN=(I-1)*24
      IF(I.EQ.1) U=ZERO
      IF(I.EQ.1) NN=NN+24
      CALL CNCURV(U,SCAN(ISCAN+1+NN),CV,1)
      DO 780 L=1,3
  780 SCAN(NL+LOC+L+4)=CV(L+4)
      SCAN(NL+LOC+8)=ONE
C
  720 CONTINUE
C
  721 CONTINUE
C
  710 CONTINUE
C
  709 CONTINUE
C---     END OF LOOP TO GENERATE CROSS CONSTRAINTS ON SPLINES
C
C
  800 CONTINUE
C---     CASE OF A GENCUR SURFACE WITH NO CROSS SPLINES
C---     FETCH CURVES AND DECOMPOSE SURFACE DEFINITION INTO A
C---     PATCH STRUCTURE
C
      NM=NUMSPL-1
C---     ICAN IS THE LAST USED LOCATION IN THE CAN ARRAY
      ICAN=10+6*NSEG*NM
C
C---     GENERATE SURFACE ON A PATCH-BY-PATCH BASIS
C
      DO 810 J=1,NM
      DO 810 I=1,NSEG
C
      NUMPAT=I+(J-1)*NSEG
C---     ILOC IS THE LAST USED LOCATION IN THE PATCH POINTER TABLE
      ILOC=10+(NUMPAT-1)*6
C
C---     LOAD TWO SPLINE CURVE BOUNDARIES OF THIS PATCH
      DO 820 K=1,2
C
      ICURV=NLOC(J+K-1)
      ICANMX=MAXLDA-ICAN
      CALL DISEG(I,SCAN(ICURV),CAN(ICAN+1),ICANMX,IERROR)
C****    DISSECTION OF A SPLINE CURVE FAILED
      IF(IERROR.NE.0) GO TO 9998
      ILOC=ILOC+1
      CAN(ILOC)=ICAN+1
      ICAN=ICAN+CAN(ICAN+12)
  820 CONTINUE
C
C---     NOW LOAD THE CROSS CURVES IN A SIMILAR FASHION, BUT
C---     DO NOT SAVE THEM UNLESS CROSS CURVES HAVE BEEN ENTERED
C
      ICANSV=ICAN
      DO 830 K=1,2
C
      ICURV=NLOC(NUMSPL+I+K-1)
      ICANMX=MAXLDA-ICAN
      CALL DISEG(J,SCAN(ICURV),CAN(ICAN+1),ICANMX,IERROR)
C****    A CROSS CURVE COULD NOT BE DISSECTED
      IF(IERROR.NE.0) GO TO 9998
      ILOC=ILOC+1
      CAN(ILOC)=ICAN+1
      ICAN=ICAN+CAN(ICAN+12)
  830 CONTINUE
C
C---     NOW COMPLETE ALL BOUNDARY CURVES BY FILLING IN
C---     ALL CROSS VECTORS AT ARC JUNCTIONS
      IA=CAN(ILOC-3)
      IB=CAN(ILOC-2)
      IC=CAN(ILOC-1)
      ID=CAN(ILOC)
C
C---     SPECIAL LOGIC WHERE DUAL(INCOMING AND OUTGOING) TANGENTS
C---     HAVE BEEN GENERATED EARLIER.  SKIP IF 2 OR FEWER SPLINES
      IF(NUMSPL.LT.3) GO TO 839
C
C---     RETAIN EXITING VECTORS FOR CAN(IA) AND ENTERING VECTORS FOR IB.
      NUMJNC=CAN(IA+3)
      IF(NUMJNC.LT.2) GO TO 834
      DO 832 II=2,NUMJNC
      KK=(II-1)*24+15
      DO 833 JJ=1,4
      CAN(IA+KK+4+JJ)=ZERO
  833 CONTINUE
  832 CONTINUE
  834 CONTINUE
C---     NEXT REARRANGE THE ENTERING VECTORS FOR CAN(IB)
      NUMJNC=CAN(IB+3)
      IF(NUMJNC.LT.2) GO TO 838
      DO 836 II=2,NUMJNC
      KK=(II-1)*24+15
      DO 837 JJ=1,4
      CAN(IB+KK+JJ)=CAN(IB+KK+JJ+4)
      CAN(IB+KK+JJ+4)=ZERO
  837 CONTINUE
  836 CONTINUE
  838 CONTINUE
C
  839 CONTINUE
C
C---     NOW FIT ANY UNRESOLVED CROSS VECTORS
C---     SINCE ALL TANGENTS HAVE ALREADY BEEN DETERMINED , SET BYPASS
C---     FLAG FOR CRSFIT LOGIC  --  CRSFIT IS CALLED FOR DISPLAY
      IERROR=0
      IF(NUMSPL.GT.2) IERROR=-11
      CALL CRSFIT(CAN(IA),CAN(IB),CAN(IC),CAN(ID),IERROR)
C****    FILLING IN OF CROSS SLOPES ON SPLINE CURVES FAILED
      IF(IERROR.NE.0) GO TO 9998
C
C---     FILL IN IC ID CURVES IF NUMCRS IS NOT ZERO.
      IF(NUMCRS.GT.0)
     X CALL CRSFIT(CAN(IC),CAN(ID),CAN(IA),CAN(IB),IERROR)
C****    FILLING IN OF CROSS SLOPES ON CROSS CURVES FAILED
      IF(IERROR.NE.0) GO TO 9998
C
C---     NOW FILL IN REMAINDER OF PATCH HEADER TABLE
C
      IF(NUMCRS.GT.0) GO TO 840
C---     FOR SPLINE CURVES ONLY, CUT BACK SPACE FROM CROSS CURVES
      ICAN=ICANSV
      CAN(ILOC-1)=ZERO
      CAN(ILOC)=ZERO
      ILOC=ILOC+1
      CAN(ILOC)=-2.
      ILOC=ILOC+1
      CAN(ILOC)=ZERO
      GO TO 810
C
  840 CONTINUE
      ILOC=ILOC+1
      CAN(ILOC)=-22.
      ILOC=ILOC+1
      CAN(ILOC)=ZERO
C
  810 CONTINUE
C
C---     FILL IN SURFACE HEADER TABLE
C
C---     LAST PATCH,LAST BOUNDARY LOCATION
      ILAST=CAN(10+NUMPAT*6-4)
      IF(NUMCRS.GT.0) ILAST=CAN(10+NUMPAT*6-2)
C---     VALUE TABLE SIZE
      CAN(2)=CAN(ILAST+11)+(ILAST-10-NUMPAT*6-1)
C---     TOPOLOGY TABLE SIZE
      CAN(3)=NUMPAT*4
C---     NUMBER OF PATCHES IN SURFACE
      CAN(4)=NUMPAT
C---     SURFACE TYPE, MESH TYPE
      CAN(5)=2.
C---     SURFACE SUBTYPE, GENCUR
      CAN(6)=5.
C---     SIGN OF SURFACE NORMAL
      CAN(7)=ONE
C---     TOTAL SIZE OF THIS SURFACE
      CAN(8)=(10+NUMPAT*6)+CAN(2)+CAN(3)
C---     NUMBER OF SPLINES
      CAN(9)=NUMSPL
C---     NUMBER OF CROSS SPLINES OR SEGMENT JUNCTION POINTS PER SPLINE
      CAN(10)=NSEG1
C
      IBADSZ=CAN(8)
      IF(IBUG.EQ.11) CALL BAD(IBADSZ,1,'CAN ',CAN)
C
C---     END OF PATCH GENERATING LOOP
C
      GO TO 9997
C
C 900 CONTINUE
C     GO TO 9997
C
 9997 CONTINUE
      IERROR=0
      GO TO 9999
C
 9998 CONTINUE
C---     GENERATE DEBUG PRINTOUT IF IBUG FLAG IS SET
      IF(IBUG.NE.11) GO TO 9996
      CALL BAD(1,0,'IRR ',IRR)
      CALL BAD(1,0,'IERR',IERROR)
      CALL BAD(1,0,'NUMS',NUMSPL)
      CALL BAD(1,0,'ISCN',ISCAN)
      CALL BAD(1,0,'NSEG',NSEG)
      CALL BAD(-1,0,'NLEN',NLEN)
      CALL BAD(-NC,0,'NLOC',NLOC)
      I1=MIN0(MAXLDA,ICAN)
      CALL BAD(-I1,1,'CAN ',CAN(1))
      I1=ISCAN+200
      I1=MIN0(ISCAN,NSCNMX)
      CALL BAD(-I1,1,'SCAN',SCAN)
 9996 CONTINUE
      IERROR=IERROR+5020
      GO TO 9999
C
 9999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0002771.V04   ***
*
C
      SUBROUTINE GETSCA(SCAN,SPL,PNTS,PTANS,PCRS,TAN,CTAN,IPARA,ILIN,
     *  ITW)
C----------SCULPTURED SURFACE ROUTINE ------- JULY 1971  *LPK*
C----------GET SSCAN ARRAY
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION SCAN(*),TAN(*),CTAN(*)
      DIMENSION IPARA(2)
C
      INCLUDE (BLANKCOM)    
C
      IDEBUG=0
C---------- XYZ
      IA=SPL
      IB=PNTS
      IC=PTANS-1
      ID=PCRS-1
      NPH=SSCAN(4)
      IE=6*NPH+10
      IG=IE
      IAA=IA-1
      IBB=IB-1
      IF(ILIN.EQ.1) GO TO 2000
      DO 1000 I=1,IAA
      DO 1000 J=1,IBB
      JA=(I-1)*IB*3+(J-1)*3
      JB=(I-1)*IB*3+J*3
      JC=IC+JA
      JD=IC+JB
      JE=I*IB*3+(J-1)*3
      JF=I*IB*3+J*3
      JG=JE+IC
      JH=JF+IC
      JI=ID+(J-1)*IA*3+(I-1)*3
      JJ=ID+I*3+(J-1)*IA*3
      JK=ID+J*IA*3+(I-1)*3
      JL=ID+J*IA*3+I*3
      JX=(J-1)*3+(I-1)*3*IBB
      JY=(J-1)*3+I*3*IBB
      JZ=(I-1)*3+(J-1)*3*IAA
      JW=(I-1)*3+J*3*IAA
      DO 1100 K=1,3
      SSCAN(IG+1)=SCAN(JA+K)
      SSCAN(IG+2)=SCAN(JB+K)
      SSCAN(IG+3)=SCAN(JC+K)
      IF(IPARA(1).EQ.1) GO TO 1002
      SSCAN(IG+4)=SCAN(JD+K)
 1012 SSCAN(IG+5)=SCAN(JE+K)
      SSCAN(IG+6)=SCAN(JF+K)
      SSCAN(IG+7)=SCAN(JG+K)
      IF(IPARA(1).EQ.1) GO TO 1003
      SSCAN(IG+8)=SCAN(JH+K)
 1013 SSCAN(IG+9)=SCAN(JI+K)
      SSCAN(IG+10)=SCAN(JK+K)
      IF(IPARA(2).EQ.1) GO TO 1031
      SSCAN(IG+11)=SCAN(JJ+K)
      SSCAN(IG+12)=SCAN(JL+K)
      GO TO 1005
C----------PARALLEL CASE
 1002 SSCAN(IG+4)=TAN(JX+K)
      GO TO 1012
 1003 SSCAN(IG+8)=TAN(JY+K)
      GO TO 1013
 1031 SSCAN(IG+11)=CTAN(JZ+K)
      SSCAN(IG+12)=CTAN(JW+K)
 1005 IF(ITW.EQ.0) GO TO 1101
C---------- INSERT TWIST VECTOR,IF SPL=2 OR PNTS=2
      TEMA=SSCAN(IG+11)
      TEMB=SSCAN(IG+12)
      IF(ITW.EQ.2  ) GO TO 1110
      SSCAN(IG+11)=(SSCAN(IG+7)-SSCAN(IG+3))
      SSCAN(IG+12)=(SSCAN(IG+8)-SSCAN(IG+4))
      GO TO 1111
 1110 SSCAN(IG+11)=(SSCAN(IG+10)-SSCAN(IG+9))
      SSCAN(IG+12)=(TEMB-TEMA)
 1111 SSCAN(IG+13)=TEMA
      SSCAN(IG+14)=TEMB
      SSCAN(IG+15)=SSCAN(IG+11)
      SSCAN(IG+16)=SSCAN(IG+12)
 1101 IG=IG+12
      IF(ITW.NE.0) IG=IG+4
 1100 CONTINUE
      SSCAN(IG+1)=1.0
      IG=IG+1
 1000 CONTINUE
      GO TO 9999
 2000 DO 2001 I=1,IAA
      DO 2001 J=1,IBB
      JA=(I-1)*IB*3+(J-1)*3
      JB=(I-1)*IB*3+J*3
      JC=IC+JA
      JD=IC+JB
      JE=I*IB*3+(J-1)*3
      JF=I*IB*3+J*3
      JG=JE+IC
      JH=JF+IC
      JI=ID+(J-1)*IA*3+(I-1)*3
      JJ=ID+I*3+(J-1)*IA*3
      JK=ID+J*IA*3+(I-1)*3
      JL=ID+J*IA*3+I*3
      JX=(J-1)*3+(I-1)*3*IBB
      JY=(J-1)*3+I*3*IBB
      JZ=(I-1)*3+(J-1)*3*IAA
      JW=(I-1)*3+J*3*IAA
      IF(SSCAN(6)-2.0) 2100,2200,2300
C----------XYPLAN
 2100 SSCAN(IG+1)=SCAN(JA+1)
      SSCAN(IG+2)=SCAN(JB+1)
      SSCAN(IG+3)=SCAN(JE+1)
      SSCAN(IG+4)=SCAN(JF+1)
      SSCAN(IG+5)=SCAN(JA+2)
      SSCAN(IG+6)=SCAN(JB+2)
      SSCAN(IG+7)=SCAN(JE+2)
      SSCAN(IG+8)=SCAN(JF+2)
      SSCAN(IG+9)=SCAN(JA+3)
      SSCAN(IG+10)=SCAN(JB+3)
      SSCAN(IG+11)=SCAN(JC+3)
      IF(IPARA(1).EQ.1) GO TO 2102
      SSCAN(IG+12)=SCAN(JD+3)
 2112 SSCAN(IG+13)=SCAN(JE+3)
      SSCAN(IG+14)=SCAN(JF+3)
      SSCAN(IG+15)=SCAN(JG+3)
      IF(IPARA(1).EQ.1) GO TO 2103
      SSCAN(IG+16)=SCAN(JH+3)
 2113 SSCAN(IG+17)=SCAN(JI+3)
      SSCAN(IG+18)=SCAN(JK+3)
      IF(IPARA(2).EQ.1) GO TO 2131
      SSCAN(IG+19)=SCAN(JJ+3)
      SSCAN(IG+20)=SCAN(JL+3)
      GO TO 2107
C----------PARALLEL CASE
 2102 SSCAN(IG+12)=TAN(JX+3)
      GO TO 2112
 2103 SSCAN(IG+16)=TAN(JY+3)
      GO TO 2113
 2131 SSCAN(IG+19)=CTAN(JZ+3)
      SSCAN(IG+20)=CTAN(JW+3)
 2107 IF(ITW.EQ.0  ) GO TO 2105
C---------- INSERT TWIST VECTOR,IF SPL=2 OR PNTS=2
      TEMA=SSCAN(IG+19)
      TEMB=SSCAN(IG+20)
      IF(ITW.EQ.2) GO TO 2110
      SSCAN(IG+19)=(SSCAN(IG+15)-SSCAN(IG+11))
      SSCAN(IG+20)=(SSCAN(IG+16)-SSCAN(IG+12))
      GO TO 2111
 2110 SSCAN(IG+19)=(SSCAN(IG+18)-SSCAN(IG+17))
      SSCAN(IG+20)=(TEMB-TEMA)
 2111 SSCAN(IG+21)=TEMA
      SSCAN(IG+22)=TEMB
      SSCAN(IG+23)=SSCAN(IG+19)
      SSCAN(IG+24)=SSCAN(IG+20)
      GO TO 2106
C---------- YZPLAN
 2200 SSCAN(IG+1)=SCAN(JA+1)
      SSCAN(IG+2)=SCAN(JB+1)
      SSCAN(IG+3)=SCAN(JC+1)
      IF(IPARA(1).EQ.1) GO TO 2202
      SSCAN(IG+4)=SCAN(JD+1)
 2212 SSCAN(IG+5)=SCAN(JE+1)
      SSCAN(IG+6)=SCAN(JF+1)
      SSCAN(IG+7)=SCAN(JG+1)
      IF(IPARA(1).EQ.1) GO TO 2203
      SSCAN(IG+8)=SCAN(JH+1)
 2213 SSCAN(IG+9)=SCAN(JI+1)
      SSCAN(IG+10)=SCAN(JK+1)
      IF(IPARA(2).EQ.1) GO TO 2231
      SSCAN(IG+11)=SCAN(JJ+1)
      SSCAN(IG+12)=SCAN(JL+1)
 2215 SSCAN(IG+13)=SCAN(JA+2)
      SSCAN(IG+14)=SCAN(JB+2)
      SSCAN(IG+15)=SCAN(JE+2)
      SSCAN(IG+16)=SCAN(JF+2)
      SSCAN(IG+17)=SCAN(JA+3)
      SSCAN(IG+18)=SCAN(JB+3)
      SSCAN(IG+19)=SCAN(JE+3)
      SSCAN(IG+20)=SCAN(JF+3)
      IF(ITW.EQ.0  ) GO TO 2105
C---------- INSERT TWIST VECTOR,IF SPL=2 OR PNTS=2
      TEMA=SSCAN(IG+11)
      TEMB=SSCAN(IG+12)
      SSCAN(IG+17)=SSCAN(IG+13)
      SSCAN(IG+18)=SSCAN(IG+14)
      SSCAN(IG+19)=SSCAN(IG+15)
      SSCAN(IG+20)=SSCAN(IG+16)
      SSCAN(IG+21)=SSCAN(IG+17)
      SSCAN(IG+22)=SSCAN(IG+18)
      SSCAN(IG+23)=SSCAN(IG+19)
      SSCAN(IG+24)=SSCAN(IG+20)
      IF(ITW.EQ.2) GO TO 2210
      SSCAN(IG+11)=(SSCAN(IG+7)-SSCAN(IG+3))
      SSCAN(IG+12)=(SSCAN(IG+8)-SSCAN(IG+4))
      GO TO 2211
 2210 SSCAN(IG+11)=(SSCAN(IG+10)-SSCAN(IG+9))
      SSCAN(IG+12)=(TEMB-TEMA)
 2211 SSCAN(IG+13)=TEMA
      SSCAN(IG+14)=TEMB
      SSCAN(IG+15)=SSCAN(IG+11)
      SSCAN(IG+16)=SSCAN(IG+12)
      GO TO 2106
C----------PARALLEL CASE
 2202 SSCAN(IG+4)=TAN(JX+1)
      GO TO 2212
 2203 SSCAN(IG+8)=TAN(JY+1)
      GO TO 2213
 2231 SSCAN(IG+11)=CTAN(JZ+1)
      SSCAN(IG+12)=CTAN(JW+1)
      GO TO 2215
C----------ZXPLAN
 2300 SSCAN(IG+1)=SCAN(JA+1)
      SSCAN(IG+2)=SCAN(JB+1)
      SSCAN(IG+3)=SCAN(JE+1)
      SSCAN(IG+4)=SCAN(JF+1)
      SSCAN(IG+5)=SCAN(JA+2)
      SSCAN(IG+6)=SCAN(JB+2)
      SSCAN(IG+7)=SCAN(JC+2)
      IF(IPARA(1).EQ.1) GO TO 2302
      SSCAN(IG+8)=SCAN(JD+2)
 2312 SSCAN(IG+9)=SCAN(JE+2)
      SSCAN(IG+10)=SCAN(JF+2)
      SSCAN(IG+11)=SCAN(JG+2)
      IF(IPARA(1).EQ.1) GO TO 2303
      SSCAN(IG+12)=SCAN(JH+2)
 2313 SSCAN(IG+13)=SCAN(JI+2)
      SSCAN(IG+14)=SCAN(JK+2)
      IF(IPARA(2).EQ.1) GO TO 2331
      SSCAN(IG+15)=SCAN(JJ+2)
      SSCAN(IG+16)=SCAN(JL+2)
 2315 SSCAN(IG+17)=SCAN(JA+3)
      SSCAN(IG+18)=SCAN(JB+3)
      SSCAN(IG+19)=SCAN(JE+3)
      SSCAN(IG+20)=SCAN(JF+3)
      IF(ITW.EQ.0  ) GO TO 2105
C---------- INSERT TWIST VECTOR,IF SPL=2 OR PNTS=2
      TEMA=SSCAN(IG+15)
      TEMB=SSCAN(IG+16)
      SSCAN(IG+21)=SSCAN(IG+17)
      SSCAN(IG+22)=SSCAN(IG+18)
      SSCAN(IG+23)=SSCAN(IG+19)
      SSCAN(IG+24)=SSCAN(IG+20)
      IF(ITW.EQ.2) GO TO 2310
      SSCAN(IG+15)=(SSCAN(IG+11)-SSCAN(IG+7))
      SSCAN(IG+16)=(SSCAN(IG+12)-SSCAN(IG+8))
      GO TO 2311
 2310 SSCAN(IG+15)=(SSCAN(IG+14)-SSCAN(IG+13))
      SSCAN(IG+16)=(TEMB-TEMA)
 2311 SSCAN(IG+17)=TEMA
      SSCAN(IG+18)=TEMB
      SSCAN(IG+19)=SSCAN(IG+15)
      SSCAN(IG+20)=SSCAN(IG+16)
      GO TO 2106
C----------PARALLEL CASE
 2302 SSCAN(IG+8)=TAN(JX+2)
      GO TO 2312
 2303 SSCAN(IG+12)=TAN(JY+2)
      GO TO 2313
 2331 SSCAN(IG+15)=CTAN(JZ+2)
      SSCAN(IG+16)=CTAN(JW+2)
      GO TO 2315
 2105 SSCAN(IG+21)=1.0
      IG=IG+21
      GO TO 2001
 2106 SSCAN(IG+25)=1.0
      IG=IG+25
 2001 CONTINUE
 9999 RETURN
      END
**** SOURCE FILE : M0002890.V10   ***
*
C     READ ROUTINE (LDARD) FOR LARGE DATA ARRAYS
C
      SUBROUTINE LDARD(MOD,A,NUMBER)
C
      IMPLICIT DOUBLE PRECISION (A-H), DOUBLE PRECISION (O-Z)
C
      INCLUDE (BLANKCOM)    
C
      DOUBLE PRECISION A(3),B(10)
      INTEGER IB(20)
      EQUIVALENCE (B(1),IB(1))
      INCLUDE (DARRAY)    
      COMMON/SSPRT/SSPRT,SSTEST
      INTEGER ITEMP(2),BCDF
      EQUIVALENCE (TEMP,ITEMP(1))
      CHARACTER*1 TEST
      LOGICAL SSPRT,SSTEST
      DOUBLE PRECISION SNAME(2)
      DOUBLE PRECISION MEMBER
      CHARACTER BLA8*8,BLA*1
      CHARACTER LNAME*16,LMEM*8
      DATA BLA8/'        '/,BLA/' '/
C
      CALL UNPACK(A(1),MODE,ISIZE,ISUB)
      MEMBER=A(ISIZE+1)
      CALL HOLFRM(MEMBER,LMEM,1,8,NWD)
      SNAME(1)=MEMBER
      ITEMP(1)=BCDF(BLA8(1:4))
      ITEMP(2)=BCDF(BLA8(5:8))
      SNAME(2)=TEMP
      CALL HOLFRM(SNAME,LNAME,1,16,NWD)
      IF(ISUB.EQ.0) GOTO 8
      CALL ICONV(ISUB+10000000,LMEM,1,8)
      SNAME(1)=A(ISUB*ISIZE+ISUB)
      CALL HOLFRM(SNAME(1),LNAME,1,8,NWD)
      DO 5 K=1,8
      IF(LNAME(K:K).EQ.BLA)GOTO 5
      LMEM(K:K)=LNAME(K:K)
    5 CONTINUE
      CALL CFORM(' (     )',LNAME,9,8)
      CALL ICONV(ISUB,LNAME,11,4)
C   OPEN READING FROM PDS
    8 CALL FINDME (19,LMEM,IRET)
      IF(IRET.EQ.0)GOTO 10
      CALL CFORM('0 CANNOT FIND FILE :          :',DARRAY,1,31)
      CALL CFORM(LMEM,DARRAY,22,8)
      CALL CPRINT(DARRAY)
      RETURN
   10 CALL RDSATZ(19,B,IANZ,NRSATZ,IRET)
      IF(B(1).EQ.SNAME(1))GOTO 20
      CALL CFORM('0 FILE :          : CONTAINS WRONG SURFACE',DARRAY,
     +           1,42)
      CALL CFORM(LMEM,DARRAY,10,8)
      CALL CPRINT(DARRAY)
      RETURN
C      READ SURFACE
C   RESTORE LENGTH
   20 A(2)=IB(8)
C   RESTORE SURFACE-TYPE
      MODE =IB(5)
C   PREPARE RESTORAGE
      IEND=40+IB(8)
      J=6
      DO 30 I=42,IEND
      COM(I)=B(J)
      J=J+1
      IF(J.LE.9)GOTO 30
      CALL RDSATZ(19,B,IANZ,NRSATZ,IRET)
      J=1
   30 CONTINUE
C   STORE SURFACE
      JMODE=1
      CALL APT094(JMODE,A(1),COM(41))
      IF(JMODE.NE.1)GOTO 99
      ISPRNT=2
      IF(SSTEST)ISPRNT=1
      IF(.NOT.SSPRT)RETURN
C    ONLY SSURF: OUTPUT VERIFICATION-LISTING
      IF(MODE.EQ.29)CALL SSPICT(COM(41),LNAME ,ISPRNT)
      IF(MODE.NE.30)RETURN
      ISPRNT=2
      IF(SSTEST)ISPRNT=3
      CALL SCPICT(COM(41),LNAME,ISPRNT)
      RETURN
   99 CALL ERROR(5000,'READ    ')
      CALL UNDEF(A(1))
      RETURN
      END
**** SOURCE FILE : M0002770.V02   ***
*
      SUBROUTINE LINEAR(SCAN,SPL,PNTS,ILIN)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      INCLUDE (BLANKCOM)    
C
      DIMENSION SCAN(2000),X(200),Y(200),SLOP(200)
      DIMENSION IU(3),IV(3)
      DATA IU,IV/1,2,3,2,3,1/
      DATA AZERO/0.1D-6/
      IDEBUG=0
      ID=SSCAN(6)
      IA=SPL
      IB=PNTS
      NU=IU(ID)
      NV=IV(ID)
      DO 150 J=1,IA
      DO 150 I=1,IB
      IC=(J-1)*IB*3+(I-1)*3
      X(I+J*IB-IB)=SCAN(IC+NU)
      Y(I+J*IB-IB)=SCAN(IC+NV)
  150 CONTINUE
      I=IA
      J=IB
      DO 100 N=1,I
      JA=J-1
      DO 100 M=1,JA
      MN=M+IB*N-IB
      IF (DABS(X(MN+1) -X(MN )).LE.AZERO) GO TO 101
      SLOP(MN)=(Y(MN+1)-Y(MN))/(X(MN+1)-X(MN))
      IF (DABS(SLOP(MN )).LE.AZERO) SLOP(MN )=0.0
      GO TO 100
  101 SLOP(MN)=9999.0
 100  CONTINUE
      CSLOP=SLOP(1)*1.001
      DSLOP=SLOP(1)*0.999
      DO 120 N=1,I
      I1N=1+(N-1)*IB
      ASLOP=SLOP(I1N)*1.001
      BSLOP=SLOP(I1N)*0.999
      DO 110 M=1,JA
      MN=M+(N-1)*IB
      IF((SLOP(MN ).LE.ASLOP).AND.(SLOP(MN ).GE.BSLOP)) GO TO 110
      GO TO 130
 110  CONTINUE
      IF((SLOP(I1N).LE.CSLOP).AND.(SLOP(I1N).GE.DSLOP)) GO TO 120
      GO TO 130
 120  CONTINUE
      GO TO 1500
 130  ILIN=0
      GO TO 300
 1500 DO 200 N=1,J
      IA=I-1
      DO 200 M=1,IA
      NM=N+(M-1)*IB
      IF (DABS(X(NM+IB)-X(NM )).LE.AZERO) GO TO 201
      SLOP(NM)=(Y(NM+IB)-Y(NM))/(X(NM+IB)-X(NM))
      IF (DABS(SLOP(NM )).LE.AZERO) SLOP(NM )=0.0
      GO TO 200
  201 SLOP(NM)=9999.0
 200  CONTINUE
      CSLOP=SLOP(1)*1.001
      DSLOP=SLOP(1)*0.9990
      DO 220 N=1,J
      IN1=N
      ASLOP=SLOP(IN1)*1.001
      BSLOP=SLOP(IN1)*0.999
      DO 210 M=1,IA
      NM=N+(M-1)*IB
      IF((SLOP(NM ).LE.ASLOP).AND.(SLOP(NM ).GE.BSLOP)) GO TO 210
      GO TO 130
 210  CONTINUE
      IF((SLOP(IN1).LE.CSLOP).AND.(SLOP(IN1).GE.DSLOP)) GO TO 220
      GO TO 130
 220  CONTINUE
      ILIN=1
 300  RETURN
      END
**** SOURCE FILE : M0001897.V03   ***
*
      SUBROUTINE LODPCH(SS,B,IFLAG,ITOP,N,MODE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------INPUT A SCULPTURED SURFACE DATA PACK SS AND A PATCH
C------ NUMBER N.  OUTPUT THE PATCH COEFFICIENTS INTO THE
C------ ARRAY B, THE FOUR MATRIX FLAGS INTO IFLAG AND
C------ THE TOPOLOGY ENTRIES INTO ITOP
      DIMENSION B(64),IFLAG(4),ITOP(6,4)
      DIMENSION SS(*), IXYZ(3,3)
C---     TEMPORARY ARRAY TO HOLD INTERIM CANON FORM OF SURFACE
      DIMENSION TEMP(2)
C---     INTEGER JJJ IS EQUIVALENCED TO AAA BECAUSE THIRD ARGUMENT
C---     OF APT094 IS SUPPOSED TO BE ON A DOUBLE WORD BOUNDARY
      EQUIVALENCE (AAA,JJJ)
C
C
      DATA IXYZ/0,16,32, 16,32,0, 32,0,16 /
C
      NPCHS=SS(4)
      IF(N.GT.NPCHS) GO TO 998
      ITEMP=11+6*(N-1)
      IFLAG(1)=SS(ITEMP)
      IFLAG(2)=SS(ITEMP+1)
      IFLAG(3)=SS(ITEMP+2)
      IFLAG(4)=SS(ITEMP+3)
      IF (IFLAG(1).LT.9) THEN
       IBREL=SS(ITEMP+4)
       ITREL=SS(ITEMP+5)
      ELSE
       ITREL=SS(ITEMP+5)
      ENDIF
C---     SPECIAL LOGIC IS FOLLOWED FOR A GENERAL CURVE TYPE PATCH
C
      IF(IFLAG(1).LT.9) GO TO 90
C
C---     GENERAL CURVE TYPE PATCH, OBTAIN INDEX TO SURFACE IN COMMON
      JMODE=3
      JJJ=0
C---     RETRIEVE THE LOCATION OF SS IN COMMON
      TEMP(1)=SS(1)
      TEMP(2)=SS(8)
      CALL APT094(JMODE,TEMP,JJJ)
C---     NOW JJJ SHOULD CONTAIN THE START OF SS IN COMMON
C---     THE FOUR FLAGS WHICH CONTAIN RELATIVE ADDRESSES SHOULD
C---     NOW BE CONVERTED TO ABSOLUTE ADDRESSES IN COMMON
      DO 15 I=1,4
      IF(IFLAG(I).GT.0) IFLAG(I)=IFLAG(I)+JJJ-1
   15 CONTINUE
      IF(MODE.EQ.2) GO TO 501
C---     THE PARTICULAR TYPE OF GENCUR SURFACE IS STORED IN
C---     THE B-ARRAY.  OTHERWISE, THIS ARRAY IS RESERVED FOR
C---     THE COEFFICIENTS OF A COONS BICUBIC PATCH.
      DO 13 L=2,64
   13 B(L)=0.
      B(49)=1.
      B(50)=1.
      B(53)=1.
      B(54)=1.
C
      B(1)=SS(ITEMP+4)
      IF(MODE.LE.1) RETURN
      GO TO 501
C
   90 CONTINUE
C---     CASE OF A CONVENTIONAL COONS BICUBIC FOLLOWS
C
      IF(MODE.EQ.2) GO TO 501
      M=-15
      DO 10 L=1,4
      M=M+16
      IFT=IFLAG(L)
      IF (IFT.GT.4)  IFT=3
      GO TO (100,200,400,400),IFT
  100 B(M)=1.0
      IBREL=IBREL+1
      B(M+1)=B(M)
      B(M+2)=0.0
      B(M+3)=0.0
      B(M+4)=B(M)
      B(M+5)=B(M)
      JL=M+6
      JU=M+15
      DO 120 K=JL,JU
  120 B(K)=0.0
      GO TO 10
  200 B(M)=SS(IBREL)
      B(M+1)=SS(IBREL+1)
      B(M+4)=SS(IBREL+2)
      B(M+5)=SS(IBREL+3)
      IBREL=IBREL+4
      B(M+2)=B(M+1)-B(M)
      B(M+3)=B(M+2)
      B(M+6)=B(M+5)-B(M+4)
      B(M+7)=B(M+6)
      B(M+8)=B(M+4)-B(M)
      B(M+12)=B(M+8)
      B(M+9)=B(M+5)-B(M+1)
      B(M+13)=B(M+9)
      B(M+10)=B(M+6)-B(M+2)
      B(M+14)=B(M+10)
      B(M+11)=B(M+7)-B(M+3)
      B(M+15)=B(M+11)
      GO TO 10
  400 IM=M-1
      IB=IBREL-1
      B(IM+1)=SS(IB+1)
      B(IM+2)=SS(IB+2)
      B(IM+3)=SS(IB+3)
      B(IM+4)=SS(IB+4)
      B(IM+5)=SS(IB+5)
      B(IM+6)=SS(IB+6)
      B(IM+7)=SS(IB+7)
      B(IM+8)=SS(IB+8)
      B(IM+9)=SS(IB+9)
      B(IM+10)=SS(IB+10)
      IF (IFT.EQ.3) GO TO 300
      B(IM+11)=SS(IB+11)
      B(IM+12)=SS(IB+12)
      B(IM+13)=SS(IB+13)
      B(IM+14)=SS(IB+14)
      B(IM+15)=SS(IB+15)
      B(IM+16)=SS(IB+16)
      IBREL=IBREL+16
      GO TO 10
  300 B(IM+11)=0.0
      B(IM+12)=0.0
      B(IM+13)=SS(IB+11)
      B(IM+14)=SS(IB+12)
      B(IM+15)=0.0
      B(IM+16)=0.0
      IBREL=IBREL+12
   10 CONTINUE
C------ FURTHER MODIFICATION IS REQUIRED FOR XY,YZ OR ZX CASE
      ISUM = IFLAG(1)+IFLAG(2)+IFLAG(3)
      IF (ISUM.GE.9) GO TO 20
      ID=1
      IF(IFLAG(1).GE.3) ID=2
      IF(IFLAG(2).GE.3) ID=3
      IA=IXYZ(1,ID)
      IB=IXYZ(2,ID)
      IC=IXYZ(3,ID)
      D1=(B(IA+2)-B(IA+1))**2 + (B(IB+2)-B(IB+1))**2
      D2=(B(IA+5)-B(IA+1))**2 + (B(IB+5)-B(IB+1))**2
      D3=(B(IA+6)-B(IA+2))**2 + (B(IB+6)-B(IB+2))**2
      D4=(B(IA+6)-B(IA+5))**2 + (B(IB+6)-B(IB+5))**2
      D1=DSQRT(D1)
      D2=DSQRT(D2)
      D3=DSQRT(D3)
      D4=DSQRT(D4)
      B(IC+ 3)=B(IC+ 3)*D1
      B(IC+ 4)=B(IC+ 4)*D1
      B(IC+ 7)=B(IC+ 7)*D4
      B(IC+ 8)=B(IC+ 8)*D4
      B(IC+ 9)=B(IC+ 9)*D2
      B(IC+13)=B(IC+13)*D2
      B(IC+10)=B(IC+10)*D3
      B(IC+14)=B(IC+14)*D3
   20 CONTINUE
      IF(MODE.EQ.1) RETURN
C------NOW LOAD THE TOPOLOGY DATA INTO ITOP
  501 DO 500 L=1,4
      ICT=1
  530 ICT=ICT+1
      ITOP(ICT,L)=SS(ITREL+ICT-2)
      IF (ITOP(ICT,L)) 540,550,550
  540 ITOP(ICT,L)=-ITOP(ICT,L)
      GO TO 530
  550 ITOP(ICT-1,L)=ICT-1
      ITREL=ITREL+ICT-1
  500 CONTINUE
 998  RETURN
      END
**** SOURCE FILE : M0004288.W02   ***
*
      SUBROUTINE MESH(IERROR,IRR,ITW,SSNAME,ASAV)
C----------SCULPTURED SURFACE ROUTINE ------- JULY 1971  *LPK*
C---------- MESH DEFINITION
C---------THIS ROUTINE ACCEPTS THE TRANSLATED MESH DEFINITION
C---------AND PREPARES THE NECESSARY VALUE TABLE FOR THE MESH
C---------DATA STRUCTURE. UPON ENTRANCE IT IS ASSUMED THAT THE HEADER
C---------OF THE DATA STRUCTURE -SSCAN ARRAY, WAS SET. THE ROUTINE
C---------CHECKS IF THE DEFINED SURFACE EXCEEDS THE SIZE LIMITATIONS
C---------(NMESX TOTAL NO. OF POINTS AND NSPLMX POINTS PER SPLINE).
C---------IT THEN CHECKS THE TRANSLATED DEFINITION IN SSCAN ARRY AND
C---------AND GENERATES AN INTERMEDIATE ARRAY-SCAN, CONSISTING OF
C---------FOUR BLOCKS(POINTS,TANGENT CONSTRAINTS, CROSS TANGENT
C---------CONSTRAINTS AND NORMALS), A WEIGHT ARRAY-RL,AND A LIMIT
C---------ARRAY-RLM.THE ROUTINE THEN CALLS SSPLIN ROUTINE FOR EACH S
C---------SPLINE AND CROSS SPLINE (WEIGHTS ARE RESOLVED UPON SPLINING
C---------IN THE MAIN DIRECTION). THE TANGENT VECTOR ARE MOVED BACK INTO
C---------SCAN ARRAYAND THE DISTANCES BETWEEN POINTS ARE STORED IN
C---------DIST ARRY (FOR TANSPLINES) AND CDIST ARRAY(FOR CROSSSPLINES)
C---------FURTHER PARAL OR LINEAR ROUTINES ARE CALLED TO ASSIGN
C---------LENGTHS TO THE VECTORS. A RULED SURFACE FLAG IS SET
C---------ACCORDING TO THE FOLLOWING LOGIC:IF THERE ARE TWO SPLINES
C---------AND NO NORMAL CONSTRAINTS AND NO CROSS TANGENCY CONSTRAINTS
C---------A RULED SURFACE WITH RULLINGS IN CROSSPLINE DIRECTION IS
C---------INDICATED(ITW=1). IF THERE ARE TWO POINTS PER SPLINE AND
C---------NO NORMAL AND NO TANSPLINE CONSTRAINTS A RULED SURFACE
C---------WITH  RULLINGS IN THE MAIN DIRECTION IS INDICATED (ITW=2).
C---------FINALLY GETSCA ROUTINE IS CALLED TO LOAD THE DATA FROM SCAN
C---------ARRAY TO SSCAN ARRAY.
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      CHARACTER*8 ISPLIN,ITANS,ICRS,NORMAL,IWGT,ILIM
      CHARACTER*8 TEST
      DIMENSION ASAV(10)
C---     BUFFER ARRAY FOR PRINTING
      INCLUDE (DARRAY)    
C-------- IF N IS THE MAX NO. OF POINTS IN THE MESH , DIMENSIONS OF
C-------- RL,RLM,DIST,CDIST =N.DIMENSION OF TAN AND CTAN=3*N,AND
C-------- DIMENSION OF SCAN =12*N
C---     NSCNMX IS THE MAXIMUM SPACE AVAILABLE IN SCAN
C---     ISCAN IS THE LAST USED LOCATION IN SCAN
C---     SCAN IS A SCRATCH PAD WORK AREA FOR SS CALCULATIONS
      INCLUDE (SSPAD)    
      DIMENSION S(4,6,ISCN/24)
C---     THE BUFFER ARRAY FOR CURVES IS EQUIVALENCED TO SCAN
C---     ISXX WILL BE STARTING POSITION FOR THE CURVE DATA
      EQUIVALENCE (SCAN(1),S(1,1,1))
C
      DIMENSION IPALA(2)
C
      INCLUDE (BLANKCOM)    
C
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
      DATA ISPLIN/'SPLINE  '/,ITANS/'TANSPL  '/,ICRS/'CRSSPL  '/,
     C  NORMAL/'NORMAL  '/,IWGT/'WEIGHT  '/,ILIM/'LIMIT   '/
      DATA ZERO,ONE,SMAL/0.0D0,1.0D0,1.0D-14/
C
C---     MAX NUMBER OF POINTS IN A MESH IS LIMITED BY SPACE IN SCAN.
      NMESMX=NSCNMX/20
      NSCAMX=NMESMX*20
C---     COMPUTE THE ACTUAL NUMBER OF MESH POINTS
      NUMPTS=SSCAN(9)*SSCAN(10)
      NK3=NUMPTS*3
      IF(NUMPTS.LE.NMESMX) GO TO 71
C---     TOO MANY POINTS FOR SPACE AVAILABLE IN SSPAD
      IERROR=213
      GO TO 9000
   71 CONTINUE
      NSCAMX=MIN0(NSCAMX,NSCNMX)
C---     MAX NUMBER OF POINTS IN A SINGLE SPLINE OR CROSS SPLINE
      NSPLMX=30
C---     SET UP BASE INDICES FOR VARIOUS TYPES OF DATA IN SCAN
C---     INPUT POINT DATA
      JPT=0
C---     INPUT TANSPL DATA
      JPTAN=NUMPTS*3
C---     INPUT CRSSPL DATA
      JPCTAN=NUMPTS*6
C---     INPUT NORMAL DATA
      JNRML=NUMPTS*9
C---     PROCESSED TANGENT DATA
      JTAN=NUMPTS*12
C---     SHARED LOCATION, WEIGHT DATA FOR SMOOTHING
      JRL=JTAN
C---     SHARED LOCATION, WILD POINT DATA
      JIWL=JTAN+NUMPTS
C---      PROCESSED CROSS TANGENT DATA
      JCTAN=NUMPTS*15
C---     SHARED LOCATION , LIMIT DATA
      JRLM=JCTAN
C---     SHARED LOCATION, WILD POINT DATA
      JWL=JCTAN+NUMPTS
C---     TANGENT SPACING
      JDIST=NUMPTS*18
C---     CROSS TANGENT SPACING
      JCDIST=NUMPTS*19
C---     DETERMINE WHERE THE CURVE DATA BUFFER SHOULD START AND
C---     WHETHER THERE IS ENOUGH ROOM FOR SPLINING.
      NTEMP=SSCAN(9)
      IF(SSCAN(9).LT.SSCAN(10)) NTEMP=SSCAN(10)
      ISXX=(NUMPTS*20)/24
      ISXX=ISXX+1
      IF((ISXX+1+NTEMP)*24.LE.NSCNMX) GO TO 72
C****    NOT ENOUGH SPACE FOR THE CURVE DATA
      IERROR=210
      GO TO 9000
   72 CONTINUE
C
      DO 100 I=1,NSCAMX
  100 SCAN(I)=ZERO
      DO 101 I=1,NUMPTS
      SCAN(JRLM+I)=ZERO
  101 SCAN(JRL+I)=ONE
      IERROR=0
      IRR=0
      INORM=0
      ITW=0
      IRULE=0
      JRULE=0
      SPL=SSCAN(9)
      PNTS=SSCAN(10)
      SSCAN(10)=ASAV(10)
      NEND=ASAV(5)
      IF(SPL.EQ.2.0) IRULE=1
      IF(PNTS.EQ.2.0) JRULE=1
      ITT=SPL*PNTS
      IA=PNTS
      IF (ITT .LE. NMESMX) GO TO 110
      IERROR=210
      GO TO 9000
  110 IF (IA .LE. NSPLMX) GO TO 120
      IERROR=211
      GO TO 9000
  120 CONTINUE
      PTANS=JPTAN+1
      PCRS=JPCTAN+1
      K=0
      ITA=JPTAN-2
      ICS=JPCTAN-2
      INR=JNRML-2
C---      TURN THE GLOBAL WEIGHT AND LIMIT FLAG OFF
      IGLOBE=0
      M=9
      IF(IBUG.EQ.11) CALL BAD(-NEND,1,'SSCN',SSCAN)
C---     ASSUME THE FIRST INPUT FOLLOWS THE WORD SPLINE
      GO TO 650
C---     NOW SEARCH THRU THE INPUT STREAM AND STRUCTURE
C---     THE MESH DATA INTO THE SCAN ARRAY FOR MESH PROCESSING
C
  160 CONTINUE
      IF(IBUG.NE.11) GO TO 162
      CALL BAD(1,0,'NEND',NEND)
      CALL BAD(1,0,'M   ',M)
      CALL BAD(-4,1,'SNXT',SSCAN(M))
  162 CONTINUE
      IF(M.GE.NEND) GO TO 1000
      IF(SSCAN(M).EQ.19.) GO TO 610
      IF(SSCAN(M).EQ.13.) GO TO 200
      IF(SSCAN(M).EQ.136.) GO TO 300
      IF(SSCAN(M).EQ.137.) GO TO 400
      IF(SSCAN(M).EQ.138.) GO TO 500
      IF(SSCAN(M).EQ.139.) GO TO 550
      CALL HOLFRM(SSCAN(M),TEST,1,8,NWD)
      IF(TEST.EQ.ISPLIN) GO TO 650
      GO TO 1000
C----------NORMAL
 200  M=M+1
      CALL HOLFRM(SSCAN(M),TEST,1,8,NWD)
      IF(TEST.NE.NORMAL) IERROR=214
      M=M+1
      INORM=1
      IF(SSCAN(M).NE.20.)IERROR=215
      N=INR+2
      DO 250 I=INR,N
      M=M+1
      SCAN(I)=SSCAN(M)
 250  CONTINUE
      GO TO 600
C----------TANSPL
 300  M=M+1
      CALL HOLFRM(SSCAN(M),TEST,1,8,NWD)
      IF(TEST.NE.ITANS) IERROR=216
      M=M+1
      IF(SSCAN(M).NE.20.)IERROR=215
      N=ITA+2
      DO 350 I=ITA,N
      M=M+1
      SCAN(I)=SSCAN(M)
 350  CONTINUE
      GO TO 600
C----------CRSSPL
 400  M=M+1
      CALL HOLFRM(SSCAN(M),TEST,1,8,NWD)
      IF(TEST.NE.ICRS) IERROR=217
      M=M+1
      IF(SSCAN(M).NE.20.)IERROR=215
      N=ICS+2
      DO 450 I=ICS,N
      M=M+1
      SCAN(I)=SSCAN(M)
 450  CONTINUE
      GO TO 600
C----------WEIGHT
 500  M=M+1
      CALL HOLFRM(SSCAN(M),TEST,1,8,NWD)
      IF(TEST.NE.IWGT) IERROR=218
      M=M+1
      IF(SSCAN(M).NE.21.)IERROR=219
      M=M+1
C---     IF THIS IS A GLOBAL WEIGHT, THEN SET REMAINING WEIGHTS
C---     IN THIS PARTICULAR SPLINE DEFINITION
      IF(IGLOBE.EQ.0) GO TO 501
      KLIM=PNTS-ONE+K
C---     IF THE LIMIT IS NEGATIVE, THEN IT IS GLOBAL FOR THE
C---     REMAINING POINTS IN THE MESH.
      IF(SSCAN(M).LT.-SMAL) KLIM=NUMPTS+K-1
      KLIM=MIN0(NUMPTS,KLIM)
      DO 502 L=K,KLIM
  502 SCAN(JRL+L)=DABS(SSCAN(M))
      GO TO 650
  501 CONTINUE
C
      SCAN(JRL+K)=SSCAN(M)
      GO TO 600
C-------------  LIMIT
  550 M=M+1
      CALL HOLFRM(SSCAN(M),TEST,1,8,NWD)
      IF (TEST .NE. ILIM)IERROR=220
      M=M+1
      IF (SSCAN(M) .NE. 21.)IERROR=219
      M=M+1
C---     IF THIS IS A GLOBAL LIMIT, THEN SET LIMITS IN THIS
C---     PARTICULAR SPLINE TO THE INDICATED LIMIT
      IF(IGLOBE.EQ.0) GO TO 551
      KLIM=PNTS-ONE+K
C---     IF THE LIMIT IS NEGATIVE THEN IT IS GLOBAL FOR THE
C---     REMAINING POINTS IN THE MESH
      IF(SSCAN(M).LT.-SMAL) KLIM=NUMPTS+K-1
      KLIM=MIN0(NUMPTS,KLIM)
      DO 552 L=K,KLIM
  552 SCAN(JRLM+L)=DABS(SSCAN(M))
      GO TO 650
  551 CONTINUE
C
      SCAN(JRLM+K)=SSCAN(M)
      GO TO 600
C----------SPLINE
 600  M=M+1
      GO TO 160
 610  ITA=ITA+3
      ICS=ICS+3
      INR=INR+3
      MM=K*3+1
      MA=MM+2
      K=K+1
      DO 620 I=MM,MA
      M=M+1
      SCAN(I)=SSCAN(M)
 620  CONTINUE
      GO TO 600
C
 650  M=M+1
      IGLOBE=0
      IF(SSCAN(M).EQ.19.)GO TO 610
C---     IF A WEIGHT OR LIMIT FOLLOW, THEN THESE SPECIFY GLOBAL WEIGHTS
      IGLOBE=1
      IF(SSCAN(M).EQ.138.) GO TO 500
      IF(SSCAN(M).EQ.139.) GO TO 550
      IERROR=212
      GO TO 9000
C
C--------USERS INPUT HAS NOW BEEN FORMATTED, BEGIN SPLINING PROCEDURE.
C----------SMOOTHING ALONG SPLINE DIRECTION
 1000 CONTINUE
C---     CHECK TO SEE IF ALL INPUT HAS BEEN PROCESSED
      IF(M.EQ.NEND.AND.K.EQ.ITT) GO TO 1001
C****    IMPROPER DATA IN SSURF INPUT STREAM
      CALL BAD(1,0,'NEND',NEND)
      CALL BAD(1,0,'M   ',M)
      CALL BAD(-4,1,'SNXT',SSCAN(M))
      IERROR=222
      GO TO 9000
 1001 CONTINUE
      IF(IBUG.NE.11) GO TO 1003
C---     DUMP PROCESSED POINT, TANSPL,CRSSPL,NORMAL, WT AND LIMITS
      NK3=NUMPTS*3
      CALL BAD(-NK3,1,'PTS ',SCAN(JPT+1))
      CALL BAD(-NK3,1,'TAN ',SCAN(JPTAN+1))
      CALL BAD(-NK3,1,'CTAN',SCAN(JPCTAN+1))
      CALL BAD(-NK3,1,'NRML',SCAN(JNRML+1))
      CALL BAD(-NUMPTS,1,'WGT ',SCAN(JRL+1))
      CALL BAD(-NUMPTS,1,'LIMT',SCAN(JRLM+1))
 1003 CONTINUE
C----------RESET POINTERS TO AREAS FOR TANGENTS, CROSS AND NORMALS
      ITA=JPTAN+1
      ICS=JPCTAN+1
      INR=JNRML+1
C--------------    INITIATE CROSS SPLINE  CONSTRAINT INDICATORS
      IA=SPL
      IB=PNTS
      IIT=ITT*12
      IM=IB+1
      IF (IA .GT. IB) IM=IA+1
      DO 1005 I=1,IM
 1005 S(4,3,I+ISXX)=ZERO
      IJK=0
C-------------          PREPARE S ARRAY HEADER
      S(2,1,1+ISXX)=ONE
      S(3,1,1+ISXX)=ONE
      S(4,1,1+ISXX)=IB
C-------------          IND,ITD,ICD, INDICATE EXISTANCE OF NORMAL ,
C-------------          TANSPL, CRSSPL, CONSTRAINT RESPECTIVELY
C-------------        AT ANY OF THE POINTS
      IND=0
      ITD=0
      ICD=0
      KWL=0
      KWL1=0
      KTFL=0
      SCAN(JIWL+1)=ZERO
C-------------          SPLINING ALONG MAIN DIRECTION (TANSPL)
      IB1=IB+1
      DO 1010 IG=1,IA
      IB0=(IG-1)*IB*3
      DO 1020 IG1=2,IB1
      IB2=(IG1-2)*3+IB0
C-------------          MOVE POINTS AND VECTORS INTO S ARRAY
      DO 1030 IG2=1,3
      IG3=IG2+IB2
      S(IG2,1,IG1+ISXX)=SCAN(IG3)
      S(IG2,2,IG1+ISXX)=SCAN(IG3-1+ITA)
      S(IG2,4,IG1+ISXX)=SCAN(IG3-1+INR)
 1030 CONTINUE
C-------------          SET S ARRAY CONSTRAINT INDICATORS
      S(4,2,IG1+ISXX)=ZERO
      JNN=ITA+IG3-3
      WJ=DABS(SCAN(JNN))+DABS(SCAN(JNN+1))+DABS(SCAN(JNN+2))
      IF(WJ.GT.SMAL) S(4,2,IG1+ISXX)=ONE
      IF (S(4,2,IG1+ISXX) .EQ. ONE) ITD=1
      S(4,4,IG1+ISXX)=ZERO
      JNN=INR+IG3-3
      WJ=DABS(SCAN(JNN))+DABS(SCAN(JNN+1))+DABS(SCAN(JNN+2))
      IF(WJ.GT.SMAL) S(4,4,IG1+ISXX)=ONE
      IF (S(4,4,IG1+ISXX) .EQ. ONE) IND=1
C-------------          MOVE WEIGHT TO S ARRAY
      S(1,5,IG1+ISXX)=SCAN(JRL+(IG-1)*IB+IG1-1)
C-------------          MOVE LIMITS
      S(2,5,IG1+ISXX)=SCAN(JRLM+(IG-1)*IB+IG1-1)
 1020 CONTINUE
      S(1,2,ISXX+1)=ZERO
C-------------          BRANCH TO SSPLIN ROUTINE
      JFLAG=1000+IG
      IF(IBUG.EQ.11) CALL SCDUMP(JFLAG,S(1,1,ISXX+1))
C
      CALL SSPLIN(S(1,1,ISXX+1),IRRT)
      JFLAG=2000+IG
      IF(IBUG.EQ.11) CALL SCDUMP(JFLAG,S(1,1,ISXX+1))
      IF(IRR.EQ.0.AND.IRRT.NE.0) IRR=IRRT
C-------------          MOVE POINTS AND TANSPLINES TO SCAN
      DO 1040 IG1=2,IB1
      IB2=(IG1-2)*3+IB0
      DO 1050 IG2=1,3
      IG3=IG2+IB2
      SCAN(IG3)=S(IG2,1,IG1+ISXX)
      SCAN(ITA+IG3-1)=S(IG2,2,IG1+ISXX)
 1050 CONTINUE
C-------------          MOVE DISTANCE BETWEEN POINTS TO DIST
      SCAN(JDIST+(IB-1)*(IG-1)+IG1-1)=S(4,1,IG1+ISXX)
C------------- IF WILD POINT INDICATOR GT 1 STACK THE POINT LOCATION
C------------- (SPLINE NUMBER AND POINT NUMBER) INTO IWL ARRAY AND
C------------- THE WILDNESS FACTOR INTO WL ARRAY
      IF (S(4,5,IG1+ISXX) .LE. ONE) GO TO 1040
      KWL1=KWL1+1
      KWL=KWL+1
      SCAN(JWL+KWL1)=S(4,5,IG1+ISXX)
      SCAN(JIWL+KWL)=IG
      KWL=KWL+1
      SCAN(JIWL+KWL)=IG1-1
 1040 CONTINUE
C---      PRINT ERROR NUMBER FOR EACH SPLINE, IF ANY.
      IF(IRRT.EQ.0) GO TO 1041
      CALL RECORD(ISEQNO)
      CALL ICONV(ISEQNO,DARRAY,1,6)
      CALL CFORM('. ERROR NO.',DARRAY,7,11)
      CALL ICONV(IRRT,DARRAY,18,7)
      CALL CFORM('FOR  SPLINE NO.',DARRAY,26,15)
      CALL ICONV(IG,DARRAY,41,5)
      CALL CPRINT(DARRAY)
 1041 CONTINUE
 1010 CONTINUE
C
C------------- IF ANY WILD POINT DETECTED GO TO PRINT A MESSAGE
      IF(DABS(SCAN(JIWL+1)).LT.SMAL) GO TO 777
      KO=0
      ASSIGN 777 TO IRET
      GO TO 3000
C----------END OF SPLINE FITTING, BRANCH TO WILD POINT ANALYSIS
  777 CONTINUE
      IJK=1
C-------------          SPLINE ALONG CROSS SPLINE DIRECTION
C------------           CHANGE S ARRAY HEADER (NO. OF POINTS)
      S(4,1,1+ISXX)=IA
      IB1=IA+1
      DO 1060 IG=1,IB
      IB0=(IG-1)*3
      DO 1070 IG1=2,IB1
      IB2=(IG1-2)*3*IB+IB0
C-------------          MOVE POINTS AND VECTORS INTO S ARRAY
      DO 1075 IG2=1,3
      IG3=IG2+IB2
      S(IG2,1,IG1+ISXX)=SCAN(IG3)
      S(IG2,2,IG1+ISXX)=SCAN(IG3-1+ICS)
      S(IG2,4,IG1+ISXX)=SCAN(IG3-1+INR)
 1075 CONTINUE
C-------------          SET CONSTRAINT INDICATORS
      S(4,2,IG1+ISXX)=ZERO
      S(4,4,IG1+ISXX)=ZERO
      JNN=ICS+IG3-3
      WJ=DABS(SCAN(JNN))+DABS(SCAN(JNN+1))+DABS(SCAN(JNN+2))
      IF(WJ.GT.SMAL) S(4,2,IG1+ISXX)=ONE
      IF (S(4,2,IG1+ISXX) .EQ. ONE) ICD=1
      JNN=INR+IG3-3
      WJ=DABS(SCAN(JNN))+DABS(SCAN(JNN+1))+DABS(SCAN(JNN+2))
      IF(WJ.GT.SMAL) S(4,4,IG1+ISXX)=ONE
C---------- SET WEIGHT TO CERTITUDE, AND LIMIT TO ZERO
      S(1,5,IG1+ISXX)=ONE
      S(2,5,IG1+ISXX)=ZERO
 1070 CONTINUE
      S(1,2,ISXX+1)=ZERO
C-------------          BRANCH TO SPLINING ROUTINE
      JFLAG=3000+IG
      IF(IBUG.EQ.11) CALL SCDUMP(JFLAG,S(1,1,ISXX+1))
C
      CALL SSPLIN(S(1,1,ISXX+1),IRRT)
      JFLAG=4000+IG
      IF(IBUG.EQ.11) CALL SCDUMP(JFLAG,S(1,1,ISXX+1))
      IF(IRR.EQ.0.AND.IRRT.NE.0) IRR=IRRT
C-------------          MOVE CROSS SPLINE TANGENTS TO SCAN
      DO 1080 IG1=2,IB1
      IB2=(IG1-2)*3*IB+IB0
      DO 1090 IG2=1,3
      IG3=IG2+IB2
      SCAN(ICS+IG3-1)=S(IG2,2,IG1+ISXX)
 1090 CONTINUE
C-------------          MOVE DISTANCES ALONG CROSSPLINES TO CDIST
      SCAN(JCDIST+(IA-1)*(IG-1)+IG1-1)=S(4,1,IG1+ISXX)
C------------- IF WILD POINT INDICATOR GT 1 STACK THE POINT LOCATION
C------------- (SPLINE NUMBER AND POINT NUMBER) INTO IWL ARRAY AND
C------------- THE WILDNESS FACTOR INTO WL ARRAY
      IF (S(4,5,IG1+ISXX) .LE. ONE) GO TO 1080
      KWL1=KWL1+1
      KWL=KWL+1
      SCAN(JWL+KWL1)=S(4,5,IG1+ISXX)
      SCAN(JIWL+KWL)=IG
      KWL=KWL+1
      SCAN(JIWL+KWL)=IG1-1
 1080 CONTINUE
C---      PRINT ERROR NUMBER FOR EACH CROSS SPLINE, IF ANY.
      IF(IRRT.EQ.0) GO TO 1081
      CALL RECORD(ISEQNO)
      CALL ICONV(ISEQNO,DARRAY,1,6)
      CALL CFORM('. ERROR NO.',DARRAY,7,11)
      CALL ICONV(IRRT,DARRAY,18,7)
      CALL CFORM('FOR CSPLINE NO.',DARRAY,26,15)
      CALL ICONV(IG,DARRAY,41,5)
      CALL CPRINT(DARRAY)
 1081 CONTINUE
 1060 CONTINUE
C
C------------- IF ANY WILD POINT DETECTED GO TO PRINT A MESSAGE
      IF(DABS(SCAN(JIWL+1)).LT.SMAL) GO TO 1065
      KO=1
      ASSIGN 1065 TO IRET
      GO TO 3000
C----------END OF CROSS SPLINE FITTING, BRANCH TO WILD POINT ANALYSIS
 1065 CONTINUE
      IF(IRR.NE.0) GO TO 9000
C---------- PRINT OUT RESULTS OF SPLINING AND CROSS SPLINING
      IF(IBUG.NE.11) GO TO 1068
      NKK=NUMPTS*12
      CALL BAD(-NKK,1,'SCN2',SCAN)
      CALL BAD(-NUMPTS,1,'DIST',SCAN(JDIST+1))
      CALL BAD(-NUMPTS,1,'CDIS',SCAN(JCDIST+1))
 1068 CONTINUE
      IJK=IJK+1
C--------- REARRANGE CROSS SPLINE TANGENTS TO APPEAR IN SCAN
C-------  ARRAY ACCORDING TO THEIR ORDER ALONG SPLINES. USES NORMALS
C-------- SECTION OF SCAN AS A WORK AREA
      DO 2010 J=1,ITT
      INX=((J-1)/IA+(J-1-IA*((J-1)/IA))*IB)*3+ICS-1
      IN=INR-1+(J-1)*3
      DO 2010 K=1,3
 2010 SCAN(IN+K)=SCAN(INX+K)
      IT1=ITT*3
      DO 2020 I=1,IT1
      SCAN(ICS-1+I)=SCAN(INR-1+I)
 2020 SCAN(INR-1+I)=ZERO
C---------              SET RULED SURFACE INDICATORS
      IF (IND .EQ. 0 .AND. ICD .EQ. 0 .AND. IRULE .EQ. 1) ITW=1
      IF (IND .EQ. 0 .AND. ITD .EQ. 0 .AND. JRULE .EQ. 1) ITW=2
C---------- PRINT OUT TWIST FACTOR AND REARRANGED CROSS VECTORS
      IF(IBUG.NE.11) GO TO 2023
      CALL BAD(-1,0,'ITW ',ITW)
      NKK=3*NUMPTS
      CALL BAD(-NK3,1,'CRS ',SCAN(JPCTAN+1))
 2023 CONTINUE
C
C----------PARALLEL CHECK
C----------LINEAR CHECK
 4100 CONTINUE
      DO 102 I=1,NK3
      SCAN(JTAN+I)=ZERO
      SCAN(JCTAN+I)=ZERO
  102 CONTINUE
      IJK=IJK+1
      IF(SSCAN(6).NE.4.) GO TO 7000
      IA=SPL
      IB=PNTS
      IPARA=0
      CALL PARAL(SCAN(JPTAN+1),SCAN(JDIST+1),SCAN(JTAN+1),
     X           SCAN(JNRML+1),IA,IB,IPARA)
C---------- PRINT RESULTS OF PARAL LOGIC FOR TANGENT LENGTH SELECTION
      IF(IBUG.NE.11) GO TO 2027
      CALL BAD(-1,0,'IPAR',IPARA)
      CALL BAD(-NK3,1,'TANS',SCAN(JPTAN+1))
      CALL BAD(-NK3,1,'TAN ',SCAN(JTAN+1))
 2027 CONTINUE
C
      IPALA(1)=IPARA
      IJK=IJK+1
      IA=PNTS
      IB=SPL
      IPARA=0
      CALL PARAL(SCAN(JPCTAN+1),SCAN(JCDIST+1),SCAN(JCTAN+1),
     X           SCAN(JNRML+1),IA,IB,IPARA)
C---------- PRINT RESULTS OF CROSS VECTOR LENGTH ANALYSIS
      IF(IBUG.NE.11) GO TO 2028
      CALL BAD(-1,0,'IPAR',IPARA)
      CALL BAD(-NK3,1,'CRS ',SCAN(JPCTAN+1))
      CALL BAD(-NK3,1,'CTAN',SCAN(JCTAN+1))
 2028 CONTINUE
C
      IPALA(2)=IPARA
      IJK=IJK+1
      ILIN=0
      GO TO 8000
 7000 CALL LINEAR(SCAN,SPL,PNTS,ILIN)
      IF(IBUG.EQ.11) CALL BAD(-1,0,'ILIN',ILIN)
      IJK=IJK+1
      IF(ILIN.EQ.0) IERROR=300
      IPALA(1)=0
      IPALA(2)=0
C---------- SET UP DATA STRUCTURE READY TO RETURN
 8000 CONTINUE
      SSCAN(10)=PNTS
      CALL GETSCA(SCAN,SPL,PNTS,PTANS,PCRS,SCAN(JTAN+1),
     X  SCAN(JCTAN+1),IPALA,ILIN,ITW)
C---     PRINT OUT SCAN ON RETURN FOR DEBUGGING
C
 9000 IF(IERROR.NE.0) IERROR=IERROR+5000
      IF(IRR.NE.0) IERROR=IRR
      RETURN
C
C------------- PRINT WILD POINTS MESSAGE
 3000 KWL=KWL-1
      IF (KTFL .EQ. 1) GO TO 3010
      CALL RECORD(ISEQNO)
      CALL ICONV(ISEQNO,DARRAY,1,6)
      CALL CFORM('. SOME  SPLINE POINTS MAY BE WILD',DARRAY,7,33)
      IF(IJK.EQ.1) CALL CFORM('CRSSPL',DARRAY,15,6)
      CALL CPRINT(DARRAY)
      KWL=KWL-1
      DO 3011 L=1,KWL
      K=2*L-1
      CALL BAD(1,1,'PTNO',SCAN(JIWL+K))
      CALL BAD(1,1,'SPL ',SCAN(JIWL+K+1))
      CALL BAD(-1,1,'WILD',SCAN(JWL+L))
 3011 CONTINUE
      KTFL=1
 3010 CONTINUE
      KWL=0
      KWL1=0
      SCAN(JIWL+1)=ZERO
      GO TO IRET,(1065,777)
      END
**** SOURCE FILE : M0000643.V01   ***
*
      SUBROUTINE NORML3(PA,PB,PC,AN,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------CONSTRUCT A UNIT NORMAL TO THREE POINTS PA,PB,PC AND STORE IN AN
C------IF NO NORMAL EXISTS THEN IRR NE 0.
      DIMENSION PA(3),PB(3),PC(3),AN(3),P1(3),P2(3)
      IDIAG=4000
      CRIT=1.0D-10
      DO 10 I=1,3
      P1(I)=PB(I)-PA(I)
   10 P2(I)=PC(I)-PA(I)
      AN(1) = P1(2)*P2(3) - P1(3)*P2(2)
      AN(2) = P1(3)*P2(1) - P1(1)*P2(3)
      AN(3) = P1(1)*P2(2) - P1(2)*P2(1)
      D=DSQRT(AN(1)*AN(1)+AN(2)*AN(2)+AN(3)*AN(3))
      IRR=IDIAG+1
      IF(D.LT.CRIT) RETURN
      DO 20 I=1,3
   20 AN(I)=AN(I)/D
      IRR=0
      RETURN
      END
**** SOURCE FILE : M0000644.V04   ***
*
      SUBROUTINE PARAL(VECA,DIST,VECB,AVDIST,NSPL,NPTS,IPARA)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION VECA(*),DIST(*),VECB(*),AVDIST(*)
C---      PURPOSE OF PARAL IS TO DETERMINE LENGTHS OF TANGENT
C---      VECTORS IN ONE PARAMETRIC DIRECTION ACROSS A MESH SURFACE
C---      VECA IS THE ARRAY OF UNITIZED INPUT TANGENTS AND
C---      ON OUTPUT IS THE ENTERING VECTOR FOR A PATCH AT EACH POINT
C---      DIST IS THE ARRAY OF POLYGONAL DISTANCES BETWEEN POINTS
C---      VECB IS AN OUTPUT ARRAY OF EXITING VECTORS FOR EACH PAOINT
C---      AVDIST IS AN INPUT ARRAY USED TO TEMPORARILY HOLD THE
C---      AVERAGE WIDTH OF CHORDAL BANDS ACROSS THE SURFACE
C---      NSPL IS THE TOTAL NUMBER OF SPLINE CURVES AND
C---      NPTS IS THE NUMBER OF POINTS PER SPLINE(BOTH INPUT)
C---      IPARA IS SET TO 1 IF ROUGHLY PARALLEL CHORDAL BANDS
C---      ARE DETECTED ACROSS THE SURFACE, AND 0 OTHERWISE
C---      IPARA IS SET TO 1 ON OUTPUT.
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
C
C---      NUMBER OF CHORDS PER SPLINE
      NSEG=NPTS-1
      ANSPL=NSPL
C---      CHECK FOR ROUGH EQUALITY OF CHORDS ACROSS SURFACE
      DO 10 JSEG=1,NSEG
C---      COMPUTE THE AVERAGE BAND WIDTH OF THE JTH CHORDS.
      SUM=0.0
      DO 20 ISPL=1,NSPL
      JJ=NSEG*(ISPL-1)+JSEG
      SUM=SUM+DIST(JJ)
   20 CONTINUE
C---      AVERAGE BANDWIDTH
      AVDIST(JSEG)=SUM/ANSPL
C---      IF IPARA IS 1 ON INPUT, THEN ASSUME PARALLELISM
      IF(IPARA.EQ.1) GO TO 10
C
C---      SET TOLERANCE FOR EQUALITY OF CHORDS
      BOT=AVDIST(JSEG)*0.95
      TOP=AVDIST(JSEG)*1.06
C---      CHECK ALL CHORDS IN THIS BAND.
      DO 30 ISPL=1,NSPL
      JJ=NSEG*(ISPL-1)+JSEG
      IF(BOT.LE.DIST(JJ).AND.DIST(JJ).LE.TOP) GO TO 30
C---      PARALLELISM CHECK FAILED
      IPARA=0
      GO TO 90
   30 CONTINUE
C
   10 CONTINUE
C
C---      SURFACE WILL BE TREATED AS PARALLEL.
      IPARA=1
   90 CONTINUE
C---      IF SURFACE HAS ONLY A SINGLE CROSS BAND, USE NON-PARALLEL
      IF(NSEG.LE.1) IPARA=0
C
C---      SECOND PHASE, ASSIGN LENGTHS TO INCOMING AND OUTGOING
C---      VECTORS AT EACH POINT
C
      DO 100 ISPL=1,NSPL
      DO 100 IPT=1,NPTS
      IVEC=(IPT-1+(ISPL-1)*NPTS)*3
C---      A SEPARATE POINTER IS SET UP FOR THE ARRAY OF
C---      EXITING VECTORS VECB. THIS ARRAY IS OF DIMENSION
C---      NSEG X NSPL COMPARED WITH NPTS X NSPL FOR VECA AND
C---      POINTERS FOR VECB ARE SET UP SO THAT THE FIRST ENTRY
C---      IS OVERWRITTEN IN NPT PASSES THRU THIS LOOP
      IPTB=MAX0(IPT-1,1)
      IVECB=((IPTB-1)+(ISPL-1)*NSEG)*3
C---      COMPUTE REFERENCE CHORD FOR VECTOR LENGTHS
      J1=MAX0(IPT-1,1)
      J2=MIN0(IPT,NSEG)
C
      IF(IPARA.EQ.1) GO TO 110
C---      SHARED VECTOR CASE
      J1=J1+(ISPL-1)*NSEG
      J2=J2+(ISPL-1)*NSEG
C---      CHOOSE THE MINIMUM OF THE TWO SURROUNDING CHORDS
      ALEN1=DIST(J1)
      IF(ALEN1.GT.DIST(J2)) ALEN1=DIST(J2)
      ALEN2=ALEN1
      GO TO 120
C---      PARALLEL CASE, CHOOSE SEPARATE LENGTHS
  110 CONTINUE
      ALEN1=AVDIST(J2)
      ALEN2=AVDIST(J1)
  120 CONTINUE
C---      VECB IS SET TO THE LENGTH OF THE EXITING VECTOR
      DO 130 K=1,3
      KVEC=IVEC+K
      KVECB=IVECB+K
      VECB(KVECB)=ALEN2*VECA(KVEC)
      VECA(KVEC)=ALEN1*VECA(KVEC)
  130 CONTINUE
C
  100 CONTINUE
C
C---      END OF LOOP, CHANGE IPARA TO 1
      IF(IBUG.EQ.11) CALL BAD(-1,0,'IPAR',IPARA)
      IPARA=1
C---      CLEAN UP AVDIST ARRAY
      DO 200 I=1,NSEG
  200 AVDIST(I)=0.0
C
  999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0000646.V02   ***
*
C
      SUBROUTINE PARINT(PA,PD,PC,UDIR,RAD,KK,IRR)
C------ALRP SCULPTURED SURFACE ROUTINE--MARCH 1970 JKH
C------THIS SUBROUTINE IS MODULAR AND SHOULD NOT HAVE ANY COMMON BLOCKS
C------INPUT IS THREE SPACE POINTS PA,PB,PC
C------KCASE=1,2,3 INDICATES THAT OUTPUT OF CURVATURE AND TANGENT
C------ IS DESIRED AT POINT P= PA, PB OR PC RESPECTIVELY
C------OUTPUT SHOULD CONSIST OF A UNITIZED DIRECTION VECTOR UDIR AND A
C------RADIUS AT POINT P  OF A PARABOLA WHICH PASSES THROUGH PA,PB,PC
C------IRR NE 0 INDICATES A FAILURE IN INPUT
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION PA(3),PB(3),PC(3),UDIR(3),DX(3),DY(3),PD(3)
      IDIAG=2000
      CRIT=1.0D-10
      X1=DSQRT((PC(1)-PA(1))**2+(PC(2)-PA(2))**2+(PC(3)-PA(3))**2)
      IRR=IDIAG+1
      IF(X1.LT.CRIT) RETURN
      DO 10 I=1,3
   10 DX(I)=(PC(I)-PA(I))/X1
      KCASE=MOD(KK,10)
      IF(KK.GT.10) GO TO 100
      PB(1)=PD(1)
      PB(2)=PD(2)
      PB(3)=PD(3)
      GO TO 200
 100  WA=DSQRT(PD(1)*PD(1)+PD(2)*PD(2)+PD(3)*PD(3))
      IRR=IDIAG+3
      IF(WA.LT.CRIT) RETURN
      WB=(DX(1)*PD(1)+DX(2)*PD(2)+DX(3)*PD(3))/WA
      S=1.0/WA
      IF(WB.LT.0.0D0) S=-S
      PB(1)=S*PD(1)
      PB(2)=S*PD(2)
      PB(3)=S*PD(3)
      HDST=X1/2.0
      WB=DABS(WB)
      IF(WB.GT.CRIT) GO TO 130
      IRR=IDIAG+5
      RETURN
 130  PDST=HDST/WB
      DO 150 I=1,3
      PB(I)=(PDST*PB(I)-HDST*DX(I))/2.0+HDST*DX(I)
      IF(KK.LT.20) PB(I)=PA(I)+PB(I)
      IF(KK.GT.20) PB(I)=PC(I)-PB(I)
 150  CONTINUE
 200  CONTINUE
C------PROJECT THE THIRD POINT PB ONTO THE PA,PC AXIS
      X2=(PB(1)-PA(1))*DX(1)+(PB(2)-PA(2))*DX(2)+(PB(3)-PA(3))*DX(3)
      IRR=IDIAG+2
      IF(X2.LT.CRIT.OR.X2.GT.X1-CRIT) RETURN
      DO 20 I=1,3
   20 DY(I)=PB(I)-(PA(I)+X2*DX(I))
      Y2=DSQRT(DY(1)*DY(1)+DY(2)*DY(2)+DY(3)*DY(3))
      IF(Y2.LT.CRIT) GO TO 5000
      DO 30 I=1,3
   30 DY(I)=DY(I)/Y2
C------NOW DX,DY FORM A PLANAR RECTANGULAR COORDINATE SYSTEM IN WHICH
C------A PARABOLA Y=B*X+C*X**2 CAN BE DETERMINED SO THAT IT LIES ON
C------PA = (0,0), PC = (X1,0), PB = (X2,Y2)
      C=Y2/(X2*(X2 -X1))
      B=-C*X1
      X=0
      IF(KCASE.EQ.2) X=X2
      IF(KCASE.EQ.3) X=X1
      W=C+C
      SLOPE=B+W*X
      VELA=DSQRT(1+SLOPE*SLOPE)
      VELB=SLOPE/VELA
C-------RAD IS THE RADIUS OF THE CIRCLE THRU THREE POINTS
      RD2=1.0D+6
      IF(Y2.GT.1.0D-6) YCC=(X2**2+Y2**2-X1*X2)/(2*Y2)
      IF(Y2.GT.1.0D-6) RD2=DSQRT(YCC**2+X1*X1/4)
      RAD=RD2
C------UDIR IS CHOSEN TO POINT IN THE DIRECTION OF PA TO PB
      DO 40 I=1,3
   40 UDIR(I)=DX(I)/VELA+DY(I)*VELB
      IRR=0
      RETURN
C------STRAIGHT LINE CASE
 5000 RAD=1.0/CRIT
      DO 5010 I=1,3
 5010 UDIR(I)=DX(I)
      IRR=0
      RETURN
      END
**** SOURCE FILE : M0000648.V01   ***
*
      SUBROUTINE PARMPT(PA,PD,PB,B,PC,C,TA,TD,IRR)
C------ A COMPLETELY MODULAR SCULPTURED SURFACE ROUTINE  APRIL 1970 JKH
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION PA(3),PB(3),PC(3),PD(3),DF(3),TA(3),TD(3)
C------ INPUT CONSISTS OF TWO END POINTS PA,PD AND TWO INTERIOR POINTS
C------PB WITH PARAMETER VALUE B AND PC WITH PARAMETER VALUE C THRU
C------WHICH A CUBIC CURVE MUST PASS.
C------OUTPUT CONSISTS OF TWO COONS TANGENT VECTORS TA AND TD WHICH
C-------DEFINE THE DESIRED CURVE.  A CASE OF TROUBLE IS THAT THE
C------PARAMETER VALUES B AND C ARE NEARLY EQUAL
      IDIAG=23000
      BSQ=B*B
      CSQ=C*C
      DISC = B * C * (B - 1) * (C - 1) * (B - C)
      IRR=IDIAG+1
      IF(DABS(DISC).LT.1.0D-12) RETURN
C------SET UP THE LINEAR EQUATION A * TA() + B * TB() = C()
      A1 = B * (1 - B)**2
      A2 = C * (1 - C)**2
      B1 = BSQ*(-1 + B)
      B2 = CSQ*(-1 + C)
      DO 20 I=1,3
   20 DF(I)=PD(I)-PA(I)
C------DETERMINE EACH COMPONENT OF TA() AND TD() BY SOLVING TWO EQUNS
C------IN TWO UNKNOWNS
      DO 10 I=1,3
      C1 = PB(I) - ( PA(I) + DF(I)*BSQ*(3 - 2*B) )
      C2 = PC(I) - ( PA(I) + DF(I)*CSQ*(3 - 2*C) )
      TA(I)=(C1*B2 -C2*B1)/DISC
      TD(I)=(A1*C2 - A2*C1)/DISC
   10 CONTINUE
      IRR=0
      RETURN
      END
**** SOURCE FILE : M0004286.V02   ***
*
C
      SUBROUTINE PNTSON(BIN,OUT,KTYP,KTWS,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION OUT(49),DUV(4),NEXCH(16),IP(4),JP(4)
      DIMENSION BIN( 3, 16 ), BOU( 3, 16 ), KTYP( 5 )
      DIMENSION U( 4 ), V( 4 ), DUM( 3 ), DUM1( 3 ), KTWS( 5 )
      DIMENSION TEMP(4,3)
      DIMENSION  DUM2(3)
      DATA NEXCH/1,2,3,4,13,14,15,16,5,9,8,12,6,7,10,11/
      DATA IP,JP/1,5,1,4,4,8,5,8/
C------INPUT SIXTEEN POINTS ON A PATCH STORED IN THE ARRAY BIN.
C------OUTPUT  SIXTEEN COONS VECTORS OF A COONS PATCH WHICH PASSES
C------ THRU THE INPUT POINTS
C------ IN ADDITION, KTYP() CONTAINS INFORMATION ON SURFACE TYPE AND
C------KTYP=1=NULL CURVE, =2=STRAIGHT SEG, =3=3 PT CURVE,
C------KTYP=4= 4 PT CURVE, =10=ERROR ON CURVE
C------ SOURCES OF TROUBLE IN THE INPUT
C------ IRR .NE. 0 MEANS THE PROCESSING WAS UNSUCESSFUL
C------INITIALIZE VARIOUS VALUES
      IDIAG = 5390
      IRR = 0
C------ BEGIN BY ALTERING THE ORDER OF INPUT FROM SSX2 FORMAT TO THE
C------ OLD SSX1 FORMAT( THIS IS DONE TO SAVE REWORKING PNTSON)
      DO 5 J=1,16
      N=NEXCH(J)
      DO 5 I=1,3
      BOU(I,J)=BIN(I,N)
    5 CONTINUE
      DO 6 J=1,16
      DO 6 I=1,3
    6 BIN(I,J)=BOU(I,J)
      DO 1  I = 1, 5
      KTWS(I) = 0
    1 KTYP(I) = 0
      DO 2 I  = 1, 16
      DO 2 J = 1, 3
      KTYP(3)=2
      KTYP(4)=2
    2 BOU(J,I) = 0.
      DO 3 J = 1, 3
      BOU(J,1) = BIN(J,1)
      BOU(J,2) = BIN(J,4)
      BOU(J,5) = BIN(J,5)
    3 BOU(J,6) = BIN(J,8)
      CRIT = 0.00001
C------NEXT FIT THE FIRST TWO BOUNDARIES
      CALL CURFIT( BIN(1,1), BIN(1,2), BIN(1,3), BIN(1,4),
     1             BOU(1,3), BOU(1,4), KTYP(1), IRR )
      IF ( IRR .NE. 0 ) KTYP(1) = 10
      CALL CURFIT( BIN(1,5),BIN(1,6),BIN(1,7),BIN(1,8),
     1             BOU(1,7),BOU(1,8), KTYP(2), IRR )
      IF ( IRR .NE. 0 ) KTYP(2) = 10
C------NEXT, CHECK FOR TOTAL EQUALITY AMONG THE EIGHT CENTRAL VECTORS
C------ SUCH EQUALITY IMPLIES THE SURFACE IS RULED
      DO 10 I = 9, 15
      N = I + 1
      DO 10 J = N, 16
      DO 20 K = 1, 3
      W  =  BIN( K, J ) - BIN( K, I )
      IF ( DABS(W) .GT. CRIT ) GO TO 300
   20 CONTINUE
   10 CONTINUE
C------ ALL EQUALITY CHECKS HAVE BEEN MET -- A RULED SURFACE FOLLOWS
C------DETERMINE THE REMAINING TANGENTS AND TWISTS
      KTYP(5) = 1
      DO 210 J = 1, 3
C------SET UP THE CROSS TANGENTS FIRST
      BOU(J,9) = BIN(J,5) - BIN(J,1)
      BOU(J,13) = BOU(J,9)
      BOU(J,10) = BIN(J,8) - BIN(J,4)
      BOU(J,14) = BOU(J,10)
C------NOW SET UP TWIST VECTORS
      BOU(J,11) = BOU(J,7) - BOU(J,3)
      BOU(J,15) = BOU(J,11)
      BOU(J,12) = BOU(J,8) - BOU(J,4)
      BOU(J,16) = BOU(J,12)
  210 CONTINUE
C------FINALLY RESET IRR
      DO 220 I = 1, 2
  220 IF ( KTYP(I) .EQ. 10 ) IRR = IDIAG + 1
      GO TO 999
C-----------   END OF RULED SURFACE PROCESSING   -------------
  300 CONTINUE
C------NEXT COMPARE FOR TWO EQUAL CENTER POINTS
      NUMTWS = 4
      DO 310 I = 13, 15
      N = I + 1
      DO 310 J = N , 16
      DO 320 K = 1 , 3
      W  =  BIN(K,J) - BIN(K,I)
      IF ( DABS(W) .GT. CRIT ) GO TO 310
  320 CONTINUE
      NUMTWS = 0
  310 CONTINUE
C------NUMTWS=0 MEANS ZERO TWISTS, .NE.0 MEANS NON ZERO TWISTS
C------NEXT CALL FOR A FIT OF THE REMAINING TWO BOUNDARIES
      CALL CURFIT( BIN(1,1),BIN(1,9),BIN(1,10),BIN(1,5),
     1             BOU(1,9),BOU(1,13), KTYP(3), IRR)
      IF ( IRR .NE. 0 ) KTYP(3) = 10
      CALL CURFIT( BIN(1,4),BIN(1,11),BIN(1,12),BIN(1,8),
     1             BOU(1,10),BOU(1,14), KTYP(4), IRR )
      IF ( IRR .NE. 0 ) KTYP(4) = 10
C------IF TWISTS HAVE YET TO BE DETERMINED GO TO 500
      IF ( NUMTWS .NE. 0 ) GO TO 500
C------FINISH THE ZERO TWIST CASE BY RESETTING IRR
      DO 410 I = 1, 4
  410 IF ( KTYP(I) .EQ. 10 ) IRR = IDIAG + 2
      KTYP(5) = 2
      GO TO 999
C------THE DETERMINATION OF FOUR TWISTS FOLLOWS
  500 CONTINUE
C------FIRST PROJECT EACH OF THE POINTS BIN(,I), I = 13,14,15,16
C------IN SUCCESSION ONTO THE ZERO TWIST PATCH
      ONE = 1.0
      DO 510 I = 13, 16
      DO 550 LL=1,4
      IS=IP(LL)
      IE=JP(LL)
      BXS=BIN(1,IS)
      BYS=BIN(2,IS)
      BZS=BIN(3,IS)
      DX=BIN(1,IE)-BXS
      DY=BIN(2,IE)-BYS
      DZ=BIN(3,IE)-BZS
      PX=BIN(1,I)-BXS
      PY=BIN(2,I)-BYS
      PZ=BIN(3,I)-BZS
      DP=DX*DX+DY*DY+DZ*DZ+1.0D-30
      DUV(LL)=(PX*DX+PY*DY+PZ*DZ)/DP
  550 CONTINUE
      U(I-12)=(DUV(1)+DUV(2))/2.0
      V(I-12)=(DUV(3)+DUV(4))/2.0
  510 CONTINUE
C------NOW RESET IRR IF TROUBLE HAS OCCURRED AND RETURN
C------KTWS HERE ALWAYS ZERO !!!!!!!!, WHY ????????????
      DO 520 I = 1, 4
  520 IF ( KTWS(I) .NE. 0 ) IRR = IDIAG + 3
      IF(IRR.NE.0) RETURN
C------FINALLY COMPUTE TWISTS BASED ON PARAMETER VALUES WHICH HAVE
C------ BEEN COMPUTED
      DO 530 I = 1, 4
      DO 530 K = 1, 3
      N = 12 + I
  530 TEMP(I,K) = BIN(K,N)
C     WRITE(6,571)(U(M),M=1,4),(V(MM),MM=1,4),TEMP
C 571 FORMAT(10X,4F15.4,/)
      CALL COMPTW ( BOU, TEMP, U, V, IRR )
      KTYP(5) = 3
  999 CONTINUE
      DO 560 I=1,3
      DO 560 K=1,4
      DO 560 J=1,4
      IN=(I-1)*16+(K-1)*4+J
      OUT(IN)=BOU(I,4*K-4+J)
  560 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0004147.V02   ***
*
      SUBROUTINE RATCON(X1,XM,YM,XI,YI,CX)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---  THIS SUBROUTINE ACCEPTS AS INPUT COORDINATES OF THREE
C---  POINTS IN THE X,Y-PLANE OF A LOCAL SYSTEM OF COORDINATES.
C---  THE OUTPUT CX IS THE CANONICAL FORM IN THE SAME COORDINATE
C---  SYSTEM OF A CONIC ARC WITH ENDPOINTS (0,0) AND (X1,0),
C---  WHOSE END TANGENTS INTERSECT AT (XI,YI), AND WHICH ALSO
C---  INTERPOLATES THE POINT (XM,YM). THE ARC IS PARAMETRISED SO
C---  THAT THE MAGNITUDES OF ITS END TANGENTS ARE EQUAL.
C---  REVISED AND CORRECTED, CRANFIELD 1981, M.J.P.
      DIMENSION CX(16)
      RATIO=DSQRT((XI**2+YI**2)/((XI-X1)**2+YI**2))
      DET=X1*YM
      S0=2*((XI-XM)*YM-(XM-X1)*(YI-YM))/DET
      S1=2*(XM*(YI-YM)-(XI-XM)*YM)/DET
      W0=DSQRT(S0*S1*RATIO)
      W1=W0/RATIO
C---  IN THE STANDARD RATIONAL QUADRATIC FORMULA FOR A CONIC ARC
C---  THE WEIGHT ASSOCIATED WITH THE TANGENT INTERSECTION POINT
C---  HAS BEEN ARBITRARILY TAKEN AS 1.0. W0 AND W1 ARE THE WEIGHTS
C---  ASSOCIATED WITH THE END POINTS.  WE NEXT SET UP THE CANONICAL
C---  MATRIX FOR THE ARC, CONTAINING THE TWO PROJECTIVE END POINTS
C---  AND END TANGENTS.
      CX(1)=0.0
      CX(2)=W1*X1
      CX(3)=2*XI
      CX(4)=2*(CX(2)-XI)
      CX(5)=0.0
      CX(6)=0.0
      CX(7)=2*YI
      CX(8)=-2*YI
      DO 10 J=9,12
   10 CX(J)=0
C---  ALL Z-COORDINATES ARE ZERO IN LOCAL COORDINATE SYSTEM
      CX(13)=W0
      CX(14)=W1
      CX(15)=2*(1-W0)
      CX(16)=2*(W1-1)
      RETURN
      END
**** SOURCE FILE : M0004289.W01   ***
*
      SUBROUTINE REVOLV(SC,PA,PB,DA,DB,ICCLW,IRR,S)
C***** INSERT 2510 UND 4310 : REVOLV FUER 360 GRAD WINKEL
C--- SCULPTURED SURFACE ROUTINE TO GENERATE A SCULPTURED SURFACE WHICH
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C--- REPRESENTS  A SURFACE FORM BY REVOLVING THE SYNTHETIC CURVE SC
C--- AROUND AN AXIS THRU PA AND PB FROM ANGLE A TO B.  THE SSURF IS
C--- PACKED INTO THE S ARRAY WITHOUT A TOPOLOGY TABLE( CALL TOPGEN)
C--- LATER)  IF A PROBLEM OCCURS IRR WILL BE NONZERO ON RETURN
C--- ICCLW SHOULD BE 1 IF ANGLE DB IS CLOCKWISE ROTATED FROM DB AND -1
C--- OTHERWISE
C--- SECONDARILY, A CYLINDER WITH ARBITRARY AXIS CAN BE GENERATED THRU
C--- THE S CURVE SC,  IN ORDER TO ACHIEVE THIS THE INPUT IS AS FOLLOWS
C---  PA AND PB ARE TWO POINTS WHICH DESCRIBE THE AXIS VECTOR OF THE
C--- CYLINDER. SET DA=0., DB=90. AND ICCLW=0
      DIMENSION S(*),SC(4,6,*),PA(*),PB(*)
      DIMENSION P(4),T(4,4),BT(4,4),CC(4,4),BM(4,4,4),BU(4,4,4)
      DIMENSION CX(4,6,4)
C
      INCLUDE (XUNITS)    
C
      DATA Z,U,SMAL/0.0,1.0,0.0001/
      DATA PI,CDR/3.141592654,.01745329252/
      TPI=2.*PI
C---  PROCESS ANGLES FIRST
      A=DA*CDR
      B=DB*CDR
      C=DABS(A-B)-TPI
      IF(ICCLW.EQ.0) GO TO 6
C--- NORMALIZE THE ANGLES BETWEEN ZERO AND TPI
      A=DMOD(A,TPI)
      B=DMOD(B,TPI)
      IF(DABS(A).LT.SMAL) A=Z
      IF(DABS(B).LT.SMAL) B=Z
      IF(A.LT.Z) A=A+TPI
      IF(B.LT.Z) B=B+TPI
C---  ADJUST THE NUMERICAL VALUE OF B IF NECESSARY
      IF(ICCLW*(B-A).GE.-SMAL) B=B-ICCLW*TPI
    6 CONTINUE
      DIF=B-A
      IF(DABS(C).LT.SMAL)DIF=-ICCLW*TPI
      NSPL=3.*DABS(DIF)/TPI+1.9999
C*** NUMBER OF SPLINES MUST BE AT LEAST TWO
      IRR=2
      IF(NSPL.LT.2) GO TO 998
C--- DIF BECOMES THE ANGULAR SPAN OF EACH SECTOR OF REVOLUTION
      DIF=DIF/(NSPL-1.0)
C--- THE SURFACE TYPE IS CALLED A MESH (USUALLY)
      S(5)=2.
C--- IF THE SURFACE IS CLOSED IT IS CALLED A NON-MESH
      WW=DMOD(B-A,TPI)
      IF(DABS(WW).GT.SMAL) GO TO 10
      S(5)=1.
   10 CONTINUE
      S(6)=5.
C---  DETERMINE CRITICAL DATA FROM THE SCURV AND SET UP THE HEADER OF S
      NHD=SC(2,1,1)
      NCS=SC(4,1,1)+1.
      NLO=NHD+1
      NHI=NHD+NCS-1
      NPCH=(NCS-1)*(NSPL-1)
      S(2)=NPCH*64.
      S(3)=4*NPCH
      S(4)=NPCH
      S(7)=1.0
      S(8)=10+NPCH*(6+64+4)
      S(9)=NSPL
      S(10)=NCS
C--- FILL IN THE FLAG DATA FOR PATCHES
      NSM=NSPL-1
      NCM=NCS-1
      DO 20 J=1,NSM
      DO 20 I=1,NCM
      KP=I+(J-1)*NCM
      IS=(KP-1)*6+11
      IS3=IS+3
      DO 30 L=IS,IS3
   30 S(L)=4.0
C--- COMPUTE THE LOCATION OF PATCH DATA FOR PATCH KP
      S(IS+4)=11+NPCH*6+(KP-1)*64
   20 CONTINUE
C---   DETERMINE A LOCAL COORDINATE SYSTEM
      DO 100 I=1,3
  100 BT(I,1)=PB(I)-PA(I)
C***   PA AND PB SHOULD NOT BE EQUAL
      IRR=4
      CALL SNORM(BT(1,1),BT(1,1),IR)
      IF (IR.NE.0) GO TO 998
      IF(ICCLW.NE.0) GO TO 70
C---  FOR A CYLINDER SKIP THE COORDINATE TRANSFORMATION BUSINESS
C--- SET BT AND T EQUAL TO THE IDENTITY MATRIX
C---  FOR A CYLINDER, LOAD THE AXIS INTO THE P ARRAY
      DO 60 JJ=1,3
   60 P(JJ)=BT(JJ,1)
      DO 50 K=1,4
      DO 50 J=1,4
      BT(J,K)=Z
      IF(J.EQ.K) BT(J,K)=U
      T(J,K)=BT(J,K)
   50 CONTINUE
      GO TO 150
   70 CONTINUE
C--- THE ORIGIN IS AT PA, X- AXIS IS PA,PB
      DO 110 L=1,NCS
      KSEG=MIN0(L+NHD,NHI)
      V=Z
      IF(L.EQ.NCS) V=U
      CALL CNCURV(V,SC(1,1,KSEG),P,0)
C---  PROJECT THE END POINT OF THE CURVE ONTO PA,VX
      DO 120 LL=1,3
  120 P(LL)=P(LL)-PA(LL)
      CALL CROSS(BT(1,1),P,BT(1,3))
      CALL SNORM(BT(1,3),BT(1,3),IR)
      IF(IR.NE.0) GO TO 110
      CALL CROSS(BT(1,3),BT(1,1),BT(1,2))
      GO TO 130
  110 CONTINUE
C***  ALL THE END POINTS OF THE CURVE LAY ON THE AXIS
      IRR=5
      GO TO 998
  130 CONTINUE
C---  SET UP THE TRANSFORMATION TO MOVE THIS COORDINATE SYSTEM INTO
C---  STANDARD POSITION
      DO 140 I=1,3
      T(1,I)=BT(I,1)
      T(2,I)=BT(I,2)
      T(3,I)=BT(I,3)
      T(I,4)=Z
      BT(I,4)=Z
      BT(4,I)=-(PA(1)*BT(1,I)+PA(2)*BT(2,I)+PA(3)*BT(3,I))
  140 CONTINUE
      DO 145 I=1,3
  145 T(4,I)=-(BT(4,1)*T(1,I)+BT(4,2)*T(2,I)+BT(4,3)*T(3,I))
      T(4,4)=U
      BT(4,4)=U
  150 CONTINUE
C--- GENERATE PATCHES FOR EACH SECTOR AND EACH CUBIC SPLINE SEGMENT
C---  LOAD THE PATCH VALUES ONE-BY-ONE INTO THE S ARRAY
      DO 200 II=1,NSM
C--- SKIP TO SPECIAL AREA FOR A CYLINDER
      IF(ICCLW.EQ.0) GO TO 250
C---   DETERMINE ANGLES FOR THIS SECTOR
      A1=A+(II-1)*DIF
      A2=A+II*DIF
C---  DETERMINE THREE POINTS ON THE BOUNDED UNIT CIRCULAR ARC
      CX(2,1,1)=1.
      CX(3,1,1)=3.
      CX(4,1,1)=3.
      DO 220 L=1,4
      DO 220 J=2,6
      DO 220 K=1,4
  220 CX(K,J,L)=Z
      DO 210 J=1,3
      AX=(J-1.0)/2.0*(A2-A1)+A1
      CX(1,5,J+1)=1.0
      CX(1,1,J+1)=U
      CX(2,1,J+1)=DCOS(AX)
      CX(3,1,J+1)=DSIN(AX)
  210 CX(4,1,J+1)=U
C***   IF SCURV DEFINTION FAILS, THEN QUIT
      IRR=6
      CALL SCURV(CX,IR)
      IF(IR.NE.0) GO TO 998
C
      NLOO=CX(2,1,1)+1
C---  BM NOW CONTAINS A COONS CANON FORM OF THE UNIT CIRCLE REQUIRED
C---  TO DRIVE A SURFACE OF REVOLUTION -- MOVE ITS TRANSPOSE INTO CC
      DO 230 L=1,4
      DO 230 J=1,4
  230 CC(L,J)=CX(J,L,NLOO)
      GO TO 290
C--- SPECIAL PROCESSING FOR A CYLINDRICAL SURFACE
C--- THE DRIVING CURVE CC SHOULD BE A STRAIGHT LINE
  250 CONTINUE
C--- FOR A CYLINDER,THE DIRECTRIX SHOULD EXTEND 10 UNITS ON EACH SIDE
      DO 260 I=1,3
      CC(I,1)=-P(I)*SSEXT
      CC(I,2)=P(I)*SSEXT
      CC(I,3)=CC(I,2)-CC(I,1)
  260 CC(I,4)=CC(I,3)
      CC(4,1)=U
      CC(4,2)=U
      CC(4,3)=Z
      CC(4,4)=Z
  290 CONTINUE
C-- CC IS A TRANSPOSED COONS CURVE FOR A CIRCLE OR STRT LINE
C---  SETUP THE FOUR LAYER MATRIX TO SWEEP THE CURVE ACROSS THE SECTOR
      DO 310 J=1,4
      DO 310 K=1,4
      DO 310 L=1,4
  310 BM(J,K,L)=Z
      IF(ICCLW.EQ.0) GO TO 311
      BM(1,1,1)=U
      BM(2,2,2)=U
      BM(3,3,2)=-U
      BM(2,3,3)=U
      BM(3,2,3)=U
      BM(4,4,4)=U
      GO TO 312
C--- SET UP BM TO GENERATE A TRANSLATION IN SPACE FOR A CYLINDER
  311 CONTINUE
      BM(1,4,1)=U
      BM(4,1,1)=U
      BM(2,4,2)=U
      BM(4,2,2)=U
      BM(3,4,3)=U
      BM(4,3,3)=U
      BM(4,4,4)=U
  312 CONTINUE
C---  BM=BM*CC
      DO 320 KZ=1,4
      K=KZ
      CALL SMMULT(4,4,4,1,BM(1,1,K),CC,BU)
      CALL SMMULT(4,4,4,2,BT,BM(1,1,K),BU)
  320 CONTINUE
C---  NOW SWEEP EACH CUBIC SEGMENT OF SC THRU THIS SECTOR
      DO 400 I=1,NCM
      NCB=SC(2,1,1)+I
      DO 410 KZ=1,4
      K=KZ
      CALL SMMULT(4,4,4,3,SC(1,1,NCB),BM(1,1,K),BU(1,1,K))
  410 CONTINUE
C---  BU MUST NOW BE BACK TRANSFORMED TO BECOME A COONS MATRIX
      DO 420 J=1,4
      DO 420 K=1,4
      DO 430 L=1,4
  430 P(L)=BU(J,K,L)
      CALL SMMULT(1,4,4,1,P, T,BU)
      DO 440 L=1,4
  440 BU(J,K,L)=P(L)
  420 CONTINUE
C---  NORMALIZE ALL MATRICES AFTER THE FIRST TO HAVE THE SAME W COORD
      IF(II+I.NE.2) GO TO 460
      WSAVE=BU(1,1,4)
      GO TO 480
C------ NORMALIZE THE MATRIX BU WITH WSAVE
  460 CONTINUE
      FAC=WSAVE/BU(1,1,4)
      DO 470 L=1,4
      DO 470 K=1,4
      DO 470 J=1,4
  470 BU(L,K,J)=FAC*BU(L,K,J)
  480 CONTINUE
C---  BU SHOULD NOW BE THE COONS MATRIX, PLACE IT INTO THE S ARRAY
      ILOC=10+NPCH*6+(I+(II-1)*NCM-1)*64.
      DO 450 J=1,4
      DO 450 K=1,4
      DO 450 L=1,4
      ILOC=ILOC+1
      S(ILOC)=BU(L,K,J)
  450 CONTINUE
  400 CONTINUE
  200 CONTINUE
      IRR=0
  998 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0000656.V04   ***
*
      SUBROUTINE SCDUMP(IN,SCAN)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION SCAN(*)
      CALL BAD(-1,0,' ',0)
      CALL BAD(-1,0,'CHK=',IN)
      NTOT=SCAN(12)
      IF(NTOT.EQ.0) NTOT=(SCAN(2)+SCAN(4))*24.
      IK=-3
      DO 10 L=1,NTOT,4
      IF(MOD(L,24).EQ.1) CALL BAD(-1,0,' ',0)
      IK=IK+4
      CALL BAD(1,0,'KCT ',IK)
      CALL BAD(-4,1,'SCAN',SCAN(L))
   10 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0004124.V05   ***
*
      SUBROUTINE SCPICT(SC,SCNAME,MODE)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C--- INPUT- A SYNTHETIC CURVE S WITH NAME SCNAME
C--- OUTPUT - A PRINTED ANALYSIS AND DISPLAY OF THE CURVE S ON VLFILE
      INCLUDE (DARRAY)    
      CHARACTER*120 ARRAY
      DIMENSION SC(4,6,*)
      DIMENSION CV(16),TT(3)
      INTEGER VLFILE
      CHARACTER*6 TYPFLO(2),ARCTYP(5)
      CHARACTER*16 SCNAME
      DATA ZERO,ONE,SMAL/0.0D0,1.0D0,1.0D-9/
C---     ALPHA EQUIVALENT OF SEGMENT FLOW TYPE
      DATA TYPFLO/'PARAM ','LENGTH'/
      DATA ARCTYP/'ARC   ','ANGLE ','CHORD ','PARAM ','TRASH '/
      DATA MXARC/4/,MXFLO/2/
C
      DATA ARRAY/   '0   PARAM     XCOORD    YCOORD    ZCOORD    UTAN-I
     C   UTAN-J    UTAN-K    UNORMI    UNORMJ    UNORMK    CURVATURE RAD
     CIUS'/
C
      CALL CFORM('1 VERIFICATION LISTING FOR SCURV',DARRAY,1,32)
      CALL CFORM(SCNAME,DARRAY,36,16)
      CALL CPRIN1(DARRAY)
      CALL CPRIN1(DARRAY)
C---     PRINT HEADER TABLE VALUES FOR SYNTHETIC CURVE
      CALL CFORM('0 INTERIM SCURV HEADER TABLE',DARRAY,1,28)
      IF(MODE.GT.0) CALL CFORM('  FINAL ',DARRAY,3,8)
      CALL CPRIN1(DARRAY)
      CALL FCONV(SC(1,1,1),DARRAY,4,9,3)
      CALL CFORM('= 1.APT FILE RECORD NUMBER',DARRAY,15,26)
      CALL CPRIN1(DARRAY)
      CALL FCONV(SC(2,1,1),DARRAY,4,9,3)
      CALL CFORM('= 2.NUMBER OF BLOCKS FOR HEADER',DARRAY,15,31)
      CALL CPRIN1(DARRAY)
      CALL FCONV(SC(3,1,1),DARRAY,4,9,3)
      CALL CFORM('= 3.1=COMBIN,2=SPLINE,3=CURSEG',DARRAY,15,30)
      CALL CPRIN1(DARRAY)
      CALL FCONV(SC(4,1,1),DARRAY,4,9,3)
      CALL CFORM('= 4.NUMBER OF CUBIC ARCS',DARRAY,15,24)
      CALL CPRIN1(DARRAY)
C---     SKIP REST OF HEADER FOR MODE 0
      IF(MODE.LT.1) GO TO 11
C
      CALL FCONV(SC(1,2,1),DARRAY,4,9,3)
      CALL CFORM('= 5.LOCATION OF FIRST CUBIC ARC',DARRAY,15,31)
      CALL CPRIN1(DARRAY)
      CALL FCONV(SC(2,2,1),DARRAY,4,9,3)
      CALL CFORM('= 6.NUMBER OF ROWS FOR FLOW DATA',DARRAY,15,32)
      CALL CPRIN1(DARRAY)
      CALL FCONV(SC(3,2,1),DARRAY,4,9,3)
      CALL CFORM('= 7.LOCATION OF FIRST FLOW ROW',DARRAY,15,30)
      CALL CPRIN1(DARRAY)
      CALL FCONV(SC(4,2,1),DARRAY,4,9,3)
      CALL CFORM('= 8.NUMBER OF ROWS FOR SEGMENTS',DARRAY,15,31)
      CALL CPRIN1(DARRAY)
      CALL FCONV(SC(1,3,1),DARRAY,4,9,3)
      CALL CFORM('= 9.LOCATION OF FIRST ROW OF SEGMENTS',DARRAY,15,37)
      CALL CPRIN1(DARRAY)
      CALL FCONV(SC(2,3,1),DARRAY,4,9,3)
      CALL CFORM('=10.TOTAL NUMBER OF FLOW SPLINES',DARRAY,15,32)
      CALL CPRIN1(DARRAY)
      CALL FCONV(SC(3,3,1),DARRAY,4,9,3)
      CALL CFORM('=11.LOCATION OF FIRST FLOW SPLINE',DARRAY,15,33)
      CALL CPRIN1(DARRAY)
      CALL FCONV(SC(4,3,1),DARRAY,4,9,3)
      CALL CFORM('=12.TOTAL SIZE OF STRUCTURE',DARRAY,15,27)
      CALL CPRIN1(DARRAY)
      CALL FCONV(SC(1,4,1),DARRAY,4,9,3)
      CALL CFORM('=13.FIRST LOCATION OF STRUCTURE',DARRAY,15,31)
      CALL CPRIN1(DARRAY)
   11 CONTINUE
C
C---     SET UP POINTERS FOR USING CURVE STRUCTURE
      D=0.25
      N=1.0/D+1.1
      NHD=SC(2,1,1)
      NLO=NHD+1
      NSEGST=SC(4,1,1)
      NHI=NLO+NSEGST-1
C
      ICT=0
   13 CONTINUE
      IF(MODE.LT.2) GO TO 101
      CALL VORSCH (12,DARRAY)
      IF(ICT.EQ.0) CALL CFORM('0CURVE SHAPE- DISPLAYED BY CUBIC ARCS',
     X DARRAY,1,37)
      IF(ICT.EQ.1) CALL CFORM('0FLOW RATE ACROSS CURVE BY SEGMENTS',
     X DARRAY,1,35)
      CALL CPRIN1(DARRAY)
      DARRAY=ARRAY
      CALL CPRIN1(DARRAY)
      CALL CFORM(' ',DARRAY,1,1)
      CALL CPRIN1(DARRAY)
C
      DO 30 I=NLO,NHI
      KK=I-NHD
      IF(ICT.GT.0) KK=I-NLO+1
      CALL VORSCH ( 6, ARRAY)
      IF (ICT.EQ.1)CALL CFORM('0SEGMENT NUMBER',DARRAY,1,15)
      IF (ICT.EQ.0)CALL CFORM('0    ARC NUMBER',DARRAY,1,15)
      CALL ICONV(KK,DARRAY,17,6)
      CALL CPRIN1(DARRAY)
C
      DO 50 L=1,N
      U=(L-ONE)*D
      IF(ICT.EQ.0) CALL CNCURV(U,SC(1,1,I),CV,1)
      IF(ICT.EQ.1) CALL CURFLO(U,SC,CV,1,KK)
      CALL CROSS(CV(5),CV(9),TT)
      X=DSQRT(TT(1)**2+TT(2)**2+TT(3)**2)
      DD=DSQRT(CV(5)**2+CV(6)**2+CV(7)**2)+SMAL
      R=X/DD**3
      RR=ONE/(R+SMAL)
      CALL SNORM(TT,TT,II)
      K=1
      CALL FCONV(U,DARRAY,K,10,4)
      K=K+10
      DO 41 LL=1,3
      CALL FCONV(CV(LL),DARRAY,K,9,4)
   41 K=K+10
      DO 42 LL=13,15
      CALL FCONV(CV(LL),DARRAY,K,9,4)
   42 K=K+10
      DO 43 LL=1,3
      CALL FCONV(TT(LL),DARRAY,K,9,4)
   43 K=K+10
      CALL FCONV(R,DARRAY,K,9,4)
      K=K+10
      CALL FCONV(RR,DARRAY,K,9,3)
      CALL CPRIN1(DARRAY)
   50 CONTINUE
C
      IF(SC(2,2,1).LT.SMAL) GO TO 55
C---     LIST SUMMARY FLOW INFORMATION FOR THIS ARC
      IF(ICT.NE.0) GO TO 55
C
      LOCARC=SC(3,2,1)+4*(KK-1)
      K=(LOCARC-1)/24+1
      J=LOCARC-(K-1)*24
      J=(J-1)/4+1
      ITYPE=SC(3,J,K)
      IF(ITYPE.LT.1.OR.ITYPE.GT.MXARC) ITYPE=MXARC+1
      TOL=SC(3,J,K)-ITYPE
      NUM=SC(2,J,K)
      CALL CFORM('FLOW TYPE=',DARRAY,5,10)
      CALL CFORM(ARCTYP(ITYPE),DARRAY,17,6)
      CALL CFORM('TOLERANCE FACTOR=',DARRAY,25,17)
      CALL FCONV(TOL,DARRAY,44,7,4)
      CALL CFORM(ARCTYP(ITYPE),DARRAY,54,6)
      CALL CFORM('LENGTH=',DARRAY,61,7)
      CALL FCONV(SC(4,J,K),DARRAY,70,9,4)
      CALL CFORM('NUMBER OF FLOW SPLINES=',DARRAY,81,23)
      CALL ICONV(NUM,DARRAY,106,4)
      CALL CPRIN1(DARRAY)
C
   55 CONTINUE
      IF(ICT.LT.1) GO TO 30
C---     PRINT SPECIAL SUMMARY INFORMATION FOR A FLOW SEGMENT
      LOCSEG=SC(1,3,1)+(KK-1)*4
      JA=(LOCSEG-1)/24+1
      L=LOCSEG-(JA-1)*24
      IA=(L-1)/4+1
C---     SUMMARY INFORMATION FOR SEGMENT IS IN SC(1,IA,JA)
      CALL CFORM(' FIRST POINT=',DARRAY,4,13)
      CALL FCONV(SC(1,IA,JA),DARRAY,18,6,1)
      CALL CFORM(' LAST POINT=',DARRAY,25,12)
      DUM=SC(1,IA,JA)+SC(2,IA,JA)
      CALL FCONV(DUM,DARRAY,37,6,1)
      CALL CFORM(' TYPE OF FLOW=',DARRAY,44,14)
      II=SC(3,IA,JA)
      CALL CFORM(TYPFLO(II),DARRAY,59,6)
      CALL CFORM(' TOTAL SPAN=',DARRAY,66,12)
      CALL FCONV(SC(4,IA,JA),DARRAY,79,13,4)
      CALL CPRIN1(DARRAY)
C
   30 CONTINUE
C
      IF(SC(4,2,1).LT.SMAL) GO TO 101
      IF(ICT.GE.1) GO TO 101
C---     FOR A CURVE WITH FLOW RATE, REDISPLAY ACCORDING TO FLOW.
      NLO=1
      NHI=SC(4,2,1)
      ICT=1
      GO TO 13
C
  101 IF (MODE.EQ.0) GOTO 102
C---     SUPRESS CANON FORM PRINTING IF MODE IS LT 3
      IF(MODE.LT.3)  GO TO 111
C---     MODIFY THE EFFECTIVE SIZE FOR A FLOW CURVE
      NHI=SC(4,3,1)/24.+1.
      NMX=SC(4,3,1)
  102 NCT=0
      IF(ICT.EQ.0) NHI=SC(4,1,1)+SC(2,1,1)
      NMX=5000
      CALL CFORM('0',DARRAY,1,1)
      CALL CPRIN1(DARRAY)
      CALL VORSCH ( 3,DARRAY)
      CALL CFORM(' CANONICAL ARRAY FOLLOWS',DARRAY,1,24)
      CALL CPRIN1(DARRAY)
      J2=6
      DO 110 I=1,NHI
      CALL VORSCH ( 3,DARRAY)
      CALL CFORM('  INDEX=',DARRAY,1,8)
      II=(I-1)*24+1
      CALL ICONV(II,DARRAY,9,4)
      JB=0
 120  JA=JB+1
      JB=JA+2
      K=14
      IF(JA.GT.J2) GO TO 110
      IF(JB.GT.J2) JB=J2
      DO 141 J1=JA,JB
      K=K+3
      DO 141 L=1,4
      NCT=NCT+1
      IF(NCT.GT.NMX) GO TO 141
      CALL FCONV(SC(L,J1,I),DARRAY,K,8,3)
      K=K+8
  141 CONTINUE
      CALL CPRIN1(DARRAY)
      GO TO 120
  110 CONTINUE
  111 CONTINUE
      IF(MODE.LT.2) GO TO 150
C---     PRINT END MESSAGE
      CALL CFORM('0---- END OF SYNTHETIC CURVE VERIFICATION -------',
     X  DARRAY,1,49)
      CALL CPRIN1(DARRAY)
  150 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001090.V07   ***
*
       SUBROUTINE SCTRA(XMA,ANA,CAN,ISPRNT)
C----------  THE PURPOSE OF THIS SUBROUTINE IS TO PERFORM GEOMETRY
C----------  TRANSFORMATION FOR THE SYNTHETIC CURVESS.
C----------      XMA     TRANSFORMATION MATRIX
C----------      ANA     CURVE NAME
C----------      CAN     CANON OF THE CURVE
C----------      ISPRNT  PRINT FLAG
C----------
       IMPLICIT DOUBLE PRECISION(A-H,O-Z)
       CHARACTER*8 BLANK,DARRAY*120,ANAME*16
       DIMENSION ANA(10),CAN(*),A(4,4),B(4,24),C(4,24)
       DIMENSION IFLG(4),W(16),XMA(12)
       DATA BLANK/'        '/
       IGNC=0
       CALL HOLFRM(ANA(3),ANAME,1,8,NWD)
       ANAME(9:16)=BLANK
       DARRAY=BLANK
       CALL CFORM('1THE FOLLOWING SSURF OR SCURV WAS ',DARRAY,1,34)
       CALL CFORM('TRANSFORMED BY THE MATRIX',DARRAY,36,25)
       CALL CPRINT(DARRAY)
       CALL CFORM('0',DARRAY,1,1)
       CALL CPRINT(DARRAY)
C***  INPUT MATRIX
       DO 7 I=1,3
       DO 7 J=1,4
       LL=(I-1)*4+J
       A(I,J)=XMA(LL)
  7    CONTINUE
       A(4,1)=0.0
       A(4,2)=0.0
       A(4,3)=0.0
       A(4,4)=1.0
C***  ************
       DO 12 I=1,4
       K=2
       DO 11 J=1,4
       CALL FCONV(A(I,J),DARRAY,K,12,5)
       K=K+12
 11    CONTINUE
       CALL CPRINT(DARRAY)
 12    CONTINUE
       CALL CFORM('0',DARRAY,1,1)
       CALL CPRINT(DARRAY)
       NARC=CAN(4)
       NPT=NARC+1
       IV=CAN(5)
       IA=IV
       DO 2200 N=1,NARC
       IB=IA
       DO 2100 M=1,4
       B(1,M)=CAN(IB)
       B(2,M)=CAN(IB+4)
       B(3,M)=CAN(IB+8)
       B(4,M)=CAN(IB+12)
       IB=IB+1
 2100  CONTINUE
       IB=IA
C----------  CRSSPL  OR  NORMAL
       DO 2300 K=1,2
       KK=K+4
       IC=IB-(3-K)*4
       B(1,KK)=CAN(IC)
       B(2,KK)=CAN(IC+1)
       B(3,KK)=CAN(IC+2)
       B(4,KK)=0.0
 2300  CONTINUE
       ML=6
       IF(N.NE.NARC) GO TO 2500
       IA1=IA+19
       IA2=IA+23
       IF((CAN(IA1).EQ.0).AND.(CAN(IA2).EQ.0)) GO TO 2500
       DO 2310 K=1,2
       KK=K+6
       IC=IB+16+(K-1)*4
       B(1,KK)=CAN(IC)
       B(2,KK)=CAN(IC+1)
       B(3,KK)=CAN(IC+2)
       B(4,KK)=0.0
 2310  CONTINUE
       ML=8
 2500  CONTINUE
       DO 240 KA=1,ML
       DO 230 II=1,4
       D=0.0
       DO 220 JJ=1,4
       C(II,KA)=A(II,JJ)*B(JJ,KA)+D
 220   D=C(II,KA)
 230   CONTINUE
 240   CONTINUE
       IB=IA
       DO 2600 M=1,4
       CAN(IB)=C(1,M)
       CAN(IB+4)=C(2,M)
       CAN(IB+8)=C(3,M)
       CAN(IB+12)=C(4,M)
       IB=IB+1
 2600  CONTINUE
       IB=IA
       DO 2700 K=1,2
       KK=K+4
       IC=IB-(3-K)*4
       CAN(IC)=C(1,KK)
       CAN(IC+1)=C(2,KK)
       CAN(IC+2)=C(3,KK)
 2700  CONTINUE
       IF(ML.EQ.6) GO TO 2800
       DO 2710 K=1,2
       KK=K+6
       IC=IB+16+(K-1)*4
       CAN(IC)=C(1,KK)
       CAN(IC+1)=C(2,KK)
       CAN(IC+2)=C(3,KK)
 2710  CONTINUE
 2800  IA=IA+24
 2200  CONTINUE
       CALL SCPICT(CAN,ANAME,ISPRNT)
 999    RETURN
        END
**** SOURCE FILE : M0004151.V04   ***
*
      SUBROUTINE SCURV(S,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------ INPUT IS A STREAM OF POINTS TOGETHER WITH VARIOUS
C------ TANSPL,CRSSPL,NORMAL,WEIGHT,LIMIT CONSTRAINTS
C------ ALL OF THIS INPUT IS STRUCTURED INTO THE S ARRAY
C------ THE OBJECTIVE OF THIS ROUTINE IS TO CREATE EITHER
C------ A CONIC ARC(S(3,1,1)=3.) OR A SPLINE CURVE(S(3,1,1)=2.)
C------ THE FINAL PROCESSED CURVE IS PACKED INTO THE S ARRAY
C------ REVISED VERSION, CRANFIELD 1981, R.J.G./M.J.P.
C
      COMMON/IBUGG/IBUG,IPCOLC,IPCOLM
C
      DIMENSION S(4,6,31)
      DIMENSION X(5),Y(5),XT(5),YT(5)
      DIMENSION VA(3),VB(3),VN(3),DIF(3)
      DIMENSION C(4,4),A(3,3),CL(4,4),R(4,4)
      CHARACTER*20 BADMSG
      DATA SMAL1,SMAL2,VSMAL/.000000001D0,.00001D0,1.0D-30/
      DATA ZERO,ONE,TWO,THREE/0.0D0,1.0D0,2.0D0,3.0D0/
      IRRR=0
      IRR=0
C
C-------  FIRST CHECK FOR PRESENCE OF NULL ARC
      NHD=S(2,1,1)
      NPL=NHD+1
      NP=S(4,1,1)
      NPH=NHD+NP
      NPLP=NPL+1
      NPHM=NPH-1
C
      IF(IBUG.NE.11) GO TO 7
      CALL BAD(-1,0,' ',0)
      BADMSG=' ENTRY TO SCURV'
      CALL CPRINT(BADMSG)
      JLIM=S(4,1,1)+ONE
      DO 8 J=1,JLIM
      DO 8 I=1,6
      CALL BAD(-4,1,'SC  ',S(1,I,J))
    8 CONTINUE
    7 CONTINUE
C
      IF(NP.NE.2) GO TO 1
      DO 2 I=1,3
    2 DIF(I)=S(I,1,NPH)-S(I,1,NPL)
      CALL DOTF(W,DIF,DIF)
      IF(W.GT.VSMAL) GO TO 1
C-------  NULL ARC INPUT CONFIRMED, PROCESS CURVE DEFINITION HERE
C
C-------  SET UP COONS CANON FORM FOR NULL CURVE
      DO 3 I=1,3
      C(1,I)=S(I,1,NPL)
      C(2,I)=S(I,1,NPH)
      C(3,I)=ZERO
      C(4,I)=ZERO
    3 CONTINUE
      C(1,4)=ONE
      C(2,4)=ONE
      C(3,4)=ZERO
      C(4,4)=ZERO
C-------  NOW MOVE ALL VECTOR CONSTRAINTS
      DO 4 I=1,4
      S(I,5,NPL-1)=S(I,3,NPL)
      S(I,6,NPL-1)=S(I,4,NPL)
      S(I,5,NPL)=S(I,3,NPH)
      S(I,6,NPL)=S(I,4,NPH)
      DO 5 J=1,4
      S(I,J,NPL)=C(I,J)
    5 CONTINUE
    4 CONTINUE
C
C-------  REDUCE POINT BLOCK COUNT BY 1 AND QUIT
      S(4,1,1)=S(4,1,1)-ONE
      GO TO 1000
C
    1 CONTINUE
C------ ELIMINATE ALL SMALL CONSTRAINT VECTORS BEFORE SSPLIN
      DO 12 I=NPL,NPH
      IF(S(4,3,I).LT.SMAL2) GO TO 12
      CALL DOTF(W,S(1,3,I),S(1,3,I))
      IF(W.GT.VSMAL) GO TO 12
C------ CONSTRAINT VECTOR IS SMALL, SO ELIMINATE IT
      DO 13 L=1,4
   13 S(L,3,I)=ZERO
   12 CONTINUE
C
C------ CALL SSPLIN FOR SMOOTHING AND GENERATION OF TANGENTS,
C------ DISCRIMINATION OF INPUT ERRORS AND GENERATION OF TANGENT
C------ DIRECTIONS AT EACH POINT IN THE CASE OF A SPLINE DEFINITION
C
      CALL SSPLIN(S,IRR)
      IF(IRR.NE.0) GO TO 998
C------ JUMP TO LABEL 700 FOR SPLINE PROCESSING
C
C------ THE CASE OF A CURSEG DEFINITION
C------ TEST FOR COPLANARITY OF THE NUMERICAL INPUT
C------ BEGIN BY CONSTRUCTING THE FIRST CHORD VECTOR
      NHD=S(2,1,1)
      NPL=NHD+1
      NP=S(4,1,1)
      NPH=NHD+NP
      NPLP=NPL+1
      NPHM=NPH-1
      IF (S(3,1,1) .NE. THREE) GO TO 700
      DO 10 L=1,3
   10 VA(L)=S(L,1,NPLP)-S(L,1,NPL)
      CALL SNORM(VA,VA,IRRR)
      IF (NP .EQ. 2) GO TO 25
C------ CONSTRUCT A SECOND NON PARALLEL CHORD VECTOR
      DO 20 I=NPLP,NPHM
      DO 30 L=1,3
      VB(L)=S(L,1,I+1)-S(L,1,NPL)
   30 CONTINUE
      CALL CROSS(VB,VA,VN)
      D=DSQRT(VN(1)**2+VN(2)**2+VN(3)**2)
      IF(D.GT.SMAL1) GO TO 50
   20 CONTINUE
C------ THE POINTS ARE COLINEAR SO FIND A NONPARALLEL TANGENT
   25 CONTINUE
      DO 40 I=NPL,NPH
      KK=0
      IF(S(4,4,I).NE.ZERO) KK=4
      IF(S(4,2,I).NE.ZERO) KK=2
      IF(KK.EQ.0) GO TO 40
      IF(I.EQ.NPH)GO TO 42
      CALL CROSS(VA,S(1,KK,I),VN)
      GO TO 45
   42 CALL CROSS(S(1,KK,I),VA,VN)
   45 D=DSQRT(VN(1)**2+VN(2)**2+VN(3)**2)
      IF(D.GT.SMAL1) GO TO 50
   40 CONTINUE
C------ THERE IS NO UNIQUE NORMAL, CONDITIONS INDICATE A STRAIGHT LINE
      GO TO 200
C
C------ VN IS THE POTENTIAL NORMAL TO THE BASE PLANE
   50 CALL SNORM(VN,VN,IRRR)
C------ NOW CHECK ALL INPUT POINTS AND VECTORS TO SEE IF THEY
C------ DO LIE IN THE BASE PLANE
      DO 100 I=NPLP,NPH
      DO 110 L=1,3
  110 DIF(L)=S(L,1,I)-S(L,1,NPL)
      CALL SNORM(DIF,DIF,IRRR)
      DOT=DIF(1)*VN(1)+DIF(2)*VN(2)+DIF(3)*VN(3)
C------ NON COPLANAR POINTS
      IRR=5751
      IF(DABS(DOT).GT.SMAL2) GO TO 998
  100 CONTINUE
C------ NOW CHECK FOR NON COPLANAR TANGENTS
C------ NT GIVES TOTAL NUMBER OF TANGENT CONSTRAINTS
      IRR=5752
      NT=0
      DO 120 I=NPL,NPH
      IF(S(4,2,I).EQ.ZERO) GO TO 120
      NT=NT+1
      DOT=VN(1)*S(1,2,I)+VN(2)*S(2,2,I)+VN(3)*S(3,2,I)
      IF(DABS(DOT).GT.SMAL2) GO TO 998
  120 CONTINUE
      IRR=5753
      IF(NP+NT.GT.5) GO TO 998
C------ ERROR IF MORE THAN 5 IMPOSED CONSTRAINTS
      GO TO 300
C------ INPUT DOES LIE IN A PLANE
C
C------ LINEAR CASE
  200 CONTINUE
      DO 210 K=1,2
      I=NPL
      IF(K.EQ.2) I=NPH
      DO 210 L=1,3
      C(K,L)=S(L,1,I)
  210 C(K+2,L)=S(L,1,NPH)-S(L,1,NPL)
      C(1,4)=ONE
      C(2,4)=ONE
      C(3,4)=ZERO
      C(4,4)=ZERO
      GO TO 604
C
C------ NON-LINEAR CASES; CONSTRUCT NEW COORDINATE SYSTEM
  300 CONTINUE
      DO 305 I=1,3
  305 VA(I)=DIF(I)
      CALL CROSS(VN,VA,VB)
      CALL SNORM(VB,VB,IRR)
C------ VA,VB,VN ARE NEW AXES CENTRED AT FIRST POINT
C------ R IS RATIONAL TRANSFORMATION MATRIX
      DO 310 I=1,3
  310 R(I,4)=0.0
      R(4,4)=1.0
      DO 320 J=1,3
      R(1,J)=VA(J)
      R(2,J)=VB(J)
      R(3,J)=VN(J)
  320 R(4,J)=S(J,1,NPL)
C------ NEW COORDINATES STORED IN ARRAYS X,Y,TANGENTS IN XT,YT
      NPN1=NP-1
      DO 340 I=1,NPN1
      SUMX=0.0
      SUMY=0.0
      DO 330 J=1,3
      SUMX=SUMX+(S(J,1,NPL+I)-S(J,1,NPL))*VA(J)
  330 SUMY=SUMY+(S(J,1,NPL+I)-S(J,1,NPL))*VB(J)
      X(I+1)=SUMX
  340 Y(I+1)=SUMY
      DO 350 I=1,NP
      J=NPL+I-1
      IF(S(4,2,J).EQ.ZERO) GO TO 350
      XT(I)=S(1,2,J)*VA(1)+S(2,2,J)*VA(2)+S(3,2,J)*VA(3)
      YT(I)=S(1,2,J)*VB(1)+S(2,2,J)*VB(2)+S(3,2,J)*VB(3)
  350 CONTINUE
      X(1)=0.0
      Y(1)=0.0
C
C------ CHECK CONVEXITY OF POINTS AND CONDITIONS DEFINED
      IRR=5770
      IF(NP.EQ.2) GO TO 361
      NPN1=NP-1
      DO 360 I=2,NPN1
      D=(Y(I)-Y(I-1))*(X(I+1)-X(I-1))-(X(I)-X(I-1))*(Y(I+1)-Y(I-1))
      IF(D.LE.SMAL1) GO TO 998
  360 CONTINUE
  361 CONTINUE
C
      IF(NT.EQ.0) GO TO 372
      DO 371 I=1,NP
      IF(S(4,2,NPL+I-1).EQ.ZERO) GO TO 371
      DO 370 J=1,NP
      IF(J.EQ.I) GO TO 370
      DT=(X(J)-X(I))*YT(I)-(Y(J)-Y(I))*XT(I)
      IF(DT.LE.SMAL1) GO TO 998
  370 CONTINUE
  371 CONTINUE
  372 CONTINUE
C
C------ FIT CONIC X*X+B*Y*Y+C0*X*Y+D*X+E*Y=0 TO DATA
      D=-X(NP)
      IRR=5772
      IF(NP+NT.EQ.4) GO TO 400
      IF(NP+NT.EQ.5) GO TO 500
C------ 3 CONDITIONS DEFINE UNIQUE CIRCULAR ARC
      IF(NT.EQ.0) GO TO 381
      DO 380 I=1,NP
      IF(S(4,2,NPL+I-1).EQ.ZERO) GO TO 380
      E=-(2.0*X(I)*XT(I)+2.0*Y(I)*YT(I)+D*XT(I))/YT(I)
  380 CONTINUE
  381 CONTINUE
      IF(NP.NE.3) GO TO 390
      E=-(X(2)*X(2)+Y(2)*Y(2)+D*X(2))/Y(2)
  390 CONTINUE
C
C------ GENERATE CANONICAL FORM MATRIX CL
      A0=(DSQRT(D*D+E*E)-E)/DABS(D)
      A2=A0*A0
      DO 391 I=1,4
      DO 391 J=1,4
  391 CL(I,J)=0.0
      CL(1,4)=A2+1.0
      CL(2,1)=-D*(A2+1.0)
      CL(2,4)=A2+1.0
      CL(3,1)=-D*(1.0-A2)
      CL(3,2)=-2.0*A0*D
      CL(3,4)=-4.0*A2
      CL(4,1)=-D*(1.0+3.0*A2)
      CL(4,2)=2.0*A0*D
      CL(4,4)=4.0*A2
      GO TO 600
C------ FOUR CONDITIONS,CURVE IS ELLIPSE OR PARABOLA
  400 CONTINUE
      IF(NT.NE.2) GO TO 410
      E=-D*XT(1)/YT(1)
      C0=-(XT(2)/YT(2)+XT(1)/YT(1))
C------ MINIMUM ECCENTRICITY ELLIPSE HAS B=C0*C0/2+1, PARABOLA B=C0*C0/4
      B=1.0+C0*C0/2.0
      GO TO 550
  410 IF(NT.NE.1) GO TO 425
      DO 420 I=1,NP
      IF(S(4,2,NPL+I-1).EQ.ZERO) GO TO 420
C------ FORM QUADRATIC A2*C0*C0+A1*C0+A0=0 FOR C,TRY B=1+C0*C0/2 FIRST
      A2=Y(2)*YT(I)*(Y(I)-0.5*Y(2))
      A1=Y(2)*(X(I)*YT(I)+Y(I)*XT(I)-X(2)*YT(I))
      A0=XT(I)*Y(2)*(2.0*X(I)+D)-X(2)*YT(I)*(X(2)+D)+2.0*A2
  420 CONTINUE
      GO TO 430
  425 A2=Y(2)*Y(3)*(Y(2)-Y(3))/2.0
C------ CASE OF 4 DEFINED POINTS
      A1=Y(2)*Y(3)*(X(2)-X(3))
      A0=X(2)*Y(3)*(X(2)+D)-X(3)*Y(2)*(X(3)+D)+2.0*A2
  430 IF(DABS(A2).LE.SMAL1) GO TO 450
      DISC=A1*A1-4.0*A2*A0
      IF(DISC.LT.ZERO) GO TO 460
      IF(DISC.GT.SMAL1) GO TO 435
      C0=-A1/(2.0*A2)
      GO TO 455
  435 DO 440 K=1,3,2
      C0=(-A1+(K-2)*DSQRT(DISC))/(2.0*A2)
      B=1.0+C0*C0/2.0
      E=(X(2)*X(2)+B*Y(2)*Y(2)+C0*X(2)*Y(2)+D*X(2))/(-Y(2))
      IF(D*E.LT.ZERO.AND.D*(E-C0*D).LT.ZERO) GO TO 550
  440 CONTINUE
      GO TO 460
  450 C0=-A0/A1
C------ EQUAL ROOTS OR LINEAR EQUATION FOR C
  455 B=1.0+C0*C0/2.0
      E=(X(2)*X(2)+B*Y(2)*Y(2)+C0*X(2)*Y(2)+D*X(2))/(-Y(2))
      IF(D*E.LT.ZERO.AND.D*(E-C0*D).LT.ZERO) GO TO 550
  460 A2=A2/2.0
C------ PARABOLIC CASE
      A0=A0-4.0*A2
      IF(DABS(A2).LE.SMAL1) GO TO 480
      DISC=A1*A1-4.0*A0*A2
      IF(DISC.LT.0.0) GO TO 998
      IF(DISC.GT.SMAL1) GO TO 465
      C0=-A1/(2.0*A2)
      GO TO 485
  465 DO 470 K=1,3,2
      C0=(-A1+(K-2)*DSQRT(DISC))/(2.0*A2)
      B=C0*C0/4.0
      E=(X(2)*X(2)+B*Y(2)*Y(2)+C0*X(2)*Y(2)+D*X(2))/(-Y(2))
      IF(D*E.LT.ZERO.AND.D*(E-C0*D).LT.ZERO) GO TO 550
  470 CONTINUE
      GO TO 998
C------ NO SATISFACTORY CONIC FOUND
  480 C0=-A0/A1
C------ EQUAL ROOTS OR LINEAR EQUATIONS FOR C
  485 B=C0*C0/4.0
      E=(X(2)*X(2)+B*Y(2)*Y(2)+C0*X(2)*Y(2)+D*X(2))/(-Y(2))
      IF(D*E.LT.ZERO.AND.D*(E-C0*D).LT.ZERO) GO TO 550
      GO TO 998
  500 CONTINUE
C
C------ UNIQUE CONIC DEFINED BY 5 CONDITIONS;
C------ SET UP EQUATIONS FOR COEFFICIENTS
      NPN2=NP-2
      DO 510 I=1,NPN2
      J=I+1
      A(I,1)=Y(J)*Y(J)
      A(I,2)=X(J)*Y(J)
      A(I,3)=Y(J)
  510 VA(I)=-(X(J)+D)*X(J)
      IF(NT.EQ.0) GO TO 530
      I=NP-2
      DO 520 J=1,NP
      IF(S(4,2,NPL+J-1).EQ.ZERO) GO TO 520
      I=I+1
      A(I,1)=2.0*Y(J)*YT(J)
      A(I,2)=Y(J)*XT(J)+X(J)*YT(J)
      A(I,3)=YT(J)
      VA(I)=-(2.0*X(J)+D)*XT(J)
  520 CONTINUE
C------ SOLVE LINEAR EQUATIONS
  530 CALL GELG(VA,A,SMAL1,3,1,IRR)
      IF(IRR.EQ.0) GO TO 540
      IRR=5772
      GO TO 998
  540 B=VA(1)
      C0=VA(2)
      E=VA(3)
C
C------ COEFFICIENTS OF CONIC HAVE BEEN DETERMINED,FIND MID POINT OF
C------ ARC (XM,YM) AND TANGENT INTERSECTION (XI,YI)
  550 IRR=5760
      XM=-0.5*D
      IF(DABS(B).GT.SMAL2) GO TO 560
      IF(C0.LT.SMAL2) GO TO 555
      IF(DABS(0.5+E/C0).LT.0.5) GO TO 998
C------ DISCONTINUOUS HYPERBOLIC CASES REJECTED
  555 YM=XM*XM/(E-C0*XM)
      GO TO 570
  560 BB=E-0.5*C0*D
      DISC=BB*BB+B*D*D
      IF(DISC.LT.0.0) GO TO 998
      YM=(-BB+DSQRT(DISC))/(2.0*B)
  570 DENOM=2.0*E-C0*D
      IF(DABS(DENOM).LE.SMAL1) GO TO 998
C------ PARALLEL TANGENTS
      XI=-D*E/DENOM
      YI=D*D/DENOM
      IF(YI*YM.LT.ZERO) GO TO 998
C------ POINTS ON OPPOSITE SIDES OF CHORD
      CALL RATCON(-D,XM,YM,XI,YI,CL)
C
C------ NOW REVERSE THE COORDINATE TRANSFORMATION
  600 CNORM=0.0
      DO 602 I=1,4
      DO 602 J=1,4
      SUM=0.0
      DO 601 K=1,4
  601 SUM=SUM+CL(I,K)*R(K,J)
      IF(DABS(SUM).GT.CNORM) CNORM=SUM
  602 C(I,J)=SUM
C------ NORMALISE THE C MATRIX
      DO 603 I=1,4
      DO 603 J=1,4
  603 C(I,J)=C(I,J)*10.0/CNORM
C------ BUILD THE NEW DATA BASE CONSISTING OF A SINGLE RATIONAL
C------ CUBIC CURVE WITH POSSIBLE CRRSPL AND NORMAL CONSTRAINTS
C------ AT CURVE ENDS
C------ SHIFT THE FIRST AND LAST CONSTRAINT VECTORS INTO APPROPRIATE
C------ PARTS OF THE FINAL ARRAY
  604 NDIFF=NPH-NPL
      DO 610 I=NPL,NPH,NDIFF
      K=NHD
      IF(I.EQ.NPH) K=NHD+1
      DO 610 J=3,4
      JJ=J+2
      DO 620 L=1,4
  620 S(L,JJ,K)=S(L,J,I)
  610 CONTINUE
C------ NOW LOAD THE RATIONAL PARAMETRIC CUBIC CANON FORM
C------ INTO THE DATA BASE
      DO 630 K=1,4
      DO 630 L=1,4
  630 S(L,K,NPL)=C(L,K)
C------ ZERO OUT THE REST OF THE ARRAY
      DO 640 I=NPLP,NPH
      DO 640 K=1,6
      DO 640 L=1,4
  640 S(L,K,I)=ZERO
      S(4,1,1)=ONE
      GO TO 1000
C------ THE INPUT HERE IS A PARTIALLY COMPLETED SPLINE DATA BASE
C------ IN THIS SECTION FINAL LENGTHS ARE ASSIGNED TO TANGENT VECTORS
C------ COONS MATRICES ARE CONSTRUCTED FOR EACH SEGMENT, AND THE
C------ COMPLETE DATA BASE IS CONSTRUCTED
C
  700 CONTINUE
C------ FIRST SHIFT THE LOCATION OF ALL CROSS SPLINE AND NORMAL
C------ CONSTRAINTS
      DO 710 I=NPL,NPH
      DO 710 K=3,4
      DO 710 L=1,4
      S(L,K+2,I-1)=S(L,K,I)
  710 CONTINUE
C------ NOW GENERATE LENGTHS FOR VECTORS AND THEN COONS MATRICES
C
      DO 720 I=NPL,NPHM
C-------  THREE LOGIC LEVELS FOR TANGENT VECTOR LENGTHS ARE AVAILABLE
C-------  ILEVEL=2, DEFAULT, MINIMIZES DDR(0)**2+DDR(1)**2
      ILEVEL=2
C-------  ILEVEL=1 USE CHORD LENGTH FOR TANGENT VECTORS
C-------  ILEVEL=3 USED LENGTHS WHICH MINIMIZE TENSION
      IF(IBUG.EQ.9) ILEVEL=1
      IF(IBUG.EQ.10) ILEVEL=3
C-------  CTOLR SETS THE TOLERANCE LEVEL FOR TERMINATING THE
C-------  ITERATIVE PROCESS OF ADJUSTING TANGENT LENGTHS FOR
C-------  THE PURPOSE OF REDUCING CURVE TENSION.
      CTOLR=0.005
C-------  NUMINT IS THE NUMBER OF INTERVALS USED FOR APPROXIMATING
C-------  TENSION.  VALUE 5 IS ECONOMIC BUT MORE MAY PRODUCE
C-------  MORE ACCURATE RESULTS, BUT WITH GREATER RUN TIMES
      NUMINT=5
C-------  MXCT IS AN UPPER LIMIT ON THE NUMBER OF ITERATIONS
C-------  THIS IS TO LIMIT TOTAL CPU TIME FOR SPLINING.
      MXCT=10
C-------  ALPH AND BETA ARE THE DESIRED LENGTHS OF TANGENT VECTORS
C
      CALL CRVLEN(S(1,1,I),S(1,1,I+1),S(1,2,I),S(1,2,I+1),
     X            ALPH,BETA,NUMINT,MXCT,CTOLR,ILEVEL)
C
C------ THIS ASSIGNMENT OF LENGTHS IS BASED ON A MINIMUM VALUE
C------ FOR THE INTEGRAL OF THE SECOND DERIVATIVE SQUARED
      DO 750 L=1,3
      C(1,L)=S(L,1,I)
      C(2,L)=S(L,1,I+1)
      C(3,L)=ALPH*S(L,2,I)
      C(4,L)=BETA*S(L,2,I+1)
  750 CONTINUE
      C(1,4)=ONE
      C(2,4)=ONE
      C(3,4)=ZERO
      C(4,4)=ZERO
C------ NOW LOAD THE COONS MATRIX INTO THE S ARRAY
      DO 760 K=1,4
      DO 760 L=1,4
  760 S(L,K,I)=C(L,K)
  720 CONTINUE
C
C------ ZERO OUT THE LAST BLOCK AND RESET THE POINT BLOCK NUMBER
      S(4,1,1)=NP-1
      DO 770 K=1,6
      DO 770 L=1,4
  770 S(L,K,NPH)=ZERO
      GO TO 1000
 1000 CONTINUE
      IRR=0
  998 CONTINUE
C
      IF(IBUG.NE.11) GO TO 917
      CALL BAD(-1,0,' ',0)
      BADMSG=' EXIT FROM SCURV'
      CALL CPRINT(BADMSG)
      JLIM=S(4,1,1)+ONE
      DO 918 J=1,JLIM
      DO 918 I=1,6
      CALL BAD(-4,1,'SC  ',S(1,I,J))
  918 CONTINUE
  917 CONTINUE
C
      RETURN
      END
**** SOURCE FILE : M0000658.V02   ***
*
      SUBROUTINE SMMULT(L,M,N,KS,A,B,C)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C--- SCULPTURED SURFACE ROUTINE FOR MATRIX MULTIPLY
C---  A IS AN INPUT MATRIX L ROWS BY M COLUMNS
C--- B IS AN INPUT MATRIX M ROWS X N COLUMNS
C--- KS DETERMINES WHERE THE OUTPUT IS LOADED
C--- KS =1 A  KS=2 B  KS=3 C
C--- NO INPUT MATRIX IS ALTERED UNLESS REQUESTED
      DIMENSION A(*),B(*),C(*)
      DIMENSION D(16)
      KN(I,J,KK)=I+(J-1)*KK
      DO 10 JC=1,N
      DO 10 IR=1,L
      KLOC=KN(IR,JC,L)
      D(KLOC)=0.0
      DO 20 KK=1,M
      KA=KN(IR,KK,L)
      KB=KN(KK,JC,M)
      D(KLOC)=D(KLOC)+A(KA)*B(KB)
   20 CONTINUE
   10 CONTINUE
      MSIZE=L*N
      GO TO (100,200,300),KS
  100 CONTINUE
      DO 110 K=1,MSIZE
  110 A(K)=D(K)
      GO TO 999
  200 CONTINUE
      DO 210 K=1,MSIZE
  210 B(K)=D(K)
      GO TO 999
  300 CONTINUE
      DO 310 K=1,MSIZE
  310 C(K)=D(K)
  999 RETURN
      END
**** SOURCE FILE : M0000659.V02   ***
*
C
      SUBROUTINE SMOOTH(Q,RL,A,TV,CB,NIN,IDC)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C----************* SMTH1 *********************************'71/4/23  N.K.
C---- THIS ROUTINE CALCULATES SMOOTHED POINTS AND TANGENT VECTORS AT
C---- THOSE POINTS , AND INPUT IS AN ARRAY OF POINT VECTORS.
C---- INPUT --- N = NUMBER OF POINTS
C----           Q = AN ARRAY OF INPUT POINT VECTORS
C----           RL = AN ARRAY OF RELAXATION FACTORS ASSOCIATED TO EACH
C----                INPUT POINTS   ( RL(I)=0. MEANS NO SMOOTHING
C----                                 TO THE I-TH POINT.)
C----           IDC = BOUNDARY CONDITION IDENTIFIER
C----               =1   CLOSED CURVE
C----                =2   1-ST DERIVATIVE --- 1-ST DERIVATIVE
C----               =3   1-ST DERIVATIVE --- 2-ND DERIVATIVE
C----               =4   2-ND DERIVATIVE --- 1-ST DERIVATIVE
C----               =5   2-ND DERIVATIVE --- 2-ND DERIVATIVE
C----           TV = END CONDITION VECTORS INTERPRETED AS SPECIFIED BY
C----                IDC.
C---- OUTPUT--- A = AN ARRAY OF DISTANCE BETWEEN CONSECUTIVE OUTPUT
C----               POINTS  ( A(J)=DISTANCE BTW. J-TH AND (J-1)-TH PNT.)
C----           CB = AN ARRAY OF 1-ST DERIVATIVES (NORMALIZED)
C----           IDC = ERROR INDICATOR
C----               =0   NO ERROR
C----               =-1   A DISTANCE BTW. TWO CONSECUTIVE INPUT POINTS
C----                     IS VANISHING
C----               = -2   IDC IS NOT SIGNIFICANT.
C----               =-3   ERROR IN SOLVING SIMULTANEOUS EQUATION
C----               =-4   NUMBER OF INPUT POINTS IS LESS THAN 3.
C----               =-5   A DISTANCE BTW. TWO CONSECUTIVE OUTPUT POINTS
C----                     IS VANISHING.
C----               =-6   AN OUTPUT 1-ST DERIVATIVE IS VANISHING.
C----********* SUBSIDIARY --- GELG
C----*******************************************************************
      DIMENSION Q(3,30),RL(30),A(30),TV(3,2),CV(3,30),CT(90),CM(900),
     1  CA(3,30),CB(3,30)
      DATA SMAL1,SMAL2,SMAL3/1.0D-7,1.0D-6,1.0D-14/
      DATA ZERO,ONE/0.0D0,1.0D0/
C------ JG CONTROLS OUTPUT. JO IS OUTPUT FILE NUMBER.
      JG=0
      JO=6
C------ INITIAL EXAMINATION TO DETERMINE IF CURVE IS CLOSED
      N=NIN
      W=DSQRT((Q(1,1)-Q(1,N))**2+(Q(2,1)-Q(2,N))**2+(Q(3,1)-Q(3,N))**2)
      IF(W.GT.SMAL2) GO TO 3
C--- CLOSED CURVE CASE   END POINTS ASSUMED EQUAL
      N=NIN-1
      IDC=1
    3 CONTINUE
C------ CONVERT FROM A PART PROGRAMMER WEIGHT FACTOR(0.0 TO 1.0 WHERE
C------ 1.0 MEANS CERTAINTY FOR A POINT) TO A RELAXATION FACTOR ( INF
C------ TO 0.0 WHERE 0.0 IS CERTITUDE AND INFINITY IS COMPLETE RELAXA)
      DO 1517 I=1,NIN
      AA=RL(I)
      IF(AA.LT.SMAL1)  AA=SMAL1
      IF(AA.GT.ONE) AA=ONE
      RL(I)=ONE/AA-ONE
 1517 CONTINUE
      NN=N*N
      N3=3*N
C
C    ***DISTANCE BTW,CONSECUTIVE INPUT POINTS***
C    ***NORMALIZED INCREMENTAL VECTORS***
C    ***SINGULARITY IS CHECKED***
C
      IF(N.LT.3)  GO TO 1300
    1 DO  10   J=2,N
      JJ=J-1
      DO  11   I=1,3
      CV(I,J)=Q(I,J)-Q(I,JJ)
   11 CONTINUE
      A(J)= DSQRT(CV(1,J)**2+CV(2,J)**2+CV(3,J)**2)
      IF(A(J).LT.SMAL1)   GO TO 1000
      DO  12   I=1,3
      CV(I,J)=CV(I,J)/A(J)
   12 CONTINUE
   10 CONTINUE
      DO  13   I=1,3
   13 CV(I,1)=Q(I,1)-Q(I,N)
      A(1)=DSQRT(CV(1,1)**2+CV(2,1)**2+CV(3,1)**2)
      IF(A(1).LT.SMAL1)  GO TO 1000
      DO  14   I=1,3
   14 CV(I,1)=CV(I,1)/A(1)
C
C    ***CONSTANT VECTORS FOR THE EQUATION OF CURVATURE***
C
      L1=N+1
      DO  20   I=1,3
      II=I*N-L1
      DO  21   J=2,N
      CT(II+J)=6.*(CV(I,J)-CV(I,J-1))
   21 CONTINUE
      CT(II+L1)=6.*(CV(I,1)-CV(I,N))
   20 CONTINUE
C
C    ***CLEAR THE MATRIX***
C
      DO  30   I=1,NN
      CM(I)=0.
   30 CONTINUE
C
C    ***MATRIX ELEMENTS***
C
      CA(1,1)=6.*(RL(1)+RL(2))/A(2)**2
      CB(1,1)=6.*(RL(1)/A(2))/A(1)
      DO  31   I=1,N
      II=I+1-(I/N)*N
      J1=I+2-((I+1)/N)*N
      CA(1,II)=6.*(RL(II)+RL(J1))/A(J1)**2
      CB(1,II)=6.*(RL(II)/A(J1))/A(II)
      CB(2,I)=A(II)-(CB(1,II)+CA(1,I)+CB(1,I))
      CB(3,II)=2.*(A(J1)+A(II))+(CA(1,II)+CA(1,I)+2.*CB(1,II))
   31 CONTINUE
C
C    ***SET PRIMARY MATRIX***
C
      L2=N+2
      N2=2*N
      DO  41   IJ=L1,N2
      J=IJ-1-((IJ-2)/N)*N
      JJ=J+1-(J/N)*N
      I=J*L1-N
      IA=I+N-((I+N-1)/NN)*NN
      IB=I+2*N-((I+2*N)/NN)*NN
      IC=I+1-(J/N)*N
      ID=I+2-((J+1)/N)*N
      CM(I)=CB(3,J)+CM(I)
      CM(IA)=CB(2,J)+CM(IA)
      CM(IB)=CB(1,JJ)+CM(IB)
      CM(IC)=CB(2,J)+CM(IC)
      CM(ID)=CB(1,JJ)+CM(ID)
   41 CONTINUE
C
C    ***CLOSED CURVE***
C
      IF(IDC.EQ.1)  GO TO 200
C
C    ***OPEN ENDS***
C
      K1=N-1
      CM(NN-N+1)=0.
      CM(NN-N+2)=0.
      CM(NN-N2+1)=0.
      CM(N)=0.
      CM(N2)=0.
      CM(K1)=0.
      CM(2)=A(2)-CA(1,1)-CB(1,2)
      IF(N.NE.3)  GO TO 60
      CM(8)=A(3)-(CA(1,2)+CB(1,2))
      GO TO 61
   60 CM(NN-1)=A(N)-(CA(1,K1)+CB(1,K1))
C
C    *** FIRST END BY CURVATURE***
C
   61 IF(IDC.LT.4)  GO TO 110
      DO  42   I=1,3
      CT(I*N-K1)=TV(I,1)
   42 CONTINUE
      CM(1)=1.
      CM(L1)=0.
      CM(N2+1)=0.
C
C    ***LAST END BY TANGENT***
C
      IF(IDC.NE.4)  GO TO 120
  130 DO  43   I=1,3
      CT(I*N)=6.*(CV(I,N)-TV(I,2))
   43 CONTINUE
      CM(NN-N)=-A(N)+CB(1,K1)+CA(1,K1)
      CM(NN)=-2.*A(N)-CA(1,K1)
      CM(NN-N2)=-   CB(1,K1)
      GO TO 200
C
C    ***LAST END BY CURVATURE***
C
  120 IF(IDC.NE.5)  GO TO 1100
  140 DO  44   I=1,3
      CT(I*N)=TV(I,2)
   44 CONTINUE
      CM(NN)=1.
      CM(NN-N)=0.
      CM(NN-N2)=0.
      GO TO 200
C
C    ***FIRST END BY TANGENT***
C
  110 DO  45   I=1,3
      CT(I*N-K1)=6.*(CV(I,2)-TV(I,1))
   45 CONTINUE
      CM(1)=2.*A(2)+   CA(1,1)
      CM(L1)=A(2)-   (CA(1,1)+CB(1,2))
      CM(N2+1)=CB(1,2)
      IF(IDC.EQ.2)   GO TO 130
      GO TO 140
C
C    *** CALCULATION OF CURVATURE***
C
  200 EPS=SMAL3
      NR=3
      CALL GELG(CT,CM,EPS,N,NR,IER)
      IF(IER.NE.0)   GO TO 1200
      DO  50   I=1,3
      II=I*N-N
      DO  51   J=1,N
      CV(I,J)=CT(II+J)
   51 CONTINUE
   50 CONTINUE
C    ***CALCULATION OF CURVE SEGMENT COEFFICIENTS***
C
      DO  55   I=1,3
      DO  56   J=2,N
      CA(I,J)=(CV(I,J)-CV(I,J-1))/A(J)
   56 CONTINUE
      CA(I,1)=(CV(I,1)-CV(I,N))/A(1)
      K1=N-1
      DO  57   J=2,K1
      Q(I,J)=Q(I,J)-RL(J)*(CA(I,J+1)-CA(I,J))
   57 CONTINUE
      IF(IDC.EQ.1)  GO TO 250
      Q(I,1)=Q(I,1)-RL(1)*(CV(I,2)-CV(I,1))/A(2)
      Q(I,N)=Q(I,N)+RL(N)*(CV(I,N)-CV(I,N-1))/A(N)
      GO TO 55
  250 Q(I,1)=Q(I,1)-RL(1)*(CA(I,2)-CA(I,1))
      Q(I,N)=Q(I,N)-RL(N)*(CA(I,1)-CA(I,N))
   55 CONTINUE
      IDXX=0
      DO  400   J=1,N
      IF(RL(J).GT.SMAL2)   IDXX=IDXX+1
      IF(RL(J).GT.SMAL2)   RL(J)=0.
  400 CONTINUE
      IF(IDXX.EQ.0)   GO TO 590
      GOTO 500
  590 DO  510   J=2,N
      DO  510   I=1,3
      CA(I,J)=Q(I,J)-Q(I,J-1)
  510 CONTINUE
      IF(IDC.NE.1)   GO TO 260
      DO  520   I=1,3
  520 CA(I,1)=Q(I,1)-Q(I,N)
  260 DO  91   J=1,N
      J1=J+1-(J/N)*N
      DO  93   I=1,3
      CB(I,J)=CA(I,J1)/A(J1)-A(J1)*(2.*CV(I,J)+CV(I,J1))/6.
   93 CONTINUE
      A(J1)=0.
      DO  92   I=1,3
      A(J1)=CA(I,J1)**2+A(J1)
   92 CONTINUE
      A(J1)=DSQRT(A(J1))
      IF(A(J1).GE.SMAL3)  GO TO 91
      IF(J.NE.N)  GO TO 1400
      IF(IDC.EQ.1)  GO TO 1400
      A(1)=99999.
   91 CONTINUE
      IF(IDC.EQ.1)   GO TO 511
      DO  94   I=1,3
   94 CB(I,N)=CA(I,N)/A(N)+A(N)*(CV(I,N-1)+2.*CV(I,N))/6.
  511 CONTINUE
      DO  300 J=1,N
      TL=DSQRT(CB(1,J)*CB(1,J)+CB(2,J)*CB(2,J)+CB(3,J)*CB(3,J))
      IF(TL.LE.SMAL2)   GO TO 1500
      DO  310   I=1,3
  310 CB(I,J)=CB(I,J)/TL
  300 CONTINUE
      GO TO 500
 1000 IDC=-1
      GO TO 500
 1100 IDC=-2
      GO TO 500
 1200 IDC=-3
      GO TO 500
 1300 IDC=-4
      GO TO 500
 1400 IDC=-5
      GO TO 500
 1500 IDC=-6
  500 CONTINUE
      IF(IDC.NE.1) RETURN
C------ FINAL ADJUSTMENT FOR CLOSED CURVE
      DO 502 I=1,3
      Q(I,NIN)=Q(I,1)
      CB(I,NIN)=CB(I,1)
  502 CONTINUE
      A(NIN)=A(1)
      IDC=2
      RETURN
      END
**** SOURCE FILE : M0000660.V02   ***
*
      SUBROUTINE SNORM(A,B,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(*),B(*)
      IRR=1
      W=DSQRT(A(1)*A(1)+A(2)*A(2)+A(3)*A(3))
      IF(W.LT.1.0D-15) RETURN
      IRR=0
      B(1)=A(1)/W
      B(2)=A(2)/W
      B(3)=A(3)/W
      RETURN
      END
**** SOURCE FILE : M0002769.W01   ***
*
      SUBROUTINE SRFCOM(ISPRNT,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---     ISPRNT  IS INPUT AND CONTROLS PRINT VERIFICATION
C---     IRR IS OUTPUT AND IF NON ZERO INDICATES AN ERROR
C---     PURPOSE IS TO COMBINE A STRING OF SEPARATELY DEFINED SSURFS
C---     INTO A SINGLE NEW SSURF
C---     PART PROGRAM DATA ARRIVES IN BLANK COMMON(LOC 41 ON)
C---     IT IS FIRST TRANSFERRED TO LABELED COMMON.
C---     SURFACES ARE THEN LOADED ONE BY ONE INTO BLANK COMMON
C---     STRIPPED OF THEIR TOPOLOGY TABLES, AND CONSOLIDATED INTO
C---     A SINGLE SURFACE IN BLANK COMMON.  THEN A PROCESS OF
C---     COMPARING EACH PATCH TO EVERY OTHER PATCH IS INVOKED TO
C---     BUILD A NEW TOPOLOGY TABLE FOR THE CONSOLIDATED
C---     SURFACE IN LABELED COMMON.  PRINT VERIFICATION FOLLOWS
C---     IF THE PRINT FLAG HAS BEEN TURNED ON AND AS A FINAL
C---     STEP THIS TOPOLOGY DATA IS CONSOLIDATED WITH THE
C---     NEW SURFACE.
C
      INCLUDE (DARRAY)    
C
      COMMON/MAXLDA/MAXLDA
      INCLUDE (SSPAD)    
      COMMON/IBUGG/IBUG,IPCOLC,IPCOMC
C
      INCLUDE (BLANKCOM)    
C
C     DUMMY ARRAY FOR BLANK-COMMON RESERVATION, MESH-TEST
      DIMENSION FDUMMY(2)
      DIMENSION SCH(4)
C
      CHARACTER*8 WEIGHT,ALIMIT
      CHARACTER*8 TEST
      LOGICAL CKDEF
C
      DIMENSION SPV(32),B(64),IFLAG(4),ITOP(6,4)
C
      DIMENSION U(4),V(4)
C
C---     INTEGER ARRAY KTOP USED FOR QUICK MANIPULATION OF TOPOLOGY DATA
      DIMENSION KTOP(2*ISCN)
      EQUIVALENCE (KTOP(1),SCAN(1))
C
      DIMENSION ICP(2),JCP(2)
C
      DIMENSION IBPT(4,2)
C
      DIMENSION ICURV(4,2)
C
      DIMENSION NP(2)
C
      DATA FDUMMY /2*0.D0/
      DATA WEIGHT,ALIMIT/'WEIGHT  ','LIMIT   '/
      DATA ZERO,ONE,SMAL/0.0D0,1.0D0,1.0D-14/
      DATA U/0.0D0,1.0D0,0.0D0,1.0D0/
      DATA V/0.0D0,0.0D0,1.0D0,1.0D0/
      DATA IBPT/1,1,2,3,2,3,4,4/
      DATA ICURV/3,6,6,3,6,3,3,6/
      DATA SMALP/1.0D-4/
      DATA SMALV/1.0D-5/
C
C---     TRANSFER PART PROGRAM INPUT
      NSIZE=SSCAN(5)
      DO 10 I=1,NSIZE
      SCAN(I)=SSCAN(I)
   10 CONTINUE
C---     NEXT AVAILABLE SLOT IN SCAN
      ISCAN=NSIZE
C---     NPAT IS TOTAL NUMBER OF PATCHES IN NEW SURFACE
C---     NTOT IS TOTAL SIZE OF ALL SURFACES
C---     NUMSUR IS TOTAL NUMBER OF INPUT SURFACES
      NPAT=0
      NTOT=0
      NUMSUR=0
C---     LOAD IN ALL SURFACES TO OBTAIN NPAT,NTOT,NUMSUR
      I=9
  100 CONTINUE
      CALL HOLFRM(SCAN(I+1),TEST,1,8,NWD)
      IF(TEST.NE.WEIGHT.AND.TEST.NE.ALIMIT) GO TO 110
      I=I+2
      GO TO 120
C
  110 CONTINUE
C****    INPUT SURFACE WAS NOT DEFINED OR INCORRECT INPUT
      IRR=01
      IF(CKDEF(SCAN(I))) GO TO 998
      MODE=2
      CALL APT094(MODE,SCAN(I),SSCAN)
      IRR=02
C****    INPUT SURFACE COULD NOT BE FETCHED FROM EXTERNAL STORAGE
      IF(MODE.NE.2) GO TO 998
C---     SURFACE HAS BEEN LOADED, EXTRACT NEEDED INFORMATION.
      NPAT=NPAT+SSCAN(4)
      NTOT=NTOT+SSCAN(8)
      NUMSUR=NUMSUR+1
  120 CONTINUE
      I=I+2
      IF(I.LT.NSIZE) GO TO 100
C
      IF(IBUG.NE.11) GO TO 130
      CALL BAD(1,0,'NPAT',NPAT)
      CALL BAD(1,0,'NTOT',NTOT)
      CALL BAD(-1,0,'NMSR',NUMSUR)
  130 CONTINUE
C****    ERROR IF THIS COMBINATION OF SURFACES IS TOO LARGE
      IRR=03
      IF(NTOT-NUMSUR*10.GT.MAXLDA) GO TO 998
C---      IF ONLY ONE SURFACE IS INPUT, THEN LEAVE IT UNALTERED
      IF(NUMSUR.EQ.1) GO TO 999
C
C---     NOW RE-READ ALL SURFACES AND CONSOLIDATE THEM INTO A
C---     A SINGLE SURFACE AFTER EACH SURFACE LOAD
C---     ALSO, STRIP OUT ALL TOPOLOGY TABLES, AS THEY WILL BE RESET.
C---     FIRST SET POINTER FOR SCANNING THRU PART PROGRAM INPUT
      I=9
C---     CURRENT AVAILABLE SLOT IN PATCH HEADER TABLE
      NHEAD=11
C---     SET CURRENT AVAILABLE SLOT IN VALUE TABLE
      NVAL=11+6*NPAT
C---     SET CURRENT AVAILABLE SLOT TO LOAD THE NEXT  SURFACE.
      NEXSUR=NVAL
C
  200 CONTINUE
      CALL HOLFRM(SCAN(I+1),TEST,1,8,NWD)
      IF(TEST.NE.WEIGHT.AND.TEST.NE.ALIMIT) GO TO 210
      I=I+2
      GO TO 299
C
  210 CONTINUE
C****    INPUT SURFACE NOT CORRECTLY DEFINED
      IRR=04
      IF(CKDEF(SCAN(I))) GO TO 998
      MODE=2
      CALL APT094(MODE,SCAN(I),SSCAN(NEXSUR))
C****    INPUT SURFACE COULD NOT BE FETCHED
      IRR=05
      IF(MODE.NE.2) GO TO 998
C---     NEXT  SURFACE IS NOW AVAILABLE.  CONSOLIDATE IT WITH
C---     THE CONSOLIDATED SURFACE.
C---     PATCH HEADER DATA MUST BE MODIFIED TO REFLECT NEW DISPLACEMENTS
C---      OF VALUE AND TOPOLOGY DATA.
C
C---     NUMBER OF PATCHES IN CURRENT INPUT SURFACE
      KPAT=SSCAN(NEXSUR+3)
C---     LENGTH OF VALUE TABLE FOR CURRENT INPUT SURFACE
      KVAL=SSCAN(NEXSUR+1)
C---     POINTER TO CURRENT PATCH HEADER DATA
      KLOC=NEXSUR+10
C---     COMPUTE NEW DISPLACEMENT FOR HEADER DATA
      DISP=NVAL-SSCAN(KLOC+4)
C---     RULE FOR DISPLACEMENT IS DIFFERENT FOR A GENCUR TYPE
      IF(SSCAN(KLOC).GT.9.0) DISP=NVAL-SSCAN(KLOC)
      IF(IBUG.NE.0) CALL BAD(-1,1,'DISP',DISP)
C
      DO 220 L=1,KPAT
      IF(SSCAN(KLOC).GT.9.0) GO TO 230
C---     CONVENTIONAL COONS BICUBIC PATCH
      SSCAN(KLOC+4)=SSCAN(KLOC+4)+DISP
      GO TO 240
C
  230 CONTINUE
C---     GENCUR TYPE PATCH
      DO 250 LL=1,4
      LK=KLOC+LL-1
      IF(SSCAN(LK).GT.SMAL) SSCAN(LK)=SSCAN(LK)+DISP
  250 CONTINUE
C
  240 CONTINUE
C---     NOW TRANSFER SIX HEADER LOCATIONS
      DO 260 LL=1,6
      SSCAN(NHEAD)=SSCAN(KLOC)
      NHEAD=NHEAD+1
      KLOC=KLOC+1
  260 CONTINUE
C---      ZERO OUT THE TOPOLOGY TABLE REFERENCE
      SSCAN(NHEAD-1)=ZERO
C
  220 CONTINUE
C
C---     NOW TRANSFER PATCH VALUE DATA IN ONE BLOCK
      KLOC=NEXSUR+9+6*KPAT
      DO 270 LL=1,KVAL
      SSCAN(NVAL)=SSCAN(KLOC+LL)
      NVAL=NVAL+1
  270 CONTINUE
C
  299 CONTINUE
      NEXSUR=NVAL
      I=I+2
      IF(I.LT.NSIZE) GO TO 200
C
C---     SURFACES HAVE ALL BEEN FETCHED AND HEADER AND VALUE DATA
C---     CONSOLIDATED INTO ONE SURFACE.
C
C---     NOW A PORTION OF THE SURFACE HEADER TABLE CAN BE FILLED
      DO 292 L=1,10
  292 SSCAN(L)=ZERO
C---     VALUE TABLE SIZE
      SSCAN(2)=NVAL-11-6*NPAT
C---     NUMBER OF PATCHES
      SSCAN(4)=NPAT
C---     TYPE OF SURFACE - NON-MESH
      SSCAN(5)=ONE
C---     SURFACE TYPE -- ASSEMBLAGE OF ALL TYPES
      SSCAN(6)=7.
C---     SIGN OF SURFACE NORMAL
      SSCAN(7)=ONE
C---     TOTAL SIZE - NOT YET KNOWN BUT SET TO CURRENT SIZE
      SSCAN(8)=NVAL-1
C
      IF(IBUG.NE.11) GO TO 291
      CALL BAD(-10,1,'SSHD',SSCAN)
      NK=NPAT*6
      CALL BAD(-NK,1,'PCHD',SSCAN(11))
      NK1=NVAL-11-NK
      NK=11+NK
      CALL BAD(-NK1,1,'VALD',SSCAN(NK))
  291 CONTINUE
C
C---     FETCH AND STORE ALL VECTORS FOR EACH PATCH CORNER
C---     BASE POINTER FOR THIS STORAGE IS IPT+1
      IPT=ISCAN-1
      ISCAN=IPT
      NLEN=NPAT*60
C****    THERE IS NOT ENOUGH BUFFER SPACE TO HOLD CORNER DATA
      IRR=06
      IF(NLEN+IPT.GT.NSCNMX) GO TO 998
C
C RESERV PRESENT NEW SURFACE
      MODE=5
      FDUMMY(2)=NVAL-1
      CALL APT094(MODE,FDUMMY,SSCAN)
C
      DO 300 ICUR=1,NPAT
C---     FETCH THE ICUR-TH PATCH
      CALL LODPCH(SSCAN,B,IFLAG,ITOP,ICUR,1)
C---     OBTAIN DATA FROM EACH CORNER
      DO 310 J=1,4
      CALL CNSURF(U(J),V(J),B,SPV,IFLAG,1)
      DO 320 K=1,3
C---     SAVE POINT,TANSPL,CRSSPL,TWIST,NORMAL
      SCAN(ISCAN+K)=SPV(K)
      SCAN(ISCAN+3+K)=SPV(K+4)
      SCAN(ISCAN+6+K)=SPV(K+8)
      SCAN(ISCAN+9+K)=SPV(K+16)
      SCAN(ISCAN+12+K)=SPV(K+28)
  320 CONTINUE
      ISCAN=ISCAN+15
  310 CONTINUE
C
  300 CONTINUE
C---     CORNER DATA HAS NOW BEEN LOADED
      IF(IBUG.NE.11) GO TO 340
      CALL BAD(-NLEN,1,'CORN',SCAN(IPT+1))
  340 CONTINUE
C
C---     PREPARE FOR SAVING TOPOLOGY CALCULATIONS
      KLIM=2*NSCNMX
      KSTART=(ISCAN+1)*2
      KNOW=KSTART+4
      DO 399 K=1,4
  399 KTOP(K+KSTART)=0
C---     FIND TOPOLOGICAL RELATIONS BY COMPARING ALL BOUNDARIES
C---     IBN OF THE  ICUR-TH PATCH TO ALL BOUNDARIES JBN OF THE
C---     PATCHES JCUR=ICUR+1,ICUR+2,... NPAT
C
      IF(NPAT.LE.1) GO TO 600
      NLIM1=NPAT-1
      DO 400 ICUR=1,NLIM1
C
      NLIM2=ICUR+1
C---     POINTER TO STORAGE OF CORNER DATA FOR PATCH ICUR.
      ICORN=(ICUR-1)*60+IPT
C---     DEVELOP DATA FOR EACH BOUNDARY OF THE ICUR TH PATCH.
      DO 410 IBN=1,4
C---      INSERT INDICES TO CORNERS OF IBN-TH BOUNDARY
      ICP(1)=IBPT(IBN,1)
      ICP(2)=IBPT(IBN,2)
      DO 420 JCUR=NLIM2,NPAT
      JCORN=(JCUR-1)*60+IPT
C---     COMPARE EACH BOUNDARY OF THIS PATCH TO OTHERS
      DO 430 JBN=1,4
      JCP(1)=IBPT(JBN,1)
      JCP(2)=IBPT(JBN,2)
C---     FIRST CHECK FOR IDENTICAL CORNER POINTS
      NP(1)=1
      NP(2)=2
C---      NOCOMP=0 IF A BOUNDARY MATCH EXISTS, 1 IF IT DOES NOT.
      NOCOMP=0
C
      K=1
  438 CONTINUE
      IF(K.GT.2) GO TO 443
C
      II=ICORN+(ICP(K)-1)*15
  439 CONTINUE
      KK=NP(K)
      JJ=JCORN+(JCP(KK)-1)*15
      W=ZERO
      DO 441 L=1,3
  441 W=W+DABS(SCAN(II+L)-SCAN(JJ+L))
      IF(W.LT.SMALP) GO TO 440
C---      MATCH FAILED, SWITCH POINTS AND RETRY
      IF(NP(1).EQ.1) GO TO 442
C---      MATCH FAILED BETWEEN POINTS BOTH WAYS - NO BOUNDARY MATCH
      NOCOMP=1
      GO TO 443
C
  442 CONTINUE
C---      SWITCH POINTS AND COMPARE AGAIN
      K=1
      NP(1)=2
      NP(2)=1
      GO TO 438
C
  440 CONTINUE
      K=K+1
      GO TO 438
C
  443 CONTINUE
C
C---      IF CORNER POINTS DO NOT MATCH, TERMINATE SEARCH BETWEEN
C---      THESE TWO BOUNDARIES, ASSUME NO RELATION.
      IF(NOCOMP.NE.0) GO TO 430
C
      IF(IBUG.NE.11) GO TO 446
      CALL BAD(1,0,'ICUR',ICUR)
      CALL BAD(1,0,'JCUR',JCUR)
      CALL BAD(1,0,'IBN ',IBN)
      CALL BAD(-1,0,'JBN ',JBN)
      CALL BAD(2,0,'NP  ',NP)
      CALL BAD(2,0,'ICP ',ICP)
      CALL BAD(-2,0,'JCP ',JCP)
  446 CONTINUE
      ACOMP=ONE
      IF(NP(1).NE.1) ACOMP=-ONE
C---     NEXT CHECK FOR IDENTICAL BOUNDARIES
      NOCOMP=0
      DO 450 K=1,2
      II=ICORN+(ICP(K)-1)*15+ICURV(IBN,1)
      KK=NP(K)
      JJ=JCORN+(JCP(KK)-1)*15+ICURV(JBN,1)
      DO 451 L=1,3
      W=SCAN(II+L)-ACOMP*SCAN(JJ+L)
      IF(DABS(W).GT.SMALV) NOCOMP=1
  451 CONTINUE
  450 CONTINUE
      IF(NOCOMP.NE.0) GO TO 430
C
C---     ALL CONDITIONS FOR A CONNECTION HAVE BEEN MET
C---     STORE THE RESULTS
      KTOP(KNOW)=ICUR
      KTOP(KNOW+1)=IBN
      KTOP(KNOW+2)=JCUR
      KTOP(KNOW+3)=JBN
      KNOW=KNOW+4
C****    NOT ENOUGH SPACE TO STORE TOPOLOGY RESULTS
      IRR=07
      IF(KNOW.GT.KLIM) GO TO 998
C
  430 CONTINUE
C
  420 CONTINUE
C
  410 CONTINUE
C
  400 CONTINUE
C
  600 CONTINUE
C
C---     TOPOLOGY RELATIONS HAVE ALL BEEN DETERMINED, NOW CONSOLIDATE
C---     THESE INTO THE SURFACE CANON FORM
      IF(IBUG.NE.11) GO TO 499
      IK=KSTART
  498 CONTINUE
      CALL BAD(-4,0,'TOPO',KTOP(IK))
      IK=IK+4
      IF(IK.LT.KNOW) GO TO 498
  499 CONTINUE
C---      SET END OF LIST OF TOPOLOGY TABLE POINTERS
      KEND=KNOW-4
C
C---      SAVE CURRENT NVAL FOR TOPOLOGY SIZE CALCULATION
      NVALSV=NVAL
C
      DO 500 ICUR=1,NPAT
C---      LCON IS NUMBER OF SIDES OF PATCH CONNECTED TO SURFACE
      LCON=0
C---     TOPOLOGY POINTER LOCATION IN CURRENT PATCH HEADER
      IHTOP=10+6*ICUR
      SSCAN(IHTOP)=NVAL
C---      SEARCH EACH BOUNDARY IPN OF THE ICUR-TH PATCH
      DO 510 IPN=1,4
      LCONSV=LCON
      SSCAN(NVAL)=ZERO
C---      SEARCH THROUGH THE ENTIRE TOPOLOGY TABLE FOR A MATCH
      DO 520 K=KSTART,KEND,4
      IF(KTOP(K).NE.ICUR.OR.KTOP(K+1).NE.IPN) GO TO 525
      SSCAN(NVAL)=-KTOP(K+2)
      LCON=LCON+1
      NVAL=NVAL+1
      GO TO 520
  525 CONTINUE
      IF(KTOP(K+2).NE.ICUR.OR.KTOP(K+3).NE.IPN) GO TO 520
      SSCAN(NVAL)=-KTOP(K)
      LCON=LCON+1
      NVAL=NVAL+1
  520 CONTINUE
      IF(LCONSV.EQ.LCON) NVAL=NVAL+1
      SSCAN(NVAL-1)=-SSCAN(NVAL-1)
  510 CONTINUE
C
      IF(LCON.GT.0) GO TO 501
      CALL CFORM(' WARNING. PATCH NOT CONNECTED TO SURFACE',
     X  DARRAY,1,40)
      CALL ICONV(ICUR,DARRAY,43,6)
      CALL CPRINT(DARRAY)
      IRR=-09
  501 CONTINUE
  500 CONTINUE
C
C---      UPDATE SURFACE SIZE AND SIZE OF TOPOLOGY TABLE
      SSCAN(8)=NVAL-1
      SSCAN(3)=NVAL-NVALSV
      GO TO 999
C
  999 CONTINUE
      IRR=0
C
C MESH TEST, 1. TOPOLOGY-POINTER
      N1TT=SSCAN(16)
C LOWER LEFT CORNER AT 1. PATCH ?
      IF(SSCAN(N1TT).NE.0.D0.OR.SSCAN(N1TT+1).NE.0.D0) GOTO 997
      IF(SSCAN(N1TT+2).EQ.0.D0.AND.
     *   SSCAN(N1TT+3).EQ.0.D0) GOTO 997
C SPLINE AND CROSS-SPLINE NUMBER
      NU=SSCAN(N1TT+3)
      IF(NU.EQ.0)NU=2
      NU1=NU-1
      NV1=SSCAN(4)/NU1
      NV=NV1+1
      SNU2=NU1-1
      ICH=1-NU1
C TEST LOOP
      DO 1000 I=1,NV1
      DO 1000 J=1,NU1
      SCH(1)=ICH
      SCH(2)=SCH(1)+SNU2
      SCH(3)=SCH(2)+2.D0
      SCH(4)=SCH(3)+SNU2
      ICH=ICH+1
      DO 1000 K=1,4
      IF(I.NE.1.AND.I.NE.NV1.AND.J.NE.1.AND.J.NE.NU1) GOTO 996
      IF(SSCAN(N1TT).EQ.0.D0) GOTO 1000
      GOTO 997
  996 IF(SSCAN(N1TT).NE.SCH(K)) GOTO 997
 1000 N1TT=N1TT+1
      SSCAN( 5)=2.D0
      SSCAN( 9)=NV
      SSCAN(10)=NU
C
      GO TO 997
C
  998 CONTINUE
      CALL BAD(-1,1,'ERR ',IRR)
C
  997 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0004128.V08   ***
*
      SUBROUTINE  SSPICT(SS,SSNAME,ISPRNT)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C------ THIS ROUTINE GENERATES A VERIFICATION LISTING REPORT FOR A
C------ SCULPTURED SURFACE CANONICAL ARRAY
C------ IN ADDITION THE ROUTINE CONDUCTS AVERAGING FOR PNTSON CASE
C
      CHARACTER*8 BLANK
      CHARACTER*4 NA(8,2),NB(8,2),NC(8)
C
      DIMENSION SS(*),B(64),SV(32),U(9),V(9),IFLAG(4),ITOP(6,4)
      DIMENSION UZ(4),VZ(4),SNM(3)
      DIMENSION IA(8),IB(8),PZ(3,2)
      DIMENSION PARE(9)
      CHARACTER*24 SSHD(9)
      CHARACTER*16 SSNAME
C------ SETUP VARIABLES TO SAVE MESH POINTS DURING DEFINITION
C---     NSCNMX IS THE MAXIMUM SPACE AVAILABLE IN SCAN
C---     ISCAN IS THE LAST USED LOCATION IN SCAN
C---     SCAN IS A SCRATCH PAD WORK AREA FOR SS CALCULATIONS
      INCLUDE (SSPAD)    
C---     ARRAY IISCAN IS USED  TO STORE INTEGERS IN SCAN
      DIMENSION IISCAN(2*ISCN)
      EQUIVALENCE (IISCAN(1),SCAN(1))
C---     ASSUMPTION ONE INTEGER IS ONE HALF THE LENGTH OF A REAL.
C
      DIMENSION PT(3,4),SNT(3,4)
      DIMENSION LOC(4),MP(4),MS(4),IAR(12)
      CHARACTER*120 DARRAY,HEADR1,HEADR2,HEADR3,
     C HEADR4,HEADR5
      CHARACTER*3 IB1234(4)
      DATA IB1234/'B1=','B2=','B3=','B4='/
      DATA HEADR1   /   ' PT=SURFACE POINT,TN=FIRST(SPLINE) DIRECTION,CS
     C =SECOND(CROSS SPLINE) DIRECTION, NR=SURFACE NORMAL
     C       '/
      DATA HEADR2   /   ' EACH PATCH HAS FOUR CORNERS PT00,PT10,PT01,PT1
     C1. BOUNDARY B1=PT00-PT10, B2=PT00-PT01, B3=PT10-PT11, B4=PT01-PT11
     C       '/
      DATA HEADR3   /   ' NR50,NR05, ETC REPRESENT SURFACE NORMALS AT IN
     CTERIM PTS. NR05 REPRESENTS A NORMAL AT U=0,V=0.5 MIDWAY BETWEEN PT
     C00-PT01'/
      DATA HEADR4   /   ' POSITIVE RADII AND CURVATURES ARE CUPPED IN TH
     CE DIRECTION OF THE SURFACE NORMALS NRI,NRJ,NRK
     C       '/
      DATA HEADR5    /   ' PATCH     X        Y        Z        W
     C         X        Y        Z        W              NRI     NRJ
     C NRK    '/
C
      DATA SSHD/
     X   'VALUE TABLE SIZE        ',
     X   'TOPOLOGY TABLE SIZE     ',
     X   'NUMBER OF PATCHES       ',
     X   'SURFACE TYPE(MESH=2)    ',
     X   'PNTVEC,POLYGN,PNTSON    ',
     X   'SIGN OF NORMAL(TN X CR) ',
     X   'TOTAL SIZE OF SURF      ',
     X   'NUMBER OF SPLINES       ',
     X   'NUMBER OF CROSS SPLINES '/
      DATA NA/'PT00','PT10','TN00','TN10','CR00','CR10','TW00','TW10',
     X        'PT00','PT50','PT10','PT01','PT51','PT11','PT05','PT15'/
      DATA NB/'PT01','PT11','TN01','TN11','CR01','CR11','TW01','TW11',
     X        'CR00','CR50','CR10','CR01','CR51','CR11','CR05','CR15'/
      DATA NC/'NR00','NR50','NR10','NR01','NR51','NR11','NR05','NR15'/
      DATA UZ,VZ/0.0D0,1.0D0,0.0D0,1.0D0,0.0D0,0.0D0,1.0D0,1.0D0/
      DATA U/0.0D0,0.5D0,1.0D0,0.0D0,0.5D0,1.0D0,0.0D0,1.0D0,0.5D0/
      DATA V/3*0.0D0,3*1.0D0,3*0.5D0/
      DATA IA/1,2,3,4,9,10,11,12/
      DATA IB/5,6,7,8,13,14,15,16/
      DATA IAR/3,9,4,10,7,13,8,14,11,12,15,16/
      DATA LOC/1,3,4,6/
      DATA ZERO,SMAL1/0.0D0,1.0D-11/
      DATA BLANK/'        '/
C
      NTOT=SS(4)
      NP=SS(10)
      NS=SS(9)
      NMESH=SS(5)
      NTYP=SS(6)
      CMAX=-1.0D+5
      CMIN=1.0D+5
      IF(NMESH.NE.2) SS(9)=0.0
      IF(NMESH.NE.2) SS(10)=0.0
C------ AT THIS POINT PATCH AVERAGING IS DONE FOR THE
C------ POINTS ON CASE
C---     COMPUTE LOCATIONS FOR DATA STORAGE IN SCAN
C---     ALSO DETERMINE WHETHER SCAN HAS ENOUGH ROOM
C---     IF THE DATA IS TOO VOLUMINOUS THE DISPLAY IS SKIPPED
      NPTMAX=SS(4)*4.
      IF(NMESH.EQ.2) NPTMAX=NP*NS
      NPTMAX=NPTMAX+1
C---     INDEX TO CORNER POINT STORAGE
      IPMESH=0
C---     INDEX TO SCAN FOR CORNER SURFACE NORMALS
      ISNMES=NPTMAX*3-1
C---     AREAS FOR STORAGE OF INTEGER ARRAYS
      INUN=NPTMAX*6*2-1
      INUNQ=INUN+NPTMAX
      ICOMP=INUNQ+NPTMAX
C
      NQMAX=(15*NPTMAX)/2+2
      IF(NQMAX.LE.NSCNMX) GO TO 773
C****    NOT ENOUGH SPACE FOR SSPICT CALCULATION.  BYPASS.
      CALL CFORM('0 NOT ENOUGH SPACE TO DISPLAY ',DARRAY,1,29)
      CALL CFORM(SSNAME,DARRAY,37,16)
      CALL CPRIN1(DARRAY)
      GO TO 130
  773 CONTINUE
      IF(NMESH.NE.1.OR.NTYP.NE.3) GO TO 1000
C------ COMMENCE PATCH AVERAGING BY CONSTRUCTING A TABLE OF
C------ CORNER POINTS AND CORNER NORMALS
      NCT=0
      DO 1010 I=1,NTOT
      CALL LODPCH(SS,B,IFLAG,ITOP,I,3)
      DO 1010 L=1,4
      CALL CNSURF(UZ(L),VZ(L),B,SV,IFLAG,1)
      NCT=NCT+1
      DO 1020 K=1,3
      SCAN(IPMESH+NCT*3-3+K)=SV(K)
      SCAN(ISNMES+NCT*3-3+K)=SV(K+28)
 1020 CONTINUE
 1010 CONTINUE
      NCOMP=4*NTOT
      DO 1030 I=1,NCOMP
 1030 IISCAN(ICOMP+I)=I
C------ SEARCH THRU THE TABLE OF POINTS TO FIND EQUALS
C------ IF A LATER POINT EQUALS AN EARLIER, THEN REFERENCE
C------ THE EARLIER POINT IN ICOMP
      ICOMPC=0
      NCOMPM=NCOMP-1
C------ ICOMPC KEEPS TRACK OF THE TOTAL NUMBER OF UNIQUE POINTS
      DO 1040 I=1,NCOMPM
      IF(IISCAN(ICOMP+I).NE.I) GO TO 1040
      J=I+1
      DO 1050 K=J,NCOMP
      II=IPMESH+I*3-3
      KK=IPMESH+K*3-3
      D=(SCAN(II+1)-SCAN(KK+1))**2+(SCAN(II+2)-SCAN(KK+2))**2
     X  +(SCAN(II+3)-SCAN(KK+3))**2
      IF(D.LT.SMAL1) IISCAN(ICOMP+K)=I
 1050 CONTINUE
      ICOMPC=ICOMPC+1
      IISCAN(INUN+ICOMPC)=I
C------ICOMPC CONTAINS THE NUMBER OF UNIQUE POINTS AND IISCAN(INUN+)
C------ CONTAINS THE FIRST POINT IN EACH UNIQUE STRING.
 1040 CONTINUE
      DO 1060 I=1,ICOMPC
      J=IISCAN(INUN+I)
      NCT=0
      DO 1065 K=1,3
 1065 SNM(K)=0.0
      DO 1070 K=J,NCOMP
      IF(IISCAN(ICOMP+K).NE.J) GO TO 1070
      JJ=ISNMES+J*3-3
      KK=ISNMES+K*3-3
      W=SCAN(JJ+1)*SCAN(KK+1)+SCAN(JJ+2)*SCAN(KK+2)
     X  +SCAN(JJ+3)*SCAN(KK+3)
      SQ=1.0
      IF(W.LT.0.0D0) SQ=-1.0
      DO 1080 L=1,3
 1080 SNM(L)=SNM(L)+SQ*SCAN(ISNMES+K*3-3+L)
      NCT=NCT+1
      IISCAN(INUNQ+NCT)=K
 1070 CONTINUE
      DSNM=0.0
      DO 1090 K=1,3
      SNM(K)=SNM(K)/NCT
      DSNM=DSNM+SNM(K)**2
 1090 CONTINUE
      DSNM=DSQRT(DSNM)
      DO 1100 L=1,3
 1100 SNM(L)=SNM(L)/DSNM
C------SNM IS AN AVERAGED SURFACE NORMAL AT THE CURRENT UNIQUE PT
C------ REPLACE EACH NORMAL VECTOR IN THE LIST WITH ITS CORRES-
C------ PONDING AVERAGED NORMAL.
      DO 1110 L=1,NCT
      DO 1110 K=1,3
      M=IISCAN(INUNQ+L)
      SCAN(ISNMES+M*3-3+K)=SNM(K)
 1110 CONTINUE
 1060 CONTINUE
C------ FINALLY ALTER THE TANGENTS AND ZERO THE TWISTS
      DO 1120 L=1,NTOT
      DO 1120 K=1,4
      IC=K+4*(L-1)
      IBREL=10+6*(L-1)+5
      IBREL=SS(IBREL)-1.0
      DO 1130 M=1,2
      MC=2*(K-1)+M
      IV=IBREL+IAR(MC)
      IIC=ISNMES+3*IC-3
      DOT=SS(IV)*SCAN(IIC+1)+SS(IV+16)*SCAN(IIC+2)
     X    +SS(IV+32)*SCAN(IIC+3)
      DO 1140 LL=1,3
 1140 SS(IV+16*LL-16)=SS(IV+16*LL-16)-DOT*SCAN(ISNMES+IC*3-3+LL)
 1130 CONTINUE
C------ ZERO OUT TWIST VECTORS
      DO 1150 M=9,12
      IV=IAR(M)+IBREL
      DO 1150 LL=1,3
      SS(IV+16*LL-16)=ZERO
 1150 CONTINUE
 1120 CONTINUE
 1000 CONTINUE
C------ THE PNTSON  SURFACE HAS NOW BEEN AVERAGED
C
      DO 3000 I=1,15
      I8=I*8
 3000 DARRAY(I8-7:I8)=BLANK
      CALL CFORM('1',DARRAY,1,1)
      CALL CPRIN1(DARRAY)
      CALL CFORM(' SCULPTURED SURFACE ',DARRAY,20,20)
      CALL CFORM(SSNAME,DARRAY,52,16)
      CALL CPRIN1(DARRAY)
      CALL CFORM('0',DARRAY,1,1)
      CALL CPRIN1(DARRAY)
      IF(ISPRNT.EQ.2) GO TO 3020
      DARRAY=HEADR1
      CALL CPRIN1(DARRAY)
      DARRAY=HEADR2
      CALL CPRIN1(DARRAY)
      DARRAY=HEADR3
      CALL CPRIN1(DARRAY)
      DARRAY=HEADR4
      CALL CPRIN1(DARRAY)
 3020 CALL CFORM('0SS HEADER TABLE',DARRAY,1,16)
      CALL CPRIN1(DARRAY)
C---     WRITE OUT SS HEADER INFORMATION
      DO 3008 J=1,9
      CALL CFORM(SSHD(J),DARRAY,2,24)
      NIU=SS(J+1)
      CALL ICONV(NIU,DARRAY,27,6)
      CALL CPRIN1(DARRAY)
 3008 CONTINUE
C
      CALL CFORM('0',DARRAY,1,1)
      CALL CPRIN1(DARRAY)
      IF(ISPRNT.EQ.2) GO TO 3121
      DARRAY=HEADR5
      CALL CPRIN1(DARRAY)
C
 3121 AREA=0.0
      DO 90 I=1,NTOT
      IF(ISPRNT.EQ.2) GO TO 3021
      CALL VORSCH( 12,HEADR5)
      CALL CFORM(' PATCH NUMBER ',DARRAY,1,14)
      CALL ICONV(I,DARRAY,16,5)
      CALL CPRIN1(DARRAY)
 3021 CALL LODPCH(SS,B,IFLAG,ITOP,I,3)
      DO 80 L=1,8
      CALL CNSURF(U(L),V(L),B,SV,IFLAG,1)
      D=DSQRT(SV(25)**2+SV(26)**2+SV(27)**2)
      PARE(L)=D
      MA=IA(L)
      MB=IB(L)
C--- COMPUTE THE EUCLIDEAN X,Y,Z COORDINATES FOR DISPLAY
      MDIF=MB-MA
C---     SET INDEX TO NA TO NON-GENCUR TYPE
      IGENCR=1
C---     SPECIAL TEMPORARY PATH FOR GENCUR SURFACE
      IF(IFLAG(1).LT.9) GO TO 47
C---     SET INDEX TO NA TO GENCUR TYPE
      IGENCR=2
C
      DO 46 IIL=1,3
      PZ(IIL,1)=SV(IIL)
      PZ(IIL,2)=SV(IIL+8)
   46 CONTINUE
      GO TO 61
   47 CONTINUE
      IF(L.LT.3) GO TO 41
      IF(L.LT.7) GO TO 51
C--- LEAVE TWIST VECTORS AS IS
      DO 62 IM=1,2
      MM=MA+MDIF*(IM-1)
      DO 62 IL=1,3
   62 PZ(IL,IM)=B(MM+16*IL-16)
      GO TO 61
C--- DIVIDE X,Y, AND Z COORDINATES BY W
   41 CONTINUE
      DO 42 IM=1,2
      MM=MA+MDIF*(IM-1)
      W=B(MM+48)+SMAL1
      DO 42 IL=1,3
   42 PZ(IL,IM)=B(MM+IL*16-16)/W
      GO TO 61
   51 CONTINUE
C--- DERIVATIVES ARE MODIFIED BY (DX*W-DW*X)/W**2
      DO 52 IM=1,2
      MM=MA+MDIF*(IM-1)
      MMP=MOD(L+1,2)+1+(IM-1)*4
      W=B(MMP+48)
      WP=B(MM+48)
      DO 52 IL=1,3
      PZ(IL,IM)=(W*B(MM+16*IL-16)-WP*B(MMP+16*IL-16))/(W+SMAL1)**2
   52 CONTINUE
   61 CONTINUE
      IF(ISPRNT.EQ.2) GO TO 3022
C
      CALL CFORM(NA(L,IGENCR),DARRAY,2,4)
      K=7
      DO 3031 IW=1,3
      CALL FCONV(PZ(IW,1),DARRAY,K,9,3)
      K=K+9
 3031 CONTINUE
      CALL FCONV(B(MA+48),DARRAY,K,9,3)
      K=K+12
      CALL CFORM(NB(L,IGENCR),DARRAY,K,4)
      K=K+5
      DO 3032 IY=1,3
      CALL FCONV(PZ(IY,2),DARRAY,K,9,3)
      K=K+9
 3032 CONTINUE
      CALL FCONV(B(MB+48),DARRAY,K,9,3)
      K=K+12
      CALL CFORM(NC(L),DARRAY,K,4)
      K=K+6
      DO 3033 IZ=29,31
      CALL FCONV(SV(IZ),DARRAY,K,8,5)
      K=K+8
 3033 CONTINUE
      CALL CPRIN1(DARRAY)
C
C------SAVE CORNER POINTS AND NORMALS AS THEY ARE GENERATED
 3022 IF(NMESH.NE.2) GO TO 330
      DO 310 LLOC=1,4
      LLC=LOC(LLOC)
      IF(LLC.NE.L) GO TO 310
C------ CASE L HAS GENERATED THE LLOC TH CORNER.  SAVE POINT AND NORMAL
      DO 320 LK=1,3
      PT(LK,LLOC)=SV(LK)
      SNT(LK,LLOC)=SV(LK+28)
  320 CONTINUE
  310 CONTINUE
  330 CONTINUE
   80 CONTINUE
      CALL CNSURF(U(9),V(9),B,SV,IFLAG,1)
C
      IF(ISPRNT.EQ.2) GO TO 3023
      IF(IGENCR.NE.2)GOTO 3045
C    GENCUR-OBERFLAECHE HAT KEINE RELEVANTEN FLAGS
      K=8
      GOTO 3046
 3045 CALL CFORM(' FLAGS=',DARRAY,1,7)
      K=8
      DO 3040 JJ=1,4
      CALL ICONV(IFLAG(JJ),DARRAY,K,1)
      K=K+1
      CALL CFORM(',',DARRAY,K,1)
      K=K+1
 3040 CONTINUE
 3046 K=K+1
      DO 3041 LL=1,4
      CALL CFORM(IB1234(LL),DARRAY,K,3)
      K=K+3
      CALL ICONV(ITOP(2,LL),DARRAY,K,3)
      K=K+4
 3041 CONTINUE
      CALL CFORM(' PT55 ',DARRAY,K,6)
      K=K+6
      DO 3042 LJ=1,3
      CALL FCONV(SV(LJ),DARRAY,K,9,3)
 3042 K=K+12
      CALL CFORM('NR55 ',DARRAY,K,5)
      K=K+5
      DO 3043 JL=29,31
      CALL FCONV(SV(JL),DARRAY,K,8,4)
 3043 K=K+8
      CALL CPRIN1(DARRAY)
C
 3023 D=DSQRT(SV(25)**2+SV(26)**2+SV(27)**2)
      PARE(L)=D
      PAREA=(PARE(1)+PARE(3)+PARE(4)+PARE(6)+2.0*(PARE(2)+PARE(5)+
     C        PARE(7)+PARE(8))+4.0*PARE(9))/16.0
      G11=SV(5)**2+SV(6)**2+SV(7)**2
      G12=SV(5)*SV(9)+SV(6)*SV(10)+SV(7)*SV(11)
      G22=SV(9)**2+SV(10)**2+SV(11)**2
      A11=SV(13)*SV(29)+SV(14)*SV(30)+SV(15)*SV(31)
      A12=SV(17)*SV(29)+SV(18)*SV(30)+SV(19)*SV(31)
      A22=SV(21)*SV(29)+SV(22)*SV(30)+SV(23)*SV(31)
      C=A11*A22-A12*A12
      E=-G11*A22+2.0*G12*A12-G22*A11
      A=G11*G22-G12*G12
      DD=E*E-4.0*A*C
      IF(DD.LT.ZERO)GO TO 170
      DD=DSQRT(DD)
      CA=(-E+DD)/(A+A)
      CB=(-E-DD)/(A+A)
      HM=(CA+CB)/2.D0
      GK=CA*CB
      SMAL=1.0D-5
      RA=1.0/(CA+SMAL)
      RB=1.0/(CB+SMAL)
C------ SAVE THE CRITICAL CURVATURES
      CBIG=CA
      CSMAL=CA
      IF(CBIG.LT.CB) CBIG=CB
      IF(CSMAL.GT.CB) CSMAL=CB
      IF(CBIG.LT.CMAX) GO TO 210
      CMAX=CBIG
      ICMAX=I
  210 IF(CSMAL.GT.CMIN) GO TO 220
      CMIN=CSMAL
      ICMIN=I
  220 CONTINUE
C
      IF(ISPRNT.EQ.2) GO TO 170
      CALL CFORM(' PATCH AREA=',DARRAY,1,12)
      K=13
      CALL FCONV(PAREA,DARRAY,K,12,5)
      K=K+12
      CALL CFORM(' CURVATURES=',DARRAY,K,12)
      K=K+12
      CALL FCONV(CA,DARRAY,K,10,4)
      K=K+10
      CALL FCONV(CB,DARRAY,K,10,4)
      K=K+10
      CALL CFORM(' MEAN & GAUSS=',DARRAY,K,14)
      K=K+14
      CALL FCONV(HM,DARRAY,K,10,4)
      K=K+10
      CALL FCONV(GK,DARRAY,K,10,4)
      K=K+10
      CALL CFORM(' RADII=',DARRAY,K,7)
      K=K+7
      CALL FCONV(RA,DARRAY,K,12,3)
      K=K+12
      CALL FCONV(RB,DARRAY,K,10,3)
      CALL CPRIN1(DARRAY)
      CALL CPRIN1(DARRAY)
C
  170 CONTINUE
      IF(NMESH.NE.2) GO TO 350
C------ PACK THE FOUR CORNER POINTS AND NORMALS INTO THE MESH ARRAY
C------ MP IS THE POINT LOCATION ON A SPLINE
C------ MS IS THE SPLINE NUMBER
      MP(1)=MOD(I-1,NP-1)+1
      MS(1)=(I-1)/(NP-1)+1
      MP(2)=MP(1)+1
      MS(2)=MS(1)
      MP(3)=MP(1)
      MS(3)=MS(1)+1
      MP(4)=MP(1)+1
      MS(4)=MS(3)
      DO 380 KK=1,4
      NCURR=(MS(KK)-1)*NP+MP(KK)
      DO 380 KKK=1,3
      SCAN(IPMESH+NCURR*3-3+KKK)=PT(KKK,KK)
      SCAN(ISNMES+NCURR*3-3+KKK)=SNT(KKK,KK)
  380 CONTINUE
  350 CONTINUE
      AREA=AREA+PAREA
   90 CONTINUE
C
      CALL VORSCH ( 7,DARRAY)
      CALL CPRIN1(DARRAY)
      CALL CFORM('0',DARRAY,1,1)
      CALL CPRIN1(DARRAY)
      CALL CFORM(' APPROXIMATE TOTAL SURFACE AREA=',DARRAY,1,32)
      K=35
      CALL FCONV(AREA,DARRAY,K,15,6)
      CALL CPRIN1(DARRAY)
C
      RMAX=1.0/(CMAX+SMAL)
      RMIN=1.0/(CMIN+SMAL)
C
C
      CALL CFORM('0  CRITICAL CURVATURES ON THE SURFACE',DARRAY,1,37)
      CALL CPRIN1(DARRAY)
      CALL CFORM('MAXIMUM SIGNED CURVATURE AND RADIUS=',DARRAY,10,36)
      K=46
      CALL FCONV(CMAX,DARRAY,K,15,5)
      K=K+17
      CALL FCONV(RMAX,DARRAY,K,15,5)
      K=K+15
      CALL CFORM('   AT PATCH NUMBER',DARRAY,K,18)
      K=K+18
      CALL ICONV(ICMAX,DARRAY,K,5)
      CALL CPRIN1(DARRAY)
      CALL CFORM('MINIMUM SIGNED CURVATURE AND RADIUS=',DARRAY,10,36)
      K=46
      CALL FCONV(CMIN,DARRAY,K,15,5)
      K=K+17
      CALL FCONV(RMIN,DARRAY,K,15,5)
      K=K+15
      CALL CFORM('   AT PATCH NUMBER',DARRAY,K,18)
      K=K+18
      CALL ICONV(ICMIN,DARRAY,K,5)
      CALL CPRIN1(DARRAY)
C
C
      IF(NMESH.NE.2) GO TO 480
      CALL VORSCH(15,DARRAY)
      CALL CFORM('0',DARRAY,1,1)
      CALL CPRIN1(DARRAY)
      CALL CFORM('MESH PATTERN OF POINTS AND NORMALS',DARRAY,10,34)
      CALL CPRIN1(DARRAY)
      CALL CFORM('0  POINT',DARRAY,1,8)
      K=17
      CALL CFORM('X',DARRAY,K,1)
      K=K+13
      CALL CFORM('Y',DARRAY,K,1)
      K=K+13
      CALL CFORM('Z',DARRAY,K,1)
      K=K+26
      CALL CFORM('SNI',DARRAY,K,3)
      K=K+13
      CALL CFORM('SNJ',DARRAY,K,3)
      K=K+13
      CALL CFORM('SNK',DARRAY,K,3)
      CALL CPRIN1(DARRAY)
C
      DO 440 IMM=1,NS
C
      CALL VORSCH( 5,DARRAY)
      CALL CFORM('0',DARRAY,1,1)
      CALL CFORM('SPLINE NUMBER=',DARRAY,15,14)
      CALL ICONV(IMM,DARRAY,30,6)
      CALL CFORM('(V=....)',DARRAY,40,8)
      CALL ICONV(IMM-1,DARRAY,43,4)
      CALL CPRIN1(DARRAY)
C
      DO 440 IIP=1,NP
      NCURR=(IMM-1)*NP+IIP
C
      CALL VORSCH ( 1,DARRAY)
      CALL ICONV(IIP,DARRAY,4,4)
      CALL CFORM('*',DARRAY,8,1)
      K=12
      DO 3050 LLL=1,3
      CALL FCONV(SCAN(IPMESH+NCURR*3-3+LLL),DARRAY,K,12,5)
      CALL CFORM(',',DARRAY,K+12,1)
      K=K+13
 3050 CONTINUE
      K=K+10
      DO 3051 LN=1,3
      CALL FCONV(SCAN(ISNMES+NCURR*3-3+LN),DARRAY,K,12,5)
      IF(LN.LT.3) CALL CFORM(',',DARRAY,K+12,1)
      K=K+13
 3051 CONTINUE
      CALL CFORM('(U=....)',DARRAY, K+6,8)
      CALL ICONV(IIP-1,DARRAY,K+9,4)
      CALL CPRIN1(DARRAY)
C
  440 CONTINUE
C
C        PRINT OUT CROSS SPLINE INFORMATION
C
      CALL CFORM('0',DARRAY,1,1)
      CALL CPRIN1(DARRAY)
C
      DO 450 IIP=1,NP
      CALL VORSCH ( 5,DARRAY)
      CALL CFORM('0',DARRAY,1,1)
      CALL CFORM('CROSS SPLINE NUMBER=',DARRAY,15,20)
      CALL ICONV(IIP,DARRAY,36,6)
      CALL CFORM('(U=....)',DARRAY,46,8)
      CALL ICONV(IIP-1,DARRAY, 49,4)
      CALL CPRIN1(DARRAY)
C
      DO 450 IMM=1,NS
      MCURR=IMM*NP-(NP-IIP)
      CALL VORSCH ( 1,DARRAY)
      CALL ICONV(IMM,DARRAY,4,4)
      CALL CFORM('*',DARRAY,8,1)
      K=12
      DO 460 LLL=1,3
      CALL FCONV(SCAN(IPMESH+MCURR*3-3+LLL),DARRAY,K,12,5)
      CALL CFORM(',',DARRAY,K+12,1)
       K=K+13
 460  CONTINUE
      K=K+10
      DO 470 LN=1,3
      CALL FCONV(SCAN(ISNMES+MCURR*3-3+LN),DARRAY,K,12,5)
      IF(LN.LT.3) CALL CFORM(',',DARRAY,K+12,1)
      K=K+13
 470  CONTINUE
      CALL CFORM('(V=....)',DARRAY, K+6,8)
      CALL ICONV(IMM-1,DARRAY,K+9,4)
      CALL CPRIN1(DARRAY)
 450  CONTINUE
C
  480 CONTINUE
  130 RETURN
      END
**** SOURCE FILE : M0004143.V04   ***
*
      SUBROUTINE SSPLIN(S,IRR)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION S(4,6,31)
C------ S IS AN INPUT ARRAY CONTAINING ALL POINTS AND CONSTRAINTS
C------ FOR A SPLINE FIT
C------ UPON RETURN S CONTAINS ALL OF THE PROCESSED OUTPUT DATA
C------ IRR IS AN ERROR INDICATOR.  ON  RETURN IRR IS ZERO IF
C------ NO ERRORS OCCURRED DURING PROCESSING WHILE IF AN
C------ ERROR DID OCCUR IRR GIVES THE APPROPRIATE ERROR NUMBER
C------ THE STRUCTURE OF S( IC, IL, IB ) IS AS FOLLOWS
C------ IB IS THE BLOCK OR POINT NUMBER( THE FIRST BLOCK IS A
C------ HEADER)
C------ IL  IS THE LINE NUMBER OF THE BLOCK
C------ IC IS THE COORDINATE NUMBER OF THE LINE
C------ ON INPUT S IS STRUCTURED AS FOLLOWS
C      S(1-3,1,2) = X,Y,Z OF THE INPUT POINT
C      S(1-4,2,2) = I,J,K OF TANSPL CONSTRAINT AND INDICATOR(0 OR 1)
C      S(1-4,3,2) = I,J,K OF CRSSPL CONSTRAINT AND INDICATOR(0 OR 1)
C      S(1-4,4,2) = I,J,K OF NORMAL CONSTRAINT AND INDICATOR(0 OR 1)
C      S(1,5,2) = WEIGHT FACTOR FOR SMOOTHING
C      S(2,5,2) = LIMIT FACTOR TO LIMIT MOVEMENT IN SMOOTHING
C      S(1-4,6,2) ,S(4,1,2) AND S(3-4,5,2) ARE NOT INITIATED INPUT
C------ OUTPUT CONTAINS THE FOLLOWING ADDITIONAL INFORMATION
C      S(1-3,1,2) = X,Y,Z OF THE SMOOTHED INPUT POINT
C      S(4,1,2)   = DISTANCE FROM THIS POINT TO THE NEXT
C      S(1-3,2,2) = I,J,K OF UNIT TANGENT VECTOR GENERATED AT THE PT
C      S(1,5,2) = WEIGHT WHICH GIVES CERTITUDE(1.0)
C      S(2,5,2) = INPUT LIMIT
C      S(3,5,2) = ORIGINAL INPUT WEIGHT
C      S(4,5,2) =  MEASUREMENT OF WILDNESS RELATIVE TO ADJACENT POINTS
C      S(1-3,6,2) = X,Y,Z OF THE ORIGINAL INPUT POINT
C      S(4,6,2)   = DISTANCE OF OUTPUT POINT FROM INPUT
C------ THE HEADER CONTAINS THE FOLLOWING INFORMATION
C      S(2,1,1) = LENGTH OF THE HEADER TABLE IN BLOCKS(=1)
C      S(3,1,1) = ORIGIN OF CALL  SSURF/MESH = 1, SCURV/SPLINE=2
C                 SCURV/CURSEG =3
C      S(4,1,1) = NUMBER OF POINT BLOCKS USED(GE.2)
      DIMENSION P(3,30),W(30),D(30),TV(3,2),V(3,30)
      DIMENSION T(3),TA(3),TB(3)
C------ LOGICAL FLAGS ARE TRUE WHEN NO CONSTRAINT IS PRESENT
C------ ID(1,I) TRUE MEANS THERE IS NO TANSPL CONSTRAINT AT ITH PT
C------ ID(2,I) TRUE MEANS THERE IS NO CRSSPL CONSTRAINT AT ITH PT
C------ ID(3,I) TRUE MEANS THERE IS NO NORMAL CONSTRAINT AT ITH PT
      LOGICAL ITAN,ICRS,INOR,IWGT,ILIM,ID(3,31)
      DATA SMAL1,SMAL2/1.0D-8,1.0D-12/
      NP=S(4,1,1)
      IORG=S(3,1,1)
      NHD=S(2,1,1)
      NTOT=NP+NHD
      NPL=NHD+1
      NPLP=NPL+1
      NPH=NTOT
      NPHM=NPH-1
C------ MOVE INPUT POINTS INTO SIXTH LINE FOR SAVING
      DO 30 I=NPL,NPH
      S(4,6,I)=0.0
      DO 20 L=1,3
   20 S(L,6,I)=S(L,1,I)
   30 CONTINUE
C------ THERE SHOULD BE AT LEAST TWO POINTS IN A SPLINE
      IRR=5901
      IF(NP.LT.2) GO TO 998
C------ CHECK FOR IDENTICAL POINTS
      IF(IORG.EQ.3) GO TO 200
 10   IRR=5902
      DO 100 I=NPL,NPHM
      INX=I+1
      SUM=0.0
      DO 110 L=1,3
      SUM=SUM+(S(L,1,INX)-S(L,1,I))**2
  110 CONTINUE
      IF(SUM.LT.SMAL1) GO TO 998
  100 CONTINUE
      GO TO 300
  200 CONTINUE
C------ CHECK FOR ANY TWO POINTS IDENTICAL IN CURSEG CASE
      IRR=5903
      DO 210 I=NPL,NPHM
      INX=I+1
      DO 210 J=INX,NPH
      SUM=0.0
      DO 220 L=1,3
      SUM=SUM+(S(L,1,J)-S(L,1,I))**2
  220 CONTINUE
      IF(SUM.LT.SMAL1) GO TO 998
  210 CONTINUE
  300 CONTINUE
C------ DETERMINE THE PRESENCE OF CONSTRAINTS OF DIFFERENT TYPES
C1----- IF A FLAG IS TRUE THEN THERE IS NO CONSTRAINT OF THIS TYPE
      INOR=.TRUE.
      ITAN=.TRUE.
      ICRS=.TRUE.
      IWGT=.TRUE.
      ILIM=.TRUE.
      DO 340 I=NPL,NPH
      DO 340 K=1,3
      KK=K+1
      DUM=S(4,KK,I)-1.0
      DUM=DABS(DUM)
      ID(K,I)=.TRUE.
      IF(DUM.GT.SMAL1) GO TO 340
      ID(K,I)=.FALSE.
  340 CONTINUE
      DO 310 I=NPL,NPH
      IF(.NOT.ID(1,I)) ITAN=.FALSE.
      IF(.NOT.ID(2,I)) ICRS=.FALSE.
      IF(.NOT.ID(3,I)) INOR=.FALSE.
C---  CII UPDATE TO INITIALIZE WT AND LIM. NIU-APR/75E
      IF(DABS(S(1,5,I)-1.0).GT.SMAL1) IWGT=.FALSE.
      IF(DABS(S(2,5,I)).GT.SMAL1) ILIM=.FALSE.
  310 CONTINUE
C------ SKIP THE NEXT SECTION IF WEIGHTS ARE NOT EFFECTED
      IF(IWGT) GO TO 500
C------ WEIGHTS ARE PRESENT, MAKE A SMOOTHING PASS TO OBTAIN NEW
C------ POINT POSITIONS
  400 CONTINUE
      DO 420 I=NPL,NPH
      DO 410 L=1,3
      DO 410 J=1,2
  410 TV(L,J)=0.0
      J=I-NHD
      W(J)=S(1,5,I)
      S(3,5,I)=W(J)
      DO 420 L=1,3
  420 P(L,J)=S(L,1,I)
      IDC=5
      CALL SMOOTH(P,W,D,TV,V,NP,IDC)
      IRR=5904
      IF(IDC.LT.0) GO TO 998
C------ RELOAD NEW POINTS INTO THE S ARRAY
      DO 430 I=NPL,NPH
      J=I-NHD
      S(1,5,I)=1.0
      IF(ILIM) GO TO 450
C------ VAL IS THE DISTANCE BETWEEN THE OLD POINT AND NEW POINT
      VAL=DSQRT((P(1,J)-S(1,1,I))**2+(P(2,J)-S(2,1,I))**2
     X          +(P(3,J)-S(3,1,I))**2)
      IF(VAL.LE.DABS(S(2,5,I))) GO TO 450
C------ BRING THE POINT BACK INTO THE LIMITED SPHERE AROUND THE OLD
      VAL=DABS(S(2,5,I))/VAL
      DO 440 L=1,3
  440 P(L,J)=S(L,1,I)+VAL*(P(L,J)-S(L,1,I))
      VAL=DABS(S(2,5,I))
  450 CONTINUE
      DO 460 L=1,3
      S(L,6,I)=S(L,1,I)
      S(L,1,I)=P(L,J)
  460 CONTINUE
      S(4,6,I)=VAL
  430 CONTINUE
C------ NOW RECYCLE THRU PRIOR LOGIC WITH NEW POINTS AND NO WEIGHTS
      GO TO 10
  500 CONTINUE
      IF(INOR.AND.ICRS.AND.ITAN) GO TO 700
C------ CHECK FOR NULL CONSTRAINT VECTORS AND UNITIZE ALL
      IRR=5905
      DO 600 I=NPL,NPH
      DO 630 K=2,4
      IF(ID(K-1,I)) GO TO 630
      SUM=S(1,K,I)**2+S(2,K,I)**2+S(3,K,I)**2
      IF(SUM.LT.SMAL1) GO TO 998
      SUM=DSQRT(SUM)
      DO 620 L=1,3
  620 S(L,K,I)=S(L,K,I)/SUM
  630 CONTINUE
  600 CONTINUE
  700 CONTINUE
C------ REORIENT TANSPL VECTORS BASED ON THE DIRECTION INDICATED BY PTS
      IF(ITAN) GO TO 790
      DO 710 I=NPL,NPH
      IF(ID(1,I)) GO TO 710
      NLO=MAX0(I-1,NPL)
      NHI=MIN0(I+1,NPH)
      SUM=0.0
      DO 720 L=1,3
      T(L)=S(L,1,NHI)-S(L,1,NLO)
      SUM=SUM+T(L)*S(L,2,I)
  720 CONTINUE
      IF(SUM.GE.0.0) GO TO 710
C------ REORIENT THIS TANGENT CONSTRAINT
      DO 730 L=1,3
  730 S(L,2,I)=-S(L,2,I)
  710 CONTINUE
  790 CONTINUE
      IRR=5909
C------ GENERATE A TANSPL CONSTRAINT WHEREEVER A NORMAL IS PRESENT
      IF(INOR) GO TO 980
      DO 910 I=NPL,NPH
C------ IF THERE ALREADY IS A TANSPL CONTRAINT OR NO NORMAL, SKIP
      IF(.NOT.ID(1,I).OR.ID(3,I)) GO TO 910
      NLO=MAX0(I-1,NPL)
      NHI=MIN0(I+1,NPH)
      IF(NHI-NLO.GT.1) GO TO 920
      DO 930 L=1,3
  930 T(L)=S(L,1,NHI)-S(L,1,NLO)
      GO TO 950
  920 CALL PARINT(S(1,1,NLO),S(1,1,I),S(1,1,NHI),T,DUM,2,IRRR)
      IF(IRRR.NE.0) GO TO 998
  950 VAL=T(1)*S(1,4,I)+T(2)*S(2,4,I)+T(3)*S(3,4,I)
      DO 960 L=1,3
  960 T(L)=T(L)-VAL*S(L,4,I)
      CALL SNORM(T,S(1,2,I),IRRR)
      IF(IRRR.NE.0) GO TO 998
      ID(1,I)=.FALSE.
      S(4,2,I)=-1.0
  910 CONTINUE
  980 CONTINUE
      IF(IORG.EQ.3) GO TO 900
C END TANGENTS ARE NOT GENERATED IN CURSEG CASE
C------ GENERATE TANGENTS AT THE ENDS
      IRR=5909
      NDIF=NPH-NPL
      DO 800 I=NPL,NPH,NDIF
      IF(.NOT.ID(1,I)) GO TO 800
      IF(I.EQ.NPL) GO TO 830
      IF(I.EQ.NPH) GO TO 860
  830 IF(NP.EQ.2.AND..NOT.ID(1,I+1)) GO TO 840
      IF(NP.GT.2.AND.S(4,2,I+1).EQ.1.0) GO TO 840
      IF(NP.GT.2) GO TO 836
      DO 835 L=1,3
  835 T(L)=S(L,1,I+1)-S(L,1,I)
      CALL SNORM(T,T,IDUM)
      GO TO 880
  836 CALL PARINT(S(1,1,I),S(1,1,I+1),S(1,1,I+2),T,DUM,1,IRRR)
      GO TO 880
  840 CALL PARINT(S(1,1,I),S(1,2,I+1),S(1,1,I+1),T,DUM,21,IRRR)
      IF(IRRR.NE.0) GO TO 998
      GO TO 880
  860 IF(NP.EQ.2.AND..NOT.ID(1,I-1)) GO TO 870
      IF(NP.GT.2.AND.S(4,2,I-1).EQ.1.0) GO TO 870
      IF(NP.GT.2) GO TO 866
      DO 865 L=1,3
  865 T(L)=S(L,1,I)-S(L,1,I-1)
      CALL SNORM(T,T,IDUM)
      GO TO 880
  866 CALL PARINT(S(1,1,I-2),S(1,1,I-1),S(1,1,I),T,DUM,3,IRRR)
      GO TO 880
  870 CALL PARINT(S(1,1,I-1),S(1,2,I-1),S(1,1,I),T,DUM,13,IRRR)
      IF(IRRR.NE.0) GO TO 998
  880 CONTINUE
      DO 890 L=1,3
  890 S(L,2,I)=T(L)
      S(4,2,I)=-1.0
      ID(1,I)=.FALSE.
  800 CONTINUE
C------ PROJECT ALL TANSPL AND CRRSPL CONSTRAINTS INTO THE PLANE OF THE
C------ NORMAL CONSTRAINT AND UNITIZE THEM
  900 CONTINUE
      IF(INOR) GO TO 1100
      DO 1000 I=NPL,NPH
      IF(ID(3,I)) GO TO 1000
      DO 1010 K=2,3
      IRR=5904+K
      IF(ID(K-1,I)) GO TO 1010
      VAL=S(1,K,I)*S(1,4,I)+S(2,K,I)*S(2,4,I)+S(3,K,I)*S(3,4,I)
      DO 1015 L=1,3
 1015 S(L,K,I)=S(L,K,I)-VAL*S(L,4,I)
      CALL SNORM(S(1,K,I),S(1,K,I),IRRR)
      IF(IRRR.NE.0) GO TO 998
 1010 CONTINUE
 1000 CONTINUE
 1100 CONTINUE
C------ CHECK FOR THE COLLINEARITY OF CONSTRAINTS
      IF(INOR.OR.ICRS) GO TO 1300
      IRR=5908
      DO 1200 I=NPL,NPH
      IF(ID(1,I).OR.ID(2,I).OR.ID(3,I)) GO TO 1200
      CALL CROSS(S(1,2,I),S(1,3,I),T)
      VAL=T(1)*S(1,4,I)+T(2)*S(2,4,I)+T(3)*S(3,4,I)
      IF(DABS(VAL).LT.SMAL2) GO TO 998
 1200 CONTINUE
 1300 CONTINUE
C------ CHECK FOR WILD POINTS
      IF(NP.EQ.2) GO TO 1500
      IRR=5910
      DO 1400 I=NPLP,NPHM
      DO 1410 L=1,3
 1410 T(L)=S(L,1,I+1)-S(L,1,I-1)
      DO 1420 L=1,3
 1420 TA(L)=S(L,1,I)-S(L,1,I-1)
      VAL=T(1)*TA(1)+T(2)*TA(2)+T(3)*TA(3)
      IF(VAL.LE.0.0) GO TO 998
      DO 1430 L=1,3
 1430 TB(L)=S(L,1,I+1)-S(L,1,I)
      VAL=T(1)*TB(1)+T(2)*TB(2)+T(3)*TB(3)
      IF(VAL.LE.0.0) GO TO 998
      CALL CROSS(T,TA,TB)
      VAL=TB(1)*TB(1)+TB(2)*TB(2)+TB(3)*TB(3)
      VALA=T(1)*T(1)+T(2)*T(2)+T(3)*T(3)
C------ WILD POINT MEASURE -- RATIO OF THE HEIGHT TO BASE
      S(4,5,I)=DSQRT(VAL)/VALA
 1400 CONTINUE
 1500 CONTINUE
      S(4,5,NPL)=0
      S(4,5,NPH)=0
C------ BRANCH TO SPLINE OR CURSEG PROCESSING
      GO TO (2000,2000,3000),IORG
C------ COLLECT SUBSPLINES ONE BY ONE AND CONDUCT SMOOTHING
 2000 IBEG=NPL
      ICUR=NPL
 2010 NCUR=1
      IBEG=ICUR
      IF(IBEG.EQ.NTOT) GO TO 2160
      DO 2040 L=1,3
 2040 P(L,NCUR)=S(L,1,ICUR)
      W(NCUR)=1.
 2020 NCUR=NCUR+1
      ICUR=ICUR+1
      IF(.NOT.ID(1,ICUR)) GO TO 2100
      DO 2030 L=1,3
 2030 P(L,NCUR)=S(L,1,ICUR)
      W(NCUR)=1.0
      GO TO 2020
 2100 IF(NCUR.EQ.2) GO TO 2010
      DO 2110 L=1,3
      P(L,NCUR)=S(L,1,ICUR)
      TV(L,1)=S(L,2,IBEG)
 2110 TV(L,2)=S(L,2,ICUR)
      IDC=2
      W(NCUR)=1.0
      NREL=ICUR-IBEG+1
      CALL SMOOTH (P,W,D,TV,V,NREL,IDC)
      IRR=5920+IABS(IDC)
      IF(IDC.LT.0) GO TO 998
      DO 2120 J=IBEG,ICUR
      K=J-IBEG+1
      S(4,2,J)=1.0
      IF((J-IBEG)*(J-ICUR).NE.0) S(4,2,J)=-1.0
      ID(1,ICUR)=.FALSE.
      DO 2130 L=1,3
      S(L,1,J)=P(L,K)
 2130 S(L,2,J)=V(L,K)
      S(4,1,J)=D(K)
 2120 CONTINUE
      IF(ICUR.LT.NTOT) GO TO 2010
 2160 CONTINUE
      DO 2150 I=NPL,NPHM
      J=I+1
      S(4,1,I)=DSQRT((S(1,1,J)-S(1,1,I))**2+(S(2,1,J)-S(2,1,I))**2
     X          +(S(3,1,J)-S(3,1,I))**2)
 2150 CONTINUE
      GO TO 999
C------ CURSEG PROCESSING
 3000 CONTINUE
  999 IRR=0
      RETURN
C------ ERROR RETURN.  IRR IS NOT ZERO.
  998 CONTINUE
      S(1,2,1)=IRR
      RETURN
      END
**** SOURCE FILE : M0008157.V11   ***
*
       SUBROUTINE SSTRA(XMA,ANA,CAN,ISPRNT)
C----------  THE PURPOSE OF THIS SUBROUTINE IS TO PERFORM GEOMETRY
C----------  TRANSFORMATION FOR THE SCULPTURED SURFACES.
C----------      XMA     TRANSFORMATION MATRIX
C----------      ANA     SURFACE NAME
C----------      CAN     CANON OF THE SURFACE
C----------      ISPRNT  PRINT FLAG
C----------
       IMPLICIT DOUBLE PRECISION(A-H,O-Z)
       CHARACTER BLANK*8
       INTEGER BCDF
       DIMENSION ANA(10),CAN(*),A(4,4),B(4,24),C(4,24)
       DIMENSION IFLG(4),W(16),XMA(12)
      CHARACTER*8 TNAME,ANAME*16
      INCLUDE (DARRAY)    
C
       DATA BLANK/'        '/
C
C---      BUDD CHANGE TO TEST TABPRT FLAG FOR PRINT OUTPUT.
       IGNC=0
       CALL HOLFRM(ANA(3),ANAME,1,8,NWD)
       ANAME(9:16)=BLANK
      IF(ISPRNT.EQ.0) GO TO 2
       DO 1 I=1,15
       I1=I*8
  1    DARRAY(I1-7:I1)=BLANK
       CALL CFORM('1THE FOLLOWING SSURF OR SCURV WAS ',DARRAY,1,34)
       CALL CFORM('TRANSFORMED BY THE MATRIX',DARRAY,36,25)
       CALL CPRINT(DARRAY)
       CALL CFORM('0',DARRAY,1,1)
       CALL CPRINT(DARRAY)
C***  INPUT MATRIX
    2 CONTINUE
       DO 7 I=1,3
       DO 7 J=1,4
       LL=(I-1)*4+J
       A(I,J)=XMA(LL)
  7    CONTINUE
       A(4,1)=0.0
       A(4,2)=0.0
       A(4,3)=0.0
       A(4,4)=1.0
C***  ************
      IF(ISPRNT.EQ.0) GO TO 3
       DO 12 I=1,4
       K=2
       DO 11 J=1,4
       CALL FCONV(A(I,J),DARRAY,K,12,5)
       K=K+12
 11    CONTINUE
       CALL CPRINT(DARRAY)
 12    CONTINUE
       CALL CFORM('0',DARRAY,1,1)
       CALL CPRINT(DARRAY)
C***  ************
    3 CONTINUE
       NPCH=CAN(4)
       NNN=CAN(5)
       DO 15 I=1,16
 15    W(I)=0.0
       W(1)=1.0
       W(2)=W(1)
       W(5)=W(1)
       W(6)=W(1)
       DO 500 N=1,NPCH
       I=11+6*(N-1)
       IFLG(1)=CAN(I)
       IFLG(2)=CAN(I+1)
       IFLG(3)=CAN(I+2)
       IFLG(4)=CAN(I+3)
      IF(IFLG(2).NE.0) GOTO 8
C NON NATIVE PATCH TRANSFORMATION
      IGNC=1
      CALL HOLFRM(CAN(I+4),TNAME,1,8,NWD)
      CALL TEVAL(TNAME,XMA,CAN(IFLG(1)))
      GOTO 500
    8 CONTINUE
       IV=CAN(I+4)
       IF(IV.LT.0) GO TO 1000
C----------  GENERAL CURVE TYPE BRANCH TO 1000
C----------  COONS BICUBIC PATCH FOLLOWS
       IF(IFLG(4).NE.4) GO TO 19
       IU=IV+47
       DO 17 IW=1,16
       IX=IU+IW
 17    W(IW)=CAN(IX)
 19    CONTINUE
C----------  NON TWIST CONSTANT
       MM=12
       NST=3
       IH=1
       IF (IFLG(1).EQ.3) GO TO 50
C----------  TWIST CONSTANT
       MM=16
       NST=4
   50  IF(IFLG(1).LT.3) GO TO 900
       DO 400 IJK=1,NST
       IA=IV
       IB=IV+MM
       IC=IV+MM+MM
       B(1,1)=CAN(IA)
       B(2,1)=CAN(IB)
       B(3,1)=CAN(IC)
       B(4,1)=W(IH)
       B(1,2)=CAN(IA+1)
       B(2,2)=CAN(IB+1)
       B(3,2)=CAN(IC+1)
       B(4,2)=W(IH+1)
       L=4
       IF((IJK.EQ.3).AND.(NST.EQ.3)) L=2
       B(1,3)=CAN(IA+L)
       B(2,3)=CAN(IB+L)
       B(3,3)=CAN(IC+L)
       B(4,3)=W(IH+L)
       B(1,4)=CAN(IA+L+1)
       B(2,4)=CAN(IB+L+1)
       B(3,4)=CAN(IC+L+1)
       B(4,4)=W(IH+L+1)
       DO 40 KA=1,4
       DO 30 II=1,4
       D=0.0
       DO 20 JJ=1,4
       C(II,KA)=A(II,JJ)*B(JJ,KA)+D
 20    D=C(II,KA)
 30    CONTINUE
 40    CONTINUE
       IA=IV
       IB=IV+MM
       IC=IV+MM+MM
       CAN(IA)=C(1,1)
       CAN(IB)=C(2,1)
       CAN(IC)=C(3,1)
       CAN(IA+1)=C(1,2)
       CAN(IB+1)=C(2,2)
       CAN(IC+1)=C(3,2)
       CAN(IA+L)=C(1,3)
       CAN(IB+L)=C(2,3)
       CAN(IC+L)=C(3,3)
       CAN(IA+L+1)=C(1,4)
       CAN(IB+L+1)=C(2,4)
       CAN(IC+L+1)=C(3,4)
       IV=IV+2
       IF(IJK.EQ.2) IV=IV+4
       IH=IH+2
       IF(IJK.EQ.2) IH=IH+4
400    CONTINUE
       GO TO 500
C----------  GENCUR  SURFACE
 1000  IGNC=1
       DO 1900 JK=1,4
       ISC=IFLG(JK)
       IF(ISC.EQ.0) GO TO 1900
       NARC=CAN(ISC+3)
       NPT=NARC+1
       IQ=CAN(ISC+4)+ISC-1
       IA=IQ
       DO 1200 NR=1,NARC
       IB=IA
       DO 1100 M=1,4
       B(1,M)=CAN(IB)
       B(2,M)=CAN(IB+4)
       B(3,M)=CAN(IB+8)
       B(4,M)=CAN(IB+12)
       IB=IB+1
 1100  CONTINUE
       IB=IA
C----------  CRSSPL  AND  NANDMAL
       DO 1300 K=1,2
       KK=K+4
       IC=IB-(3-K)*4
       B(1,KK)=CAN(IC)
       B(2,KK)=CAN(IC+1)
       B(3,KK)=CAN(IC+2)
       B(4,KK)=0.0
 1300  CONTINUE
       ML=6
       IF(NR.NE.NARC) GO TO 1500
       IA1=IA+19
       IA2=IA+23
       IF((CAN(IA1).EQ.0).AND.(CAN(IA2).EQ.0)) GO TO 1500
       DO 1310 K=1,2
       KK=K+6
       IC=IB+16+(K-1)*4
       B(1,KK)=CAN(IC)
       B(2,KK)=CAN(IC+1)
       B(3,KK)=CAN(IC+2)
       B(4,KK)=0.0
 1310  CONTINUE
       ML=8
 1500  CONTINUE
       DO 140 KA=1,ML
       DO 130 II=1,4
       D=0.0
       DO 120 JJ=1,4
       C(II,KA)=A(II,JJ)*B(JJ,KA)+D
 120   D=C(II,KA)
 130   CONTINUE
 140   CONTINUE
       IB=IA
       DO 1600 M=1,4
       CAN(IB)=C(1,M)
       CAN(IB+4)=C(2,M)
       CAN(IB+8)=C(3,M)
       CAN(IB+12)=C(4,M)
       IB=IB+1
 1600  CONTINUE
       IB=IA
       DO 1700 K=1,2
       KK=K+4
       IC=IB-(3-K)*4
       CAN(IC)=C(1,KK)
       CAN(IC+1)=C(2,KK)
       CAN(IC+2)=C(3,KK)
 1700  CONTINUE
       IF(ML.EQ.6) GO TO 1800
       DO 1710 K=1,2
       KK=K+6
       IC=IB+16+(K-1)*4
       CAN(IC)=C(1,KK)
       CAN(IC+1)=C(2,KK)
       CAN(IC+2)=C(3,KK)
 1710  CONTINUE
 1800  IA=IA+24
 1200  CONTINUE
 1900  CONTINUE
 500   CONTINUE
       IF(IGNC.NE.1) GO TO 550
       JMD=1
       CALL APT094(JMD,ANA(1),CAN(1))
  550 IF(ISPRNT.EQ.0) GO TO 999
      CALL SSPICT(CAN,ANAME,ISPRNT)
       GO TO 999
C----------  LINEAR OR CONSTANT MATRIX, WILL NOT TRANSFORM
 900    CONTINUE
 999   RETURN
       END
**** SOURCE FILE : M0001226.V04   ***
*
      SUBROUTINE SYCURV(ANAME,PNTS,CRL,ITY)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C
      INCLUDE (BLANKCOM)    
C
      DIMENSION PNTS(20),ANAME(7),CRL(10),CENT(10),VEC(5)
      DIMENSION CENT0(2)
      EQUIVALENCE (CENT0(2),CENT(1))
      INTEGER BCDF,ITEMP(2)
      EQUIVALENCE (TEMP,ITEMP(1))
C
C
      DO 10 I=41,49
 10   CANON(I)=0.0D0
      CANON(43)=2.0D0
      CANON(44)=2.0D0
      CANON(45)=18.0D0
      ITEMP(1)=BCDF('CURS')
      ITEMP(2)=BCDF('EG  ')
      CANON(49)=TEMP
      KON=49
      CANON(KON+1)=19.0D0
      CANON(KON+2)=PNTS(1)
      CANON(KON+3)=PNTS(2)
      CANON(KON+4)=PNTS(3)
      IF(ITY.GT.0) GO TO 20
      CENT0(1)=19030000.0D0
       CALL APT007(CENT,CRL)
      VEC(1)=PNTS(1)-CENT(1)
      VEC(2)=PNTS(2)-CENT(2)
      VEC(3)=PNTS(3)-CENT(3)
      CANON(KON+5)=136.0D0
      ITEMP(1)=BCDF('TANS')
      ITEMP(2)=BCDF('PL  ')
      CANON(KON+6)=TEMP
      CANON(KON+7)=20.0D0
C  LOESUNG FUER ZSURF SENKRECHTER ZYLINDER
      CALL CROSS(VEC,CRL(4),CANON(KON+8))
C  ANDERE FAELLE NICHT ABGEFANGEN !
      CANON(44)=3.0D0
      CANON(45)=24.0D0
      KON=KON+6
20    CANON(KON+5)=19.0D0
      CANON(KON+6)=PNTS(4)
      CANON(KON+7)=PNTS(5)
      CANON(KON+8)=PNTS(6)
C CODE GELOESCHT
C CODE GELOESCHT
      CALL STRTSH(ARG1)
      CALL APT108(ANAME,CRSEG,ARG1,ARG1)
      RETURN
      END
**** SOURCE FILE : M0000680.V02   ***
*
      SUBROUTINE TOPGEN(SS)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
C---     ROUTINE TO GENERATE A TOPOLOGY TABLE FOR AN OTHERWISE COMPLETE
C---      SS DATA STRUCTURE
      DIMENSION SS(*)
      DIMENSION P(3,4),PT(3,4),NSZ(4),NBOUN(8)
      DATA NSZ/1,4,12,16/,NBOUN/1,2,1,3,2,4,3,4/
      DATA ZERO,SMAL/0.0D0,1.0D-10/
      DATA IZERO/0/
C
C---     NTOT IS THE TOTAL NUMBER OF PATCHES IN THE SS ARRAY
      NTOT=SS(4)
C---    SPECIAL HANDLING FOR A GENCUR SURFACE
      IF(SS(6).LT.5.999.OR.SS(6).GT.6.001) GO TO 10
      ITOP1=11+NTOT*6+SS(2)
      GO TO 25
C
   10 CONTINUE
C---   TOPOLOGY TABLE IS ASSUMED REGULAR(CONTACT AT CORNER POINTS ONLY)
C---     FILL IN POINTERS FROM EACH PATCH HEADER TO TOPOLOGY TABLE
C---     ALSO ZERO OUT THE TOPOLOGY TABLE ENTRIES
      ITOP1=10+6*(NTOT-1)+5
      ITOP1=SS(ITOP1)
C---     ITOP1 IS THE LOCATION OF THE LAST PATCH COEFFICIENT ARRAY
      DO 20 K=1,4
      I=SS(10+6*NTOT-6+K)
      ITOP1=ITOP1+NSZ(I)
   20 CONTINUE
   25 CONTINUE
C---     ITOP1 IS THE SS LOCATION OF THE FIRST TOPOLOGY TABLE ENTRY
C---      FILL POINTERS TO THE TOPOLOGY TABLE FOR EACH PATCH
      DO 30 K=1,NTOT
      SS(10+6*K)=ITOP1+4*(K-1)
      KT=SS(10+6*K)-1
C---     ZERO OUT THE TOPOLOGY TABLE ENTRIES
      DO 30 KK=1,4
      SS(KT+KK)=0.
   30 CONTINUE
C---  NOW SEPARATE THE CASE OF A MESH SURFACE FROM PNTSON,PNTVEC,POLYGN
      NTYPE=SS(5)
      IF(NTYPE.NE.2) GO TO 200
C---     SURFACE IS A MESH TYPE
C------NUMBER OF PATCHES IN A STRIP ALONG THE MAJOR SPLINE DIRECTION
      NP=SS(10)-1
C---     NUMBER OF PATCHES IN A STRIP ALONG THE CROSS SPLINE DIRECTION
      NS=SS(9)-1
C---     PATCHES ARE STORED LINEARLY AS I,J WHERE I=1 TO NP AND THEN
C---     J = 1 TO NS
C---     GENERATE TOPOLOGY TABLE FOR EACH PATCH IN SUCCESSION
      DO 40 J=1,NS
      DO 40 I=1,NP
      ITOP=10+6*((J-1)*NP+I)
      ITOP=SS(ITOP)
      NCUR=I+(J-1)*NP
      NLOWER=(J-1)*NP+1
      NUPPER=J*NP
C---     FIRST BOUNDARY ( U= 0 TO 1= 1 WHILE V=0)
      SS(ITOP)=MAX0(IZERO,NCUR-NP)
      ITOP=ITOP+1
C---     SECOND BOUNDARY ( U=0 WHILE V= 0 TO 1 )
      KTEMP=NCUR-1
      IF(KTEMP.LT.NLOWER) KTEMP=0
      SS(ITOP)=KTEMP
      ITOP=ITOP+1
C---     THIRD BOUNDARY ( U=1 WHILE V= 0 TO 1)
      KTEMP=NCUR+1
      IF(KTEMP.GT.NUPPER) KTEMP=0
      SS(ITOP)=KTEMP
      ITOP=ITOP+1
C---     FOURTH BOUNDARY (U=0 TO 1 WHILE V=1)
      KTEMP=NCUR+NP
      IF(KTEMP.GT.NTOT) KTEMP=0
      SS(ITOP)=KTEMP
C---     THIS COMPLETES THE TOPOLOGY TABLE FOR THE MESH DEFINITION
   40 CONTINUE
      GO TO 9999
C
C
C---     THE NEXT SURFACE IS PNTSON,POLYGN OR PNTVEC
C---     ASSUMPTIONS:  THE PATCHES HAVE FLAGS 4,4,4,1
C---     ASSUMPTIONS:  TWO ADJACENT PATCHES HAVE CONTACT IN TWO CORNER
C---     POINTS
  200 CONTINUE
C---     RESOLVE TOPOLOGY RELATIONS ONE PATCH AT A TIME
      DO 210 I=1,NTOT
      ITOP=SS(10+6*I)
      IPREL=SS(10+6*I-1)-1
C---     LOAD THE CORNER POINTS(USING THE MATRIX ASSUMPTION)
      DO 220 K=1,3
      KK=(K-1)*16
      P(K,1)=SS(IPREL+KK+1)
      P(K,2)=SS(IPREL+KK+2)
      P(K,3)=SS(IPREL+KK+5)
  220 P(K,4)=SS(IPREL+KK+6)
C---     COMPARE EACH BOUNDARY OF THE I TH PATCH TO OTHER PATCHES
      DO 230 J=1,4
C---     BOUNDARY 1  POINTS P(,1) TO P(,2)
C---     BOUNDARY 2  POINTS P(,1) TO P(,3)
C---     BOUNDARY 3  POINTS P(,2) TO P(,4)
C---     BOUNDARY 4  POINTS P(,3) TO P(,4)
      JA=NBOUN(2*J-1)
      JB=NBOUN(2*J)
C---     CHECK EACH PATCH AGAINST BOUNDARY J OF PATCH I
      DO 240 L=1,NTOT
      IF (L.EQ.I) GO TO 240
      IPRELT=SS(10+6*L-1)-1
C---     LOAD CORNER POINTS OF PATCH L
      DO 250 K=1,3
      KK=(K-1)*16
      PT(K,1)=SS(IPRELT+KK+1)
      PT(K,2)=SS(IPRELT+KK+2)
      PT(K,3)=SS(IPRELT+KK+5)
  250 PT(K,4)=SS(IPRELT+KK+6)
      DO 260 M=1,4
      MA=NBOUN(2*M-1)
      MB=NBOUN(2*M)
      D=ZERO
      DO 280 NN=1,3
  280 D=D+(P(NN,JA)-PT(NN,MA))**2+(P(NN,JB)-PT(NN,MB))**2
      IF (D.GT.SMAL) GO TO 290
      GO TO 300
  290 D=ZERO
      DO 310  NN=1,3
  310 D=D+(P(NN,JA)-PT(NN,MB))**2+(P(NN,JB)-PT(NN,MA))**2
      IF(D.GT.SMAL) GO TO 260
C---     BOUNDARY CHECK IS POSITIVE LTH PATCH LIES ACROSS J TH BOUNDARY
C---     OF THE I TH PATCH
  300 ITOPIJ=10+6*I
      ITOPIJ=SS(ITOPIJ)
      SS(ITOPIJ-1+J)=L
  260 CONTINUE
  240 CONTINUE
  230 CONTINUE
  210 CONTINUE
C
C
 9999 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0001121.V01   ***
*
      SUBROUTINE TRANSP(A,B,N)
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      DIMENSION A(N,N),B(N,N)
C---     TRANSPOSE A NXN MATRIX  CALLED A AND PLACE IN B
C---     NOTE THAT B MAY BE THE SAME AS A
      DO 10 I=1,N
      J=I
      DO 20 K=1,J
      T=A(I,K)
      B(I,K)=A(K,I)
      B(K,I)=T
   20 CONTINUE
   10 CONTINUE
      RETURN
      END
