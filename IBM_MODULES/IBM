**** SOURCE FILE : ARTIME00.IBM;1   ***
*
*
*  * ARTIME *  FORTRAN 77 SUBROUTINE  9-DEC-1985  E.MCLELLAN
*                MODIFIED                 9-FEB-1988  E.MCLELLAN
*
*  PURPOSE:  EXTRACT CURRENT DATE AND TIME AND STORE IN ATIME BLOCK
*
*  CALLING SEQUENCE:
*                   CALL ARTIME
*
*  ARGUMENTS:  NONE
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   T               ATIME     DOUBLE     CURRENT TIME
*                             PRECISION  CURRENT DATE
*
*  LOCAL VARIABLES:  NONE
*                   TYPE       DESCRIPTION
*   CTIME           CHARACTER  CURRENT TIME
*   CDATE           CHARACTER  CURRENT DATE
*
*  FILES:  NONE
*
*  SUBSIDIARIES:
*              DATE
*              TIME
*
      SUBROUTINE ARTIME
C
      DOUBLE PRECISION T(4)
      COMMON/ATIME/T
C
      CHARACTER CTIME*8,CDATE*8,DAOFWK*9
C
      CALL TIME(CTIME)
      CALL DATE(DAOFWK,CDATE)
C
      RETURN
      END
**** SOURCE FILE : CLOSPE00.IBM;1   ***
*
*                MODIFIED                23-FEB-1988  E.MCLELLAN
      SUBROUTINE CLOSPE(ID,IRET)
C
      INTEGER ID,IRET,JCODE,JRET
C
      JCODE=2
      CALL UCLOSE(ID,JCODE,JRET)
      IF (JRET.EQ.0) THEN
       IRET=0
      ELSE
       IRET=1
      ENDIF
      RETURN
      END
**** SOURCE FILE : CPUTIM00.IBM;1   ***
*
C.... INTEGER FUNCTION CPUTIM
C     UTILIZING IBM FORTRAN UTILITY DATETM ( TXTLIB UTILITY )
C
      INTEGER FUNCTION CPUTIM()
      CHARACTER*23 DATTIM
      REAL ECPU,ETIME,ETCPU
C
      CALL DATETM(DATTIM,ECPU,ETIME,ETCPU)
C
      CPUTIM=INT(ECPU*100.0)
      RETURN
      END
**** SOURCE FILE : FILOPN00.IBM;2   ***
*
*
*  * FILOPN *    VAX11 FORTRAN SUBROUTINE  10.5.82 E.MCLELLAN
*                MODIFIED                  18.07.85 E.MCLELLAN
*
*  PURPOSE     TO OPEN A FILE WITH REQUIRED ATTRIBUTES
*
*  CALLING SEQUENCE
*              CALL FILOPN(NO)
*  ARGUMENTS
*              NO    FILE NUMBER
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   FILNAM          FILTAB    CHARACTER  FILE NAME
*   FILACC          FILTAB    CHARACTER  FILE ACCESS
*                                         (DIRECT OR SEQUENTIAL)
*   FILFMT          FILTAB    CHARACTER  FILE FORMAT
*                                         (FORMATTED OR UNFORMATTED)
*   OPSTAT          FILTAB    CHARACTER  OPEN STATUS
*                                         (UNKNOWN,SCRATCH,NEW,OLD)
*   CLSTAT          FILTAB    CHARACTER  CLOSE STATUS (KEEP,DELETE)
*   U               IFILTB    INTEGER    UNIT NUMBER
*   RL              IFILTB    INTEGER    RECORD LENGTH
*   NXTREC          IFILTB    INTEGER    NUMBER OF NEXT RECORD TO BE
*                                        READ OR WRITTEN (DIRECT ACCESS)
*   LSTREC          IFILTB    INTEGER    NUMBER OF LAST RECORD ON FILE
*                                         (DIERECT ACCESS)
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*        DARRAY     CHARACTER  PRINT BUFFER
*        POSN       INTEGER    START POSITION IN PRINT BUFFER
*        SLEN       INTEGER    LENGTH OF STRING ENTERED IN BUFFER
*
*  FILES:  FILE REFERENCED BY FILE NUMBER
*
*  SUBSIDIARIES:
*               CFORM
*               ICONV
*               CPRINT
*
      SUBROUTINE FILOPN(NO)
C
      INCLUDE (FILTAB)
C
      INTEGER POSN,SLEN
      CHARACTER*80 DARRAY
      DATA DARRAY/' '/
C
C.... FOR IBM VM/CMS UNFORMATTED D.A. FILES RECORD LENGTH = NO 0F BYTES
      IF (FILFMT(NO).EQ.'UNFORMATTED') THEN
        IRL=RL(NO)*4
      ELSE
        IRL=RL(NO)
      ENDIF
      IF (OPSTAT(NO).EQ.'SCRATCH') THEN
      IF (FILACC(NO).EQ.'DIRECT') THEN
        OPEN (UNIT=U(NO),IOSTAT=IRET,ERR=90,
     +        STATUS=OPSTAT(NO),ACCESS=FILACC(NO),
     +        FORM=FILFMT(NO),RECL=IRL)
      ELSE
        OPEN (UNIT=U(NO),IOSTAT=IRET,ERR=90,
     +        STATUS=OPSTAT(NO),ACCESS=FILACC(NO),
     +        FORM=FILFMT(NO))
      ENDIF
      ELSE
      IF (FILACC(NO).EQ.'DIRECT') THEN
        OPEN (UNIT=U(NO),FILE=FILNAM(NO),IOSTAT=IRET,ERR=90,
     1      STATUS=OPSTAT(NO),ACCESS=FILACC(NO),
     2      FORM=FILFMT(NO),RECL=IRL)
      ELSE
        OPEN (UNIT=U(NO),FILE=FILNAM(NO),IOSTAT=IRET,ERR=90,
     1      STATUS=OPSTAT(NO),ACCESS=FILACC(NO),
     2      FORM=FILFMT(NO))
      ENDIF
      ENDIF
      RETURN
C
   90 SLEN=0
      CALL CFORM (' **** ERROR OPENING FILE :',DARRAY,2,SLEN)
      POSN=SLEN+3
      SLEN=0
      CALL CFORM (FILNAM(NO),DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+1
      SLEN=0
      CALL CFORM ('; UNIT NO :',DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+1
      CALL ICONV (U(NO),DARRAY,POSN,2)
      POSN=POSN+4
      SLEN=0
      CALL CFORM ('****',DARRAY,POSN,SLEN)
      CALL CPRINT (DARRAY)
      CALL ABNEND
      RETURN
      END
**** SOURCE FILE : FINDME00.IBM;1   ***
*
      SUBROUTINE FINDME(ID,MEMBER,IRET)
C
      INTEGER ID,IRET
      CHARACTER*(*) MEMBER
C
      LOGICAL EX
C
      CHARACTER FLNAME*20,TYPE*4,MODE*2
      INTEGER NLEN,JRET
C
      DATA TYPE/' LDA'/,MODE/' A'/
C
C.... SET UP FILENAME
C
      NLEN=LEN(MEMBER)
      K=INDEX(MEMBER,' ')
      IF (K.NE.0) NLEN=K-1
      FLNAME=MEMBER(:NLEN)//TYPE//MODE
      NLEN=NLEN+6
C
C.... INQUIRE IF FILE EXISTS
C
      CALL UOPEN(ID,FLNAME(:NLEN),1,4,80,0,'U',0,JRET)
      IF (JRET.EQ.0) THEN
C.... FILE EXISTS - OPEN ATTACHED TO ID
        CALL UOPEN(ID,FLNAME(:NLEN),1,1,80,0,'U',0,JRET)
        IF (JRET.NE.0) GOTO 20
        IRET=0
      ELSE
        IRET=6
      ENDIF
      RETURN
C.... ERROR OPENING FILE
  20  IRET=5
      RETURN
      END
**** SOURCE FILE : LIBOPC00.IBM;2   ***
*
      SUBROUTINE LIBOPC(IND,FLAG)
*
*  * LIBOPC *  VAX-11 FORTRAN VERSION  27.09.82  E.MCLELLAN
*                            MODIFIED  26.09.86
*                MODIFIED                25-FEB-1988  E.MCLELLAN
*
*  PURPOSE     TO CHECK THE EXISTENCE OF SUBDIRECTORY [.APTLIB]
*              OR CLOSE UNIT REFERENCING SUBDIRECTORY
*  CALLING SEQUENCE
*              CALL LIBOPC(IND,FLAG)
*  ARGUMENTS
*              IND   =1 DOES SUBDIRECTORY EXIST
*                    =2 CLOSE UNIT WHICH REFERENCES SUBDIRECTORY
*              FLAG  =0 SUBDIRECTORY EXISTS
*                    =1 SUBDIRECTORY DOES NOT EXIST
*                    =2 NOT USED
*                    =3 ALREADY CLOSED (IND=2)
*                    =4 IND IS NOT 1 OR 2
*
      INTEGER FLAG
      LOGICAL OD,EX
C
      INCLUDE (FILTAB)
C
C
C
C.....UNIT NUMBER
C
      ID=U(24)
C
      IF (IND.EQ.1) THEN
        FLAG=0
C
      ELSE IF (IND.EQ.2) THEN
        CALL UCLOSE(ID,2,JRET)
        IF (JRET.EQ.4) THEN
          FLAG=3
        ELSE
          FLAG=0
        ENDIF
C
      ELSE
C
C.....IND NOT 1 OR 2
        FLAG=4
      END IF
      RETURN
      END
**** SOURCE FILE : LIBRD000.IBM;1   ***
*
      SUBROUTINE LIBRD(MEMBER,FLAG,ARRAY)
*
*  * LIBRD *  VAX-11 FORTRAN 77 VERSION  28.09.82  E.MCLELLAN
*                              MODIFIED  26.09.86
*                MODIFIED                25-FEB-1988  E.MCLELLAN
*
*  PURPOSE    TO READ A RECORD (80 CHARACTERS) FROM THE GIVEN
*             MEMBER FILE OF [.APTLIB]
*  CALLING SEQUENCE
*             CALL LIBRD(MEMBER,FLAG,ARRAY)
*  ARGUMENTS
*             MEMBER    CHARACTER STRING CONTAINING THE
*                       MEMBER NAME (BCD LEFT JUSTIFIED)
*             FLAG      INTEGER SET BY LIBRD
*                       0 = SUCCESSFUL READ
*                       1 = END OF DATA ENCOUNTERED (EOF)
*                       2 = I/O ERROR
*                       3 = NOT USED
*                       4 = A DIFFERENT MEMBER NAME APPEARED WITHOUT
*                           CALLING LIBSCH OR BEFORE END OF DATA
*                           ENCOUNTERED
*             ARRAY     CHARACTER STRING TO CONTAIN A RETRIEVED RECORD
*
      CHARACTER MEMBER*(*),ARRAY*80,TEST*8
      INTEGER FLAG
C
      INCLUDE (FILTAB)
C
      CHARACTER*8 MEMNAM
      COMMON/CLIBCM/MEMNAM
      COMMON/LIBCOM/IEOF
C
      TEST=MEMBER//' '
C
C.....IS MEMBER NAME SAME AS IN LAST CALL TO LIBSCH
C
      IF (TEST.NE.MEMNAM) THEN
         FLAG=4
         RETURN
      ELSE
C.....YES - READ A RECORD FROM MEMBER FILE
         ID=U(24)
         READ (UNIT=ID,FMT='(A80)',ERR=80,END=90) ARRAY
         FLAG=0
         RETURN
C
C.....I/O ERROR
   80    FLAG=2
         CALL UCLOSE(ID,2,JRET)
         RETURN
C
C.....EOF ENCOUNTERED
   90    FLAG=1
         IEOF=1
         CALL UCLOSE(ID,2,JRET)
         RETURN
      END IF
      END
**** SOURCE FILE : LIBSCH00.IBM;2   ***
*
      SUBROUTINE LIBSCH(MEMBER,FLAG)
*
*  * LIBSCH *  VAX-11 FORTRAN 77 VERSION  27.09.82  E.MCLELLAN
*                               MODIFIED  30.10.86  E.MCLELLAN
*                MODIFIED                25-FEB-1988  E.MCLELLAN
*
*  PURPOSE     TO SEARCH SUBDIRECTORY [.APTLIB] FOR A GIVEN
*              MEMBER FILE AND TO OPEN SAID FILE
*  CALLING SEQUENCE
*              CALL LIBSCH(MEMBER,FLAG)
*  ARGUMENTS
*              MEMBER    CHARACTER STRING CONTAINING THE
*                        MEMBER NAME (BCD LEFT JUSTIFIED)
*              FLAG      0 = MEMBER FOUND
*                        1 = MEMBER NOT FOUND IN SUBDIRECTORY
*                        2 = ERROR OPENING FILE
*                        3 = SUBDIRECTORY [.APTLIB] DOES NOT EXIST
*                        4 = LIBSCH IS CALLED BEFORE COMPLETING THE
*                            PROCESSING OF PREVIOUS MEMBER
*
      CHARACTER*(*) MEMBER
      INTEGER FLAG
C
      INCLUDE (FILTAB)
C
      CHARACTER*8 MEMNAM
      COMMON/CLIBCM/MEMNAM
      COMMON/LIBCOM/IEOF
C
      CHARACTER FLNAME*20,TYPE*4,MODE*2
      INTEGER NLEN,JRET
      LOGICAL OD,EX
C
      DATA TYPE/' TXT'/,MODE/' A'/
C
C
      ID=U(24)
C
C.....HAS PROCESSING OF PREVIOUS MEMBER BEEN COMPLETED
         IF (IEOF.EQ.0) THEN
C.....NO
             FLAG=4
             RETURN
C.....YES - SET UP FILE NAME FOR MEMBER
         ELSE
            NLEN=LEN(MEMBER)
            K=INDEX(MEMBER,' ')
            IF (K.NE.0) NLEN=K-1
            FLNAME=MEMBER(:NLEN)//TYPE//MODE
            NLEN=NLEN+6
C
C.....STORE MEMBER NAME AND RESET EOF FLAG
            MEMNAM=MEMBER
            IEOF=0
C.....DOES FILE EXIST
            CALL UOPEN(ID,FLNAME(:NLEN),1,4,80,0,'FB',0,JRET)
               IF (JRET.EQ.0) THEN
C.....YES
                 CALL UOPEN(ID,FLNAME(:NLEN),1,1,80,0,'FB',0,JRET)
                 IF (JRET.EQ.0) THEN
                   FLAG=0
                 ELSE
                   FLAG=2
                 ENDIF
               ELSE
C.....NO
                 FLAG=1
               END IF
C
        END IF
      RETURN
      END
**** SOURCE FILE : M0002726.IBM;1   ***
*
C
C.....FORTRAN INTEGER FUNCTION  ...APT201
C
C.....NEW SUBROUTINE FOR VAX 11 IMPLEMENTATION   02.06.82   E.MCLELLAN
C
C.....MODIFICATION TO PERMIT RESTART PROCEDURE USING
C     VAX CONDITION HANDLING FACILITIES
C
C
      INTEGER FUNCTION APT201(ADRESS,HDRECT)
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DIMENSION ADRESS(*)
      INTEGER APT211
C
C
      IAEEE=0
C...ESTABLISH CONDITION HANDLER FOR AERR ERROR
    1 CALL APT241
      APT201 = APT211(ADRESS,HDRECT,IAEEE)
      IF (IAEEE.EQ.1) GO TO 1
      RETURN
      END
C
C
C
C
C.....FORTRAN INTEGER FUNCTION  ...APT211    8/68              HG,DE,PH
C
C.....MODIFIED FOR VAX 11 IMPLEMENTATION   02.06.82   E.MCLELLAN
C
C.....MODIFICATION TO PERMIT RESTART PROCEDURE USING
C     VAX CONDITION HANDLING FACILITIES
C
C
      INTEGER FUNCTION APT211(ADRESS,HDRECT,IAEEE)
C
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION(O-Z)
      DIMENSION ADRESS(*)
C
      INCLUDE (TOTAL)
      INCLUDE (DSHAR4)
      INCLUDE (FXCOR)
      INCLUDE (HOLRTH)
      INCLUDE (SV)
      INCLUDE (ZNUMBR)
      INCLUDE (LDEF)
      INCLUDE (ISV)
      INCLUDE (IFXCOR)
      INCLUDE (KNUMBR)
C
C...            SYSTEM I/O FILE NAMES
C
      INCLUDE (SYMFIL)
C
      CHARACTER*8 TEST,HNOCS
      INTEGER BCDF,TDS(2)
      LOGICAL FIRST
      SAVE FIRST,HOLDPP,TDS
      CHARACTER*8 HOLRTH(6)
      EQUIVALENCE (HOLRTH(1),HLFT)
C
      INTEGER Z4E
      PARAMETER (Z4E=1308622848)
      INTEGER HOLDPP
      DIMENSION HOLDPP(8)
C
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
      COMMON /HSAVE/ SAVEH(50)
      COMMON/SQNC/ LSEQNO
C
C
C
      LOGICAL KCS
C
      INCLUDE (BLANKCOM)
C
      DIMENSION MODTYP(3,6)
      DIMENSION CSSAVE(10)
C
      DATA HOLDPP/0,0,Z4E,1,Z4E,1,Z4E,1/
      DATA HNOCS/'NOCS    '/
      DATA MODTYP/1,2,3,2,1,3,6*4,1,2,3,2,1,3/
      DATA ZLIT2/.0349D0/
      DATA FIRST/.TRUE./
C
      IF (FIRST)THEN
        HOLDPP(1) = BCDF('HOLD')
        HOLDPP(2) = BCDF('PP  ')
        TDS(1) = BCDF(HDS(1:4))
        TDS(2) = BCDF(HDS(5:8))
        FIRST=.FALSE.
      ENDIF
C
      CALL HOLFRM(HDRECT,TEST,1,8,NWD)
      IF (IAEEE .EQ. 1) GO TO 8010
      IF(IAERR.EQ.1) GO TO 1000
      IF(TEST.EQ.HNOCS) GO TO 8000
      IF(IGOTO+ICTDEF)1,1,3000
    1 DO 4001 I=1,6
      IF(TEST.EQ.HOLRTH(I)) GO TO 4002
 4001 CONTINUE
      CALL AERR(20104,'APT211  ')
      GO TO 1000
 4002 ISAV=I
      IF(.NOT.JDS)GO TO 4000
      KSEQNO = LSEQNO
      LSEQNO = JSEQNO
      KCSCNT=ICSCNT
      KCS=JCS
      LSAV=ISFTYP(IDS)
      ISFTYP(IDS)=MSAV
      ICSCNT=0
      KIPL=IPL(ICS)
      KLMFL=LIMFL(ICS)
      KUNFL=IUNFL(ICS)
      KFIDN=ISFIDN(ICS)
      KSTYP=ISFTYP(ICS)
      KTLON=ITLON(ICS)
      SPAST=PAST(ICS)
      KCAN=ICANON(ICS)
      KFL4=IFL4(ICS)
      KFAR=IFAR(ICS)
      DO 1530 IIT = 1,10
 1530 CSSAVE(IIT) = CANON(IIT+20)
      CALL APT200(TDS,ADRESS,Z1)
      IF(IAERR.NE.0)GO TO 1000
      IF(MOTMOD.EQ.0)GO TO 4004
      ISFTYP(ICS)=MODTYP(MOTMOD,ISAV)
      IF(ISFTYP(ICS).EQ.2) PAST(ICS)=-K1
      IS=IDS
      GO TO 9200
 4000 MODFER=TEST
      IGO=ISAV
      MSAV=ISFTYP(IDS)
      IS=IDS
      CALL APT234(TDS,ADRESS)
      IF(IAERR.NE.0)GO TO 1000
      IF(JCS)GO TO 9200
      JSEQNO = LSEQNO
      JDS=.TRUE.
C     INTEG.ON EXFILE DP. 1ST WD UNNORM POWER,2ND INTEG VALUE
      NR=0
      CALL EWRITE(EXFILE,NR,HOLDPP,8,IR)
      JHLDFG=1
      GO TO 9999
 4004 CALL AERR(20109,'APT211  ')
      GO TO 1000
 9200 CALL APT235
      IF(IAERR)6000,6000,1000
 6000 CALL APT240 (NUMDIM)
   14 ICL = K2
      NW = 0
   19 IF (CUTDAT(6).EQ.0.)GO TO 32
      NUMDIM = K1
      GO TO 32
   72 CALL APT236
      IF(IAERR.NE.0)GO TO 4006
      IF(JDS)GO TO 4005
 4006 CONTINUE
      JHLDFG=0
      ITHCNT=1
      JCS=.FALSE.
      JDS=.FALSE.
      GO TO 9999
 4005 JCS=KCS
      JHLDFG=0
      GO TO 9500
 9600 CONTINUE
      NR=0
      HOLDPP(8)=K2
      CALL EWRITE(EXFILE,NR,HOLDPP,8,IR)
      HOLDPP(8)=K1
      ISFTYP(IDS)=LSAV
      LSEQNO = KSEQNO
      IF(.NOT.JCS)GO TO 4000
      IPL(ICS)=KIPL
      LIMFL(ICS)=KLMFL
      ISFIDN(ICS)=KFIDN
      ISFTYP(ICS)=KSTYP
      ITLON(ICS)=KTLON
      PAST(ICS)=SPAST
      ICANON(ICS)=KCAN
      IFL4(ICS)=KFL4
      IFAR(ICS)=KFAR
      ICSCNT=KCSCNT
      JDS=.FALSE.
      DO 1531 IIT = 1,10
 1531 CANON(IIT+20) = CSSAVE(IIT)
      GO TO 4000
   32 J6 = 0
      IS=IPS
C  INITIALIZE VARIABLES FOR AMIND
   33 IF (JENT(IS)) 301,302,301
  301 JTN(IS) = K0
      IOPSET(IS)=0
      JU1(IS)=0
      JIOPS(IS)=0
  302 JAP = K1
  201 CALL AMIND
      IF(IAERR)1000,2000,1000
 2000 IF(IPL(IS))141,140,141
  141 IF(S(IS))142,39,143
  142 IF (S(IS)-TAU2(IS)+1.D-4) 36,39,39
  143 IF (S(IS)-TAU1(IS)-1.D-4) 39,39,36
  140 IF(RC(IS)*S(IS))34,39,35
   34 IF(DABS(S(IS))-Z9EM1*TAU(IS)-1.D-4) 39,39,36
   35 IF(DABS(S(IS))-EPS1(IS)-1.D-4) 39,39,36
   36 GO TO(505,508,504,204),JAP
  505 IF (IPL(IS)) 506,202,506
  202 IF (ISFTYP(IS)-K3) 504,507,504
  504 RC(IS)=-RC(IS)
      JAP = JAP + K1
      GO TO 201
  506 IF (TH(IS)) 510,510,204
  507 JAP = K4
  203 Z(IS)=-Z(IS)
      GO TO 201
  510 IF (IAFL(IS)) 507,511,507
  511 JENT(IS)= -K1
      JAP = K4
      GO TO 201
  508 IF (TH(IS)) 509,204,204
  509 JAP = JAP + K1
      GO TO 203
  204 IF(J6)38,37,38
C  CUTTER NOT WITHIN TOLERANCE OF DRIVE SURFACE AT START OF CUT SEQUENCE
   38 CALL AERR (20102,'APT211  ')
      GO TO 1000
C  CUTTER NOT WITHIN TOLERANCE OF PART SURFACE AT START OF CUT SEQUENCE
   37 CALL AERR (20103,'APT211  ')
      GO TO 1000
   40 J6=K1
      IS=IDS
      GO TO 33
   39 IF (JAP-K1) 480,481,480
  480 TPK(1,IS)=TP(1,IS)
      TPK(2,IS)=TP(2,IS)
      TPK(3,IS)=TP(3,IS)
      SNK(1,IS)=SN(1,IS)
      SNK(2,IS)=SN(2,IS)
      SNK(3,IS)=SN(3,IS)
      SK(1,IS) = S(IS)
  481 IF(J6)41,40,41
C  DETERMINE GENERAL DIRECTION OF FIRST CUT VECTOR AND STORE IN FWD
   41 DO 42 K=1,3
   42 FWD(K)=TE(K)-TEK(K)
 2001 CALL VNORM(FWD,FWD)
C  IGO =1 IF LFT, =2 IF RGT, =3 IF FWD, =4 IF BACK, =5 IF UP, =6 IF DOWN
C  RELATIVE TO LAST COMMAND
      IF(K4-IGO)43,45,45
   43 DO 44 K=1,3
   44 FWD(K)=TA(K)
      GO TO 50
   45 CALL CROSS(FWD,TA,FWD)
      CALL VNORM(FWD,FWD)
      IF (VTEM.GT.Z1EM6)GO TO 48
   46 CALL CROSS(PMOVE,TA,FWD)
      CALL VNORM(FWD,FWD)
      IF(IER)47,48,47
C  FWD DIRECTION CANNOT BE DETERMINED
   47 CALL AERR (20105,'APT211  ')
      GO TO 1000
   48 IF(K3-IGO)49,49,50
   49 CALL CROSS(TA,FWD,FWD)
      CALL VNORM(FWD,FWD)
      IF(IER)147,50,147
  147 GO TO 47
   50 GO TO (52,54,54,52,54,52),IGO
   52 DO 53 K=1,3
   53 FWD(K)=-FWD(K)
C  CALCULATE TI VECTOR PERPENDICULAR TO BOTH PART AND DRIVE SURFACE
C  NORMALS
   54 CALL CROSS(SN(1,IPS),SN(1,IDS),TI)
      CALL VNORM(TI,TI)
      IF(IER)58,60,58
   58 DO 59 K=1,3
   59 TI(K)=FWD(K)
      GO TO 67
C  TI VECTOR AND FWD VECTOR SHOULD NOT BE ORTHOGONAL. IF SO CALL AERR
   60 TEM(1)= TI(1)*FWD(1) +TI(2)*FWD(2)+TI(3)*FWD(3)
      IF(DABS(TEM(1)) - ZLIT2) 64,64,63
   64 CALL AERR (20106,'APT211  ')
      GO TO 1000
   63 IF(TEM(1)) 65,65,67
   65 DO 66 K=1,3
   66 TI(K)=-TI(K)
   67 IF(NUMDIM)68,68,73
C  ICSCNT = NUMBER OF CHECK SURFACES. IF MORE THAN ONE CHECK SURFACE 3D
C  ROUTES USED
 68   CONTINUE
  168 IF(I3DFLG-K1)130,73,130
  130 IF(ICSCNT-K2)69,73,73
C  IF THICKNESS OF PART, DRIVE, AND CHECK SURFACE NOT ZERO 3D ROUTES
C  FOLLOWED
   69 IF(TH(IPS))173,70,173
  173 GO TO 73
   70 IF(TH(IDS))174,71,174
  174 GO TO 73
   71 IF(TH(ICS))73,76,73
   73 CONTINUE
C  ENTRY FOR 3D CALCULATIONS
  732 CALL ARLM3
      APT211=TEMP(1)+0.5
  101 IF(IAERR)1000,72,1000
   76 IS=ICS
      IF(ISFIDN(IDS)-K3)80,86,86
   80 IF(ISFIDN(ICS)-K3)82,81,81
C  LINE TO LINE CASE
   82 JBR=K3
      GO TO 83
C  CIRCLE TO LINE OR CIRCLE TO CIRCLE CASE
   86 JBR=K1
C  ENTRY FOR 2D CALCULATIONS
   83 CALL ARLM2
      APT211=Z1
      GO TO 101
C  LINE TO CIRCLE CASE
   81 JBR=K2
      GOTO83
 6001 IF(IGOTO)3001,3001,3002
 3001 CALL AERR (20107,'APT211  ')
      GO TO 1000
 3002 CALL AERR (20108,'APT211  ')
 1000 CONTINUE
 6002 APT211=Z1
      GO TO 72
 3000 IF(ISRCH)6001,6001,6002
 9999 CONTINUE
      RETURN
 9500 JJ=0
 9510 JJ=JJ+1
      IF(JJ.EQ.ITHCNT) GO TO 9590
      KK=ITABH(JJ)
      GO TO (9510,9510,9510,9504,9505,9506,9507,9508,9509,
     C 9550,9511,9512,9513),KK
 9504 CALL TOLERH
      GO TO 9510
 9505 CALL CUTTEH
      GO TO 9510
 9506 CALL CUTH
      GO TO 9510
 9507 CALL DNTCUH
      GO TO 9510
 9508 CALL INTOLH
      GO TO 9510
 9509 CALL OUTTOH
      GO TO 9510
 9550 CALL MAXDPH
      GO TO 9510
 9511 CALL INDRVH
      GO TO 9510
 9512 CALL INDRPH
      GO TO 9510
 9513 CALL THICKH
      GO TO 9510
 9590 ITHCNT=1
      IF(IAEEE.EQ.1) GO TO 8020
      GO TO 9600
 8000 KSEQNO = LSEQNO
      LSEQNO = JSEQNO
      CALL APT235
      IAEEE = 1
      CALL AERR(20110,'APT211  ')
 8010 IAERR = 0
      GO TO 9500
 8020 IAERR = 1
      NR = 0
      HOLDPP(8) = K2
      CALL EWRITE(EXFILE,NR,HOLDPP,8,IR)
      HOLDPP(8) = K1
      LSEQNO = KSEQNO
C....   RETURN TO CALLER
      GO TO 1000
      END
**** SOURCE FILE : M0002827.IBM;1   ***
*
C
C...  FORTRAN SUBROUTINE               CUTTER
      SUBROUTINE CUTTER(NMBR,PRM)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C-VAX.... MODIFICATION TO PERMIT RESTART PROCEDURE USING
C-VAX     VAX CONDITION HANDLING FACILITIES
      LOGICAL FLG
      FLG=.FALSE.
C.... ESTABLISH CONDITION HANDLER FRO AERR ERROR
      CALL APT241
   1  CALL CUTTES(NMBR,PRM,FLG)
      IF (FLG) GOTO 1
      RETURN
      END
C
      SUBROUTINE CUTTES(NMBR,PRM,FLG)
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE (TOTAL)
      INCLUDE (FXCOR)
      INCLUDE (ZNUMBR)
      INCLUDE (IFXCOR)
      INCLUDE (ISHR18)
      INCLUDE (KNUMBR)
C
C
C
      INTEGER HCUTER(2)
      INTEGER BCDF
C
C
C     25.   COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM / IAERFG
C
      COMMON /HOLD/ JHLDFG,ITHCNT,ITABH(100)
      COMMON /HSAVE/ SAVEH(50)
      EQUIVALENCE  (SAVEH( 6),PARAM(1) ),(SAVEH(15),NUMBER    )
      DIMENSION PRM(9)
C     -----------------------------------------------------------
C
C
C...  DEFINES CUTTER SHAPE AND SETS UP TOOL DATA BLOCKS
      DIMENSION PARAM(9)
      LOGICAL FLG
      HCUTER(1) = BCDF('CUTT')
      HCUTER(2) = BCDF('ER  ')
      IF(FLG)GO TO 9990
      FLG=.TRUE.
      DO 500 I=1,9
  500 PARAM(I)=PRM(I)
      NUMBER=NMBR
      IF(JHLDFG.EQ.0) GO TO 501
      ITABH(ITHCNT)=5
      ITHCNT=ITHCNT+1
      RETURN
C
  501 CONTINUE
  105 ICTDEF=K1
C...  ZERO CUTTER PARAMETER STORAGE AREA
      DO 110 J=1,7
  110 CUTDAT(J)=Z0
      CUTDAT(7) = TLHIT
      IF(NUMBER-K7)126,126,125
  125 NUMERR=22201
      GO TO 1000
  126 DO 127 J=1,NUMBER
  127 CUTDAT(J)=PARAM(J)
C  WRITE CUTTER STATEMENT ON EXFILE
      CALL APT299(NUMBER,HCUTER,1,PARAM(1))
      IF(NUMBER.LE.1) GO TO 129
      KK=1
      DO 128 I=2,NUMBER,2
      IF(I.EQ.NUMBER) KK=0
  128 CALL APT299(1,PARAM(I),KK,PARAM(I+1))
C
C  PLACE ZEROES IN TLLDAT BLOCK
C
  129 DO 1 I=1,8
      TLHITE(I)=Z0
      SINL(I)=Z0
      COSL(I)=Z0
      UMAX(I)=Z0
      RI(I)=Z0
      CORRAD(I)=Z0
      TCONT(I)=Z0
      TLINC(I)=Z0
    1 CONTINUE
C  MAKE SURE TOOL DIAMETER NOT LESS THAN ZERO
      IF(CUTDAT(1))2,92,3
    2 NUMERR=22202
      GO TO 1000
C  EXAMINE TOOL HEIGHT. IF LESS THAN ZERO ERROR. SET TO 5 IF = ZERO.
C  OKAY OTHERWISE
    3 IF(CUTDAT(7))4,5,6
    4 NUMERR=22203
      GO TO 1000
    5 CONTINUE
C  SUM OF ANGLES A AND B MUST BE LESS THAN 90 DEGREES
    6 IF(Z90-CUTDAT(5)-CUTDAT( 6))7,7,8
    7 NUMERR=22204
      GO TO 1000
    8 RI(6)=Z5EM1*CUTDAT(1)
      CUTDAT(1)=RI(6)
C  ERROR IF ANGLE A NEGATIVE
      IF(CUTDAT(5))9,10,11
    9 NUMERR=22205
      GO TO 1000
   10 COSL(2)=Z1
      TANHI(1)=Z1E38
      GO TO 12
C  COMPUTE PARAMETERS FOR CERTAIN TOOL SEGMENTS FOR A GREATER THAN ZERO
   11 TLHITE(8)=DEGRAD*CUTDAT(5)
      SINL(2)=DSIN(TLHITE(8))
      COSL(2)=DCOS(TLHITE(8))
      TCONT(1)=SINL(2)/COSL(2)
      TLHITE(6)=TCONT(1)*RI(6)
      TANHI(1)=Z1/TCONT(1)
C  MAKE SURE HEIGHT OF BOTTOM LINE SEGMENT DOES NOT EXCEED TOOL HEIGHT
   12 IF(Z1EM5-DABS(CUTDAT(7)-TLHITE(6))) 13,13,15
   13 IF(CUTDAT(7)-TLHITE(6))14,14,16
   14 NUMERR=22206
      GO TO 1000
   15 TLHITE(6)=CUTDAT(7)
C  ERROR IF ANGLE B NEGATIVE
   16 IPT1=K1
      IF(CUTDAT(6))17,18,19
C                    BELL SHAPED CUTTER
   17 CALL AERR (-22207,'CUTTER  ')
      GO TO 19
   18 SINL(6)=Z1
      GO TO 20
C  COMPUTE PARAMETERS FOR CERTAIN TOOL SEGMENTS FOR B GREATER THAN ZERO
   19 TANHI(8)=DEGRAD*CUTDAT(6)
      SINL(6)=DCOS(TANHI(8))
      COSL(6)=DSIN(TANHI(8))
      TANLO(7)=COSL(6)/TANHI(7)
C  FURTHER CALCULATIONS
   20 UMAX(2)=RI(6)/COSL(2)
      UMAX(6)=(CUTDAT(7)-TLHITE(6))/SINL(6)
      RI(7)=RI(6)+COSL(6)*UMAX(6)
      TCONT(2)=Z1
      TCONT(6)=Z1
C  EXAMINE TOOL RADIUS. IF GREATER THAN ZERO, CORNER CIRCLE WILL BE PART
C  OF TOOL CONFIGURATION. IF = ZERO, TOOL WILL CONSIST ONLY OF LINE AND
C  POINT CIRCLE SEGMENTS. ERROR IF NEGATIVE.
      IF(CUTDAT(2))21,22,25
   21 NUMERR=22208
      GO TO 1000
C  COMPARE LENGTH OF UPPER LINE SEGMENT TO ZERO. SET VALUES IN TLLDAT
C  BLOCK ACCORDINGLY
   22 IF(UMAX(6))23,23,24
   23 TANLO(7)=TANHI(1)
      TCONT(6)=Z0
      GO TO 87
   24 TLHITE(4)=TLHITE(6)
      RI(4)=RI(6)
      TANHI(4)=TANLO(7)
      TANLO(4)=TANHI(1)
      GO TO 86
C  COMPUTE CENTER OF CORNER CIRCLE
   27 CUTDAT(3)=RI(6)-CORRAD(4)
      CUTDAT(4)=CORRAD(4)
      GO TO 26
C  STORE RADIUS OF CORNER CIRCLE AND COMPUTE DISTANCE FROM CENTER OF
C  CIRCLE TO BOTTOM LINE (UMAX(3))
   25 CORRAD(4)=CUTDAT(2)
   26 UMAX(3)=CUTDAT(4)*COSL(2)-CUTDAT(3)*SINL(2)
      TANLO(1)=CUTDAT(3)*CUTDAT(3)+CUTDAT(4)*CUTDAT(4)
C  IF = 0, CENTER OF CORNER CIRCLE HAS TO BE CALCULATED
      IF(TANLO(1)+CUTDAT(5)+CUTDAT(6)*CUTDAT(6))28,27,28
C  DISTANCE FROM CENTER OF CIRCLE TO INTERSECTION OF LINE SEGMENTS
   28 UMAX(1)=DSQRT((CUTDAT(3)-RI(6))*(CUTDAT(3)-RI(6))
     1        +(CUTDAT(4)-TLHITE(6))*(CUTDAT(4)-TLHITE(6)))
      UMAX(7)=TANLO(7)*(CUTDAT(7)-TLHITE(6))
C  DISTANCE FROM CENTER OF CIRCLE TO UPPER END OF UPPER LINE SEGMENT
      UMAX(4)=DSQRT((CUTDAT(4)-CUTDAT(7))*(CUTDAT(4)-CUTDAT(7))
     1        +(CUTDAT(3)-RI(7))*(CUTDAT(3)-RI(7)))
C  IF THE Y COORD. (F) OF THE CENTER OF THE CORNER CIRCLE IS LESS THAN
C  THE Y COORD. OF THE INTERSECTION OF THE LINES, THEN ERROR
      IF(CUTDAT(4)+Z1EM5-TLHITE(6))29,29,30
   29 NUMERR=22209
      GO TO 1000
C  IF THE RADIUS IS BOTH LARGER THAN THE DISTANCE TO THE INTERSECTION
C  OF THE LINES AND DIFFERENT THAN THE DISTANCE TO THE ORIGIN OF THE
C  BOTTOM LINE SEGMENT, WE HAVE AN INVALID TOOL CONFIGURATION
   33 IF(Z1EM5-DABS(TANLO(1)-CORRAD(4)*CORRAD(4))) 34,34,35
   34 NUMERR=22210
      GO TO 1000
C  IF E GREATER THAN ZERO, WE HAVE AN INVALID TOOL CONFIGURATION
   35 IF(CUTDAT(3))53,37,34
   53 CALL AERR(-22211,'CUTTER  ')
      TANHI(1)=CUTDAT(4)/CUTDAT(3)
      TCONT(1)=CUTDAT(3)/CUTDAT(4)
C  NO LOWER LINE SEGMENT
   54 TCONT(2)=Z0
C  FURTHER TLLDAT VARIABLES
   55 TANLO(4)=TANHI(1)
   56 UMAX(5)=(RI(6)-CUTDAT(3))*SINL(6)+COSL(6)*(CUTDAT(4)-TLHITE(6))
C  IF = 0, THERE IS NO UPPER LINE SEGMENT AND IN THIS CASE TOOL NO GOOD
      IF(UMAX(6))67,57,67
C  IF GREATER THAN ZERO, RADIUS AND DISTANCE FROM CENTER OF CORNER
C  CIRCLE TO INTERSECTION OF LINES EQUAL.
   67 IF(CORRAD(4)-UMAX(1))68,68,62
   68 TCONT(7)=CORRAD(4)*CORRAD(4)-UMAX(5)*UMAX(5)
C  LENGTH OF UPPER LINE SEGMENT
      UMAX(6)=UMAX(6)+DSQRT(DABS(TCONT(7)))
     1       -DSQRT(UMAX(1)*UMAX(1)-UMAX(5)*UMAX(5))
      UMAX(8)=CUTDAT(4)-CUTDAT(7)-TANLO(7)*(UMAX(7)+RI(6)-CUTDAT(3))
      IF(Z1EM5-DABS(UMAX(8))) 72,72,69
   72 IF(UMAX(8))73,73,77
C  IF GREATER THAN ZERO, UPPER LINE SEGMENT WITH CORNER CIRCLE TANGENT.
C  OTHERWISE CORNER CIRCLE, PT. CIRCLE, UPPER LINE, AND THEN PT. CIRCLE
   73 IF(Z1EM5-DABS(TCONT(7))) 75,75,74
   75 IF(TCONT(7))76,76,83
   76 GO TO 41
   57 NUMERR=22212
      GO TO 1000
C  WE MUST CHANGE PARAMETERS FOR BOTTOM POINT CIRCLE DUE TO NATURE OF
C  CORNER CIRCLE
   37 CALL AERR(-22211,'CUTTER  ')
      TCONT(1)=Z0
      TANHI(1)=Z1E38
      GO TO 54
C  IF GREATER THAN OR EQUAL TO ZERO, CORNER CIRCLE IS A POINT CIRCLE
   30 IF(Z1EM5-DABS(CORRAD(4)-UMAX(1))) 32,31,31
   31 CORRAD(4) = 0.
      TANLO(1) = 0.
      UMAX(1) = 0.
      UMAX(3) = 0.
      UMAX(4) = 0.
      UMAX(7) = 0.
      CUTDAT(2) = 0.
      CUTDAT(3) = 0.
      CUTDAT(4) = 0.
      GO TO 22
   32 IF (CORRAD(4)-UMAX(1)) 38,38,33
   38 IF(RI(6)+TCONT(1)*(TLHITE(6)-CUTDAT(4))-
     1CUTDAT(3)+Z1EM5)39,39,40
C  CORNER CIRCLE INTERSECTS LOWER LINE SEGMENT AT AN UNACCEPTABLE ANGLE
   39 NUMERR=22213
      GO TO 1000
   40 IF(CUTDAT(4)+Z1EM5-TLHITE(6)-TANLO(7)*(RI(6)-
     1CUTDAT(3)))41,41,42
C  CORNER CIRCLE INTERSECTS UPPER LINE SEGMENT AT AN UNACCEPTABLE ANGLE
   41 NUMERR=22214
      GO TO 1000
   42 TANLO(3)=CORRAD(4)*CORRAD(4)-UMAX(3)*UMAX(3)
      IF(TANLO(3).LT.Z0)GO TO 39
C  LENGTH OF LOWER LINE SEGMENT
      UMAX(2)=UMAX(2)+DSQRT(TANLO(3))
     1       -DSQRT(UMAX(1)*UMAX(1)-UMAX(3)*UMAX(3))
      TANLO(8)=CUTDAT(3)+TCONT(1)*CUTDAT(4)
      IF(DABS(TANLO(8))-Z1EM5)43,46,46
C  IF GREATER THAN ZERO, PT. CIRCLE FOLLOWED BY CORNER CIRCLE OR JUST
C  CORNER CIRCLE. OTHERWISE PT. CIRCLE (MAYBE), LOWER LINE SEGMENT, PT.
C  CIRCLE, AND THEN CORNER CIRCLE
   43 IF(Z1EM5-DABS(TANLO(3))) 44,44,54
   44 IF(TANLO(3))45,45,50
   45 GO TO 39
   46 IF(TANLO(8))51,47,47
C  IF GREATER THAN ZERO,PT. CIRCLE (MAYBE), LOWER LINE SEGMENT, PT. CIR-
C  CLE, AND THEN CORNER CIRCLE. IF = 0, PT. CIRCLE AND CORNER CIRCLE.
C  ERROR LESS THAN ZERO
   51 IF(CORRAD(4)*CORRAD(4)-TANLO(1))52,53,50
   52 GO TO 39
C  IF GREATER THAN ZERO, CORNER CIRCLE TANGENT TO LOWER LINE SEGMENT
   47 IF(Z1EM5-DABS(TANLO(3))) 48,48,55
   48 IF(TANLO(3))49,49,50
   49 GO TO 39
C  LOWER LINE SEGMENT, PT. CIRCLE, AND CORNER CIRCLE PARAMETER CALC.
   50 TCONT(3)=DSQRT(TANLO(3))/UMAX(3)
      TANHI(3)=(Z1-TCONT(1)*TCONT(3))/(TCONT(1)+TCONT(3))
      TLHITE(3)=SINL(2)*UMAX(2)
      RI(3)=COSL(2)*UMAX(2)
      TANLO(3)=TANHI(1)
      TANLO(4)=TANHI(3)
      GO TO 56
   62 IF(Z1EM5-DABS(UMAX(4)-CORRAD(4))) 63,63,64
   63 NUMERR=22215
      GO TO 1000
C  IF GREATER THAN ZERO, CORNER CIRCLE MEETS UPPER PT. CIRCLE AT UNAC-
C  CEPTABLE ANGLE. IF = 0 WE MUST CHANGE PARAMETERS FOR UPPER PT. CIRCLE
   64 IF(CUTDAT(7)-CUTDAT(4))78,66,63
   78 CALL AERR(-22216,'CUTTER  ')
      TANLO(7)=(CUTDAT(4)-CUTDAT(7))/(RI(6)+SINL(6)-CUTDAT(3))
   79 TCONT(6)=Z0
   80 TANHI(4)=Z0
      GO TO 85
C  NO UPPER LINE SEGMENT. CHANGE IN PARAMETERS FOR UPPER POINT CIRCLE
C  NECESSARY DUE TO NATURE OF CORNER CIRCLE
   66 CALL AERR(-22216,'CUTTER  ')
      TANLO(7)=Z0
      GO TO 79
C  IF GREATER THAN ZERO,CORNER CIRCLE AND THEN UPPER PT. CIRCLE. OTHER-
C  WISE CORNER CIRCLE, PT. CIRCLE, UPPER LINE, AND THEN UPPER PT. CIRCLE
   69 IF(Z1EM5-DABS(TCONT(7))) 70,70,79
   70 IF(TCONT(7))71,71,83
   71 GO TO 41
   74 TANHI(4)=TANLO(7)
      GO TO 84
   77 IF(Z1EM5-DABS(CORRAD(4)-UMAX(4))) 81,81,78
   81 IF(CORRAD(4)-UMAX(4))82,82,83
   82 GO TO 41
C  FURTHER CALCULATIONS FOR TLLDAT BLOCK PARAMETERS
   83 TCONT(5)=DSQRT(TCONT(7))/UMAX(5)
      TANHI(4)=(TCONT(5)+TANLO(7))/(Z1-TCONT(5)*TANLO(7))
      TANLO(5)=TANHI(4)
      TANHI(5)=TANLO(7)
   84 RI(5)=RI(7)-COSL(6)*UMAX(6)
      TLHITE(5)=CUTDAT(7)-SINL(6)*UMAX(6)
      TLHITE(6)=TLHITE(5)
      RI(6)=RI(5)
   85 TLHITE(4)=CUTDAT(4)
      RI(4)=CUTDAT(3)
   86 TCONT(4)=Z1
   87 TANLO(1)=Z1E38
      TLINC(2)=Z1
      TLINC(6)=Z1
      TLHITE(7)=CUTDAT(7)
  200 IBEGIN=1
C  WE NOW SEARCH EACH OF THE 7 POSSIBLE SEGMENTS TO DETERMINE FIRST ONE
   91 IF(TCONT(IBEGIN))90,88,90
   90 TCONT(IBEGIN-1)=-Z1
      TCONT(8)=-Z1
      TCONT(7)=Z1
      TANHI(7)=-Z1E38
      TANHI(8)=-Z1E38
      TANLO(8)=Z1E38
      TLINC(8)=Z0
      CORRAD(8)=Z0
      ICTDEF=0
      IAERR=0
      CALL TLCONV
      GO TO 9999
   88 IBEGIN=IBEGIN+1
      IF(7-IBEGIN)89,91,91
   89 NUMERR=22217
      GO TO 1000
   92 IF(CUTDAT(7))4,93,10
   93 IPT1=0
      TANLO(7)=Z1E38
      IBEGIN=7
      GO TO 90
C
C        ** CUTTER PARAMETER ERROR-CALL AERR AND DEFINE POINT CUTTER
C
 1000 IAERFG=1
      ICTDEF=0
      CALL AERR(NUMERR,'CUTTER  ')
 9990 DO 1001 JJ=1,7
 1001 PARAM(JJ)=Z0
      NUMBER=K7
      FLG=.FALSE.
      GO TO 105
 9999 CONTINUE
      FLG=.FALSE.
      RETURN
      END
C
C
C
C
      SUBROUTINE CUTTEH
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE (TOTAL)
      INCLUDE (FXCOR)
      INCLUDE (ZNUMBR)
      INCLUDE (IFXCOR)
      INCLUDE (ISHR18)
      INCLUDE (KNUMBR)
C
C
C
      INTEGER HCUTER(2)
      INTEGER BCDF
C
C
C     25.   COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM / IAERFG
C
      COMMON /HSAVE/ SAVEH(50)
      EQUIVALENCE  (SAVEH( 6),PARAM(1) ),(SAVEH(15),NUMBER    )
C     -----------------------------------------------------------
C
C
C...  DEFINES CUTTER SHAPE AND SETS UP TOOL DATA BLOCKS
      DIMENSION PARAM(9)
      HCUTER(1) = BCDF('CUTT')
      HCUTER(2) = BCDF('ER  ')
C
  105 ICTDEF=K1
C...  ZERO CUTTER PARAMETER STORAGE AREA
      DO 110 J=1,7
  110 CUTDAT(J)=Z0
      CUTDAT(7) = TLHIT
      IF(NUMBER-K7)126,126,125
  125 NUMERR=22201
      GO TO 1000
  126 DO 127 J=1,NUMBER
  127 CUTDAT(J)=PARAM(J)
C  WRITE CUTTER STATEMENT ON EXFILE
      CALL APT299(NUMBER,HCUTER,1,PARAM(1))
      IF(NUMBER.LE.1) GO TO 129
      KK=1
      DO 128 I=2,NUMBER,2
      IF(I.EQ.NUMBER) KK=0
  128 CALL APT299(1,PARAM(I),KK,PARAM(I+1))
C
C  PLACE ZEROES IN TLLDAT BLOCK
C
  129 DO 1 I=1,8
      TLHITE(I)=Z0
      SINL(I)=Z0
      COSL(I)=Z0
      UMAX(I)=Z0
      RI(I)=Z0
      CORRAD(I)=Z0
      TCONT(I)=Z0
      TLINC(I)=Z0
    1 CONTINUE
C  MAKE SURE TOOL DIAMETER NOT LESS THAN ZERO
      IF(CUTDAT(1))2,92,3
    2 NUMERR=22202
      GO TO 1000
C  EXAMINE TOOL HEIGHT. IF LESS THAN ZERO ERROR. SET TO 5 IF = ZERO.
C  OKAY OTHERWISE
    3 IF(CUTDAT(7))4,5,6
    4 NUMERR=22203
      GO TO 1000
    5 CONTINUE
C  SUM OF ANGLES A AND B MUST BE LESS THAN 90 DEGREES
    6 IF(Z90-CUTDAT(5)-CUTDAT( 6))7,7,8
    7 NUMERR=22204
      GO TO 1000
    8 RI(6)=Z5EM1*CUTDAT(1)
      CUTDAT(1)=RI(6)
C  ERROR IF ANGLE A NEGATIVE
      IF(CUTDAT(5))9,10,11
    9 NUMERR=22205
      GO TO 1000
   10 COSL(2)=Z1
      TANHI(1)=Z1E38
      GO TO 12
C  COMPUTE PARAMETERS FOR CERTAIN TOOL SEGMENTS FOR A GREATER THAN ZERO
   11 TLHITE(8)=DEGRAD*CUTDAT(5)
      SINL(2)=DSIN(TLHITE(8))
      COSL(2)=DCOS(TLHITE(8))
      TCONT(1)=SINL(2)/COSL(2)
      TLHITE(6)=TCONT(1)*RI(6)
      TANHI(1)=Z1/TCONT(1)
C  MAKE SURE HEIGHT OF BOTTOM LINE SEGMENT DOES NOT EXCEED TOOL HEIGHT
   12 IF(Z1EM5-DABS(CUTDAT(7)-TLHITE(6))) 13,13,15
   13 IF(CUTDAT(7)-TLHITE(6))14,14,16
   14 NUMERR=22206
      GO TO 1000
   15 TLHITE(6)=CUTDAT(7)
C  ERROR IF ANGLE B NEGATIVE
   16 IPT1=K1
      IF(CUTDAT(6))17,18,19
C                    BELL SHAPED CUTTER
   17 CALL AERR (-22207,'CUTTEH  ')
      GO TO 19
   18 SINL(6)=Z1
      GO TO 20
C  COMPUTE PARAMETERS FOR CERTAIN TOOL SEGMENTS FOR B GREATER THAN ZERO
   19 TANHI(8)=DEGRAD*CUTDAT(6)
      SINL(6)=DCOS(TANHI(8))
      COSL(6)=DSIN(TANHI(8))
      TANLO(7)=COSL(6)/TANHI(7)
C  FURTHER CALCULATIONS
   20 UMAX(2)=RI(6)/COSL(2)
      UMAX(6)=(CUTDAT(7)-TLHITE(6))/SINL(6)
      RI(7)=RI(6)+COSL(6)*UMAX(6)
      TCONT(2)=Z1
      TCONT(6)=Z1
C  EXAMINE TOOL RADIUS. IF GREATER THAN ZERO, CORNER CIRCLE WILL BE PART
C  OF TOOL CONFIGURATION. IF = ZERO, TOOL WILL CONSIST ONLY OF LINE AND
C  POINT CIRCLE SEGMENTS. ERROR IF NEGATIVE.
      IF(CUTDAT(2))21,22,25
   21 NUMERR=22208
      GO TO 1000
C  COMPARE LENGTH OF UPPER LINE SEGMENT TO ZERO. SET VALUES IN TLLDAT
C  BLOCK ACCORDINGLY
   22 IF(UMAX(6))23,23,24
   23 TANLO(7)=TANHI(1)
      TCONT(6)=Z0
      GO TO 87
   24 TLHITE(4)=TLHITE(6)
      RI(4)=RI(6)
      TANHI(4)=TANLO(7)
      TANLO(4)=TANHI(1)
      GO TO 86
C  COMPUTE CENTER OF CORNER CIRCLE
   27 CUTDAT(3)=RI(6)-CORRAD(4)
      CUTDAT(4)=CORRAD(4)
      GO TO 26
C  STORE RADIUS OF CORNER CIRCLE AND COMPUTE DISTANCE FROM CENTER OF
C  CIRCLE TO BOTTOM LINE (UMAX(3))
   25 CORRAD(4)=CUTDAT(2)
   26 UMAX(3)=CUTDAT(4)*COSL(2)-CUTDAT(3)*SINL(2)
      TANLO(1)=CUTDAT(3)*CUTDAT(3)+CUTDAT(4)*CUTDAT(4)
C  IF = 0, CENTER OF CORNER CIRCLE HAS TO BE CALCULATED
      IF(TANLO(1)+CUTDAT(5)+CUTDAT(6)*CUTDAT(6))28,27,28
C  DISTANCE FROM CENTER OF CIRCLE TO INTERSECTION OF LINE SEGMENTS
   28 UMAX(1)=DSQRT((CUTDAT(3)-RI(6))*(CUTDAT(3)-RI(6))
     1        +(CUTDAT(4)-TLHITE(6))*(CUTDAT(4)-TLHITE(6)))
      UMAX(7)=TANLO(7)*(CUTDAT(7)-TLHITE(6))
C  DISTANCE FROM CENTER OF CIRCLE TO UPPER END OF UPPER LINE SEGMENT
      UMAX(4)=DSQRT((CUTDAT(4)-CUTDAT(7))*(CUTDAT(4)-CUTDAT(7))
     1        +(CUTDAT(3)-RI(7))*(CUTDAT(3)-RI(7)))
C  IF THE Y COORD. (F) OF THE CENTER OF THE CORNER CIRCLE IS LESS THAN
C  THE Y COORD. OF THE INTERSECTION OF THE LINES, THEN ERROR
      IF(CUTDAT(4)+Z1EM5-TLHITE(6))29,29,30
   29 NUMERR=22209
      GO TO 1000
C  IF THE RADIUS IS BOTH LARGER THAN THE DISTANCE TO THE INTERSECTION
C  OF THE LINES AND DIFFERENT THAN THE DISTANCE TO THE ORIGIN OF THE
C  BOTTOM LINE SEGMENT, WE HAVE AN INVALID TOOL CONFIGURATION
   33 IF(Z1EM5-DABS(TANLO(1)-CORRAD(4)*CORRAD(4))) 34,34,35
   34 NUMERR=22210
      GO TO 1000
C  IF E GREATER THAN ZERO, WE HAVE AN INVALID TOOL CONFIGURATION
   35 IF(CUTDAT(3))53,37,34
   53 CALL AERR(-22211,'CUTTEH  ')
      TANHI(1)=CUTDAT(4)/CUTDAT(3)
      TCONT(1)=CUTDAT(3)/CUTDAT(4)
C  NO LOWER LINE SEGMENT
   54 TCONT(2)=Z0
C  FURTHER TLLDAT VARIABLES
   55 TANLO(4)=TANHI(1)
   56 UMAX(5)=(RI(6)-CUTDAT(3))*SINL(6)+COSL(6)*(CUTDAT(4)-TLHITE(6))
C  IF = 0, THERE IS NO UPPER LINE SEGMENT AND IN THIS CASE TOOL NO GOOD
      IF(UMAX(6))67,57,67
C  IF GREATER THAN ZERO, RADIUS AND DISTANCE FROM CENTER OF CORNER
C  CIRCLE TO INTERSECTION OF LINES EQUAL.
   67 IF(CORRAD(4)-UMAX(1))68,68,62
   68 TCONT(7)=CORRAD(4)*CORRAD(4)-UMAX(5)*UMAX(5)
C  LENGTH OF UPPER LINE SEGMENT
      UMAX(6)=UMAX(6)+DSQRT(DABS(TCONT(7)))
     1       -DSQRT(UMAX(1)*UMAX(1)-UMAX(5)*UMAX(5))
      UMAX(8)=CUTDAT(4)-CUTDAT(7)-TANLO(7)*(UMAX(7)+RI(6)-CUTDAT(3))
      IF(Z1EM5-DABS(UMAX(8))) 72,72,69
   72 IF(UMAX(8))73,73,77
C  IF GREATER THAN ZERO, UPPER LINE SEGMENT WITH CORNER CIRCLE TANGENT.
C  OTHERWISE CORNER CIRCLE, PT. CIRCLE, UPPER LINE, AND THEN PT. CIRCLE
   73 IF(Z1EM5-DABS(TCONT(7))) 75,75,74
   75 IF(TCONT(7))76,76,83
   76 GO TO 41
   57 NUMERR=22212
      GO TO 1000
C  WE MUST CHANGE PARAMETERS FOR BOTTOM POINT CIRCLE DUE TO NATURE OF
C  CORNER CIRCLE
   37 CALL AERR(-22211,'CUTTEH  ')
      TCONT(1)=Z0
      TANHI(1)=Z1E38
      GO TO 54
C  IF GREATER THAN OR EQUAL TO ZERO, CORNER CIRCLE IS A POINT CIRCLE
   30 IF(Z1EM5-DABS(CORRAD(4)-UMAX(1))) 32,31,31
   31 CORRAD(4) = 0.
      TANLO(1) = 0.
      UMAX(1) = 0.
      UMAX(3) = 0.
      UMAX(4) = 0.
      UMAX(7) = 0.
      CUTDAT(2) = 0.
      CUTDAT(3) = 0.
      CUTDAT(4) = 0.
      GO TO 22
   32 IF (CORRAD(4)-UMAX(1)) 38,38,33
   38 IF(RI(6)+TCONT(1)*(TLHITE(6)-CUTDAT(4))-
     1CUTDAT(3)+Z1EM5)39,39,40
C  CORNER CIRCLE INTERSECTS LOWER LINE SEGMENT AT AN UNACCEPTABLE ANGLE
   39 NUMERR=22213
      GO TO 1000
   40 IF(CUTDAT(4)+Z1EM5-TLHITE(6)-TANLO(7)*(RI(6)-
     1CUTDAT(3)))41,41,42
C  CORNER CIRCLE INTERSECTS UPPER LINE SEGMENT AT AN UNACCEPTABLE ANGLE
   41 NUMERR=22214
      GO TO 1000
   42 TANLO(3)=CORRAD(4)*CORRAD(4)-UMAX(3)*UMAX(3)
      IF(TANLO(3).LT.Z0)GO TO 39
C  LENGTH OF LOWER LINE SEGMENT
      UMAX(2)=UMAX(2)+DSQRT(TANLO(3))
     1       -DSQRT(UMAX(1)*UMAX(1)-UMAX(3)*UMAX(3))
      TANLO(8)=CUTDAT(3)+TCONT(1)*CUTDAT(4)
      IF(DABS(TANLO(8))-Z1EM5)43,46,46
C  IF GREATER THAN ZERO, PT. CIRCLE FOLLOWED BY CORNER CIRCLE OR JUST
C  CORNER CIRCLE. OTHERWISE PT. CIRCLE (MAYBE), LOWER LINE SEGMENT, PT.
C  CIRCLE, AND THEN CORNER CIRCLE
   43 IF(Z1EM5-DABS(TANLO(3))) 44,44,54
   44 IF(TANLO(3))45,45,50
   45 GO TO 39
   46 IF(TANLO(8))51,47,47
C  IF GREATER THAN ZERO,PT. CIRCLE (MAYBE), LOWER LINE SEGMENT, PT. CIR-
C  CLE, AND THEN CORNER CIRCLE. IF = 0, PT. CIRCLE AND CORNER CIRCLE.
C  ERROR LESS THAN ZERO
   51 IF(CORRAD(4)*CORRAD(4)-TANLO(1))52,53,50
   52 GO TO 39
C  IF GREATER THAN ZERO, CORNER CIRCLE TANGENT TO LOWER LINE SEGMENT
   47 IF(Z1EM5-DABS(TANLO(3))) 48,48,55
   48 IF(TANLO(3))49,49,50
   49 GO TO 39
C  LOWER LINE SEGMENT, PT. CIRCLE, AND CORNER CIRCLE PARAMETER CALC.
   50 TCONT(3)=DSQRT(TANLO(3))/UMAX(3)
      TANHI(3)=(Z1-TCONT(1)*TCONT(3))/(TCONT(1)+TCONT(3))
      TLHITE(3)=SINL(2)*UMAX(2)
      RI(3)=COSL(2)*UMAX(2)
      TANLO(3)=TANHI(1)
      TANLO(4)=TANHI(3)
      GO TO 56
   62 IF(Z1EM5-DABS(UMAX(4)-CORRAD(4))) 63,63,64
   63 NUMERR=22215
      GO TO 1000
C  IF GREATER THAN ZERO, CORNER CIRCLE MEETS UPPER PT. CIRCLE AT UNAC-
C  CEPTABLE ANGLE. IF = 0 WE MUST CHANGE PARAMETERS FOR UPPER PT. CIRCLE
   64 IF(CUTDAT(7)-CUTDAT(4))78,66,63
   78 CALL AERR(-22216,'CUTTEH  ')
      TANLO(7)=(CUTDAT(4)-CUTDAT(7))/(RI(6)+SINL(6)-CUTDAT(3))
   79 TCONT(6)=Z0
   80 TANHI(4)=Z0
      GO TO 85
C  NO UPPER LINE SEGMENT. CHANGE IN PARAMETERS FOR UPPER POINT CIRCLE
C  NECESSARY DUE TO NATURE OF CORNER CIRCLE
   66 CALL AERR(-22216,'CUTTEH  ')
      TANLO(7)=Z0
      GO TO 79
C  IF GREATER THAN ZERO,CORNER CIRCLE AND THEN UPPER PT. CIRCLE. OTHER-
C  WISE CORNER CIRCLE, PT. CIRCLE, UPPER LINE, AND THEN UPPER PT. CIRCLE
   69 IF(Z1EM5-DABS(TCONT(7))) 70,70,79
   70 IF(TCONT(7))71,71,83
   71 GO TO 41
   74 TANHI(4)=TANLO(7)
      GO TO 84
   77 IF(Z1EM5-DABS(CORRAD(4)-UMAX(4))) 81,81,78
   81 IF(CORRAD(4)-UMAX(4))82,82,83
   82 GO TO 41
C  FURTHER CALCULATIONS FOR TLLDAT BLOCK PARAMETERS
   83 TCONT(5)=DSQRT(TCONT(7))/UMAX(5)
      TANHI(4)=(TCONT(5)+TANLO(7))/(Z1-TCONT(5)*TANLO(7))
      TANLO(5)=TANHI(4)
      TANHI(5)=TANLO(7)
   84 RI(5)=RI(7)-COSL(6)*UMAX(6)
      TLHITE(5)=CUTDAT(7)-SINL(6)*UMAX(6)
      TLHITE(6)=TLHITE(5)
      RI(6)=RI(5)
   85 TLHITE(4)=CUTDAT(4)
      RI(4)=CUTDAT(3)
   86 TCONT(4)=Z1
   87 TANLO(1)=Z1E38
      TLINC(2)=Z1
      TLINC(6)=Z1
      TLHITE(7)=CUTDAT(7)
  200 IBEGIN=1
C  WE NOW SEARCH EACH OF THE 7 POSSIBLE SEGMENTS TO DETERMINE FIRST ONE
   91 IF(TCONT(IBEGIN))90,88,90
   90 TCONT(IBEGIN-1)=-Z1
      TCONT(8)=-Z1
      TCONT(7)=Z1
      TANHI(7)=-Z1E38
      TANHI(8)=-Z1E38
      TANLO(8)=Z1E38
      TLINC(8)=Z0
      CORRAD(8)=Z0
      ICTDEF=0
      IAERR=0
      CALL TLCONV
      GO TO 9999
   88 IBEGIN=IBEGIN+1
      IF(7-IBEGIN)89,91,91
   89 NUMERR=22217
      GO TO 1000
   92 IF(CUTDAT(7))4,93,10
   93 IPT1=0
      TANLO(7)=Z1E38
      IBEGIN=7
      GO TO 90
C
C        ** CUTTER PARAMETER ERROR-CALL AERR AND DEFINE POINT CUTTER
C
 1000 IAERFG=1
      ICTDEF=0
      CALL AERR(NUMERR,'CUTTEH  ')
 9990 DO 1001 JJ=1,7
 1001 PARAM(JJ)=Z0
      NUMBER=K7
      GO TO 105
 9999 CONTINUE
      RETURN
       END
C
C
C
C
      SUBROUTINE CUTRED
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
C
C
C
      INCLUDE (TOTAL)
      INCLUDE (FXCOR)
      INCLUDE (ZNUMBR)
      INCLUDE (IFXCOR)
      INCLUDE (ISHR18)
      INCLUDE (KNUMBR)
C
C
C
      INTEGER HCUTER(2)
      INTEGER BCDF
C
C
C     25.   COMMON FOR AERR INFORMATION
C
      COMMON /AERCOM / IAERFG
C
      COMMON /HSAVE/ SAVEH(50)
      EQUIVALENCE  (SAVEH( 6),PARAM(1) ),(SAVEH(15),NUMBER    )
C     -----------------------------------------------------------
C
C
C...  DEFINES CUTTER SHAPE AND SETS UP TOOL DATA BLOCKS
      DIMENSION PARAM(9)
C
      HCUTER(1) = BCDF('CUTT')
      HCUTER(2) = BCDF('ER  ')
C
C  PLACE ZEROES IN TLLDAT BLOCK
C        CUTRED ROUTINE TO REDEFINE EXISTING CUTTER FOR NEW UNITS/
  129 DO 1 I=1,8
      TLHITE(I)=Z0
      SINL(I)=Z0
      COSL(I)=Z0
      UMAX(I)=Z0
      RI(I)=Z0
      CORRAD(I)=Z0
      TCONT(I)=Z0
      TLINC(I)=Z0
    1 CONTINUE
C  MAKE SURE TOOL DIAMETER NOT LESS THAN ZERO
      IF(CUTDAT(1))2,92,3
    2 NUMERR=22202
      GO TO 1000
C  EXAMINE TOOL HEIGHT. IF LESS THAN ZERO ERROR. SET TO 5 IF = ZERO.
C  OKAY OTHERWISE
    3 IF(CUTDAT(7))4,5,6
    4 NUMERR=22203
      GO TO 1000
    5 CONTINUE
C  SUM OF ANGLES A AND B MUST BE LESS THAN 90 DEGREES
    6 IF(Z90-CUTDAT(5)-CUTDAT( 6))7,7,8
    7 NUMERR=22204
      GO TO 1000
    8 RI(6)=Z5EM1*CUTDAT(1)
      CUTDAT(1)=RI(6)
C  ERROR IF ANGLE A NEGATIVE
      IF(CUTDAT(5))9,10,11
    9 NUMERR=22205
      GO TO 1000
   10 COSL(2)=Z1
      TANHI(1)=Z1E38
      GO TO 12
C  COMPUTE PARAMETERS FOR CERTAIN TOOL SEGMENTS FOR A GREATER THAN ZERO
   11 TLHITE(8)=DEGRAD*CUTDAT(5)
      SINL(2)=DSIN(TLHITE(8))
      COSL(2)=DCOS(TLHITE(8))
      TCONT(1)=SINL(2)/COSL(2)
      TLHITE(6)=TCONT(1)*RI(6)
      TANHI(1)=Z1/TCONT(1)
C  MAKE SURE HEIGHT OF BOTTOM LINE SEGMENT DOES NOT EXCEED TOOL HEIGHT
   12 IF(Z1EM5-DABS(CUTDAT(7)-TLHITE(6))) 13,13,15
   13 IF(CUTDAT(7)-TLHITE(6))14,14,16
   14 NUMERR=22206
      GO TO 1000
   15 TLHITE(6)=CUTDAT(7)
C  ERROR IF ANGLE B NEGATIVE
   16 IPT1=K1
      IF(CUTDAT(6))17,18,19
C                    BELL SHAPED CUTTER
   17 CALL AERR (-22207,'CUTRED  ')
      GO TO 19
   18 SINL(6)=Z1
      GO TO 20
C  COMPUTE PARAMETERS FOR CERTAIN TOOL SEGMENTS FOR B GREATER THAN ZERO
   19 TANHI(8)=DEGRAD*CUTDAT(6)
      SINL(6)=DCOS(TANHI(8))
      COSL(6)=DSIN(TANHI(8))
      TANLO(7)=COSL(6)/TANHI(7)
C  FURTHER CALCULATIONS
   20 UMAX(2)=RI(6)/COSL(2)
      UMAX(6)=(CUTDAT(7)-TLHITE(6))/SINL(6)
      RI(7)=RI(6)+COSL(6)*UMAX(6)
      TCONT(2)=Z1
      TCONT(6)=Z1
C  EXAMINE TOOL RADIUS. IF GREATER THAN ZERO, CORNER CIRCLE WILL BE PART
C  OF TOOL CONFIGURATION. IF = ZERO, TOOL WILL CONSIST ONLY OF LINE AND
C  POINT CIRCLE SEGMENTS. ERROR IF NEGATIVE.
      IF(CUTDAT(2))21,22,25
   21 NUMERR=22208
      GO TO 1000
C  COMPARE LENGTH OF UPPER LINE SEGMENT TO ZERO. SET VALUES IN TLLDAT
C  BLOCK ACCORDINGLY
   22 IF(UMAX(6))23,23,24
   23 TANLO(7)=TANHI(1)
      TCONT(6)=Z0
      GO TO 87
   24 TLHITE(4)=TLHITE(6)
      RI(4)=RI(6)
      TANHI(4)=TANLO(7)
      TANLO(4)=TANHI(1)
      GO TO 86
C  COMPUTE CENTER OF CORNER CIRCLE
   27 CUTDAT(3)=RI(6)-CORRAD(4)
      CUTDAT(4)=CORRAD(4)
      GO TO 26
C  STORE RADIUS OF CORNER CIRCLE AND COMPUTE DISTANCE FROM CENTER OF
C  CIRCLE TO BOTTOM LINE (UMAX(3))
   25 CORRAD(4)=CUTDAT(2)
   26 UMAX(3)=CUTDAT(4)*COSL(2)-CUTDAT(3)*SINL(2)
      TANLO(1)=CUTDAT(3)*CUTDAT(3)+CUTDAT(4)*CUTDAT(4)
C  IF = 0, CENTER OF CORNER CIRCLE HAS TO BE CALCULATED
      IF(TANLO(1)+CUTDAT(5)+CUTDAT(6)*CUTDAT(6))28,27,28
C  DISTANCE FROM CENTER OF CIRCLE TO INTERSECTION OF LINE SEGMENTS
   28 UMAX(1)=DSQRT((CUTDAT(3)-RI(6))*(CUTDAT(3)-RI(6))
     1        +(CUTDAT(4)-TLHITE(6))*(CUTDAT(4)-TLHITE(6)))
      UMAX(7)=TANLO(7)*(CUTDAT(7)-TLHITE(6))
C  DISTANCE FROM CENTER OF CIRCLE TO UPPER END OF UPPER LINE SEGMENT
      UMAX(4)=DSQRT((CUTDAT(4)-CUTDAT(7))*(CUTDAT(4)-CUTDAT(7))
     1        +(CUTDAT(3)-RI(7))*(CUTDAT(3)-RI(7)))
C  IF THE Y COORD. (F) OF THE CENTER OF THE CORNER CIRCLE IS LESS THAN
C  THE Y COORD. OF THE INTERSECTION OF THE LINES, THEN ERROR
      IF(CUTDAT(4)+Z1EM5-TLHITE(6))29,29,30
   29 NUMERR=22209
      GO TO 1000
C  IF THE RADIUS IS BOTH LARGER THAN THE DISTANCE TO THE INTERSECTION
C  OF THE LINES AND DIFFERENT THAN THE DISTANCE TO THE ORIGIN OF THE
C  BOTTOM LINE SEGMENT, WE HAVE AN INVALID TOOL CONFIGURATION
   33 IF(Z1EM5-DABS(TANLO(1)-CORRAD(4)*CORRAD(4))) 34,34,35
   34 NUMERR=22210
      GO TO 1000
C  IF E GREATER THAN ZERO, WE HAVE AN INVALID TOOL CONFIGURATION
   35 IF(CUTDAT(3))53,37,34
   53 CALL AERR(-22211,'CUTRED  ')
      TANHI(1)=CUTDAT(4)/CUTDAT(3)
      TCONT(1)=CUTDAT(3)/CUTDAT(4)
C  NO LOWER LINE SEGMENT
   54 TCONT(2)=Z0
C  FURTHER TLLDAT VARIABLES
   55 TANLO(4)=TANHI(1)
   56 UMAX(5)=(RI(6)-CUTDAT(3))*SINL(6)+COSL(6)*(CUTDAT(4)-TLHITE(6))
C  IF = 0, THERE IS NO UPPER LINE SEGMENT AND IN THIS CASE TOOL NO GOOD
      IF(UMAX(6))67,57,67
C  IF GREATER THAN ZERO, RADIUS AND DISTANCE FROM CENTER OF CORNER
C  CIRCLE TO INTERSECTION OF LINES EQUAL.
   67 IF(CORRAD(4)-UMAX(1))68,68,62
   68 TCONT(7)=CORRAD(4)*CORRAD(4)-UMAX(5)*UMAX(5)
C  LENGTH OF UPPER LINE SEGMENT
      UMAX(6)=UMAX(6)+DSQRT(DABS(TCONT(7)))
     1       -DSQRT(UMAX(1)*UMAX(1)-UMAX(5)*UMAX(5))
      UMAX(8)=CUTDAT(4)-CUTDAT(7)-TANLO(7)*(UMAX(7)+RI(6)-CUTDAT(3))
      IF(Z1EM5-DABS(UMAX(8))) 72,72,69
   72 IF(UMAX(8))73,73,77
C  IF GREATER THAN ZERO, UPPER LINE SEGMENT WITH CORNER CIRCLE TANGENT.
C  OTHERWISE CORNER CIRCLE, PT. CIRCLE, UPPER LINE, AND THEN PT. CIRCLE
   73 IF(Z1EM5-DABS(TCONT(7))) 75,75,74
   75 IF(TCONT(7))76,76,83
   76 GO TO 41
   57 NUMERR=22212
      GO TO 1000
C  WE MUST CHANGE PARAMETERS FOR BOTTOM POINT CIRCLE DUE TO NATURE OF
C  CORNER CIRCLE
   37 CALL AERR(-22211,'CUTRED  ')
      TCONT(1)=Z0
      TANHI(1)=Z1E38
      GO TO 54
C  IF GREATER THAN OR EQUAL TO ZERO, CORNER CIRCLE IS A POINT CIRCLE
   30 IF(Z1EM5-DABS(CORRAD(4)-UMAX(1))) 32,31,31
   31 CORRAD(4) = 0.
      TANLO(1) = 0.
      UMAX(1) = 0.
      UMAX(3) = 0.
      UMAX(4) = 0.
      UMAX(7) = 0.
      CUTDAT(2) = 0.
      CUTDAT(3) = 0.
      CUTDAT(4) = 0.
      GO TO 22
   32 IF (CORRAD(4)-UMAX(1)) 38,38,33
   38 IF(RI(6)+TCONT(1)*(TLHITE(6)-CUTDAT(4))-
     1CUTDAT(3)+Z1EM5)39,39,40
C  CORNER CIRCLE INTERSECTS LOWER LINE SEGMENT AT AN UNACCEPTABLE ANGLE
   39 NUMERR=22213
      GO TO 1000
   40 IF(CUTDAT(4)+Z1EM5-TLHITE(6)-TANLO(7)*(RI(6)-
     1CUTDAT(3)))41,41,42
C  CORNER CIRCLE INTERSECTS UPPER LINE SEGMENT AT AN UNACCEPTABLE ANGLE
   41 NUMERR=22214
      GO TO 1000
   42 TANLO(3)=CORRAD(4)*CORRAD(4)-UMAX(3)*UMAX(3)
      IF(TANLO(3).LT.Z0)GO TO 39
C  LENGTH OF LOWER LINE SEGMENT
      UMAX(2)=UMAX(2)+DSQRT(TANLO(3))
     1       -DSQRT(UMAX(1)*UMAX(1)-UMAX(3)*UMAX(3))
      TANLO(8)=CUTDAT(3)+TCONT(1)*CUTDAT(4)
      IF(DABS(TANLO(8))-Z1EM5)43,46,46
C  IF GREATER THAN ZERO, PT. CIRCLE FOLLOWED BY CORNER CIRCLE OR JUST
C  CORNER CIRCLE. OTHERWISE PT. CIRCLE (MAYBE), LOWER LINE SEGMENT, PT.
C  CIRCLE, AND THEN CORNER CIRCLE
   43 IF(Z1EM5-DABS(TANLO(3))) 44,44,54
   44 IF(TANLO(3))45,45,50
   45 GO TO 39
   46 IF(TANLO(8))51,47,47
C  IF GREATER THAN ZERO,PT. CIRCLE (MAYBE), LOWER LINE SEGMENT, PT. CIR-
C  CLE, AND THEN CORNER CIRCLE. IF = 0, PT. CIRCLE AND CORNER CIRCLE.
C  ERROR LESS THAN ZERO
   51 IF(CORRAD(4)*CORRAD(4)-TANLO(1))52,53,50
   52 GO TO 39
C  IF GREATER THAN ZERO, CORNER CIRCLE TANGENT TO LOWER LINE SEGMENT
   47 IF(Z1EM5-DABS(TANLO(3))) 48,48,55
   48 IF(TANLO(3))49,49,50
   49 GO TO 39
C  LOWER LINE SEGMENT, PT. CIRCLE, AND CORNER CIRCLE PARAMETER CALC.
   50 TCONT(3)=DSQRT(TANLO(3))/UMAX(3)
      TANHI(3)=(Z1-TCONT(1)*TCONT(3))/(TCONT(1)+TCONT(3))
      TLHITE(3)=SINL(2)*UMAX(2)
      RI(3)=COSL(2)*UMAX(2)
      TANLO(3)=TANHI(1)
      TANLO(4)=TANHI(3)
      GO TO 56
   62 IF(Z1EM5-DABS(UMAX(4)-CORRAD(4))) 63,63,64
   63 NUMERR=22215
      GO TO 1000
C  IF GREATER THAN ZERO, CORNER CIRCLE MEETS UPPER PT. CIRCLE AT UNAC-
C  CEPTABLE ANGLE. IF = 0 WE MUST CHANGE PARAMETERS FOR UPPER PT. CIRCLE
   64 IF(CUTDAT(7)-CUTDAT(4))78,66,63
   78 CALL AERR(-22216,'CUTRED  ')
      TANLO(7)=(CUTDAT(4)-CUTDAT(7))/(RI(6)+SINL(6)-CUTDAT(3))
   79 TCONT(6)=Z0
   80 TANHI(4)=Z0
      GO TO 85
C  NO UPPER LINE SEGMENT. CHANGE IN PARAMETERS FOR UPPER POINT CIRCLE
C  NECESSARY DUE TO NATURE OF CORNER CIRCLE
   66 CALL AERR(-22216,'CUTRED  ')
      TANLO(7)=Z0
      GO TO 79
C  IF GREATER THAN ZERO,CORNER CIRCLE AND THEN UPPER PT. CIRCLE. OTHER-
C  WISE CORNER CIRCLE, PT. CIRCLE, UPPER LINE, AND THEN UPPER PT. CIRCLE
   69 IF(Z1EM5-DABS(TCONT(7))) 70,70,79
   70 IF(TCONT(7))71,71,83
   71 GO TO 41
   74 TANHI(4)=TANLO(7)
      GO TO 84
   77 IF(Z1EM5-DABS(CORRAD(4)-UMAX(4))) 81,81,78
   81 IF(CORRAD(4)-UMAX(4))82,82,83
   82 GO TO 41
C  FURTHER CALCULATIONS FOR TLLDAT BLOCK PARAMETERS
   83 TCONT(5)=DSQRT(TCONT(7))/UMAX(5)
      TANHI(4)=(TCONT(5)+TANLO(7))/(Z1-TCONT(5)*TANLO(7))
      TANLO(5)=TANHI(4)
      TANHI(5)=TANLO(7)
   84 RI(5)=RI(7)-COSL(6)*UMAX(6)
      TLHITE(5)=CUTDAT(7)-SINL(6)*UMAX(6)
      TLHITE(6)=TLHITE(5)
      RI(6)=RI(5)
   85 TLHITE(4)=CUTDAT(4)
      RI(4)=CUTDAT(3)
   86 TCONT(4)=Z1
   87 TANLO(1)=Z1E38
      TLINC(2)=Z1
      TLINC(6)=Z1
      TLHITE(7)=CUTDAT(7)
  200 IBEGIN=1
C  WE NOW SEARCH EACH OF THE 7 POSSIBLE SEGMENTS TO DETERMINE FIRST ONE
   91 IF(TCONT(IBEGIN))90,88,90
   90 TCONT(IBEGIN-1)=-Z1
      TCONT(8)=-Z1
      TCONT(7)=Z1
      TANHI(7)=-Z1E38
      TANHI(8)=-Z1E38
      TANLO(8)=Z1E38
      TLINC(8)=Z0
      CORRAD(8)=Z0
      ICTDEF=0
      IAERR=0
      CALL TLCONV
      GO TO 9999
   88 IBEGIN=IBEGIN+1
      IF(7-IBEGIN)89,91,91
   89 NUMERR=22217
      GO TO 1000
   92 IF(CUTDAT(7))4,93,10
   93 IPT1=0
      TANLO(7)=Z1E38
      IBEGIN=7
      GO TO 90
C
C        ** CUTTER PARAMETER ERROR-CALL AERR AND DEFINE POINT CUTTER
C
 1000 IAERFG=1
      ICTDEF=0
      CALL AERR(NUMERR,'CUTRED  ')
 9990 DO 1001 JJ=1,7
 1001 PARAM(JJ)=Z0
      NUMBER=K7
C
      ICTDEF=K1
C...  ZERO CUTTER PARAMETER STORAGE AREA
      DO 110 J=1,7
  110 CUTDAT(J)=Z0
      CUTDAT(7) = TLHIT
      IF(NUMBER-K7)126,126,125
  125 NUMERR=22201
      GO TO 1000
  126 DO 127 J=1,NUMBER
  127 CUTDAT(J)=PARAM(J)
C  WRITE CUTTER STATEMENT ON EXFILE
      CALL APT299(NUMBER,HCUTER,1,PARAM(1))
      IF(NUMBER.LE.1) GO TO 129
      KK=1
      DO 128 I=2,NUMBER,2
      IF(I.EQ.NUMBER) KK=0
  128 CALL APT299(1,PARAM(I),KK,PARAM(I+1))
      GO TO 129
C
 9999 CONTINUE
      RETURN
       END
**** SOURCE FILE : M0004132.IBM;2   ***
*
C
C
      SUBROUTINE GO(HMOD,ADRESS)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      INCLUDE (TOTAL)
      INCLUDE (LDEF)
      INCLUDE (IFXCOR)
C
      DIMENSION ADRESS(*)
      IF(JDS) CALL APT211(0,'NOCS    ',IDUM)
      CALL APT241
      IF(IAERR.EQ.1)GO TO 10
C-VAX-ESTABLISH CONDITION HANDLER
C      CALL APT241
   20 IF(ICTDEF.NE.0.AND.IGOTO.EQ.0)CALL AERR(20201,'GO      ')
C     IF (IAERR.EQ.1) GOTO 10
      CALL GO2(HMOD,ADRESS)
C     IF (IAERR.EQ.1) GOTO 20
   10 CONTINUE
      RETURN
      END
**** SOURCE FILE : OUTSET00.IBM;1   ***
*
      SUBROUTINE OUTSET(J)
*
*  * OUTSET *  VAX-11 FORTRAN 77 SUBROUTINE   E.MCLELLAN
*
*  PURPOSE     TO SET UP PAPER TAPE CODE CONVERSION TABLE
*
*  CALLING SEQUENCE
*              CALL OUTSET(J)
*  ARGUMENT
*              J  INDICATES REQUIRED CODE
*                 =1  NAS943  ,ODD PARITY, COLUMN BINARY
*                 =2  ISO     ,EVEN PARITY,COLUMN BINARY
*                 =3  ASCII   ,NO PARITY,  NO CONVERSION
*
C
      INCLUDE (DARRAY)
C
      COMMON/PUNTAB/PUNCOD
C
C...LOGICAL*1 VARIABLES IN THIS IBM IMPLEMENTATION MIGHT BE ABLE TO BE
C...BYTE VARIABLES ON OTHER SYSTEMS  E.G. VAX
      LOGICAL*1 PUNCOD(128)
      LOGICAL*1 NAS943(128),ISO(128),ASCII(128)
*
******  NAS943 ODD PARITY COLUMN BINARY
*
      DATA NAS943/
*      0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
     *Z00,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,Z3E,ZEE,ZEE,ZEE,Z80,ZEE,ZEE,
     1ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,
     2Z10,ZEE,ZEE,Z7F,Z80,Z0B,Z70,ZEE,Z0B,Z2A,Z3E,Z70,Z3B,Z40,Z6B,Z31,
     3Z20,Z01,Z02,Z13,Z04,Z15,Z16,Z07,Z08,Z19,Z7C,Z7A,ZEE,Z7F,ZEE,ZEE,
     4Z0E,Z61,Z62,Z73,Z64,Z75,Z76,Z67,Z68,Z79,Z51,Z52,Z43,Z54,Z45,Z46,
     5Z57,Z58,Z49,Z32,Z23,Z34,Z25,Z26,Z37,Z38,Z29,ZEE,ZEE,ZEE,ZEE,ZEE,
     6ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,
     7ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE/
*
******  ISO/
*
      DATA ISO/
*      0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
     *Z00,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,Z09,Z0A,ZEE,ZEE,Z8D,ZEE,ZEE,
     1ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,
     2ZA0,ZEE,ZEE,ZA3,Z24,ZA5,ZA6,Z27,Z28,ZA9,ZAA,Z2B,ZAC,Z2D,Z2E,ZAF,
     3Z30,ZB1,ZB2,Z33,ZB4,Z35,Z36,ZB7,ZB8,Z39,Z3A,ZEE,ZEE,ZEE,ZEE,ZEE,
     4ZC0,Z41,Z42,ZC3,Z44,ZC5,ZC6,Z47,Z48,ZC9,ZCA,Z4B,ZCC,Z4D,Z4E,ZCF,
     5Z50,ZD1,ZD2,Z53,ZD4,Z55,Z56,ZD7,ZD8,Z59,Z5A,ZEE,ZEE,ZEE,ZEE,ZEE,
     6ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,
     7ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZFF/
*
******  ASCII 7 BIT NO PARITY
*
      DATA ASCII/
*      0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F
     *Z00,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,Z09,Z0A,ZEE,ZEE,Z0D,ZEE,ZEE,
     1ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,ZEE,
     2Z20,Z21,Z22,Z23,Z24,Z25,Z26,Z27,Z28,Z29,Z2A,Z2B,Z2C,Z2D,Z2E,Z2F,
     3Z30,Z31,Z32,Z33,Z34,Z35,Z36,Z37,Z38,Z39,Z3A,Z3B,Z3C,Z3D,Z3E,Z3F,
     4Z40,Z41,Z42,Z43,Z44,Z45,Z46,Z47,Z48,Z49,Z4A,Z4B,Z4C,Z4D,Z4E,Z4F,
     5Z50,Z51,Z52,Z53,Z54,Z55,Z56,Z57,Z58,Z59,Z5A,Z5B,Z5C,Z5D,Z5E,Z5F,
     6Z60,Z61,Z62,Z63,Z64,Z65,Z66,Z67,Z68,Z69,Z6A,Z6B,Z6C,Z6D,Z6E,Z6F,
     7Z70,Z71,Z72,Z73,Z74,Z75,Z76,Z77,Z78,Z79,Z7A,ZEE,ZEE,ZEE,ZEE,Z7F/
*
      IF (J.EQ.1) THEN
         DO 100 I=1,128
  100    PUNCOD(I)=NAS943(I)
*
      ELSE IF (J.EQ.2) THEN
         DO 200 I=1,128
  200    PUNCOD(I)=ISO(I)
*
      ELSE IF (J.EQ.3) THEN
         DO 300 I=1,128
  300    PUNCOD(I)=ASCII(I)
*
      ELSE
         CALL CFORM('**** INVALID ARGUMENT IN CALL TO OUTSET ****',
     1               DARRAY,2,44)
         CALL CPRINT(DARRAY)
         CALL ABNEND
      END IF
      RETURN
      END
**** SOURCE FILE : PARNOM00.IBM;1   ***
*
      SUBROUTINE PARNOM(N,A,J)
*
*  * PARNOM *  VAX-11 FORTRAN 77 VERSION  26.10.82  E.MCLELLAN
*
*  PURPOSE     PUNCH COLUMN BINARY MATRIX REPRESENTATION OF
*              CHARACTERS USED FOR PUNCH TAPE IDENTIFICATION
*  CALLING SEQUENCE
*              CALL PARNOM(N,A,J)
*  ARGUMENTS
*              N  NUMBER OF BCD CHARACTERS TO BE CONVERTED (MAX 504)
*              A  ARRAY CONTAINING BCD CHARACTERS TO BE CONVERTED
*                 FORMAT A6,2X (6 BCD CHARACTERS FOLLOWED BY 2 BLANKS)
*                 THE BLANKS  ARE IGNORED
*              J  J=0  5*7 MATRIX, COLUMN BINARY, ODD PARITY
*                  =1  IGNORED
*                  =2  5*6 MATRIX, COLUMN BINARY, NO PARITY
*  ALTERNATE ENTRY
*              CALL PARNEM(N,A)
*                   PUNCHES A 5*7 MATRIX,COLUMN BINARY,EVEN PARITY
*
*  NOTE:       THE ALLOWABLE CHARACTERS ARE 0 THRO 9, A THRU Z,
*              AND !"#$%&'()*+,-./:;<=>?@[\]^_
*              IE THE COMPLETE ASCII CHARACTER SET LESS LOWER CASE
*
      DOUBLE PRECISION A(84)
      CHARACTER INFIL*504
*
C
C...LOGICAL*1 VARIABLES IN THIS IBM IMPLEMENTATION MIGHT BE ABLE TO BE
C...BYTE VARIABLES ON OTHER SYSTEMS E.G. VAX
      LOGICAL*1 OUT(3024),TABO(6,64),TABE(6,64),TAB56(6,64),CODE(6,64)
      LOGICAL*1 TBO1(6,32),TBO2(6,32),TBE1(6,32),TBE2(6,32),
     1          TB561(6,32),TB562(6,32)
C
      EQUIVALENCE (TABO(1,1),TBO1(1,1)),(TABO(1,33),TBO2(1,1)),
     1            (TABE(1,1),TBE1(1,1)),(TABE(1,33),TBE2(1,1)),
     2            (TAB56(1,1),TB561(1,1)),(TAB56(1,33),TB562(1,1))
*
      INCLUDE (DARRAY)
*
******   TABLE FOR 5X7 MATRIX OUTPUT , ODD PARITY , COLUMN BINARY
*
      DATA TBO1/
*              BLANK                      !
     1Z80,Z80,Z80,Z80,Z80,Z80, Z80,Z80,Z5E,Z80,Z80,Z80,
*                "                        #
     2Z80,Z07,Z80,Z07,Z80,Z80, Z94,Z3E,Z94,Z3E,Z94,Z80,
*                $                        %
     3ZAE,Z2A,Z7F,Z2A,ZAE,Z80, ZE3,Z13,Z08,Z34,ZE3,Z80,
*                &                        `
     4ZFB,Z45,Z6B,Z10,Z68,Z80, Z80,Z80,Z07,Z80,Z80,Z80,
*                (                        )
     5Z80,Z1C,ZA2,ZC1,ZC1,Z80, Z80,ZC1,ZC1,ZA2,Z1C,Z80,
*                *                        +
     6Z08,Z2A,Z1C,Z2A,Z08,Z80, Z08,Z08,Z3E,Z08,Z08,Z80,
*                ,                        -
     7Z80,Z80,ZD0,ZB0,Z80,Z80, Z08,Z08,Z08,Z08,Z08,Z80,
*                .                        /
     8Z80,Z80,ZE0,ZE0,Z80,Z80, Z20,Z10,Z08,Z04,Z02,Z80,
*                0                        1
     9Z3E,ZC1,ZC1,ZC1,Z3E,Z80, Z80,Z02,Z7F,Z80,Z80,Z80,
*                2                        3
     AZC2,Z61,Z51,Z49,Z46,Z80, ZA1,ZC1,Z49,ZCD,ZB3,Z80,
*                4                        5
     BZ98,Z94,Z92,Z7F,Z10,Z80, ZA7,Z45,Z45,Z45,ZB9,Z80,
*                6                        7
     CZBC,ZC2,Z49,Z49,ZB0,Z80, Z01,Z01,Z79,Z85,Z83,Z80,
*                8                        9
     DZB6,Z49,Z49,Z49,ZB6,Z80, Z86,Z49,Z49,ZA1,Z9E,Z80,
*                :                        ;
     EZ80,Z80,ZB6,ZB6,Z80,Z80, Z80,Z80,ZD6,ZB6,Z80,Z80,
*                <                        =
     FZ08,Z94,ZA2,ZC1,Z80,Z80, ZA2,ZA2,ZA2,ZA2,ZA2,Z80,
*                >                        ?
     GZ80,ZC1,ZA2,Z94,Z08,Z80, Z02,Z01,ZD9,Z85,Z02,Z80/
      DATA TBO2/
*                @                        A
     1Z3E,ZC1,Z5D,ZD5,Z5E,Z80, ZFE,Z91,Z91,Z91,ZFE,Z80,
*                B                        C
     2Z7F,Z49,Z49,Z49,ZB6,Z80, Z3E,ZC1,ZC1,ZC1,ZA2,Z80,
*                D                        E
     3Z7F,ZC1,ZC1,ZC1,ZE3,Z80, Z7F,Z49,Z49,Z49,ZC1,Z80,
*                F                        G
     4Z7F,Z89,Z89,Z89,Z01,Z80, ZE3,ZC1,ZC1,Z49,Z79,Z80,
*                H                        I
     5Z7F,Z08,Z08,Z08,Z7F,Z80, Z80,ZC1,Z7F,ZC1,Z80,Z80,
*                J                        K
     6Z20,Z40,Z40,ZBF,Z80,Z80, Z7F,Z08,Z94,ZA2,ZC1,Z80,
*                L                        M
     7Z7F,Z40,Z40,Z40,Z40,Z80, Z7F,Z02,Z8C,Z02,Z7F,Z80,
*                N                        O
     8Z7F,Z02,Z04,Z08,Z7F,Z80, Z3E,Z51,Z49,Z45,Z3E,Z80,
*                P                        Q
     9Z7F,Z89,Z89,Z89,Z86,Z80, Z3E,ZC1,Z51,ZA1,Z5E,Z80,
*                R                        S
     AZ7F,Z89,Z19,Z29,Z46,Z80, Z46,Z49,Z49,Z49,Z31,Z80,
*                T                        U
     BZ01,Z01,Z7F,Z01,Z01,Z80, ZBF,Z40,Z40,Z40,ZBF,Z80,
*                V                        W
     CZ8F,ZB0,Z40,ZB0,Z8F,Z80, ZBF,Z40,ZBC,Z40,ZBF,Z80,
*                X                        Y
     DZE3,Z94,Z08,Z94,ZE3,Z80, Z07,Z08,Z70,Z08,Z07,Z80,
*                Z                        [
     EZ61,Z51,Z49,Z45,Z43,Z80, Z7F,Z7F,ZC1,ZC1,ZC1,Z80,
*                \                        ]
     FZ02,Z04,Z08,Z20,Z40,Z80, ZC1,ZC1,ZC1,Z7F,Z7F,Z80,
*                ^                        _
     GZ04,Z02,Z01,Z02,Z04,Z80, Z40,Z40,Z40,Z40,Z40,Z80/
******   TABLE FOR 5X7 MATRIX OUTPUT ,EVEN PARITY , COLUMN BINARY
*
      DATA TBE1/
*              BLANK                      !
     1ZC0,ZC0,ZC0,ZC0,ZC0,ZC0, ZC0,ZC0,Z2F,ZC0,ZC0,ZC0,
*                "                        #
     2ZC0,Z87,ZC0,Z87,ZC0,ZC0, Z14,ZBE,Z14,ZBE,Z14,ZC0,
*                $                        %
     3Z2E,ZAA,ZFF,ZAA,Z3A,ZC0, Z63,Z93,Z88,ZE4,Z63,ZC0,
*                &                        `
     4Z7B,ZC5,ZEB,Z90,ZE9,ZC0, ZC0,ZC0,Z87,ZC0,ZC0,ZC0,
*                (                        )
     5ZC0,Z9C,Z22,Z41,Z41,ZC0, ZC0,Z41,Z41,Z22,Z9C,ZC0,
*                *                        +
     6Z88,ZAA,Z9C,ZAA,Z88,ZC0, Z88,Z88,ZBE,Z88,Z88,ZC0,
*                ,                        -
     7ZC0,ZC0,Z50,Z30,ZC0,ZC0, Z88,Z88,Z88,Z88,Z88,ZC0,
*                .                        /
     8ZC0,ZC0,Z60,Z60,ZC0,ZC0, ZA0,Z90,Z88,Z84,Z82,ZC0,
*                0                        1
     9ZBE,Z31,Z31,Z31,ZBE,ZC0, ZC0,Z82,ZFF,ZC0,ZC0,ZC0,
*                2                        3
     AZ42,ZE1,ZD1,ZC9,ZC6,ZC0, Z21,Z41,ZC9,Z4D,Z33,ZC0,
*                4                        5
     6Z18,Z14,Z12,ZFF,Z90,ZC0, Z27,ZCB,ZC5,ZC5,Z39,ZC0,
*                6                        7
     CZ3C,Z42,ZC9,ZC9,Z30,ZC0, Z81,Z81,ZF9,Z05,Z03,ZC0,
*                8                        9
     DZ36,ZC9,ZC9,ZC9,Z36,ZC0, Z06,ZC9,ZC9,Z21,Z1E,ZC0,
*                :                        ;
     EZC0,ZC0,Z1B,Z1B,ZC0,ZC0, ZC0,ZC0,Z2B,Z1B,ZC0,ZC0,
*                <                        =
     FZ88,Z14,Z22,Z41,ZC0,ZC0, Z22,Z22,Z22,Z22,Z22,ZC0,
*                >                        ?
     GZC0,Z41,Z22,Z14,Z88,ZC0, Z82,Z81,Z59,Z05,Z82,ZC0/
      DATA TBE2/
*                @                        A
     1ZBE,Z41,ZDD,Z55,ZDF,ZC0, Z7E,Z11,Z11,Z11,Z7E,ZC0,
*                B                        C
     2ZFF,ZC9,ZC9,ZC9,Z36,ZC0, ZBE,Z41,Z41,Z41,Z22,ZC0,
*                D                        E
     3ZFF,Z41,Z41,Z41,ZBE,ZC0, ZFF,ZC9,ZC9,ZC9,Z41,ZC0,
*                F                        G
     4ZFF,Z09,Z09,Z09,Z81,ZC0, ZBE,Z41,Z41,ZC9,ZF9,ZC0,
*                H                        I
     5ZFF,Z88,Z88,Z88,ZFF,ZC0, ZC0,Z41,ZFF,Z41,ZC0,ZC0,
*                J                        K
     6ZA0,ZC0,ZC0,Z3F,ZC0,ZC0, ZFF,Z88,Z14,Z22,Z41,ZC0,
*                L                        M
     7ZFF,ZC0,ZC0,ZC0,ZC0,ZC0, ZFF,Z82,Z0C,Z82,ZFF,ZC0,
*              BLANK                      O
     8ZFF,Z82,Z84,Z88,ZFF,ZC0, ZBE,ZD1,ZC9,ZC5,ZBE,ZC0,
*                P                        Q
     9ZFF,Z09,Z09,Z09,Z06,ZC0, ZBE,Z41,ZD1,Z21,ZDE,ZC0,
*                R                        S
     AZFF,Z09,Z99,ZA9,ZC6,ZC0, ZC6,ZC9,ZC9,ZC9,ZB1,ZC0,
*                T                        U
     BZ81,Z81,ZFF,Z81,Z81,ZC0, Z3F,ZC0,ZC0,ZC0,Z3F,ZC0,
*                V                        W
     CZ0F,Z30,ZC0,Z30,Z0F,ZC0, Z3F,ZC0,Z3C,ZC0,Z3F,ZC0,
*                X                        Y
     DZ63,Z14,Z88,Z14,Z63,ZC0, Z87,Z88,ZF0,Z88,Z87,ZC0,
*                Z                        [
     EZE1,ZD1,ZC9,ZC5,ZC3,ZC0, ZFF,ZFF,Z41,Z41,Z41,ZC0,
*                \                        ]
     FZ82,Z84,Z88,Z90,ZA0,ZC0, Z41,Z41,Z41,ZFF,ZFF,ZC0,
*                ^                        _
     GZ84,Z82,Z81,Z82,Z84,ZC0, Z60,Z60,Z60,Z60,Z60,ZC0/
******   TABLE FOR 5X6 MATRIX OUTPUT , NO PARITY , COLUMN BINARY
*
      DATA TB561/
*                N                        !
     1Z00,Z00,Z00,Z00,Z00,Z00, Z00,Z00,Z5E,Z00,Z00,Z00,
*                "                        #
     2Z00,Z0E,Z00,Z0E,Z00,Z00, Z14,Z3E,Z14,Z3E,Z14,Z00,
*                $                        %
     3Z2E,Z2A,Z7E,Z2A,Z3A,Z00, Z26,Z16,Z08,Z64,Z62,Z00,
*                &                        `
     4Z76,Z4A,Z56,Z20,Z50,Z00, Z00,Z00,Z0E,Z00,Z00,Z00,
*                (                        )
     5Z00,Z00,Z00,Z3C,Z42,Z00, Z00,Z42,Z3C,Z00,Z00,Z00,
*                *                        +
     6Z10,Z54,Z38,Z54,Z10,Z00, Z10,Z10,Z7C,Z10,Z10,Z00,
*                ,                        -
     7Z00,Z00,Z50,Z30,Z00,Z00, Z10,Z10,Z10,Z10,Z10,Z00,
*                .                        /
     8Z00,Z60,Z60,Z00,Z00,Z00, Z40,Z20,Z10,Z08,Z04,Z00,
*                0                        1
     9Z3C,Z42,Z42,Z42,Z3C,Z00, Z00,Z44,Z7E,Z40,Z00,Z00,
*                2                        3
     AZ64,Z52,Z4A,Z4A,Z44,Z00, Z22,Z4A,Z4A,Z4E,Z32,Z00,
*                4                        5
     BZ0E,Z08,Z08,Z7E,Z08,Z00, Z2E,Z4A,Z4A,Z4A,Z32,Z00,
*                6                        7
     CZ3C,Z4A,Z4A,Z4A,Z30,Z00, Z02,Z02,Z72,Z0A,Z06,Z00,
*                8                        9
     DZ34,Z4A,Z4A,Z4A,Z34,Z00, Z04,Z4A,Z4A,Z4A,Z3C,Z00,
*                :                        ;
     EZ00,Z00,Z36,Z36,Z00,Z00, Z00,Z00,Z56,Z36,Z00,Z00,
*                <                        =
     FZ10,Z28,Z44,Z00,Z00,Z00, Z28,Z28,Z28,Z28,Z28,Z00,
*                >                        ?
     GZ00,Z00,Z44,Z28,Z10,Z00, Z04,Z02,Z52,Z0A,Z04,Z00/
      DATA TB562/
*                @                        A
     1Z3C,Z42,Z5A,Z5A,Z4C,Z00, Z78,Z14,Z12,Z14,Z78,Z00,
*                B                        C
     2Z7E,Z4A,Z4A,Z4A,Z34,Z00, Z3C,Z42,Z42,Z42,Z24,Z00,
*                D                        E
     3Z7E,Z42,Z42,Z42,Z3C,Z00, Z7E,Z4A,Z4A,Z42,Z42,Z00,
*                F                        G
     4Z7E,Z0A,Z0A,Z02,Z02,Z00, Z3C,Z42,Z42,Z52,Z72,Z00,
*                H                        I
     5Z7E,Z08,Z08,Z08,Z7E,Z00, Z00,Z42,Z74,Z42,Z00,Z00,
*                J                        K
     6Z20,Z40,Z40,Z40,Z3E,Z00, Z7E,Z08,Z10,Z24,Z42,Z00,
*                L                        M
     7Z7E,Z40,Z40,Z40,Z40,Z00, Z7E,Z04,Z08,Z04,Z7E,Z00,
*                N                        O
     8Z7E,Z04,Z08,Z30,Z7E,Z00, Z3C,Z42,Z42,Z42,Z3C,Z00,
*                P                        Q
     9Z7E,Z0A,Z0A,Z0A,Z04,Z00, Z3C,Z42,Z52,Z22,Z5C,Z00,
*                R                        S
     AZ7E,Z0A,Z1A,Z2A,Z44,Z00, Z44,Z4A,Z4A,Z4A,Z32,Z00,
*                T                        U
     BZ02,Z02,Z7E,Z02,Z02,Z00, Z3E,Z40,Z40,Z40,Z3E,Z00,
*                V                        W
     CZ1E,Z20,Z40,Z20,Z1E,Z00, Z7E,Z20,Z18,Z20,Z7E,Z00,
*                X                        Y
     DZ66,Z10,Z08,Z10,Z66,Z00, Z06,Z08,Z70,Z08,Z06,Z00,
*                Z                        [
     EZ62,Z52,Z4A,Z42,Z46,Z00, Z7E,Z42,Z42,Z00,Z00,Z00,
*                \                        ]
     FZ02,Z04,Z08,Z10,Z20,Z00, Z00,Z00,Z42,Z42,Z7E,Z00,
*                ^                        _
     GZ08,Z04,Z02,Z04,Z08,Z00, Z40,Z40,Z40,Z40,Z40,Z00/
C
      IF (J.EQ.0) THEN
C
C.....5*7 MATRIX, ODD PARITY, COLUMN BINARY
C
      DO 10 I=1,6
      DO 10 K=1,64
   10 CODE(I,K)=TABO(I,K)
C
      ELSE IF (J.EQ.2) THEN
C
C.....5*6 MATRIX, NO PARITY, COLUMN BINARY
C
      DO 20 I=1,6
      DO 20 K=1,64
   20 CODE(I,K)=TAB56(I,K)
C
      ELSE
         CALL CFORM('**** INVALID CALL TO PARNOM ****',DARRAY,2,32)
         CALL CPRINT(DARRAY)
         RETURN
      END IF
      GO TO 100
C
C.....ENTRY PARNEM
C
      ENTRY PARNEM(N,A)
C
C.....5*7 MATRIX, EVEN PARITY, COLUMN BINARY
C
      DO 30 I=1,6
      DO 30 K=1,64
   30 CODE(I,K)=TABE(I,K)
C
C.....CHECK N.LE.504
C
  100 N=ABS(N)
      IF (N.GT.504) THEN
         CALL CFORM('**** MORE THAN 504 CHARACTERS',DARRAY,2,29)
         CALL CFORM('REQUESTED IN CALL TO PARNOM OR PARNEM ****',DARRAY,
     1                32,42)
         CALL CPRINT(DARRAY)
         N=504
      END IF
C
C.....CALCULATE NUMBER OF WORDS CONTAINING CHARACTERS (6 PER WORD)
C
      NUM=N/6
      IF (NUM*6.LT.N) NUM=NUM+1
C
C.....WRITE CHARCTERS FOR CONVERSION TO INTERNAL FILE
C
      WRITE (INFIL,'(84A6)') (A(I),I=1,NUM)
C
C.....FOR EACH CHARACTER INPUT, IDENTIFY POSITION IN ASCII CHAR SET
C
      JC=0
      DO 200 I=1,N
      IC=ICHAR(INFIL(I:I))-31
C
C.....STORE APPROP MATRIX IN OUTPUT ARRAY
C
      DO 200 K=1,6
      JC=JC+1
      OUT(JC)=CODE(K,IC)
  200 CONTINUE
C
C.....OUTPUT TO PUNCH FILE, JC IS NO OF BYTES
C
      CALL TAPEPN(OUT,JC)
      RETURN
      END
**** SOURCE FILE : PUNCHA00.IBM;2   ***
*
      SUBROUTINE PUNCHA(N,A,J,K)
*
*  * PUNCHA *   VAX-11 FORTRAN 77 VERSION 29.11.82 E.MCLELLAN
*
*  PURPOSE     TO GENERATE REQUIRED PAPER TAPE CODES FOR BCD CHARACTERS
*
*  CALLING SEQUENCE
*              CALL PUNCHA(N,A,J,K)
*  ARGUMENTS
*              N NUMBER OF BCD CHARACTERS IN ARRAY A
*              A ARRAY CONTAINING BCD CHARACTERS
*              J IGNORED
*              K -2  BLANKS AND PERIODS IGNORED
*                -1  PERIODS IGNORED
*                 0  BLANKS IGNORED
*                >0  BLANKS ARE PROCESSED
*
*  ALTERNATE ENTRY
*              CALL PUNCHB(N,A,J,K)
*
C
C...LOGICAL*1 VARIABLES IN THIS IBM IMPLEMENTATION MIGHT BE ABLE TO BE
C...BYTE VARIABLES ON OTHER SYSTEMS E.G. VAX
C
      COMMON/PUNTAB/PUNCOD
      LOGICAL*1 PUNCOD(128),ILEGAL
*
      DOUBLE PRECISION A(64)
      CHARACTER*512 INFIL,OUTFIL
      LOGICAL*1 PUNOUT(512)
      LOGICAL OD
C
      INCLUDE (DARRAY)
C
      DATA ILEGAL/ZEE/
C
C
      ENTRY PUNCHB(N,A,J,K)
C
      WRITE (INFIL,'(64A8)') (A(I),I=1,64)
C
      M=N
C
      IF (K.LE.0) THEN
         L=1
         DO 10 I=1,N
           IF ((INFIL(I:I).EQ.' ').AND.((K.EQ.0).OR.(K.EQ.-2))) THEN
              GO TO 10
           ELSE IF ((INFIL(I:I).EQ.'.').AND.(K.LT.0)) THEN
              GO TO 10
           ELSE
              OUTFIL(L:L)=INFIL(I:I)
              L=L+1
           END IF
   10    CONTINUE
         M=L-1
      ELSE
C
      OUTFIL=INFIL
C
      END IF
C
C.....CONVERT TO REQUIRED TAPE CODE
C
      JC=0
      DO 100 I=1,M
      IC=ICHAR(OUTFIL(I:I))+1
      IF (PUNCOD(IC).EQV.ILEGAL) THEN
         CALL CFORM('**** ILLEGAL CHARACTER CONVERSION IN PUNCHA ****',
     1              DARRAY,2,48)
         CALL CPRINT(DARRAY)
         GO TO 100
      END IF
C
      JC=JC+1
      PUNOUT(JC)=PUNCOD(IC)
  100 CONTINUE
C
C.....OUTPUT TO PUNCH FILE, JC IS NO OF BYTES
C
      CALL TAPEPN(PUNOUT,JC)
      RETURN
      END
**** SOURCE FILE : PUNCHC00.IBM;1   ***
*
      SUBROUTINE PUNCHC(N,A,J,K)
*
*  * PUNCHC *   VAX-11 FORTRAN 77 VERSION 29.11.82 E.MCLELLAN
*               REVISED FOR CHARACTER HANDLING 5.9.85 E.MCL.
*
*  PURPOSE     TO GENERATE REQUIRED PAPER TAPE CODES FOR CHARACTERS
*
*  CALLING SEQUENCE
*              CALL PUNCHC(N,A,J,K)
*  ARGUMENTS
*              N NUMBER OF CHARACTERS IN A
*              A CHARACTER STRING TO BE PUNCHED
*              J NUMBER OF CHARACTERS PUNCHED
*              K -2  BLANKS AND PERIODS IGNORED
*                -1  PERIODS IGNORED
*                 0  BLANKS IGNORED
*                >0  BLANKS ARE PROCESSED
*
*  ALTERNATE ENTRY
*              CALL PUNCHD(N,A,J,K)
*
C
C...LOGICAL*1 VARIABLES IN THIS IBM IMPLEMENTATION MIGHT BE ABLE TO BE
C...BYTE VARIABLES ON OTHER SYSTEMS E.G. VAX
C
      COMMON/PUNTAB/PUNCOD
      LOGICAL*1 PUNCOD(128),ILEGAL
*
      CHARACTER*512 A
      CHARACTER*512 INFIL,OUTFIL
      LOGICAL*1 PUNOUT(512)
      LOGICAL OD
C
      INCLUDE (DARRAY)
C
      DATA ILEGAL/ZEE/
C
C
      ENTRY PUNCHD(N,A,J,K)
C
      INFIL=A
C
      M=N
C
      IF (K.LE.0) THEN
         L=1
         DO 10 I=1,N
           IF ((INFIL(I:I).EQ.' ').AND.((K.EQ.0).OR.(K.EQ.-2))) THEN
              GO TO 10
           ELSE IF ((INFIL(I:I).EQ.'.').AND.(K.LT.0)) THEN
              GO TO 10
           ELSE
              OUTFIL(L:L)=INFIL(I:I)
              L=L+1
           END IF
   10    CONTINUE
         M=L-1
      ELSE
C
      OUTFIL=INFIL
C
      END IF
C
C.....CONVERT TO REQUIRED TAPE CODE
C
      JC=0
      DO 100 I=1,M
      IC=ICHAR(OUTFIL(I:I))+1
      IF (PUNCOD(IC).EQV.ILEGAL) THEN
         CALL CFORM('**** ILLEGAL CHARACTER CONVERSION IN PUNCHC ****',
     1              DARRAY,2,48)
         CALL CPRINT(DARRAY)
         GO TO 100
      END IF
C
      JC=JC+1
      PUNOUT(JC)=PUNCOD(IC)
  100 CONTINUE
C
C.....OUTPUT TO PUNCH FILE, JC IS NO OF BYTES
C
      CALL TAPEPN(PUNOUT,JC)
      J=JC
      RETURN
      END
**** SOURCE FILE : TAPEPN00.IBM;1   ***
*
      SUBROUTINE TAPEPN(CHAR,N)
*
*  * TAPEPN *  VAX-11 FORTRAN 77 VERSION  26.10.82  E.MCLELLAN
*
*  PURPOSE     TO WRITE COLUMN BINARY DATA TO PAPER TAPE PUNCH FILE
*
*  CALLING SEQUENCE
*              CALL TAPEPN(CHAR,N)
*  ARGUMENTS
*              CHAR  BYTE ARRAY CONTAINING COLUMN BINARY CODES
*              N     NO OF COLUMNS (CHARACTERS) TO BE PUNCHED
*
C
C...LOGICAL*1 VARIABLES IN THIS IBM IMPLEMENTATION MIGHT BE ABLE TO BE
C...BYTE VARIABLES ON OTHER SYSTEMS E.G. VAX
      LOGICAL*1 CHAR(3024)
*
      LOGICAL OD
C
      INCLUDE (DARRAY)
C
C
C.....WRITE IN A FORMAT TO FILE PUNTAP.DAT
C
C.....IS PUNTAP.DAT OPEN
C
      INQUIRE(FILE='PUNTAP',OPENED=OD)
         IF (.NOT.OD) THEN
            OPEN(UNIT=7,FILE='PUNTAP',ERR=90,STATUS='NEW',
     1           ACCESS='SEQUENTIAL',FORM='FORMATTED')
         END IF
C
C.....WRITE TO PUNTAP.DAT
C
      WRITE(7,'(80A1)') (CHAR(I),I=1,N)
      RETURN
C
   90 CALL CFORM('**** ERROR OPENING PUNTAP.DAT ****',DARRAY,2,34)
      CALL CPRINT(DARRAY)
      CALL ABNEND
      RETURN
      END
**** SOURCE FILE : WTDIRE00.IBM;1   ***
*
*                MODIFIED                23-FEB-1988  E.MCLELLAN
*
      SUBROUTINE WTDIRE(IU,MEMBER,USERD,NCH,IRET)
C
      INTEGER IU,ID,NCH,IRET
      DOUBLE PRECISION MEMBER,USERD
C
      LOGICAL EX
C
      CHARACTER FLNAME*20,TYPE*4,MODE*2,CMEM*8
      INTEGER NWD,NLEN,JRET
C
C
      DATA TYPE/' LDA'/,MODE/' A'/
C
      ID=ABS(IU)
C
C.... SET UP FILENAME
C
      CALL HOLFRM(MEMBER,CMEM,1,8,NWD)
      NLEN=8
      K=INDEX(CMEM,' ')
      IF (K.NE.0) NLEN=K-1
      FLNAME=CMEM(:NLEN)//TYPE//MODE
      NLEN=NLEN+6
C
C.... INQUIRE IF FILE EXISTS
C
      CALL UOPEN(ID,FLNAME(:NLEN),1,4,80,0,'U',0,JRET)
      IF (JRET.EQ.0) THEN
C.... FILE ALREADY EXISTS - SHOULD A NEW VERSION BE WRITTEN
        IF (IU.LT.0) THEN
C.... YES - OPEN ATTACHED TO UNIT ID
          CALL UOPEN(ID,FLNAME(:NLEN),1,2,80,0,'U',0,JRET)
          IF (JRET.NE.0) GOTO 20
          IRET=0
        ELSE
          IRET=9
        ENDIF
      ELSE
C.... FILE DOES NOT EXIST - OPEN ATTACHED TO UNIT ID
          CALL UOPEN(ID,FLNAME(:NLEN),1,2,80,0,'U',0,JRET)
          IF (JRET.NE.0) GOTO 20
        IRET=0
      ENDIF
      RETURN
C.... ERROR OPENING FILE
  20  IRET=5
      RETURN
      END
**** SOURCE FILE : M0006620.IBM;1   ***
*
C                                                 8/81     MBB
C...  FORTRAN BLOCK DATA               BD2ITL
C                                                 8/81     MBB
      BLOCK DATA BD2ITL
C
      IMPLICIT INTEGER (A-Z)
C
C...         2.    STACK AND POINTER STORAGE
C
      COMMON/STKLST/STKLST,STACK,ARGSTK
      DIMENSION STKLST(3),STACK(2,99),ARGSTK(99)
C
      EQUIVALENCE(STKLST(1),TOP),(STKLST(2),ARGTOP),(STKLST(3),IARGDM)
C
C
C...         5.    PROGRAM CONTROL FLAGS
C
      COMMON/FLAGS/FLAGS
      DIMENSION FLAGS(4)
      LOGICAL ENDFLG,NEWSTM,APTRAN,REFFLG
C
      EQUIVALENCE(FLAGS(1),ENDFLG),(FLAGS(2),NEWSTM),(FLAGS(3),APTRAN),
     1           (FLAGS(4),REFFLG)
C
C
C...         6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C
      COMMON/TMP/TXXXX
      DIMENSION TXXXX(2,32)
C
C
C...      13.      NAMTBL POINTERS TO NEGATIVE NUMBERS
C
      COMMON/NEGPTR/NONEPT
C
C...        11.    SEQUENCE NUMBER STORAGE
C
C                  COMMENT OF  SEQNO AND SEQNUM
C
      INCLUDE (SEQCOM)    
C
C...        12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      COMMON/CFSIZE/CFSIZE,MAXSIZ,CANSIZ,ISC,KSC
      DIMENSION  CFSIZE(3),MAXSIZ(2),CANSIZ(2,100),KSC(3,300)
      LOGICAL PARDEF,TABCYS
C
      EQUIVALENCE(CFSIZE(1),CANTOP),(CFSIZE(2),PARDEF),
     1           (CFSIZE(3),TABCYS)
C
C
C...      14.      I. L. LIST OPTION FLAGS
C
      COMMON/PRT/PRT
      DIMENSION PRT(7)
      LOGICAL    CILPRT,  ILPRT, INTERP, ASSEMB, TRACFL
     /          ,PRTERR,  MCHDNG
C
      EQUIVALENCE(PRT(1),CILPRT),(PRT(2),ILPRT ),(PRT(3),INTERP),
     1           (PRT(4),ASSEMB),(PRT(5),TRACFL),(PRT(6),PRTERR),
     2           (PRT(7),MCHDNG)
C
C
C...        15.    ARRAY LIMIT STORAGE
C
      COMMON/SBSCPT/RNGPT,RANGE
      DIMENSION RANGE(400)
C
C...        16.    LITERALS FOR I. L. OPERATION CODES
C
      COMMON/IL/IL
      DIMENSION IL(21)
C
      EQUIVALENCE(IL( 1),FADD  ),(IL( 2),FSUB  ),(IL( 3),FMPY  ),
     1           (IL( 4),FDIV  ),(IL( 5),FEXP  ),(IL( 6),LABELX),
     2           (IL( 7),ENTRYX),(IL( 8),JUMP  ),(IL( 9),SEQNCE),
     3           (IL(10),RETMC ),(IL(11),CONJMP),(IL(12),RESRV ),
     4           (IL(13),CVTSUB),(IL(14),CALMC ),(IL(15),ASNADD),
     5           (IL(16),ASNJMP),(IL(17),REPL  ),(IL(18),CALL  ),
     7           (IL(19),MOVE  ),(IL(20),VBLJMP),(IL(21),HOLDAT)
C
C
C...        17.    MODE CODES
C
      COMMON/MODX/MODX
      DIMENSION MODX(32)
C
      EQUIVALENCE(MODX( 1),LINE  ),(MODX( 2),PLANE ),(MODX( 3),CYLNDR),
     1           (MODX( 4),CIRCLE),(MODX( 5),SPHERE),(MODX( 6),HYPERB),
     2           (MODX( 7),CONIC ),(MODX( 8),ELLIPS),(MODX( 9),CONE  ),
     3           (MODX(10),GCONIC),(MODX(11),TABCYL),(MODX(12),RLDSRF),
     4           (MODX(13),POLCON),(MODX(14),QADRIC),(MODX(15),PARSRF),
     5           (MODX(16),UNUS1 ),(MODX(17),UNUS2 ),(MODX(18),MATRIX),
     6           (MODX(19),POINT ),(MODX(20),VECTOR),(MODX(21),REAL  ),
     7           (MODX(22),INTGER),(MODX(23),BOOL  ),(MODX(24),SUBSCR),
     8           (MODX(25),STRING),(MODX(26),PATERN),(MODX(27),BOUNDS),
     9           (MODX(28),OBJECT),(MODX(29),SSURF ),(MODX(30),SCURV ),
     A           (MODX(31),UNUS3 ),(MODX(32),UNUS4 )
C
C
C...        18.    STRING STORAGE AREA
C
      COMMON/CHRX/CHR
      CHARACTER CHR*400
C
C...      19.      INTERMEDIATE LANGUAGE TEXT
C
      COMMON/ILTEXT/ILTEXT,TEXTIN
      DIMENSION TEXTIN(90),ILTEXT(4)
      LOGICAL COMFIN
      EQUIVALENCE(ILTEXT(1),COMFIN),(ILTEXT(2),LENGTH),
     1           (ILTEXT(3),TPNTRX),(ILTEXT(4),OPTEXT)
C
C
C         22.      MACRO PROCESSING VARIABLES
C
      COMMON/MACXX1/MACXX1
      DIMENSION MACXX1(71)
      LOGICAL MACLDD ,CALLON ,CALLMV ,ILHLT  ,MVMAC  ,MACRED ,MVTRUE ,
     1        FINMAC ,ENTRY  ,NESTG  ,ENDMCH ,MACLK  ,MACEND ,SHOULD
C
      EQUIVALENCE(MACXX1( 1),MACDFP),(MACXX1( 2),MCNMB ),
     1           (MACXX1( 3),MCHSTP),(MACXX1( 4),MCTXTP),
     2           (MACXX1( 5),MCSAVP),(MACXX1( 6),MNMVBP),
     3           (MACXX1( 7),MACLDD),(MACXX1( 8),TEMP1 ),
     4           (MACXX1( 9),TEMP2 ),(MACXX1(10),CALLON),
     5           (MACXX1(11),CALLMV),(MACXX1(12),MVSEG ),
     6           (MACXX1(13),CALLPT),(MACXX1(14),ILHLT ),
     7           (MACXX1(15),TEXTST),(MACXX1(16),MVPNT ),
     8           (MACXX1(17),MVMAC ),(MACXX1(18),MACRED),
     9           (MACXX1(19),MVTRUE),(MACXX1(20),BRANCH),
     A           (MACXX1(21),MAXSPS),(MACXX1(22),INTMED)
      EQUIVALENCE(MACXX1(23),MAJWRD),(MACXX1(24),FINMAC),
     1           (MACXX1(25),NMLINE),(MACXX1(26),WAY   ),
     2           (MACXX1(27),NUMVAR),(MACXX1(28),NUMCAL),
     3           (MACXX1(29),BITWDS),(MACXX1(30),MBPTR ),
     4           (MACXX1(31),LSTWRT),(MACXX1(32),MCDFDM),
     5           (MACXX1(33),MHSTDM),(MACXX1(34),MCSVDM),
     6           (MACXX1(35),MNMVDM),(MACXX1(36),MSEQDM),
     7           (MACXX1(37),MACLNT),(MACXX1(38),MCSLNT),
     8           (MACXX1(39),MSP   ),(MACXX1(40),ENTRY ),
     9           (MACXX1(41),MVEXST),(MACXX1(42),MACTOP),
     A           (MACXX1(43),MCSTRT),(MACXX1(44),MAJOR )
      EQUIVALENCE(MACXX1(45),NESTG ),(MACXX1(46),ROUTE ),
     1           (MACXX1(47),ROAD  ),(MACXX1(48),SAVMSP),
     2           (MACXX1(49),TYP   ),(MACXX1(50),ENDMCH),
     3           (MACXX1(51),LNUSDP),(MACXX1(52),MCTOPP),
     4           (MACXX1(53),LNSDDM),(MACXX1(54),MVARDM),
     5           (MACXX1(55),MASDM ),(MACXX1(56),NUMBIT),
     6           (MACXX1(57),MCSPDP),(MACXX1(58),MACLK ),
     7           (MACXX1(59),MCSRCH),(MACXX1(60),MACFND),
     8           (MACXX1(61),NUMARG),(MACXX1(62),MACEND),
     9           (MACXX1(63),WHCHMN),(MACXX1(64),LARGMV),
     A           (MACXX1(65),MSPDDM),(MACXX1(66),VBLSVP)
      EQUIVALENCE(MACXX1(67),IVSVDM),(MACXX1(68),PATHLN),
     1           (MACXX1(69),NEXTLN),(MACXX1(70),SHOULD),
     2           (MACXX1(71),PATHCH)
C
C
C         23.      MACRO PROCESSING ARRAYS
C
      COMMON/MACXX2/MACXX2
      DIMENSION MACXX2(902),MBREC(2),MBUFF(350,2),MACRTB(200)
      EQUIVALENCE(MACXX2(  1),MBREC(1)),(MACXX2( 3),MBUFF(1,1))
      EQUIVALENCE(MACXX2(703),MACRTB(1))
C
C         24.      MACRO PROCESSING ARRAYS
C
      COMMON/MACXX3/MACXX3
      DIMENSION MACXX3(2630),MACDF1(400),MACDF2(400),MACHST(1800),
     1                       MACSV1( 10),MACSV2( 10),MACSV3( 10)
      EQUIVALENCE(MACXX3(   1),MACDF1(1)),(MACXX3( 401),MACDF2(1)),
     1           (MACXX3( 801),MACHST(1)),(MACXX3(2601),MACSV1(1)),
     2           (MACXX3(2611),MACSV2(1)),(MACXX3(2621),MACSV3(1))
C
C         25.      MACRO PROCESSING ARRAYS
C
      COMMON/MACXX4/MACXX4
      DIMENSION MACXX4( 100),MNMVB ( 25),MNMVC ( 25),MACSEQ( 50)
      EQUIVALENCE(MACXX4( 1),MNMVB(1)),(MACXX4(26),MNMVC(1)),
     1           (MACXX4(51),MACSEQ(1))
C
C         25A.     MACRO PROCESSING ARRAYS
C
      COMMON/MACXX5/ITMPSV
      DIMENSION ITMPSV(135)
C
C         26.      MACRO PROCESSING ARRAYS
C
      COMMON/MACXX6/MACXX6
      DIMENSION MACXX6(1300),VBLSAV(900)
      EQUIVALENCE(MACXX6(401),VBLSAV(1))
C
C         26A.     MACRO PROCESSING ARRAYS
C
      COMMON/MACXX7/MACXX7
      DIMENSION MACXX7(182),LINUSD(50),MAS(100),MACVAR(32)
      EQUIVALENCE(MACXX7(  1),LINUSD(1)),(MACXX7( 51),MAS(1)),
     1           (MACXX7(151),MACVAR(1))
C
C...        27.    OPERAND MODIFIERS
C
      COMMON/OPMOD/OPMOD
      DIMENSION    OPMOD(8)
C
      EQUIVALENCE(OPMOD(1),NOUGHT),(OPMOD(2),DLR   ),(OPMOD(3),DBLDLR),
     1           (OPMOD(4),TRPDLR),(OPMOD(5),QUADLR),(OPMOD(6),QUIDLR),
     2           (OPMOD(7),HEXDLR),(OPMOD(8),SPTDLR)
C
C
C...        29.    CLASS CODE MODULI
C
      COMMON/MODULI/MODULO,MODHLF
C
C...        30.   NAMTBL POINTERS TO FIRST CANONICAL FORMS IN EACH BLOCK
C
      COMMON/BLKCFS/FIRST
      DIMENSION  FIRST(2,3)
C....
C           31.   COMMON BLOCK FOR PRO026 AND MOTION
C....
      COMMON /COMP26/COMP26,TAGTBL
      DIMENSION TAGTBL(3),COMP26(13)
      LOGICAL FEDSAV, FMTERR, MCSJMP, JMPING
C
      EQUIVALENCE(COMP26( 1),INTOF ),(COMP26( 2),ARGCNT),
     1           (COMP26( 3),CSPNTR),(COMP26( 4),JMPCS ),
     2           (COMP26( 5),NUMBCS),(COMP26( 6),TEST  ),
     3           (COMP26( 7),TEST1 ),(COMP26( 8),FEDSAV),
     4           (COMP26( 9),FMTERR),(COMP26(10),MCSJMP),
     5           (COMP26(11),JMPING),(COMP26(12),K     ),
     6           (COMP26(13),LERR  )
C
C
C           32.   COMMON BLOCK FOR SETBIT AND BITMCH
C
      COMMON/BITCOM/BIT
      DIMENSION BIT(32)
      DIMENSION LOBIT(16),HIBIT(16)
      EQUIVALENCE (LOBIT(1),BIT(1)),(HIBIT(1),BIT(17))
C...
C ...       35.    COMMON BLOCK FOR BOUNDED GEOMETRY AND CFSAVE
C
C
      COMMON/BGEOM/BGEOM
      DIMENSION     BGEOM(4)
C
      EQUIVALENCE(BGEOM(1),IFBNDS),(BGEOM(2),IFDUMP),(BGEOM(3),J     ),
     1           (BGEOM(4),L     )
C
C           36.    SYSTEM MACRO AND SEGMENT READ VARIABLES
C
      COMMON/MACSEG/MACSEG
      DIMENSION     MACSEG(6)
      LOGICAL ALOPN,LMRSTR,LMREND
C
      EQUIVALENCE(MACSEG(1),ALOPN ),(MACSEG(2),NMSEG ),
     1           (MACSEG(3),NMMAC ),(MACSEG(4),LMRSTR),
     2           (MACSEG(5),ITMPCT),(MACSEG(6),LMREND)
C
C...        37.    INCLUSIVE SUBSCRIPT VARIABLES
C
      COMMON/ISSCOM/ISSCOM,ISSTRM
      DIMENSION ISSTRM(2),ISSCOM(7)
      LOGICAL ISSFL,ISSEND
C
      EQUIVALENCE(ISSCOM(1),ISSA  ),(ISSCOM(2),ISSB  ),
     1           (ISSCOM(3),ISSC  ),(ISSCOM(4),ISSVBL),
     2           (ISSCOM(5),ISSMOD),(ISSCOM(6),ISSFL ),
     3           (ISSCOM(7),ISSEND)
C
C
C...        39.    COMMON BLOCK LIBRARY PRINTING FLAG
C
      COMMON/LIBPRT/LIBPRT
      LOGICAL       LIBPRT
C
C...        41.    NUMBER TABLE OVERFLOW VARIABLES
C
      COMMON/NTBL/NTBL
      DIMENSION   NTBL(6)
C
      EQUIVALENCE(NTBL(1),NMOD  ),(NTBL(2),NCRNT ),(NTBL(3),NNDX  ),
     1           (NTBL(4),NLAST ),(NTBL(5),NSTR  ),(NTBL(6),NMAX  )
C
C
C           42.    COMMON BLOCK FOR CANON AND OBTAIN ARGUMENT STORAGE
C
      COMMON/CANSTR/CANSTR,CANSTK
      DIMENSION CANSTK(16),CANSTR(2)
C
      EQUIVALENCE(CANSTR(1),CANPTR),(CANSTR(2),CANCHK)
C
C
C           43.    COMMON BLOCK FOR LOOP
C
      COMMON/DOLOOP/DOLOOP
      DIMENSION DOLOOP(9)
      LOGICAL DOFLAG,DLRFLG,IFFLAG
C
      EQUIVALENCE(DOLOOP(1),JUMPTO),(DOLOOP(2),ABSDO ),
     1           (DOLOOP(3),RELDO ),(DOLOOP(4),DONEST),
     2           (DOLOOP(5),DOMAX ),(DOLOOP(6),DOJUMP),
     3           (DOLOOP(7),DOFLAG),(DOLOOP(8),DLRFLG),
     4           (DOLOOP(9),IFFLAG)
C
C
C           44.    COMMON BLOCK FOR ERROR POSITIONS
C
      COMMON/ERRPOS/ERRPOS
      INTEGER ERRPOS(302),ERRPNT(100),ESTACK(100),ERGSTK(100)
      LOGICAL NOWARN
C
      EQUIVALENCE(ERRPOS(1),NOWARN),(ERRPOS(3),ERRPNT(1)),
     1           (ERRPOS(103),ESTACK(1)),(ERRPOS(203),ERGSTK(1))
C
C
C           45.    NUMBER TABLE INDICES
C
      INCLUDE (NUMBLK)    
                          
C     DATA STATEMENTS
C
C...         2.    STACK AND POINTER STORAGE
C
      DATA TOP,ARGTOP,IARGDM/0,0,99/
C
C...         5.    PROGRAM CONTROL FLAGS
C
      DATA ENDFLG,NEWSTM,APTRAN,REFFLG/.TRUE.,.TRUE.,.FALSE.,.FALSE./
C
C...         6.    GHOST STACK FOR OBJECT TIME TEMPORARY ALLOCATION
C
C***  DATA SPECIFICATIONS TO COMPLEMENT 'INITAL'
C
C     LINE
      DATA TXXXX(1, 1),TXXXX(2, 1)/4,0/
C     PLANE
      DATA TXXXX(1, 2),TXXXX(2, 2)/4,0/
C     CYLINDER
      DATA TXXXX(1, 3),TXXXX(2, 3)/7,0/
C     CIRCLE
      DATA TXXXX(1, 4),TXXXX(2, 4)/7,0/
C     SPHERE
      DATA TXXXX(1, 5),TXXXX(2, 5)/4,0/
C     HYPERBOLA
      DATA TXXXX(1, 6),TXXXX(2, 6)/10,0/
C     LOFT CONIC
      DATA TXXXX(1, 7),TXXXX(2, 7)/10,0/
C     ELLIPSE
      DATA TXXXX(1, 8),TXXXX(2, 8)/10,0/
C     CONE
      DATA TXXXX(1, 9),TXXXX(2, 9)/7,0/
C     GENERAL CONIC
      DATA TXXXX(1,10),TXXXX(2,10)/10,0/
C     TABULATED CYLINDER
      DATA TXXXX(1,11),TXXXX(2,11)/2,0/
C     RULED SURFACE
      DATA TXXXX(1,12),TXXXX(2,12)/2,0/
C     POLYCONIC SURFACE
      DATA TXXXX(1,13),TXXXX(2,13)/2,0/
C     QUADRIC
      DATA TXXXX(1,14),TXXXX(2,14)/10,0/
C     PARAMETRIC SURFACE
      DATA TXXXX(1,15),TXXXX(2,15)/10,0/
C     UNUSED
      DATA TXXXX(1,16),TXXXX(2,16)/0,0/
C     UNUSED
      DATA TXXXX(1,17),TXXXX(2,17)/0,0/
C     MATRIX
      DATA TXXXX(1,18),TXXXX(2,18)/12,0/
C     POINT
      DATA TXXXX(1,19),TXXXX(2,19)/3,0/
C     VECTOR
      DATA TXXXX(1,20),TXXXX(2,20)/3,0/
C     REAL
      DATA TXXXX(1,21),TXXXX(2,21)/1,0/
C     INTEGER
      DATA TXXXX(1,22),TXXXX(2,22)/1,0/
C     BOOLEAN
      DATA TXXXX(1,23),TXXXX(2,23)/1,0/
C     SUBSCRIPT
      DATA TXXXX(1,24),TXXXX(2,24)/1,0/
C     STRING
      DATA TXXXX(1,25),TXXXX(2,25)/12,0/
C     PATERN
      DATA TXXXX(1,26),TXXXX(2,26)/2,0/
C     BOUNDS
      DATA TXXXX(1,27),TXXXX(2,27)/0,0/
C     OBJECT
      DATA TXXXX(1,28),TXXXX(2,28)/0,0/
C     SSURF
      DATA TXXXX(1,29),TXXXX(2,29)/2,0/
C     SCURV
      DATA TXXXX(1,30),TXXXX(2,30)/2,0/
C     UNUSED
      DATA TXXXX(1,31),TXXXX(2,31)/0,0/
C     UNUSED
      DATA TXXXX(1,32),TXXXX(2,32)/0,0/
C
C...      13.      NAMTBL POINTERS TO NEGATIVE NUMBERS
C
C
C...        11.    SEQUENCE NUMBER STORAGE
C
      DATA     SEQNO/1/
C
C...        12.    LARGE DATA ARRAY STORAGE REQUIREMENTS
C
      DATA  MAXSIZ,CANSIZ,KSC,CANTOP,ISC /1102*0,100,3/
      DATA PARDEF,TABCYS/.FALSE.,.FALSE./
C
C...      14.      I. L. LIST OPTION FLAGS
C
      DATA       CILPRT,  ILPRT, INTERP, ASSEMB, TRACFL
     /          ,PRTERR,  MCHDNG/
     /           2*.FALSE.,.TRUE.,4*.FALSE./
C
C...        15.    ARRAY LIMIT STORAGE
C
      DATA RNGPT,RANGE/1,400*0/
C
C...        16.    LITERALS FOR I. L. OPERATION CODES
C
      DATA FADD  / 1/
      DATA FSUB  / 2/
      DATA FMPY  / 3/
      DATA FDIV  / 4/
      DATA FEXP  / 5/
      DATA LABELX/ 6/
      DATA ENTRYX/ 7/
      DATA JUMP  / 8/
      DATA SEQNCE/ 9/
      DATA RETMC /10/
      DATA CONJMP/11/
      DATA RESRV /12/
      DATA CVTSUB/13/
      DATA CALMC /14/
      DATA ASNADD/15/
      DATA ASNJMP/16/
      DATA REPL  /17/
      DATA CALL  /18/
      DATA MOVE  /19/
      DATA VBLJMP/20/
      DATA HOLDAT/21/
C
C...        17.    MODE CODES
C
      DATA  LINE  / 1/
      DATA  PLANE / 2/
      DATA  CYLNDR/ 3/
      DATA  CIRCLE/ 4/
      DATA  SPHERE/ 5/
      DATA  HYPERB/ 6/
      DATA  CONIC / 7/
      DATA  ELLIPS/ 8/
      DATA  CONE  / 9/
      DATA  GCONIC/10/
      DATA  TABCYL/11/
      DATA  RLDSRF/12/
      DATA  POLCON/13/
      DATA  QADRIC/14/
      DATA  PARSRF/15/
      DATA  UNUS1 /16/
      DATA  UNUS2 /17/
      DATA  MATRIX/18/
      DATA  POINT /19/
      DATA  VECTOR/20/
      DATA  REAL  /21/
      DATA  INTGER/22/
      DATA  BOOL  /23/
      DATA  SUBSCR/24/
      DATA  STRING/25/
      DATA  PATERN/26/
      DATA  BOUNDS/27/
      DATA  OBJECT/28/
      DATA  SSURF /29/
      DATA  SCURV /30/
      DATA  UNUS3 /31/
      DATA  UNUS4 /32/
C
C...        18.    STRING STORAGE AREA
C
      DATA CHR    /' '/
C
C...      19.      INTERMEDIATE LANGUAGE TEXT
C
      DATA COMFIN,LENGTH,TPNTRX/.FALSE.,0,0/
C
C         22.      MACRO PROCESSING VARIABLES
C
      DATA MACDFP ,MCNMB  ,MCHSTP ,MCTXTP ,MCSAVP ,MNMVBP ,MVSEG  ,
     1     CALLPT ,TEXTST ,MVPNT  ,BRANCH ,MAXSPS ,INTMED ,MAJWRD ,
     2     NMLINE ,WAY    ,BITWDS ,MCSLNT ,MACLNT ,MSP    ,MVEXST ,
     3     MACTOP ,MCSTRT ,MAJOR  ,ROUTE  ,ROAD   ,SAVMSP ,TYP    ,
     4     LNUSDP ,MCTOPP ,MCSPDP ,MCSRCH ,NUMARG ,WHCHMN ,LARGMV ,
     5     VBLSVP ,PATHLN ,NEXTLN ,PATHCH ,NUMVAR,NUMCAL  /41*0/
C
      DATA MACLDD ,CALLON ,CALLMV ,ILHLT  ,MVMAC  ,MACRED ,MVTRUE ,
     1     FINMAC ,ENTRY  ,NESTG  ,ENDMCH ,MACLK  ,MACEND ,SHOULD
     2     /14*.FALSE./
C
      DATA MBPTR  ,LSTWRT ,MCDFDM ,MHSTDM ,MCSVDM ,MNMVDM ,MSEQDM
     1    /    2  ,     1 ,   400 ,  1800 ,    10 ,    25 ,    50/
      DATA LNSDDM ,MVARDM ,MASDM  ,NUMBIT ,MACFND ,MSPDDM ,IVSVDM
     1    /    50 ,    32 ,  100  ,    31 ,    -1 ,  1300 ,   900/
C
C         23.      MACRO PROCESSING ARRAYS
C
      DATA  MACXX2/1,2,900*0/
C
C         24.      MACRO PROCESSING ARRAYS
C
      DATA  MACXX3/2630*0/
C
C         25.      MACRO PROCESSING ARRAYS
C
      DATA  MACXX4/100*0/
C
C         25A.     MACRO PROCESSING ARRAYS
C
C
C         26.      MACRO PROCESSING ARRAYS
C
      DATA  MACXX6/1300*0/
C
C         26A.     MACRO PROCESSING ARRAYS
      DATA  MACXX7/182*0/
C
C...        27.    OPERAND MODIFIERS
C
      DATA NOUGHT/0/
      DATA DLR   /1/
      DATA DBLDLR/2/
      DATA TRPDLR/3/
      DATA QUADLR/4/
      DATA QUIDLR/5/
      DATA HEXDLR/6/
      DATA SPTDLR/7/
C
C...        29.    CLASS CODE MODULI
C
      DATA MODULO /1000/
      DATA MODHLF / 500/
C
C...        30.   NAMTBL POINTERS TO FIRST CANONICAL FORMS IN EACH BLOCK
C
      DATA  FIRST /6*0/
C....
C           31.   COMMON BLOCK FOR PRO026 AND MOTION
C....
      DATA JMPING,FMTERR,MCSJMP,FEDSAV/4*.FALSE./
      DATA NUMBCS/0/
C
C           32.   COMMON BLOCK FOR SETBIT AND BITMCH
C
      DATA LOBIT( 1),LOBIT( 2),LOBIT( 3),LOBIT( 4),
     1     LOBIT( 5),LOBIT( 6),LOBIT( 7),LOBIT( 8),
     2     LOBIT( 9),LOBIT(10),LOBIT(11),LOBIT(12),
     3     LOBIT(13),LOBIT(14),LOBIT(15),LOBIT(16)
C    4    /Z80000000,Z40000000,Z20000000,Z10000000,
     4    /Z80000000,1073741824,536870912,268435456,
C    5     Z 8000000,Z 4000000,Z 2000000,Z 1000000,
     5     134217728, 67108864, 33554432, 16777216,
C    6     Z  800000,Z  400000,Z  200000,Z  100000,
     6       8388608,  4194304,  2097152,  1048576,
C    7     Z   80000,Z   40000,Z   20000,Z   10000/
     7        524288,   262144,   131072,    65536/
      DATA HIBIT( 1),HIBIT( 2),HIBIT( 3),HIBIT( 4),
     1     HIBIT( 5),HIBIT( 6),HIBIT( 7),HIBIT( 8),
     2     HIBIT( 9),HIBIT(10),HIBIT(11),HIBIT(12),
     3     HIBIT(13),HIBIT(14),HIBIT(15),HIBIT(16)
C    4    /Z    8000,Z    4000,Z    2000,Z    1000,
     4    /    32768,    16384,     8192,     4096,
C    5     Z     800,Z     400,Z     200,Z     100,
     5          2048,     1024,      512,      256,
C    6     Z      80,Z      40,Z      20,Z      10,
     6           128,       64,       32,       16,
C    7     Z       8,Z       4,Z       2,Z       1/
     7             8,        4,        2,        1/
C...
C ...       35.    COMMON BLOCK FOR BOUNDED GEOMETRY AND CFSAVE
C
C
C
C           36.    SYSTEM MACRO AND SEGMENT READ VARIABLES
C
      DATA ALOPN,LMRSTR,LMREND/3*.FALSE./
      DATA NMSEG,NMMAC,ITMPCT/3*0/
C
C...        37.    INCLUSIVE SUBSCRIPT VARIABLES
C
      DATA ISSFL,ISSEND/2*.FALSE./
C
C...        39.    COMMON BLOCK LIBRARY PRINTING FLAG
C
      DATA LIBPRT/.FALSE./
C
C...        41.    NUMBER TABLE OVERFLOW VARIABLES
C
      DATA NCRNT,NLAST,NSTR,NMAX/1,0,1,100/
C
C           42.    COMMON BLOCK FOR CANON AND OBTAIN ARGUMENT STORAGE
C
      DATA CANPTR,CANCHK/0,16/
C
C           43.    COMMON BLOCK FOR LOOP
C
      DATA DOFLAG,DLRFLG,IFFLAG/3*.FALSE./
      DATA JUMPTO,ABSDO,RELDO,DONEST,DOMAX,DOJUMP/0,0,0,10,13,0/
C
C           44.    COMMON BLOCK FOR ERROR POSITIONS
C
      DATA NOWARN/.FALSE./
C
C           45.    NUMBER TABLE INDICIES
C
      DATA NMBRS,LSTCHR,MASGND/0,13,2000/
C
      END
