**** SOURCE FILE : ABCDBN00.ORG   ***
*
*
*  * ABCDBN *    FORTRAN 77 VERSION  11-JUL-1986  E.MCLELLAN
*
*   PURPOSE      TO CONVERT FLOATING POINT NUMBERS
*                FROM LEFT JUSTIFIED CHARACTER FORM
*                TO DOUBLE PRECISION VALUES
*
*   CALLING SEQUENCE
*                CALL ABCDBN(STR,VALUE,NUM)
*
*   ARGUMENTS
*       STR     CHARACTER   STRING ARRAY CONTAINING NUMBERS
*                           LEFT JUSTIFIEDIN 12 BYTES,
*                           TO BE CONVERTED TO FLOATING POINT
*       VALUE   DOUBLE      ARRAY TO CONTAIN CONVERTED NUMBERS
*               PRECISION
*       NUM     INTEGER     NUMBER OF ITEMS IN ARRAY
*
      SUBROUTINE ABCDBN(STR,VALUE,NUM)
C
      INTEGER NUM
      CHARACTER*12 STR(NUM),TSTR
      DOUBLE PRECISION VALUE(NUM)
C
      DO 10 I=1,NUM
        TSTR=STR(I)
        K=INDEX(TSTR,'.')
        IF (K.EQ.0) THEN
          J=INDEX(TSTR,' ')
          IF (J.NE.0) THEN
            TSTR(J:J)='.'
          ENDIF
        ENDIF
        READ (TSTR,'(F12.0)') VALUE(I)
 10   CONTINUE
      RETURN
      END
**** SOURCE FILE : AREAD000.ORG   ***
*
*
*  *  AREAD  *   VAX11 VERSION   11.5.82   E.MCLELLAN
*                MODIFIED        16.7.85   E.MCLELLAN
*
*
*  PURPOSE     TO READ ONE RECORD FROM A SPECIFIED FILE
*
*  CALLING SEQUENCE
*              CALL AREAD (NO,IRECNO,DATA,ISIZE,IRET)
*  ARGUMENTS
*              NO        FILE NUMBER
*              IRECNO    RECORD NO. IF SET TO ZERO RETRIEVES
*                        THE NEXT RECORD. IF SET TO 'N'
*                        RETRIEVES N-TH RECORD DIRECTLY.
*              DATA      DATA ARRAY TO CONTAIN THE RETRIEVED
*                        RECORD
*              ISIZE     SIZE OF RECORD (IN 4 BYTE WORDS)
*              IRET      RETURN FLAG =0  NO ERROR
*                                    =1  E.O.F ENCOUNTERED
*                                    =2  ISIZE IS BIGGER THAN ACTUAL
*                                        RECORD SIZE. DATA ASSUMED TO
*                                        SPAN MORE THAN ONE RECORD
*                                        DATA TRANSFERRED TO ARRAY
*                                    =3  UNRECOVERABLE ERROR
*
*
*  GLOBAL VARIABLES:  NONE
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   FILNAM          FILTAB    CHARACTER  FILE NAME
*   FILACC          FILTAB    CHARACTER  FILE ACCESS
*                                         (DIRECT OR SEQUENTIAL)
*   FILFMT          FILTAB    CHARACTER  FILE FORMAT
*                                         (FORMATTED OR UNFORMATTED)
*   OPSTAT          FILTAB    CHARACTER  OPEN STATUS
*                                         (UNKNOWN,SCRATCH,NEW,OLD)
*   CLSTAT          FILTAB    CHARACTER  CLOSE STATUS (KEEP,DELETE)
*   U               IFILTB    INTEGER    UNIT NUMBER
*   RL              IFILTB    INTEGER    RECORD LENGTH
*   NXTREC          IFILTB    INTEGER    NUMBER OF NEXT RECORD TO BE
*                                        READ OR WRITTEN (DIRECT ACCESS)
*   LSTREC          IFILTB    INTEGER    NUMBER OF LAST RECORD ON FILE
*                                         (DIRECT ACCESS)
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*         OD        LOGICAL    FLAG TO INDICATE IF FILE IS OPEN
*         IACC      CHARACTER  ACCESS TYPE RETURN BY INQUIRE
*         DARRAY    CHARACTER  PRINT BUFFER
*         IRECL     INTEGER    RECORD LENGTH
*         NUM       INTEGER    NUMBER OF COMPLETE PHYSICAL RECORDS
*                              SPANNED BY LOGICAL RECORD BEING READ
*         POSN      INTEGER    START POSITION IN PRINT BUFFER
*         SLEN      INTEGER    LENGTH OF STRING ENTERED IN PRINT BUFFER
*
*  FILES:  FILE REFERENCED BY FILE NUMBER
*
*  SUBSIDIARIES:
*               FILOPN
*               CFORM
*               ICONV
*               CPRINT
*
      SUBROUTINE AREAD (NO,IRECNO,DATA,ISIZE,IRET)
C
      INCLUDE (FILTAB)    
C
      LOGICAL OD
      DIMENSION DATA(*)
      CHARACTER*12 IACC
      CHARACTER*80 DARRAY
      INTEGER POSN,SLEN
      DATA DARRAY/' '/
      ID=U(NO)
C
C---- IS UNIT OPENED, IF NOT OPEN
      INQUIRE (UNIT=ID,OPENED=OD)
      IF (OD) GOTO 10
C---- OPEN UNIT
      CALL FILOPN(NO)
C---- CHECK FILE ACCESS
   10 INQUIRE (UNIT=ID,ACCESS=IACC)
      IF (IACC.EQ.'DIRECT') THEN
C---- DIRECT ACCESS FILE
        IRECL=RL(NO)
        IF (IRECNO.EQ.0) THEN
          IRECNO=NXTREC(NO)
        END IF
C.... IF LSTREC(NO).EQ.0 THEN READING AN EXTERNALLY WRITTEN
C     DIRECT ACCESS FILE FOR WHICH LENGTH IS NOT KNOWN
        IF ((LSTREC(NO).NE.0).AND.(IRECNO.GT.LSTREC(NO))) THEN
          IRET=1
          RETURN
        END IF
        IREC=IRECNO
        IF (ISIZE.LE.IRECL) THEN
          READ (ID,REC=IREC,IOSTAT=IRET,ERR=90) (DATA(I),I=1,ISIZE)
        ELSE
          NUM=ISIZE/IRECL
          DO 20 J=1,NUM
          I1=(J-1)*IRECL+1
          I2=J*IRECL
          READ (ID,REC=IREC,IOSTAT=IRET,ERR=90) (DATA(I),I=I1,I2)
   20     IREC=IREC+1
          IF ((ISIZE-NUM*IRECL).GT.0) THEN
            I1=NUM*IRECL+1
            READ (ID,REC=IREC,IOSTAT=IRET,ERR=90) (DATA(I),I=I1,ISIZE)
          ELSE
            IREC=IREC-1
          END IF
          IRET=2
        END IF
        NXTREC(NO)=IREC+1
        ELSE
C---- SEQUENTIAL ACCESS FILE
          READ (ID,END=80) (DATA(I),I=1,ISIZE)
        END IF
      RETURN
 80   IRET=1
      RETURN
 90   SLEN=0
      CALL CFORM (' *** ERROR READING BY AREAD FROM FILE :',
     1            DARRAY,2,SLEN)
      POSN=SLEN+3
      SLEN=0
      CALL CFORM (FILNAM(NO),DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+2
      SLEN=0
      CALL CFORM ('RECNO:',DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+1
      SLEN=6
      CALL ICONV (IRECNO,DARRAY,POSN,SLEN)
      CALL CPRINT (DARRAY)
      IRET=3
      RETURN
      END
**** SOURCE FILE : AWRITE00.V01   ***
*
*
*  *  AWRITE  *   VAX11 VERSION    11.05.82   E.MCLELLAN
*                 MODIFIED         16.7.85
*
*  PURPOSE     TO WRITE ONE RECORD ON A SPECIFIED FILE
*
*  CALLING SEQUENCE
*              CALL AWRITE (NO,IRECNO,DATA,ISIZE,IRET)
*  ARGUMENTS
*              NO        FILE NUMBER
*              IRECNO    RECORD NO. IF SET TO ZERO WILL WRITE
*                        NEXT RECORD. CONTAINS ACTUAL RECORD
*                        NUMBER ON RETURNING
*              DATA      DATA ARRAY CONTAINING RECORD TO
*                        BE WRITTEN ON THE FILE
*              ISIZE     SIZE OF RECORD (IN 4 BYTE WORDS)
*              IRET      RETURN FLAG =0  NO ERROR
*                                    =1  ERROR
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   FILNAM          FILTAB    CHARACTER  FILE NAME
*   FILACC          FILTAB    CHARACTER  FILE ACCESS
*                                         (DIRECT OR SEQUENTIAL)
*   FILFMT          FILTAB    CHARACTER  FILE FORMAT
*                                         (FORMATTED OR UNFORMATTED)
*   OPSTAT          FILTAB    CHARACTER  OPEN STATUS
*                                         (UNKNOWN,SCRATCH,NEW,OLD)
*   CLSTAT          FILTAB    CHARACTER  CLOSE STATUS (KEEP,DELETE)
*   U               IFILTB    INTEGER    UNIT NUMBER
*   RL              IFILTB    INTEGER    RECORD LENGTH
*   NXTREC          IFILTB    INTEGER    NUMBER OF NEXT RECORD TO BE
*                                        READ OR WRITTEN (DIRECT ACCESS)
*   LSTREC          IFILTB    INTEGER    NUMBER OF LAST RECORD ON FILE
*                                         (DIRECT ACCESS)
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*        OD         LOGICAL    FLAG TO INDICATE IF FILE IS OPENED
*        IACC       CHARACTER  FILE ACCESS TYPE RETURNED BY INQUIRE
*        DARRAY     CHARACTER  PRINT BUFFER
*        DUM        REAL       DUMMY ARRAY FOR FILLING OUT A PHYSICAL
*                              RECORD
*        NUM        INTEGER    NUMBER OF FULL PHYSICAL RECORDS TO
*                              WRITTEN FOR LOGICAL RECORD
*        POSN       INTEGER    START POSITION IN PRINT BUFFER
*        SLEN       INTEGER    LENGTH OF STRING ENTERED IN PRINT BUFFER
*
*  FILES:  FILE REFERENCED BY FILE NUMBER
*
*  SUBSIDIARIES:
*               FILOPN
*               CFORM
*               ICONV
*               CPRINT
*
      SUBROUTINE AWRITE (NO,IRECNO,DATA,ISIZE,IRET)
C
      INCLUDE (FILTAB)    
      LOGICAL OD
      CHARACTER*12 IACC
      DIMENSION DATA(*)
      CHARACTER*80 DARRAY
      INTEGER POSN,SLEN
      REAL DUM(256)
      DATA DARRAY/' '/
      DATA DUM/256*0.0/
      ID=U(NO)
C
C---- IS FILE OPENED, IF NOT OPEN
      INQUIRE (UNIT=ID,OPENED=OD)
      IF (OD) GOTO 10
C---- OPEN UNIT
      CALL FILOPN(NO)
C---- CHECK FILE ACCESS
   10 INQUIRE (UNIT=ID,ACCESS=IACC)
      IF (IACC.EQ.'DIRECT') THEN
C---- DIRECT ACCESS FILE
        IRECL=RL(NO)
        IF (IRECNO.EQ.0) THEN
          IRECNO=LSTREC(NO)+1
        END IF
        IREC=IRECNO
        IF (ISIZE.LE.IRECL) THEN
          WRITE (ID,REC=IREC,IOSTAT=IRET,ERR=90) (DATA(I),I=1,ISIZE)
        ELSE
        NUM=ISIZE/IRECL
          DO 20 J=1,NUM
          I1=(J-1)*IRECL+1
          I2=J*IRECL
          WRITE (ID,REC=IREC,IOSTAT=IRET,ERR=90) (DATA(I),I=I1,I2)
   20     IREC=IREC+1
          IF ((ISIZE-NUM*IRECL).GT.0) THEN
            I1=NUM*IRECL+1
            I2=(NUM+1)*IRECL-ISIZE
            WRITE (ID,REC=IREC,IOSTAT=IRET,ERR=90)
     1            (DATA(I),I=I1,ISIZE),(DUM(I),I=1,I2)
          ELSE
            IREC=IREC-1
          END IF
        END IF
        IF (IREC.GT.LSTREC(NO)) THEN
          LSTREC(NO)=IREC
        END IF
        NXTREC(NO)=IREC+1
        ELSE
C---- SEQUENTIAL ACCESS FILE
        WRITE (ID) (DATA(I),I=1,ISIZE)
        END IF
      RETURN
   90 SLEN=0
      CALL CFORM(' *** ERROR WRITING BY AWRITE ON FILE :',
     1            DARRAY,2,SLEN)
      POSN=SLEN+3
      SLEN=0
      CALL CFORM (FILNAM(NO),DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+2
      SLEN=0
      CALL CFORM ('RECNO :',DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+1
      SLEN=6
      CALL ICONV (IRECNO,DARRAY,POSN,SLEN)
      CALL CPRINT (DARRAY)
      IRET=1
      RETURN
      END
**** SOURCE FILE : BADNAM00.V01   ***
*
*
*  * BADNAM *    FORTRAN 77 SUBROUTINE   15-JUL-1986  E.MCLELLAN
*
*   PURPOSE:  TO RETURN THE BCD EQUIVALENT OF 'BADNAM  '
*
*   CALLING SEQUENCE:
*                    CALL BADNAM(IWORD)
*
*   ARGUMENTS:
*         IWORD  INTEGER  ARRAY INTO WHICH 'BADNAM  ' IS TO BE LOADED
*
*   GLOBAL VARIABLES: NONE
*
*   LOCAL VARIABLES:
*                   TYPE        DESCRIPTION
*         IBDNAM    INTEGER     INTEGER ARRAY TO BUILD UP BCDF
*         FIRST     LOGICAL     FLAG INDICATING FIRST CALL
*
*   SUBSIDIARIES:  BCDF
*
      SUBROUTINE BADNAM(IWORD)
C
      INTEGER BCDF
C
      INTEGER IBDNAM(2),IWORD(2)
      LOGICAL FIRST
      SAVE IBDNAM,FIRST
      DATA FIRST/.TRUE./
                        
      IF (FIRST) THEN
        IBDNAM(1) = BCDF('BADN')
        IBDNAM(2) = BCDF('AM  ')
        FIRST=.FALSE.
      ENDIF
C
      IWORD(1)=IBDNAM(1)
      IWORD(2)=IBDNAM(2)
      RETURN
      END
**** SOURCE FILE : BCDF0000.W01   ***
*
*
*  * BCDF *  FORTRAN 77 INTEGER FUNCTION  19-DEC-1985  E.MCLELLAN
*            MODIFIED                      2-FEB-1988  E.MCLELLAN
*
*  PURPOSE:  CONVERT A STRING OF CHARACTERS WHICH OCCUPY THE SAME
*            NUMBER OF BYTES AS AN INTEGER WORD INTO AN EQUIVALENT
*            INTEGER VALUE
*
*  CALLING SEQUENCE:
*                   VALUE=BCDF(STR)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*       STR         CHARACTER  STRING TO BE CONVERTED
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   IWRD            SDP       INTEGER    NO. OF BYTES PER WORD
*   NBCHAR          SDP       INTEGER    NO. OF BITS PER BYTE
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*        I          INTEGER    LOOP COUNT
*        BCD        INTEGER    VARIABLE FOR BUILDING UP BCD VALUE
*        TSTR       CHARACTER  TEMPORARY STORAGE FOR STRING
*
*  FILES:  NONE
*
*  SUBSIDIARIES:  NONE
*
      INTEGER FUNCTION BCDF(STR)
C
      INCLUDE (SDP)    
C
      INTEGER  BCD
      CHARACTER*(*) STR,TSTR*10
C
      BCD=0
      TSTR=STR//' '
      DO 10 I=1,IWRD
      BCD=ISHFT(BCD,NBCHAR)+ICHAR(TSTR(I:I))
  10  CONTINUE
C
      BCDF=BCD
C
      RETURN
      END
**** SOURCE FILE : CFORM000.ORG   ***
*
*
*  * CFORM *  FORTRAN 77 SUBROUTINE  26.10.84  E.MCLELLAN
*
*  PURPOSE:  TO INSERT A CHARACTER STRING IN A CHARACTER BUFFER
*            AT LOCATION POSN.
*            THE LENGTH OF THE STRING IS RETURNED IF THE ARGUMENT
*            LENGTH IS ZERO ON INPUT.
*
*  CALLING SEQUENCE:
*                   CALL CFORM(STRING,BUFFER,POSN,LENGTH)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*       STRING      CHARACTER  CHARACTER STRING TO BE INSERTED
*       BUFFER      CHARACTER  CHARACTER BUFFER INTO WHICH
*                              STRING IS TO BE INSERTED
*       POSN        INTEGER    LOCATION IN CHARACTER BUFFER
*                              AT WHICH STRING IS TO BE INSERTED
*       LENGTH      INTEGER    LENGTH OF STRING
*                              IF = 0 ON INPUT, ACTUAL LENGTH
*                              IS RETURNED TO CALLING ROUTINE
*
*  GLOBAL VARIABLES:  NONE
*
*  LOCAL VARIABLES:  NONE
*
*  FILES:  NONE
*
*  SUBSIDIARIES:  NONE
*
      SUBROUTINE CFORM(STRING,BUFFER,POSN,LENGTH)
C
      CHARACTER STRING*(*),BUFFER*(*)
      INTEGER POSN,LENGTH
C
C.....IF LENGTH IS ZERO ON INPUT RETURN ACTUAL LENGTH OF STRING
C
      IF (LENGTH.EQ.0) THEN
         LENGTH=LEN(STRING)
      ENDIF
C
C.....INSERT CHARACTER STRING IN PRINT BUFFER
C
      BUFFER(POSN:POSN+LENGTH-1)=STRING(1:LENGTH)
C
      RETURN
      END
**** SOURCE FILE : CHREAD00.ORG   ***
*
*
*  *  CHREAD  *                  18.6.86   E.MCLELLAN
*
*
*  PURPOSE     TO READ A RECORD CONTAINING CHARACTER DATA
*              FROM A SPECIFIED FILE
*
*  CALLING SEQUENCE
*              CALL CHREAD (NO,IRECNO,CDATA,ISIZE,IRET)
*  ARGUMENTS
*              NO        FILE NUMBER
*              IRECNO    RECORD NO. IF SET TO ZERO RETRIEVES
*                        THE NEXT RECORD. IF SET TO 'N'
*                        RETRIEVES N-TH RECORD DIRECTLY.
*              CDATA     CHARACTER ARRAY TO CONTAIN THE RETRIEVED
*                        RECORD
*              ISIZE     SIZE OF RECORD (IN BYTES)
*              IRET      RETURN FLAG =0  NO ERROR
*                                    =1  E.O.F ENCOUNTERED
*                                    =2  ISIZE IS BIGGER THAN ACTUAL
*                                        RECORD SIZE. DATA ASSUMED TO
*                                        SPAN MORE THAN ONE RECORD
*                                        DATA TRANSFERRED TO ARRAY
*                                    =3  UNRECOVERABLE ERROR
*
*
*  GLOBAL VARIABLES:  NONE
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   FILNAM          FILTAB    CHARACTER  FILE NAME
*   FILACC          FILTAB    CHARACTER  FILE ACCESS
*                                         (DIRECT OR SEQUENTIAL)
*   FILFMT          FILTAB    CHARACTER  FILE FORMAT
*                                         (FORMATTED OR UNFORMATTED)
*   OPSTAT          FILTAB    CHARACTER  OPEN STATUS
*                                         (UNKNOWN,SCRATCH,NEW,OLD)
*   CLSTAT          FILTAB    CHARACTER  CLOSE STATUS (KEEP,DELETE)
*   U               IFILTB    INTEGER    UNIT NUMBER
*   RL              IFILTB    INTEGER    RECORD LENGTH
*   NXTREC          IFILTB    INTEGER    NUMBER OF NEXT RECORD TO BE
*                                        READ OR WRITTEN (DIRECT ACCESS)
*   LSTREC          IFILTB    INTEGER    NUMBER OF LAST RECORD ON FILE
*                                         (DIRECT ACCESS)
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*         OD        LOGICAL    FLAG TO INDICATE IF FILE IS OPEN
*         IACC      CHARACTER  ACCESS TYPE RETURN BY INQUIRE
*         DARRAY    CHARACTER  PRINT BUFFER
*         IRECL     INTEGER    RECORD LENGTH
*         NUM       INTEGER    NUMBER OF COMPLETE PHYSICAL RECORDS
*                              SPANNED BY LOGICAL RECORD BEING READ
*         POSN      INTEGER    START POSITION IN PRINT BUFFER
*         SLEN      INTEGER    LENGTH OF STRING ENTERED IN PRINT BUFFER
*
*  FILES:  FILE REFERENCED BY FILE NUMBER
*
*  SUBSIDIARIES:
*               FILOPN
*               CFORM
*               ICONV
*               CPRINT
*
      SUBROUTINE CHREAD (NO,IRECNO,CDATA,ISIZE,IRET)
C
      INCLUDE (FILTAB)    
C
      LOGICAL OD
      CHARACTER CDATA(*)
      CHARACTER*12 IACC
      CHARACTER*80 DARRAY
      INTEGER POSN,SLEN
      DATA DARRAY/' '/
C
      ID=U(NO)
C
C---- IS UNIT OPENED, IF NOT OPEN
      INQUIRE (UNIT=ID,OPENED=OD)
      IF (OD) GOTO 10
C---- OPEN UNIT
      CALL FILOPN(NO)
C---- CHECK FILE ACCESS
   10 INQUIRE (UNIT=ID,ACCESS=IACC)
      IF (IACC.EQ.'DIRECT') THEN
C---- DIRECT ACCESS FILE
        IRECL=RL(NO)
        IF (IRECNO.EQ.0) THEN
          IRECNO=NXTREC(NO)
        END IF
        IF (IRECNO.GT.LSTREC(NO)) THEN
          IRET=1
          RETURN
        END IF
        IREC=IRECNO
        IF (ISIZE.LE.IRECL) THEN
          READ (ID,REC=IREC,IOSTAT=IRET,ERR=90) (CDATA(I),I=1,ISIZE)
        ELSE
          NUM=ISIZE/IRECL
          DO 20 J=1,NUM
          I1=(J-1)*IRECL+1
          I2=J*IRECL
          READ (ID,REC=IREC,IOSTAT=IRET,ERR=90) (CDATA(I),I=I1,I2)
   20     IREC=IREC+1
          IF ((ISIZE-NUM*IRECL).GT.0) THEN
            I1=NUM*IRECL+1
            READ (ID,REC=IREC,IOSTAT=IRET,ERR=90) (CDATA(I),I=I1,ISIZE)
          ELSE
            IREC=IREC-1
          END IF
          IRET=2
        END IF
        NXTREC(NO)=IREC+1
        ELSE
C---- SEQUENTIAL ACCESS FILE
          READ (ID,END=80) (CDATA(I),I=1,ISIZE)
        END IF
      RETURN
 80   IRET=1
      RETURN
 90   SLEN=0
      CALL CFORM (' *** ERROR READING BY CHREAD FROM FILE :',
     1            DARRAY,2,SLEN)
      POSN=SLEN+3
      SLEN=0
      CALL CFORM (FILNAM(NO),DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+2
      SLEN=0
      CALL CFORM ('RECNO:',DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+1
      SLEN=6
      CALL ICONV (IRECNO,DARRAY,POSN,SLEN)
      CALL CPRINT (DARRAY)
      IRET=3
      RETURN
      END
**** SOURCE FILE : CHWRIT00.ORG   ***
*
*
*  *  CHWRIT  *                    18.06.86   E.MCLELLAN
*
*  PURPOSE     TO WRITE ONE CHARACTER RECORD ON A SPECIFIED FILE
*
*  CALLING SEQUENCE
*              CALL CHWRIT (NO,IRECNO,CDATA,ISIZE,IRET)
*  ARGUMENTS
*              NO        FILE NUMBER
*              IRECNO    RECORD NO. IF SET TO ZERO WILL WRITE
*                        NEXT RECORD. CONTAINS ACTUAL RECORD
*                        NUMBER ON RETURNING
*              CDATA     CHARACTER ARRAY CONTAINING RECORD TO
*                        BE WRITTEN ON THE FILE
*              ISIZE     SIZE OF RECORD (IN BYTES)
*              IRET      RETURN FLAG =0  NO ERROR
*                                    =1  ERROR
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   FILNAM          FILTAB    CHARACTER  FILE NAME
*   FILACC          FILTAB    CHARACTER  FILE ACCESS
*                                         (DIRECT OR SEQUENTIAL)
*   FILFMT          FILTAB    CHARACTER  FILE FORMAT
*                                         (FORMATTED OR UNFORMATTED)
*   OPSTAT          FILTAB    CHARACTER  OPEN STATUS
*                                         (UNKNOWN,SCRATCH,NEW,OLD)
*   CLSTAT          FILTAB    CHARACTER  CLOSE STATUS (KEEP,DELETE)
*   U               IFILTB    INTEGER    UNIT NUMBER
*   RL              IFILTB    INTEGER    RECORD LENGTH
*   NXTREC          IFILTB    INTEGER    NUMBER OF NEXT RECORD TO BE
*                                        READ OR WRITTEN (DIRECT ACCESS)
*   LSTREC          IFILTB    INTEGER    NUMBER OF LAST RECORD ON FILE
*                                         (DIRECT ACCESS)
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*        OD         LOGICAL    FLAG TO INDICATE IF FILE IS OPENED
*        IACC       CHARACTER  FILE ACCESS TYPE RETURNED BY INQUIRE
*        DARRAY     CHARACTER  PRINT BUFFER
*        CDUM       CHARACTER  DUMMY ARRAY FOR FILLING OUT A PHYSICAL
*                              RECORD
*        NUM        INTEGER    NUMBER OF FULL PHYSICAL RECORDS TO
*                              WRITTEN FOR LOGICAL RECORD
*        POSN       INTEGER    START POSITION IN PRINT BUFFER
*        SLEN       INTEGER    LENGTH OF STRING ENTERED IN PRINT BUFFER
*
*  FILES:  FILE REFERENCED BY FILE NUMBER
*
*  SUBSIDIARIES:
*               FILOPN
*               CFORM
*               ICONV
*               CPRINT
*
      SUBROUTINE CHWRIT (NO,IRECNO,CDATA,ISIZE,IRET)
C
      INCLUDE (FILTAB)    
      LOGICAL OD
      CHARACTER*12 IACC
      CHARACTER CDATA(*)
      CHARACTER*80 DARRAY
      INTEGER POSN,SLEN
      CHARACTER CDUM
C
      DATA DARRAY/' '/
      DATA CDUM/' '/
C
      ID=U(NO)
C
C---- IS FILE OPENED, IF NOT OPEN
      INQUIRE (UNIT=ID,OPENED=OD)
      IF (OD) GOTO 10
C---- OPEN UNIT
      CALL FILOPN(NO)
C---- CHECK FILE ACCESS
   10 INQUIRE (UNIT=ID,ACCESS=IACC)
      IF (IACC.EQ.'DIRECT') THEN
C---- DIRECT ACCESS FILE
        IRECL=RL(NO)
        IF (IRECNO.EQ.0) THEN
          IRECNO=LSTREC(NO)+1
        END IF
        IREC=IRECNO
        IF (ISIZE.LE.IRECL) THEN
          WRITE (ID,REC=IREC,IOSTAT=IRET,ERR=90) (CDATA(I),I=1,ISIZE)
        ELSE
          NUM=ISIZE/IRECL
          DO 20 J=1,NUM
            I1=(J-1)*IRECL+1
            I2=J*IRECL
            WRITE (ID,REC=IREC,IOSTAT=IRET,ERR=90) (CDATA(I),I=I1,I2)
            IREC=IREC+1
   20     CONTINUE
          IF ((ISIZE-NUM*IRECL).GT.0) THEN
            I1=NUM*IRECL+1
            I2=(NUM+1)*IRECL-ISIZE
            WRITE (ID,REC=IREC,IOSTAT=IRET,ERR=90)
     1            (CDATA(I),I=I1,ISIZE),(CDUM,I=1,I2)
          ELSE
            IREC=IREC-1
          END IF
        END IF
        IF (IREC.GT.LSTREC(NO)) THEN
          LSTREC(NO)=IREC
        END IF
        NXTREC(NO)=IREC+1
        ELSE
C---- SEQUENTIAL ACCESS FILE
        WRITE (ID) (CDATA(I),I=1,ISIZE)
        END IF
      RETURN
   90 SLEN=0
      CALL CFORM(' *** ERROR WRITING BY CHWRIT ON FILE :',
     1            DARRAY,2,SLEN)
      POSN=SLEN+3
      SLEN=0
      CALL CFORM (FILNAM(NO),DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+2
      SLEN=0
      CALL CFORM ('RECNO :',DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+1
      SLEN=6
      CALL ICONV (IRECNO,DARRAY,POSN,SLEN)
      CALL CPRINT (DARRAY)
      IRET=1
      RETURN
      END
**** SOURCE FILE : CLOCF400.ORG   ***
*
*
*  * CLOCF4 *  FORTRAN 77 SUBROUTINE  4-DEC-85  E.MCLELLAN
*
*  PURPOSE:  USE SYSTEM DEPENDENT FUNCTION 'CPUTIM'
*            TO OBTAIN CPU TIME IN 1/100THS OF A SECOND
*
*  CALLING SEQUENCE:
*                   CALL CLOCF4(TIME)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*       TIME        INTEGER    CPU TIME IN 1/100THS OF A SECOND
*
*  GLOBAL VARIABLES:  NONE
*
*  LOCAL VARIABLES:  NONE
*
*  FILES:  NONE
*
*  SUBSIDIARIES:
*               CPUTIM
*
      SUBROUTINE CLOCF4(TIME)
C
      INTEGER TIME
C
      INTEGER CPUTIM
      EXTERNAL CPUTIM
C
      TIME=CPUTIM()
      RETURN
      END
**** SOURCE FILE : CMPRES00.ORG   ***
*
*
*  * CMPRES *  FORTRAN 77 SUBROUTINE  9-DEC-1985  E.MCLELLAN
*
*  PURPOSE:  COMPRESS STRINGS OF BLANK CHARACTERS TO A SINGLE BLANK
*
*  CALLING SEQUENCE:
*                   CALL CMPRES(STRING,SLEN)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*      STRING       CHARACTER  CHARACTER STRING TO BE COMPRESSED
*      SLEN         INTEGER    LENGTH OF ORIGINAL STRING ON INPUT
*                              AND COMPRESSED STRING ON OUTPUT
*
*  GLOBAL VARIABLES:  NONE
*
*  LOCAL VARIABLES:  NONE
*
*  FILES:  NONE
*
*  SUBSIDIARIES:  NONE
*
      SUBROUTINE CMPRES(STRING,SLEN)
C
      CHARACTER STRING*(*)
      INTEGER SLEN
C
      SLEN=LEN(STRING)
      DO 10 I=SLEN,1,-1
      IF (STRING(I:I).NE.' ') THEN
        SLEN=I
        GOTO 20
      ENDIF
   10 CONTINUE
C
   20 I=INDEX(STRING(:SLEN),'  ')
      IF (I.NE.0) THEN
         STRING(I:)=STRING(I+1:SLEN)//' '
         SLEN=SLEN-1
         GOTO 20
      ELSE
         RETURN
      ENDIF
C
      END
**** SOURCE FILE : M0001088.V03   ***
*
      SUBROUTINE CPRINT(ARRAY)
C---       PURPOSE IS TO CONTROL COMPRESSION OF PRINTOUT
C---       IF ICMTES IS GT 0, STRINGS OF BLANKS ARE COMPRESSED
      IMPLICIT DOUBLE PRECISION(A-H,O-Z)
      COMMON/CMPTST/ICMTES
      CHARACTER ARRAY*(*)
      INTEGER SLEN
C
      SLEN=LEN(ARRAY)
      IF(ICMTES.EQ.0) GO TO 10
C
      CALL CMPRES(ARRAY,SLEN)
C
   10 CONTINUE
      CALL SPRINT(ARRAY(:SLEN))
C
      RETURN
      END
**** SOURCE FILE : CPUNCH00.V01   ***
*
      SUBROUTINE CPUNCH(ARRAY,FLAGG)
*
*  *  CPUNCH  *   VAX11 FORTRAN VERSION  13.5.82  E.MCLELLAN
*
*  PURPOSE     TO FORMAT A RECORD FOR PUNCHING ON PNCHFL
*  CALLING SEQUENCE
*              CALL CPUNCH(ARRAY,FLAGG)
*  ARGUMENTS
*              ARRAY   80 BYTE ARRAY CONTAINING THE
*                      BCD CHARACTERS TO BE PUNCHED
*              FLAGG   .EQ.0 BLANK FILL ARRAY AFTER PUNCHING
*                      .NE.0 OMIT BLANKING
*
C
C...                 SYSTEM I/O FILES
C
      INCLUDE (SYMFIL)    
C
C...     FILE ATTRIBUTES
C
      INCLUDE (FILTAB)    
C
      CHARACTER ARRAY*80
      INTEGER FLAGG,ID
      LOGICAL OD
C
C.... UNIT NO FOR PNCHFL
C
      ID=U(PNCHFL)
C
C---- IS PNCHFL OPEN, IF NOT, OPEN PNCHFL
      INQUIRE (UNIT=ID,OPENED=OD)
C
      IF (.NOT.OD) THEN
        CALL FILOPN(PNCHFL)
      END IF
C
      WRITE (ID,'(A80)') ARRAY
      IF (FLAGG.EQ.0) THEN
C---- BLANK FILL ARRAY
        ARRAY=' '
      ENDIF
      RETURN
      END
C
C---- CLOSE PNCHFL, IF OPEN
C
      SUBROUTINE CPUCLO
C
      INCLUDE (SYMFIL)    
C
      INCLUDE (FILTAB)    
C
      INTEGER ID
      LOGICAL OD
C
      ID=U(PNCHFL)
      INQUIRE (UNIT=ID,OPENED=OD)
      IF (OD) THEN
         CLOSE (UNIT=ID,STATUS='KEEP')
      ENDIF
      RETURN
      END
**** SOURCE FILE : CREAD000.ORG   ***
*
*
*  *  CREAD  *   FORTRAN 77 VERSION   4-DEC-85   E.MCLELLAN
*
*  PURPOSE     TO READ A RECORD FROM SYSTEM INPUT DEVICE
*
*  CALLING SEQUENCE
*              CALL CREAD(REC,FLAG)
*  ARGUMENTS
*              REC     CHARACTER STRING TO CONTAIN INPUT RECORD
*              FLAG    =0  NORMAL RETURN
*                      =1 END OF FILE DETECTED
*
      SUBROUTINE CREAD(REC,FLAG)
C
      INCLUDE (SYMFIL)    
C
      CHARACTER*80 REC
      INTEGER FLAG
C
      READ (INFILE,'(A80)',IOSTAT=FLAG) REC
      FLAG=ABS(FLAG)
      RETURN
      END
**** SOURCE FILE : DNONAM00.V01   ***
*
*
*  * DNONAM *    FORTRAN 77 SUBROUTINE   15-JUL-1986  E.MCLELLAN
*
*   PURPOSE:  TO RETURN THE BCD EQUIVALENT OF 'DNONAM  '
*             IN THE FIRST 8 BYTES OF THE ARGUMENT
*             (NOTE: THIS SHOULD GIVE A NONE VALID D.P. NUMBER
*                    ON MOST SYSTEMS)
*
*   CALLING SEQUENCE:
*                    CALL DNONAM(IWORD)
*
*   ARGUMENTS:
*         IWORD  INTEGER  ARRAY INTO WHICH 'DNONAM  ' IS TO BE LOADED
*
*   GLOBAL VARIABLES:
*
*----------------------------------------------------
*   VARIABLE    BLOCK    TYPE        DESCRIPTION
*----------------------------------------------------
*   IFAC        SDP      INTEGER     BYTE LEFT SHIFT
*                                    MULTIPLICATION FACTOR
*
*   LOCAL VARIABLES:
*                   TYPE        DESCRIPTION
*         IBDNAM    INTEGER     INTEGER ARRAY TO BUILD UP BCDF
*         FIRST     LOGICAL     FLAG INDICATING FIRST CALL
*
*   SUBSIDIARIES:  NONE
*
      SUBROUTINE DNONAM(IWORD)
C
      INTEGER IDNONM(2),IWORD(2)
      INTEGER BCDF
      LOGICAL FIRST
      SAVE IDNONM,FIRST
      DATA FIRST/.TRUE./
                        
      IF (FIRST) THEN
        IDNONM(1) = BCDF('DNON')
        IDNONM(2) = BCDF('AM  ')
        FIRST=.FALSE.
      ENDIF
C
      IWORD(1)=IDNONM(1)
      IWORD(2)=IDNONM(2)
      RETURN
      END
**** SOURCE FILE : FCONV000.ORG   ***
*
*
*  *  FCONV  *    VAX11  FORTRAN VERSION 8.6.82  E.MCLELLAN
*
*                          IMPROVED      25.06.82  E.MCLELLAN
*                          MODIFIED      16.07.85  E.MCLELLAN
*
*  PURPOSE     TO CONVERT FLOATING POINT NUMBERS TO ALPHAMERIC
*              REPRESENTATION
*  CALLING SEQUENCE
*              CALL FCONV(F,A,N,I,J)
*  ARGUMENTS
*              F   DOUBLE PRECISION NUMBER TO BE CONVERTED
*              A   CHARACTER STRING TO CONTAIN THE CHARACTERS
*              N   INTEGER INDICATING THE STARTING BYTE POSITION
*                  FROM THE LEFT, TO STORE THE CHARACTERS IN A
*              I   NUMBER OF CHARCTERS DESIRED
*              J   NUMBER OF FRACTIONAL DIGITS REQUIRED
*
      SUBROUTINE FCONV(F,A,N,I,J)
C
      DOUBLE PRECISION F,DLSD,TENTOJ,FJ
      CHARACTER*(*) A
      CHARACTER*35 INFIL
C
C.... CHECK SIZE OF VALUE F
C
      IF ((F.LT.-2.**31).OR.(F.GT.(2.**31-1)).OR.
     1  (F.LE.-10.**(I-J-2)).OR.(F.GE.10.**(I-J-1))) THEN
C.... FOR LARGE NUMBERS AND VALUES WHICH WOULD OVERFLOW
C     REQUESTED FIELD - OUTPUT IN D FORMAT
C
        WRITE (INFIL,'(D35.15)') F
        K=14
        IF (INFIL(K:K).EQ.' ') K=15
C.... STORE MANTISSA TO MAX NO OF SIGNIFICANT FIGS FOR FIELD
        I1=N
        I2=N+I-5
        K1=K+I-5
        A(I1:I2)=INFIL(K:K1)
C.... NOW ADD EXPONENT
        I1=I2+1
        I2=I2+4
        A(I1:I2)=INFIL(32:35)
C
      ELSE
C
C.... NORMAL ROUTE
C
C.... ROUND F TO J DECIMAL PLACES
      TENTOJ=10.D0**J
      MSD=INT(F)
      DLSD=F-DFLOAT(MSD)
      LSD=INT(DLSD*TENTOJ+DSIGN(0.5D0,F))
      FJ=DFLOAT(MSD)+DFLOAT(LSD)/TENTOJ
      WRITE (INFIL,'(F35.10)') FJ
      DO 10 K=1,35
      IF (INFIL(K:K).NE.' ') GOTO 20
   10 CONTINUE
      K=35
C
   20 L=25-K+1+J
C
      I2=N+I-1
      I1=I2-L+1
      K1=25+J
      A(I1:I2)=INFIL(K:K1)
C
      ENDIF
C
      RETURN
      END
**** SOURCE FILE : FREAD000.ORG   ***
*
*
*  *  FREAD  *                  18.6.86   E.MCLELLAN
*
*
*  PURPOSE     TO READ A RECORD CONTAINING CHARACTER DATA
*              FROM A SPECIFIED FILE, CONVERT EACH 12 BYTE ITEM
*              INTO A DOUBLE PRECISION FLOATING POINT NUMBER
*
*  CALLING SEQUENCE
*              CALL FREAD (NO,IRECNO,DATA,ISIZE,IRET)
*  ARGUMENTS
*              NO        FILE NUMBER
*              IRECNO    RECORD NO. IF SET TO ZERO RETRIEVES
*                        THE NEXT RECORD. IF SET TO 'N'
*                        RETRIEVES N-TH RECORD DIRECTLY.
*              DATA      DATA ARRAY TO CONTAIN THE RETRIEVED
*                        RECORD (DOUBLE PRECISION)
*              ISIZE     SIZE OF RECORD (IN DOUBLE PRECISION WORDS)
*              IRET      RETURN FLAG =0  NO ERROR
*                                    =1  E.O.F ENCOUNTERED
*                                    =2  ISIZE IS BIGGER THAN ACTUAL
*                                        RECORD SIZE. DATA ASSUMED TO
*                                        SPAN MORE THAN ONE RECORD
*                                        DATA TRANSFERRED TO ARRAY
*                                    =3  UNRECOVERABLE ERROR
*
*
*  GLOBAL VARIABLES:  NONE
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   FILNAM          FILTAB    CHARACTER  FILE NAME
*   FILACC          FILTAB    CHARACTER  FILE ACCESS
*                                         (DIRECT OR SEQUENTIAL)
*   FILFMT          FILTAB    CHARACTER  FILE FORMAT
*                                         (FORMATTED OR UNFORMATTED)
*   OPSTAT          FILTAB    CHARACTER  OPEN STATUS
*                                         (UNKNOWN,SCRATCH,NEW,OLD)
*   CLSTAT          FILTAB    CHARACTER  CLOSE STATUS (KEEP,DELETE)
*   U               IFILTB    INTEGER    UNIT NUMBER
*   RL              IFILTB    INTEGER    RECORD LENGTH
*   NXTREC          IFILTB    INTEGER    NUMBER OF NEXT RECORD TO BE
*                                        READ OR WRITTEN (DIRECT ACCESS)
*   LSTREC          IFILTB    INTEGER    NUMBER OF LAST RECORD ON FILE
*                                         (DIRECT ACCESS)
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*         OD        LOGICAL    FLAG TO INDICATE IF FILE IS OPEN
*         CDATA     CHARACTER  CHARACTER VARIABLE INTO WHICH RECORD
*                              IS INITIALLY READ
*         IACC      CHARACTER  ACCESS TYPE RETURN BY INQUIRE
*         DARRAY    CHARACTER  PRINT BUFFER
*         IRECL     INTEGER    RECORD LENGTH
*         NUM       INTEGER    NUMBER OF COMPLETE PHYSICAL RECORDS
*                              SPANNED BY LOGICAL RECORD BEING READ
*         POSN      INTEGER    START POSITION IN PRINT BUFFER
*         SLEN      INTEGER    LENGTH OF STRING ENTERED IN PRINT BUFFER
*
*  FILES:  FILE REFERENCED BY FILE NUMBER
*
*  SUBSIDIARIES:
*               FILOPN
*               CFORM
*               ICONV
*               CPRINT
*
      SUBROUTINE FREAD (NO,IRECNO,DATA,ISIZE,IRET)
C
      INCLUDE (FILTAB)    
C
      INTEGER NO,IRECNO,ISIZE,IRET
      DOUBLE PRECISION DATA(ISIZE)
      LOGICAL OD
      CHARACTER*12 CDATA(3000)
      CHARACTER*12 IACC
      CHARACTER*80 DARRAY
      INTEGER POSN,SLEN
      DATA DARRAY/' '/
C
      ID=U(NO)
C
C---- IS UNIT OPENED, IF NOT OPEN
      INQUIRE (UNIT=ID,OPENED=OD)
      IF (OD) GOTO 10
C---- OPEN UNIT
      CALL FILOPN(NO)
C---- CHECK FILE ACCESS
   10 INQUIRE (UNIT=ID,ACCESS=IACC)
      IF (IACC.EQ.'DIRECT') THEN
C---- DIRECT ACCESS FILE
      IRECL=RL(NO)
        IF (IRECNO.EQ.0) THEN
          IRECNO=NXTREC(NO)
        END IF
        IF (IRECNO.GT.LSTREC(NO)) THEN
          IRET=1
          RETURN
        END IF
        IREC=IRECNO
        IF (ISIZE*12.LE.IRECL) THEN
          READ (ID,REC=IREC,IOSTAT=IRET,ERR=90) (CDATA(I),I=1,ISIZE)
          CALL ABCDBN(CDATA,DATA,ISIZE)
        ELSE
          NUM=(ISIZE*12)/IRECL
          DO 20 J=1,NUM
            I2=IRECL/12
            READ (ID,REC=IREC,IOSTAT=IRET,ERR=90) (CDATA(I),I=1,I2)
            I1=(J-1)*I2+1
            CALL ABCDBN(CDATA,DATA(I1),I2)
            IREC=IREC+1
   20     CONTINUE
          IF ((ISIZE*12-NUM*IRECL).GT.0) THEN
            I2=ISIZE-NUM*IRECL/12
            READ (ID,REC=IREC,IOSTAT=IRET,ERR=90) (CDATA(I),I=1,I2)
            I1=ISIZE-I2+1
            CALL ABCDBN(CDATA,DATA(I1),I2)
          ELSE
            IREC=IREC-1
          END IF
          IRET=2
        END IF
        NXTREC(NO)=IREC+1
      ELSE
C---- SEQUENTIAL ACCESS FILE
        READ (ID,END=80) (CDATA(I),I=1,ISIZE)
        CALL ABCDBN(CDATA,DATA,ISIZE)
      ENDIF
      RETURN
 80   IRET=1
      RETURN
 90   SLEN=0
      CALL CFORM (' *** ERROR READING BY FREAD FROM FILE :',
     1            DARRAY,2,SLEN)
      POSN=SLEN+3
      SLEN=0
      CALL CFORM (FILNAM(NO),DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+2
      SLEN=0
      CALL CFORM ('RECNO:',DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+1
      SLEN=6
      CALL ICONV (IRECNO,DARRAY,POSN,SLEN)
      CALL CPRINT (DARRAY)
      IRET=3
      RETURN
      END
**** SOURCE FILE : HEX00000.ORG   ***
*
*
*  * HEX *  FORTRAN 77 CHARACTER FUNCTION   6.11.85  E.MCLELLAN
*
*  PURPOSE:  TO CONVERT AN INTEGER VALUE TO A CHARACTER STRING
*            REPRESENTING THE EQUIVALENT HEXADECIMAL NUMBER
*
*  CALLING SEQUENCE:
*                   STRING=HEX(VALUE)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*       VALUE       INTEGER    INTEGER VALUE TO BE CONVERTED
*                              TO HEX CHARACTER STRING
*
*  GLOBAL VARIABLES:  NONE
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*       DIV         INTEGER    DIVISORS FOR EACH HALF BYTE
*                              POSITION (POWERS OF 16)
*       J           INTEGER    INTEGRAL QUOTIENT
*       V           INTEGER    DIVIDEND
*       H           CHARACTER  HEX CHARACTERS (0-F)
*
*  FILES:  NONE
*
*  SUBSIDIARIES:  NONE
*
      CHARACTER*8 FUNCTION HEX(VALUE)
C
      INTEGER VALUE,DIV(7),J,V
      CHARACTER H(0:15)
C
      DATA DIV / 268435456, 16777216, 1048576,
     1           65536,  4096,  256,   16    /
C
      DATA H / '0','1','2','3','4','5','6','7',
     1         '8','9','A','B','C','D','E','F'/
C
      V=VALUE
      DO 10 I=1,7
        J=V/DIV(I)
        V=V-J*DIV(I)
        HEX(I:I)=H(J)
  10  CONTINUE
      HEX(8:8)=H(V)
C
      RETURN
      END
**** SOURCE FILE : HOLFRM00.W01   ***
*
*
*  * HOLFRM *  FORTRAN 77 SUBROUTINE  16.7.86  E.MCLELLAN
*                MODIFIED                 2-FEB-1988  E.MCLELLAN
*
*  PURPOSE:  TO INSERT SPECIFIED NUMBER OF CHARACTERS IN BCDF FORM
*            FROM INTEGER ARRAY INTO CHARACTER VARIABLE
*            STARTING FROM SPECIFIED LOCATION - RETURNING THE NUMBER
*            OF INTEGER WORDS OCCUPIED
*
*  CALLING SEQUENCE:
*                   CALL HOLFRM(IARR,STR,IST,NCHR,NWD)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*       IARR        INTEGER    ARRAY CONTAINING BCDF CHARACTERS
*       STR         CHARACTER  STRING INTO WHICH CHARACTERS ARE
*                              TO BE LOADED
*       IST         INTEGER    START LOCATION IN STR
*       NCHR        INTEGER    NUMBER OF CHARACTERS TO BE INSERTED
*       NWD         INTEGER    NUMBER OF WORDS OCCUPIED
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*     IWRD          SDP       INTEGER    NO OF BYTES PER WORD
*     NBCHAR        SDP       INTEGER    NO OF BITS PER BYTE
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*     IVAL          INTEGER    VALUE OF INTEGER WORD
*     JVAL          INTEGER    INDEX OF CHARACTER IN CONCATINATION
*                              SEQUENCE
*
*  FILES:  NONE
*
*  SUBSIDIARIES:  NONE
*
      SUBROUTINE HOLFRM(IARR,STR,IST,NCHR,NWD)
C
C.... SYSTEM DEPENDENT PARAMETERS
C
      INCLUDE (SDP)    
C
      INTEGER IARR(*),IST,NCHR,NWD,IVAL,JVAL,SLEN
C
      CHARACTER*(*) STR
C
      SLEN=LEN(STR)
      NWD=NCHR/IWRD
      IF (NCHR.GT.NWD*IWRD) NWD=NWD+1
      DO 20 I=1,NWD
        IVAL=IARR(I)
        K1=IST+I*IWRD
        DO 10 J=IWRD,1,-1
          K=K1-J
          JJ=NBCHAR*(J-1)
          JVAL=ISHFT(IVAL,-JJ)
          IF (K.LE.SLEN) THEN
            STR(K:K)=CHAR(JVAL)
          ENDIF
          IVAL=(IVAL-ISHFT(JVAL,JJ))
  10    CONTINUE
  20  CONTINUE
C
      RETURN
      END
**** SOURCE FILE : ICONV000.ORG   ***
*
*
*  *  ICONV  *    VAX11 FORTRAN VERSION   8.4.81   E.MCLELLAN
*
*                              MODIFEED  25.06.82  E.MCLELLAN
*                              MODIFIED  16.07.85  E.MCLELLAN
*                              MODIFIED  07.07.86  E.MCLELLAN
*
*  PURPOSE     TO CONVERT INTEGERS TO ALPHAMERIC REPRESENTATAION
*
*  CALLING SEQUENCE
*              CALL ICONV(I,A,N,K)
*  ARGUMENTS
*              I   INTEGER VALUE TO BE CONVERTED TO CHARACTER
*              A   CHARACTER STRING TO CONTAIN THE CONVERTED INTEGER
*              N   INTEGER INDICATING THE START BYTE POSITION TO
*                  STORE THE CHARACTERS IN A
*              K   INTEGER INDICATING TOTAL NUMBER OF CHARACTERS
*                  DESIRED
*
      SUBROUTINE ICONV(I,A,N,K)
C
      CHARACTER*(*) A
      CHARACTER*11 INTFIL
      WRITE (INTFIL,'(I11)') I
      DO 10 J=1,11
      IF (INTFIL(J:J).NE.' ') GOTO 20
   10 CONTINUE
      J=11
C
   20 L=12-J
      IF (L.GT.K) GOTO 30
C
      I2=N+K-1
      I1=I2-L+1
      A(I1:I2)=INTFIL(J:11)
      GO TO 99
C---- OVERFLOW
   30 I1=N
      DO 35 J=1,K
      A(I1:I1)='*'
   35 I1=I1+1
C
   99 CONTINUE
      RETURN
      END
**** SOURCE FILE : OUTMSG.ORG   ***
*
*
*  * OUTMSG *  FORTRAN 77 SUBROUTINE  1.12.88  E.MCLELLAN
*
*  PURPOSE:  TO PRINT MESSAGE ON THE VLFILE
*
*  CALLING SEQUENCE:
*                   CALL OUTMSG(STR)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*      STR          CHARACTER  CHARACTER STRING TO BE PRINTED
*                              MAY BE LITERAL OR A STRING VARIABLE
*  GLOBAL VARIABLES:
*           BLOCK   TYPE       DESCRIPTION
*   VLFILE  SYMFIL  INTEGER    UNIT NUMBER FOR SYSTEM OUTPUT DEVICE
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*        SLEN       INTEGER    LENGTH OF STRING TO BE PRINTED
*        F1         CHARACTER  INTERNAL FILE FOR INTEGER TO CHARACTER
*                              CONVERSION
*        FORM       CHARACTER  OUTPUT FORMAT
*
*  FILES:
*        VLFILE     SYSTEM OUTPUT DEVICE
*
*  SUBSIDIARIES:  NONE
*
      SUBROUTINE OUTMSG(STR)
C
      CHARACTER STR*(*),F1*3,FORM*9
      INTEGER SLEN
C
      INCLUDE (SYMFIL)    
C
      SLEN=LEN(STR)
C
C.... SET UP FORMAT AND PRINT
C
      WRITE (F1,'(I3)') SLEN
      FORM='(1X,A'//F1//')'
      WRITE (VLFILE,FORM) STR
C
      END
**** SOURCE FILE : SHIFT000.ORG   ***
*
      SUBROUTINE SHIFT(WORD,JCHAR)
*
*  *  SHIFT  *  VAX11 VERSION   4.10.85    E.MCLELLAN
*
*  PURPOSE     TO APPEND A SINGLE CHARACTER 'JCHAR' TO THE CHARACTER
*              STRING BEING SET UP IN 'WORD' TO FORM A LEFT-JUSTIFIED
*              'NAME' IN 'WORD'
*
*  CALLING SEQUENCE
*              CALL SHIFT(WORD,JCHAR)
*  ARGUMENTS   WORD   CHARACTER STRING IN WHICH A 'NAME'
*                     IS BEING BUILT UP
*              JCHAR  CONTAINS THE NEXT CHARACTER (LEFT JUSTIFIED)
*                     TO BE PLACED IN WORD
*
      CHARACTER*6 WORD,JCHAR,TEMP
C
      J=INDEX(WORD(1:),' ')
      IF(J.NE.0) THEN
       WORD(J:J)=JCHAR(1:1)
      ELSE
C  LEFT SHIFT CONTENTS OF WORD AND APPEND CHARACTER
       TEMP=WORD(2:6)//JCHAR(1:1)
       WORD=TEMP
      ENDIF
      RETURN
      END
**** SOURCE FILE : SPRINT00.V02   ***
*
*
*  * SPRINT *  FORTRAN 77 SUBROUTINE  3.12.85  E.MCLELLAN
*
*  PURPOSE:  PRINT CHARACTER STRING ON (VLFILE) SYSTEM OUTPUT DEVICE
*
*  CALLING SEQUENCE:
*                   CALL SPRINT(BUFFER)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*      BUFFER       CHARACTER  CHARACTER STRING TO BE PRINTED
*
*  GLOBAL VARIABLES:
*           BLOCK   TYPE       DESCRIPTION
*   VLFILE  SYMFIL  INTEGER    UNIT NUMBER FOR SYSTEM OUTPUT DEVICE
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*        SLEN       INTEGER    LENGTH OF STRING TO BE PRINTED
*        F1         CHARACTER  INTERNAL FILE FOR INTEGER TO CHARACTER
*                              CONVERSION
*        FORM       CHARACTER  OUTPUT FORMAT
*
*  FILES:
*        VLFILE     SYSTEM OUTPUT DEVICE
*
*  SUBSIDIARIES:  NONE
*
      SUBROUTINE SPRINT(BUFFER)
C
      CHARACTER BUFFER*(*),F1*3,FORM*6
      INTEGER SLEN
C
      INCLUDE (SYMFIL)    
C
      SLEN=LEN(BUFFER)
C.....OMIT TRAILING BLANKS
      DO 10 I=SLEN,1,-1
        IF (BUFFER(I:I).NE.' ') THEN
          SLEN=I
          GOTO 20
        ENDIF
  10  CONTINUE
        SLEN=1
  20  CONTINUE
      IF (BUFFER(1:1).EQ.'C') THEN
         CLOSE (VLFILE,STATUS='KEEP')
      ELSE
         WRITE (F1,'(I3)') SLEN
         FORM='(A'//F1//')'
         WRITE (VLFILE,FORM) BUFFER
      ENDIF
C
      BUFFER=' '
C
      RETURN
      END
**** SOURCE FILE : STRTSH00.V01   ***
*
*
*  * STRTSH *    FORTRAN 77 SUBROUTINE   15-JUL-1986  E.MCLELLAN
*                MODIFIED                 3-FEB-1988  E.MCLELLAN
*
*   PURPOSE:  TO RETURN THE BCD EQUIVALENT OF '*',NULL,'TRASH',NULL
*             IN THE FIRST 8 BYTES OF THE ARGUMENT
*             (NOTE: THIS SHOULD GIVE A NONE VALID D.P. NUMBER
*                    ON MOST SYSTEMS)
*
*   CALLING SEQUENCE:
*                    CALL STRTSH(IWORD)
*
*   ARGUMENTS:
*         IWORD  INTEGER  ARRAY INTO WHICH '* TRASH ' IS TO BE LOADED
*
*   GLOBAL VARIABLES:
*
*----------------------------------------------------
*   VARIABLE    BLOCK    TYPE        DESCRIPTION
*----------------------------------------------------
*   NBCHAR      SDP      INTEGER     NO OF BITS PER BYTE
*
*   LOCAL VARIABLES:
*                   TYPE        DESCRIPTION
*         ITRASH    INTEGER     INTEGER ARRAY TO BUILD UP BCDF
*         FIRST     LOGICAL     FLAG INDICATING FIRST CALL
*
*   SUBSIDIARIES:  NONE
*
      SUBROUTINE STRTSH(IWORD)
C
      INCLUDE (SDP)    
C
      INTEGER ITRASH(2),IWORD(2)
      LOGICAL FIRST
      SAVE ITRASH,FIRST
      DATA FIRST/.TRUE./
      IF (FIRST) THEN
        I3=3*NBCHAR
        I2=2*NBCHAR
        ITRASH(1) = ISHFT(ICHAR('*'),I3)
     +            + ISHFT(ICHAR('T'),NBCHAR)
     +            + ICHAR('R')
        ITRASH(2) = ISHFT(ICHAR('A'),I3)
     +            + ISHFT(ICHAR('S'),I2)
     +            + ISHFT(ICHAR('H'),NBCHAR)
        FIRST=.FALSE.
      ENDIF
C
      IWORD(1)=ITRASH(1)
      IWORD(2)=ITRASH(2)
      RETURN
      END
**** SOURCE FILE : TAPOP000.ORG   ***
*
*
*  *  TAPOP  *   VAX11 VERSION    11.5.82   E.MCLELLAN
*                MODIFIED         18.07.85  E.MCLELLAN
*
*  PURPOSE     TO PERFORM I/O FILE HANDLING OPERATIONS
*
*  CALLING SEQUENCE
*              CALL TAPOP (NO,N)
*  ARGUMENTS
*              NO        FORTRAN NUMBER
*              N  =-1    REWIND FILE BEFORE WRITING NEW FILE
*                 =-2    REWIND FILE BEFORE READING OLD FILE
*                 =-3    CLOSE FILE
*                 =-4    REWIND FILE
*                 =-5    GET THE NO. OF THE NEXT RECORD
*
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   FILNAM          FILTAB    CHARACTER  FILE NAME
*   FILACC          FILTAB    CHARACTER  FILE ACCESS
*                                         (DIRECT OR SEQUENTIAL)
*   FILFMT          FILTAB    CHARACTER  FILE FORMAT
*                                         (FORMATTED OR UNFORMATTED)
*   OPSTAT          FILTAB    CHARACTER  OPEN STATUS
*                                         (UNKNOWN,SCRATCH,NEW,OLD)
*   CLSTAT          FILTAB    CHARACTER  CLOSE STATUS (KEEP,DELETE)
*   U               IFILTB    INTEGER    UNIT NUMBER
*   RL              IFILTB    INTEGER    RECORD LENGTH
*   NXTREC          IFILTB    INTEGER    NUMBER OF NEXT RECORD TO BE
*                                        READ OR WRITTEN (DIRECT ACCESS)
*   LSTREC          IFILTB    INTEGER    NUMBER OF LAST RECORD ON FILE
*                                         (DIERECT ACCESS)
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*        IACC       CHARACTER  FILE ACCESS RETURNED BY INQUIRE
*        DARRAY     CHARACTER  PRINT BUFFER
*        POSN       INTEGER    START POSTION IN PRINT BUFFER
*        SLEN       INTEGER    LENGTH OF STRING ENTERED IN BUFFER
*
*  FILES:  FILE REFERENCED BY FILE NUMBER
*
*  SUBSIDIARIES:
*               FILOPN
*               CFORM
*               CPRINT
*
      SUBROUTINE TAPOP (NO,N)
C
      INCLUDE (FILTAB)    
      CHARACTER*12 IACC
      CHARACTER DARRAY*80
      INTEGER POSN,SLEN
      DATA DARRAY/' '/
      ID=U(NO)
C
      IF (N.EQ.-1) THEN
C---- CLOSE FILE
        CLOSE (UNIT=ID,ERR=91,STATUS=CLSTAT(NO))
C---- OPEN FILE
      CALL FILOPN(NO)
      NXTREC(NO)=1
      LSTREC(NO)=0
C
        ELSE IF (N.EQ.-2) THEN
          INQUIRE (UNIT=ID,ACCESS=IACC)
          IF (IACC.EQ.'DIRECT') THEN
            NXTREC(NO)=1
          ELSE
            REWIND (UNIT=ID)
          END IF
        ELSE IF (N.EQ.-3) THEN
C---- CLOSE FILE
          CLOSE (UNIT=ID,ERR=91,STATUS=CLSTAT(NO))
        ELSE IF (N.EQ.-4) THEN
          INQUIRE (UNIT=ID,ACCESS=IACC)
          IF (IACC.EQ.'DIRECT') THEN
            NXTREC(NO)=1
          ELSE
            REWIND (UNIT=ID)
          END IF
        ELSE IF (N.EQ.-5) THEN
            N=LSTREC(NO)+1
      ENDIF
      RETURN
 90   SLEN=0
      CALL CFORM (' *** ERROR OPENING FILE :',DARRAY,2,SLEN)
      POSN=SLEN+3
      SLEN=0
      CALL CFORM (FILNAM(NO),DARRAY,POSN,SLEN)
      POSN=POSN+SLEN+4
      SLEN=0
      CALL CFORM ('*** FROM ROUTINE: TAPOP',DARRAY,POSN,SLEN)
      CALL CPRINT (DARRAY)
      CALL ABNEND
 91   CALL CFORM (' *** ERROR CLOSING FORTRAN UNIT NO:',DARRAY,2,35)
      CALL ICONV (U(NO),DARRAY,37,2)
      CALL CFORM ('*** FROM ROUTINE: TAPOP',DARRAY,40,23)
      CALL CPRINT (DARRAY)
      RETURN
      END
**** SOURCE FILE : TRASH000.V01   ***
*
*
*  * TRASH *    FORTRAN 77 SUBROUTINE   15-JUL-1986  E.MCLELLAN
*                MODIFIED                 3-FEB-1988  E.MCLELLAN
*
*   PURPOSE:  TO RETURN THE BCD EQUIVALENT OF '$',NULL,'TRASH',NULL
*             IN THE FIRST 8 BYTES OF THE ARGUMENT
*             (NOTE: THIS SHOULD GIVE A NONE VALID D.P. NUMBER
*                    ON MOST SYSTEMS)
*
*   CALLING SEQUENCE:
*                    CALL TRASH(IWORD)
*
*   ARGUMENTS:
*         IWORD  INTEGER  ARRAY INTO WHICH '$ TRASH ' IS TO BE LOADED
*
*   GLOBAL VARIABLES:
*
*----------------------------------------------------
*   VARIABLE    BLOCK    TYPE        DESCRIPTION
*----------------------------------------------------
*   NBCHAR      SDP      INTEGER     NO OF BITS PER BYTE
*
*   LOCAL VARIABLES:
*                   TYPE        DESCRIPTION
*         ITRASH    INTEGER     INTEGER ARRAY TO BUILD UP BCDF
*         FIRST     LOGICAL     FLAG INDICATING FIRST CALL
*
*   SUBSIDIARIES:  NONE
*
      SUBROUTINE TRASH(IWORD)
C
      INCLUDE (SDP)    
C
      INTEGER ITRASH(2),IWORD(2)
      LOGICAL FIRST
      SAVE ITRASH,FIRST
      DATA FIRST/.TRUE./
      IF (FIRST) THEN
        I3=3*NBCHAR
        I2=2*NBCHAR
        ITRASH(1) = ISHFT(ICHAR('$'),I3)
     +            + ISHFT(ICHAR('T'),NBCHAR)
     +            + ICHAR('R')
        ITRASH(2) = ISHFT(ICHAR('A'),I3)
     +            + ISHFT(ICHAR('S'),I2)
     +            + ISHFT(ICHAR('H'),NBCHAR)
        FIRST=.FALSE.
      ENDIF
C
      IWORD(1)=ITRASH(1)
      IWORD(2)=ITRASH(2)
      RETURN
      END
**** SOURCE FILE : ABUFTP00.V01   ***
*
      SUBROUTINE ABUFTP(NO,N)
*
*  *  ABUFTP  *  VAX-11 VERSION   08.07.82  E.MCLELLAN
*
*  PURPOSE     TO PROVIDE FILE HANDLING  CAPABILITY
*              COMPATABLE  WITH APT 111 POST PROCESSOR USAGE
*
*  CALLING SEQUENCE
*              CALL ABUFTP(NO,N)
*  ARGUMENTS
*              NO    FILE NUMBER
*                    FOR NC 360 HELD IN SECOND HALF
*                    OF REAL*8 WORD
*              N=1   OPEN FILE IN WRITE MODE
*               =2   OPEN FILE IN READ MODE
*               =3   REWIND FILE
*               =9   CLOSE FILE
*
*  ALTERNATIVE ENTRY
*              CALL BUFFTP(NO,N)
*
      INCLUDE (FILTAB)    
*
      INTEGER NO(2)
      LOGICAL OD
C
      INCLUDE (DARRAY)    
C
*
      ENTRY BUFFTP(NO,N)
C
C
      IFIL=NO(1)
      IF (NO(1).EQ.0) IFIL=NO(2)
C
      IF ((IFIL.LT.1).OR.(IFIL.GT.50)) THEN
         CALL CFORM(' *** FILE NUMBER OUTSIDE RANGE 1-50',DARRAY,2,35)
         CALL CFORM(' REQUESTED IN CALL TO ABUFTP OR BUFFTP ***',DARRAY
     1              ,37,42)
         CALL CPRINT(DARRAY)
         CALL ABNEND
      ELSE
         ID=U(IFIL)
C
        IF (N.EQ.1) THEN
C....    OPEN FILE IN WRITE MODE
C
       INQUIRE (UNIT=ID,OPENED=OD)
       IF (OD) THEN
       RETURN
       ELSE
         CALL FILOPN(IFIL)
       END IF
C
        ELSE IF (N.EQ.2) THEN
C
C.....   OPEN FILE IN READ MODE
C
        INQUIRE (UNIT=ID,OPENED=OD)
        IF (OD) THEN
        RETURN
        ELSE
         CALL FILOPN(IFIL)
        END IF
C
        ELSE IF (N.EQ.3) THEN
C
C.....   REWIND FILE
C
         CALL TAPOP(IFIL,-4)
C
        ELSE IF (N.EQ.9) THEN
C
C.....   CLOSE FILE
C
         CALL TAPOP(IFIL,-3)
C
        ELSE
C
C.....   INVALID ARGUMENT
C
        CALL CFORM(' *** INVALID ARGUMENT IN CALL TO ABUFTP(BUFFTP) ***'
     1              ,DARRAY,2,51)
        CALL CPRINT(DARRAY)
        CALL ABNEND
C
        END IF
      END IF
      RETURN
      END
**** SOURCE FILE : ASERCH00.V01   ***
*
      SUBROUTINE ASERCH(NO,IRECNO,IRET)
*
*  * ASERCH *  VAX-11 FORTRAN 77 VERSION   13.10.82  E.MCLELLAN
*
*  PURPOSE     TO POSITION A FILE TO START OF REQUIRED RECORD
*
*  CALLING SEQUENCE
*              CALL ASERCH(NO,IRECNO,IRET)
*  ARGUMENTS
*              NO         FILE NUMBER
*              IRECNO     REQUIRED RECORD
*              IRET.LT.0  NORMAL RETURN
*                  .EQ.0  ZERO OR NEGATIVE RECORD NUMBER
*                  .EQ.2  ABNORMAL CONDITION RETURNED BY ATAPRD
*                  .EQ.3  ERROR BACKSPACING FILE
*                  .EQ.4  ERROR REWINDING FILE
*
*  ALTERNATE ENTRY    ****    COMMENTED OUTT   ****
*              CALL SEARCH(NO,IRECNO,IRET)
*
      INTEGER NO(2)
C
      DOUBLE PRECISION REC(256)
      DIMENSION IREC(3)
C
C      ENTRY SEARCH(NO,IRECNO,IRET)
C
C.....CHECK VALUE IN IRECNO - MUST BE GT ZERO
      IF (IRECNO.LE.0) THEN
         IRET=0
         RETURN
      ELSE
         IREW=0
C
C.....READ NEXT RECORD FROM FILE
   10 CALL ATAPRD(NO,IRET,NWDS,2,IREC,3,REC,0)
           IF (IRET.LT.0) THEN
C.....IS THIS THE RECORD BEFORE THE REQUIRED RECORD
              IF (IREC(1).EQ.IRECNO-1) THEN
C.....YES SO NEXT RECORD WILL BE THE REQUIRED RECORD
                 RETURN
C.....NO IS NEXT RECORD LT REQUIRED RECORD - READ NEXT RECORD
              ELSE IF (IREC(1)+1.LT.IRECNO) THEN
C.....YES
                 GO TO 10
C.....N0  IS REQUIRED RECORD NEARER START OF FILE OR CURRENT RECORD
              ELSE IF (IRECNO.GT.IREC(1)/2) THEN
C.....NEARER CURRENT RECORD - BACKSPACE N TIMES BY CALLING ATAPOP
                 N=IREC(1)-IRECNO+1
                 DO 20 I=1,N
                 CALL ATAPOP(NO,3,IRET)
                      IF (IRET.GT.0) THEN
                         IRET=3
                         RETURN
                      END IF
   20            CONTINUE
                 RETURN
C.....NEARER START - REWIND AND SEARCH
              ELSE
                 CALL ATAPOP(NO,1,IRET)
                      IF (IRET.GT.0) THEN
                         IRET=4
                         RETURN
                      ELSE
                         GO TO 10
                      END IF
              END IF
C.....NON NORMAL RETURN FROM ATAPRD
         ELSE IF (IRET.EQ.0) THEN
C.....EOF ENCOUNTERED
             IF (IREW.EQ.1) THEN
                IRET=0
                RETURN
             ELSE
C.....REWIND FILE
            CALL ATAPOP(NO,1,IRET)
                 IF (IRET.GT.0) THEN
                    IRET=4
                    RETURN
                 ELSE
                    IREW=1
                    GO TO 10
                 END IF
             END IF
         ELSE
C.....ABNORMAL CONDITION RETURNED BY ATAPRD
            IRET=2
            RETURN
         END IF
      END IF
      RETURN
      END
**** SOURCE FILE : ATAPOP00.ORG   ***
*
      SUBROUTINE ATAPOP(NO,N,IRET)
*
*  *  ATAPOP  *  VAX-11 VERSION   13.07.82  E.MCLELLAN
*
*  PURPOSE     TO PROVIDE FILE POSITIONING CAPABILITY
*              COMPATABLE WITH APT 111 POST PROCESSOR USAGE
*
*  CALLING SEQUENCE
*              CALL ATAPOP(NO,N,IRET)
*  ARGUMENTS
*              NO         FILE NUMBER
*                         FOR NC 360 HELD IN SECOND HALF
*                         OF DOUBLE PRECISION WORD
*              N=1        REWIND FILE
*               =2        WRITE END OF FILE (CLOSE FILE)
*               =3        BACKSPACE RECORD
*              IRET.GT.0  ABNORMAL ERROR CONDITION
*                  .LT.0  OPERATION SUCCESSFUL
*
*  ALTERNATE ENTRY
*              CALL TAPEOP(NO,N,IRET)
*
C
      INCLUDE (FILTAB)    
C
      CHARACTER*12 IACC
C
      INTEGER NO(2)
C
      INCLUDE (DARRAY)    
C
      ENTRY TAPEOP(NO,N,IRET)
C
      IRET=-1
C
      IFIL=NO(1)
      IF (NO(1).EQ.0)  IFIL=NO(2)
      IF ((IFIL.LT.1).OR.(IFIL.GT.50)) THEN
        CALL CFORM('0 *** FILE NUMBER OUTSIDE RANGE 1-50',DARRAY,1,36)
        CALL CFORM(' REQUESTED IN CALL TO ATAPOP OR TAPEOP ***',DARRAY,
     1                37,42)
        CALL CPRINT(DARRAY)
        IRET=1
      ELSE
C
       IF (N.EQ.1) THEN
C.....REWIND
          CALL TAPOP(IFIL,-2)
       ELSE IF (N.EQ.2) THEN
C.....CLOSE FILE
          CALL TAPOP(IFIL,-3)
       ELSE IF (N.EQ.3) THEN
C.....BACKSPACE ONE RECORD
          ID=U(IFIL)
          INQUIRE(UNIT=ID,ACCESS=IACC)
             IF (IACC.EQ.'DIRECT') THEN
C.....DECREASE NO OF NEXT RECORD TO BE READ BY 1
                NXTREC(IFIL)=NXTREC(IFIL)-1
             ELSE
                BACKSPACE(UNIT=ID)
             END IF
C
        ELSE
        CALL CFORM(' *** INVALID ARGUMENT IN CALL TO ATAPOP(TAPEOP) ***'
     1              ,2,51)
        CALL CPRINT(DARRAY)
        END IF
        IRET=1
      END IF
      RETURN
      END
**** SOURCE FILE : ATAPXC00.ORG   ***
*
      SUBROUTINE ATAPXC(FILE1,FILE2)
*
*  * ATAPXC *  VAX11 FORTRAN 77 VERSION  27.8.82 E.MCLELLAN
*
*  PURPOSE     TO INTERCHANGE TWO FILES
*
*  CALLING SEQUENCE
*              CALL ATAPXC(FILE1,FILE2)
*
*  ARGUMENTS
*              FILE1  FILE NUMBER OF FIRST FILE
*              FILE2  FILE NUMBER OF SECOND FILE
*  ALTERNATE ENTRY
*              CALL TAPECH(FILE1,FILE2)
*
      ENTRY TAPECH(FILE1,FILE2)
      INTEGER FILE1,FILE2
C
      I=FILE1
      FILE1=FILE2
      FILE2=I
      RETURN
      END
**** SOURCE FILE : CARDPN00.V01   ***
*
      SUBROUTINE CARDPN(A,N,M,I,D)
*
*  * CARDPN *   VAX-11 FORTRAN 77 VERSION   15.10.82  E.MCLELLAN
*
*  PURPOSE      WRITE AN ASCII FILE , PNCHFL
*
*  CALLING SEQUENCE
*               CALL CARDPN(A,N,M,I,D)
*  ARGUMENTS
*              A   LOCATION OF FIRST WORD TO BE PUNCHED
*              N   NO OF 4 BYTE WORDS TO BE PUNCHED,NORMALLY 18,
*                  IF GREATER NO, ID AND SEQUENCE NO WILL BE PUNCHED
*              M   MODE IGNORED BY THIS VERSION OF ROUTINE
*             I   4 BYTE SEQUENCE NO TO BE PUNCHED IN COL 77-80
*                 TREATED AS MODULO 10,000
*             D   LOCATION OF A 4 BYTE IDENTIFICATION WORD TO BE
*                 PUNCHED IN COLUMNS 73-76 (ALPHA ONLY)
*
      REAL A(18)
      LOGICAL OD
C
      INCLUDE (DARRAY)    
C
C
      INQUIRE(FILE='PNCHFL.',OPENED=OD)
          IF (.NOT.OD) THEN
             OPEN(UNIT=7,FILE='PNCHFL',ERR=90,STATUS='NEW',
     1            ACCESS='SEQUENTIAL',FORM='FORMATTED')
          END IF
C
      IF (N.LE.18) THEN
         WRITE(7,'(18A4)') (A(I),I=1,N)
      ELSE
         ISEQ=MOD(I,10000)
         WRITE(7,'(19A4,I4)') (A(I),I=1,18),D,ISEQ
      END IF
      RETURN
C
   90 CALL CFORM('**** ERROR OPENING PNCHFL.DAT ****',DARRAY,2,34)
      CALL CPRINT(DARRAY)
      CALL ABNEND
      RETURN
      END
         
**** SOURCE FILE : CONBCD00.ORG   ***
*
      SUBROUTINE CONBCD(A,B,II,JJ,K)
*
*  * CONBCD *   VAX11 FORTRAN 77 VERSION  09.09.82  E.MCLELLAN
*
*  PURPOSE      TO CONVERT A FLOATING-POINT NUMBER TO A FIXED
*               FORMAT FOR SUBSEQUENT TAPE PUNCHING
*
*  CALLING SEQUENCE
*               CALL CONBCD(A,B,I,J,K)
*  ARGUMENTS
*               A  FLOATING-POINT NUMBER TO BE CONVERTED TO BCD
*               B  LOCATION WHERE BCD NUMBERS WILL BE STORED
*               I  NUMBER OF BCD DIGITS TO BE INCLUDED IN B.
*                  IF I IS NEGATIVE,THE SIGN OF A WILL BE INCLUDED
*                  AND THE FIELD LENGTH WILL BE I+1 BCD CHARACTERS
*               J  NUMBER OF FRACTIONAL BCD DIGITS TO BE INCLUDED IN I
*                  IF J NEGATIVE, DECIMAL POINT WILL BE INCLUDED
*                  AND FIELD LENGTH INCREASED TO I+1 BCD CHARACTERS
*                  IF BOTH I AND J ARE NEGATIVE,FIELD LENGTH WILL
*                  BE I+2 CHARACTERS.
*                  IF ABS(J) GT 100, TRAILING ZEROS WILL BE DELETED.
*                  J WILL THEN EQUAL ABS(J)-100
*                  IF ABS(J) GT 200, LEADING ZEROS WILL BE DELETED.
*                  J WILL THEN EQUAL ABS(J)-200
*                  IF J LT -300, LEADING AND TRAILING ZEROS WILL
*                  BE DELETED. J WILL EQUAL ABS(J)-300
*               K  =1  A ASSUMED SINGLE PRECISION
*                  =2  A ASSUMED DOUBLE PRECISION
*                  =0  A ASSUMED DOUBLE PRECISION
*                      (EQUIVALENTTO OMISSION OF K)
*         NOTE:    IF K=0 AND I LE 6,THE OUTPUT IS RIGHT JUSTIFIED IN
*                  THE FIRST 6 BYTES OF B FOLLOWED BY 2 BLANKS
*                  IF K=0 AND I GT 6,THE OUTPUT IS RIGHT JUSTIFIED IN
*                  FIRST 12 BYTES OF B FOLLOWED BY 4 BLANKS
*                  IF K=1 OR 2 THEN OUTPUT IS RIGHT JUSTIFIED IN B
*                  IF B IS DIMENSIONED CORRECTLY
*
*         LIMITS:     K    IMAX     JMAX    BMIN
*                         (CHARS) (DIGITS) (BYTES)
*                     0     12        8       8
*                     1      8        6       4
*                     2     16       14       8
*
*                     IMAX INCLUDES SIGN AND DECIMAL POINT INCLUSION
*
      LOGICAL SFL,DFL,TZFL,LZFL
C.....SFL  TRUE IF SIGN TO BE INCLUDED
C     DFL  TRUE IF DECIMAL POINT TO BE INCLUDED
C     TZFL TRUE IF TRAILING ZEROS TO BE DELETED
C     LZFL TRUE IF LEADING ZEROS TO BE DELETED
C
      DOUBLE PRECISION A,ATEM,F,TENTOJ,DPF
      REAL B(4)
      EQUIVALENCE (AS,ATEM)
      CHARACTER*32 INTFIL
      CHARACTER*16 OUTFIL
C
      INCLUDE (DARRAY)    
C
C
      ATEM=A
      I=II
      J=JJ
C
C..... INITIALIZE FLAGS
C
      SFL=.FALSE.
      DFL=.FALSE.
      TZFL=.FALSE.
      LZFL=.FALSE.
C
C.....CHECK FIFTH PARAMETER AND SET LIMITS
C
      IF (K.EQ.0) THEN
         IM=12
         JM=8
      ELSE IF (K.EQ.1) THEN
         IM=8
         JM=6
      ELSE IF (K.EQ.2) THEN
         IM=16
         JM=14
      END IF
C
C.....IF I NEGATIVE INCLUDE SIGN
C
      IF (I.LT.0) THEN
         SFL=.TRUE.
         I=IABS(I)+1
      ELSE IF (I.EQ.0) THEN
         CALL CFORM('**** INVALID CONBCD PARAMETER (I=0) ****',DARRAY,
     1               2,40)
         CALL CPRINT(DARRAY)
         CALL ABNEND
      END IF
C
C.....IF J NEGATIVE INCLUDE DECIMAL POINT
C
      IF (J.LT.0) THEN
         DFL=.TRUE.
         I=I+1
      END IF
C
C.....IF J.GT.300 ,NOT VALID
C
      IF (J.GT.300) THEN
         CALL CFORM('**** INVALID CONBCD PARAMETER (J.GT.300) ****',
     1               DARRAY,2,45)
         CALL CPRINT(DARRAY)
         CALL ABNEND
C
C.....IF J.LT.-300, DELETE LEADING AND TRAILING ZEROS
C                  (ONLY VALID IF DECIMAL POINT INCLUDED)
      ELSE IF (J.LT.-300) THEN
         TZFL=.TRUE.
         LZFL=.TRUE.
         J=IABS(J)-300
C
C.....IF ABS(J).GT.200 , DELETE LEADING ZEROS
C
      ELSE IF (IABS(J).GT.200) THEN
         LZFL=.TRUE.
         J=IABS(J)-200
C
C.....IF ABS(J).GT.100 , DELETE TRAILING ZEROS
C
      ELSE IF (IABS(J).GT.100) THEN
         TZFL=.TRUE.
         J=IABS(J)-100
      ELSE
         J=IABS(J)
      END IF
C
C.....CHECK LIMITS
C
      IF (I.GT.IM) THEN
         CALL CFORM('**** I.GT.IMAX FOR CURRENT K IN CONBCD CALL****',
     1              DARRAY,2,48)
         CALL CPRINT(DARRAY)
         I=IM
      END IF
C
      IF (J.GT.JM) THEN
         CALL CFORM('**** J.GT.JMAX FOR CURRENT K IN CONBCD CALL****',
     1            DARRAY,2,48)
         CALL CPRINT(DARRAY)
         J=JM
      END IF
C
C.....STORE VALUE IN DOUBLE PRECISION WORD F
C
      IF (K.EQ.1) THEN
          F=AS
      ELSE
          F=A
      END IF
C
C.....STORE SIGN OF F
C
      IS=INT(DSIGN(1.0D0,F))
C
C.....ROUND ABS VALUE OF F TO J DECIMAL PLACES
C
      TENTOJ=10.0D0**J
      F=ABS(F)
      INF=INT(F)
      DPF=F-DFLOAT(INF)
      INP=INT(DPF*TENTOJ+0.5D0)
      F=DFLOAT(INF)+DFLOAT(INP)/TENTOJ
C
C.....WRITE F TO INTERNAL FILE
C
      WRITE (INTFIL,'(F32.14)') F
C
C.....INSERT TRAILING BLANKS
C
      LSD=J+18
      INTFIL(LSD+1:32)=' '
C
C.....ARE TRAILING ZEROS TO BE DELETED
C
      IF (TZFL) THEN
          L=LSD
   10     IF (INTFIL(L:L).EQ.'0') THEN
             INTFIL(L:L)=' '
             L=L-1
             GO TO 10
          END IF
      END IF
C
C.....WHERE IS FIRST NON BLANK CHARACTER IN INTFIL
C
      L=1
  20  IF (INTFIL(L:L).EQ.' ') THEN
        IF (.NOT.LZFL) THEN
           INTFIL(L:L)='0'
        END IF
        L=L+1
        GO TO 20
      END IF
      L1=L
C
C.....IS DECIMAL POINT REQUIRED
C
      IF (.NOT.DFL) THEN
C.....NO DELETE DECIMAL POINT
      L=17
  30  INTFIL(L+1:L+1)=INTFIL(L:L)
      IF (L.EQ.L1) THEN
         IF (LZFL) THEN
            INTFIL(L1:L1)=' '
         ELSE
            INTFIL(L1:L1)='0'
         END IF
      ELSE
         L=L-1
         GO TO 30
      END IF
      END IF
C
C.....IS SIGN REQUIRED
C
      MSD=LSD-I+1
      IF (SFL) THEN
         IF (IS.GE.0) THEN
            INTFIL(MSD:MSD)='+'
         ELSE
            INTFIL(MSD:MSD)='-'
         END IF
      END IF
C
C.....SET UP OUTFIL ACCORDING TO K AND I
C
      OUTFIL(1:16)=' '
      IF (K.EQ.0) THEN
         IF (I.GT.6) THEN
            OUTFIL(13-I:12)=INTFIL(MSD:LSD)
            READ (OUTFIL,'(4A4)') (B(L),L=1,4)
         ELSE
            OUTFIL(7-I:6)=INTFIL(MSD:LSD)
            READ (OUTFIL,'(2A4)') B(1),B(2)
         END IF
C
      ELSE IF (I.GT.8) THEN
            OUTFIL(17-I:16)=INTFIL(MSD:LSD)
            READ (OUTFIL,'(4A4)') (B(L),L=1,4)
      ELSE IF (I.GT.4) THEN
            OUTFIL(9-I:8)=INTFIL(MSD:LSD)
            READ (OUTFIL,'(2A4)') B(1),B(2)
      ELSE
            OUTFIL(5-I:4)=INTFIL(MSD:LSD)
            READ (OUTFIL,'(A4)') B(1)
      END IF
C
      RETURN
      END
**** SOURCE FILE : DISPAT00.ORG   ***
*
      SUBROUTINE DISPAT
*
*  * DISPAT *  VAX 11 FORTRAN 77 VERSION  20.09.82  E.MCLELLAN
*
*  PURPOSE     TO TERMINATE A POSTPROCESSOR
*
      STOP ' CURRENT POSTPROCESSOR COMPLETE'
      END
**** SOURCE FILE : NNTAIN00.ORG   ***
*
      INTEGER FUNCTION NNTAIN(A,B,C)
*
*  * NNTAIN *  VAX11 FORTRAN 77 VERSION  27.8.82  E.MCLELLAN
*
*  PURPOSE     TO TEST IF A FLOATING POINT NUMBER LIES
*              WITHIN A CLOSED INTERVAL
*
*  CALLING SEQUENCE
*              IF (NNTAIN(A,B,C)) 1,2,3
*  ARGUMENTS
*              A IS ONE LIMIT OF THE CLOSED INTERVAL
*              B IS FLOATING POINT NUMBER TO BE TESTED
*                TO SEE IF IT FALLS IN THE CLOSED INTERVAL
*              C IS THE OTHER LIMIT OF THE CLOSED INTERVAL
*
*              INTEGER RETURNED = 1  IF B LIES IN CLOSED INTERVAL
*                               =-1  IF B DOES NOT LIE IN CLOSED
*                                    INTERVAL
*                               = 0  IF ERROR CONDITION APPLIES
*                                    I.E. A=C
*
      DOUBLE PRECISION A,B,C,LOW,HIGH
C
      IF (A.EQ.C) THEN
C.....ERROR CONDITION A=C
         NNTAIN=0
         RETURN
      ELSE
C.....SET UP UPPER AND LOWER LIMITS TO CLOSED INTERVAL
         IF (A.GT.C) THEN
            LOW=C
            HIGH=A
         ELSE
            LOW=A
            HIGH=C
         END IF
C.....TEST IF B WITHIN CLOSED INTERVAL
         IF ((B.GE.LOW).AND.(B.LE.HIGH)) THEN
C.....YES
            NNTAIN=1
            RETURN
         ELSE
C.....NO
            NNTAIN=-1
            RETURN
         END IF
      END IF
      END
**** SOURCE FILE : PUNIDN00.V01   ***
*
      SUBROUTINE PUNIDN(A)
*
*  * PUNIDN *  VAX-11 FORTRAN 77 VERSION  21.10.82  E.MCLELLAN
*
*  PURPOSE     TO SET UP CARD IDENTIFICATION AND SEQUENCE NUMBERS
*
*  CALLING SEQUENCE
*              CALL PUNIDN(A)
*  ARGUMENTS
*             A  ADDRESS FIELD OF 4 BCD CHARACTERS
*  ALTERNATE ENTRIES
*             CALL PUNSEQ(B)
*             B  START SEQUENCE NUMBER TO BE PUNCHED - REAL*4
*
*             CALL PUNNUM(C)
*             C  LATEST SEQUENCE NUMBER BEING PUNCHED - REAL*4
*
      COMMON/PUN/PNID,PNO
C
      PNID=A
      RETURN
C
      ENTRY PUNSEQ(B)
      PNO=B
      RETURN
C
      ENTRY PUNNUM(C)
      C=PNO
      RETURN
      END
**** SOURCE FILE : PUNIDS00.ORG   ***
*
      REAL FUNCTION PUNIDS()
*
*  * PUNIDS *  VAX-11 FORTRAN 77 VERSION  21.10.82  E.MCLELLAN
*
*  PURPOSE     TO RETREIVE CARD IDENTIFICATION AND SEQUENCE NUMBER
*
*  CALLING SEQUENCE
*              VALUE = PUNIDS()
*  ARGUMENT
*              NONE    NOTE: PARENTHESIS MUST APPEAR
*              VALUE   WILL CONTAIN 4 BCD CHARACTERS BEING IDENT
*  ALTERNATE ENTRY
*              VALUE = PUNNOM()
*
*              VALUE   WILL CONTAIN REAL*4 VALUE BEING CURRENT
*                      SEQUENCE NUMBER
*
      COMMON/PUN/PNID,PNO
C
      PUNIDS=PNID
      RETURN
C
      ENTRY PUNNOM()
      PUNNOM=PNO
      RETURN
      END
**** SOURCE FILE : RDSATZ00.ORG   ***
*
      SUBROUTINE RDSATZ(ID,ARRAY,IANZ,NRSATZ,IRET)
C
      DOUBLE PRECISION ARRAY(10)
      INTEGER ID,IANZ,NRSATZ,IRET
C
      READ(UNIT=ID,ERR=90,END=95) (ARRAY(I),I=1,10)
      IRET=0
      RETURN
C
   90 IRET=3
      RETURN
C
   95 IRET=-1
      RETURN
      END
**** SOURCE FILE : WTSATZ00.ORG   ***
*
      SUBROUTINE WTSATZ(ID,ARRAY,IANZ,IRET)
C
      DOUBLE PRECISION ARRAY(IANZ)
      INTEGER ID,IANZ,IRET
C
      WRITE(UNIT=ID,ERR=90) (ARRAY(I),I=1,IANZ)
      IRET=0
      RETURN
C
   90 IRET=3
      RETURN
      END
**** SOURCE FILE : ATAPWT.ORG   ***
*
*
*  *  ATAPWT  *  FORTRAN 77 VERSION   1-MAR-1988 E.MCLELLAN
*
*  PURPOSE     TO WRITE AN APT 111 FORMATTED CLFILE
*              RESTRICTED TO TWO INPUT ARRAYS MAXIMUM
*
*  CALLING SEQUENCE
*              CALL ATAPWT(NO,IRET,N,A1,N1,A2,N2)
*  ARGUMENTS
*              NO         FILE NUMBER
*                         FOR NC 360 HELD IN SECOND HALF
*                         OF DOUBLE PRECISION WORD
*              IRET.LT.0  NORMAL RETURN
*                  .GT.0  ABNORMAL CONDITION
*              N          NO OF ARRAYS AI SPECIFIED IN CALLING SEQUENCE
*              AI         ARRAY CONTAINING DATA TO BE WRITTEN TO FILE
*              NI         NO OF ITEMS IN ARRAY AI TO BE WRITTEN TO FILE
*
      SUBROUTINE ATAPWT(NO,IRET,NUM,A1,N1,A2,N2)
C
C.... ARGUMENTS
      INTEGER NO,IRET,NUM,A1,N1,N2
      DOUBLE PRECISION A2
      DIMENSION NO(2),A1(N1),A2(N2)
C
C.... LOCAL VARIABLES
      INTEGER NWRDS,IREC
      REAL REC
      DOUBLE PRECISION DREC
      DIMENSION REC(512),DREC(254),IREC(512)
      EQUIVALENCE (REC(1),IREC(1))
      EQUIVALENCE (REC(5),DREC(1))
C
C.... COMMON BLOCKS
      INCLUDE (DARRAY)    
C
      ID=NO(1)
      IF (NO(1).EQ.0)  ID=NO(2)
C
      IF (NUM.EQ.1) THEN
        NWRDS=N1
      ELSE IF (NUM.EQ.2) THEN
        NWRDS=3+2*N2
      ELSE
        CALL CFORM(' *** ERROR IN CALL TO ATAPWT, MAXIMUM OF TWO ARRAYS
     +ALLOWED ***',DARRAY,2,63)
        CALL CPRINT(DARRAY)
        IRET=1
        RETURN
      ENDIF
C
      IREC(1)=NWRDS
      DO 10 I=2,4
       IREC(I)=0
  10  CONTINUE
C
      DO 20 I=1,N1
       IREC(I+1)=A1(I)
  20  CONTINUE
C
      IF (NUM.EQ.2) THEN
        DO 30 I=1,N2
          DREC(I)=A2(I)
  30    CONTINUE
      ENDIF
C
      WRITE(ID,IOSTAT=IRET) (REC(I),I=1,NWRDS+1)
C
      RETURN
      END
**** SOURCE FILE : ATAPRD.ORG   ***
*
*
*  *  ATAPRD  *  FORTRAN 77 VERSION  1-MAR-1988 E.MCLELLAN
*
*  PURPOSE      TO READ AN APT 111 FORMATTED CLFILE
*               RESTRICTED TO TWO OUTPUT ARRAYS ONLY
*
*  CALLING SEQUENCE
*               CALL ATAPRD(NO,IRET,NW,N,A1,N1,A2,N2)
*  ARGUMENTS
*               NO         FILE NUMBER
*                         FOR NC 360 HELD IN SECOND HALF
*                         OF DOUBLE PRECISION WORD
*               IRET.LT.0  NORMAL RETURN
*                   .EQ.0  END OF FILE ENCOUNTERED
*                   .GT.0  ABNORMAL CONDITION
*               NW         NO OF DATA ITEMS RETURNED IN A2
*               N          NO OF ARRAYS SPECIFIED IN CALLING SEQUENCE
*               AI         ARRAY INTO WHICH DATA IS TO BE READ
*               NI         NO OF ITEMS IN ARRAY AI
*                          IF N2=0 ON ENTRY - ALL REMAINING ITEMS ARE
*                          TRANSFERRED TO ARRAY A2 AND NO RETURNED IN NW
*                          NOTE: FIRST 3 ITEMS TO BE TRANSFERRED
*                                ARE ASSUMED INTEGER THE REMAINDER
*                                REAL*8
      SUBROUTINE ATAPRD(NO,IRET,NW,N,A1,N1,A2,N2)
C
C.... ARGUMENTS
      INTEGER NO,IRET,NW,N,A1,N1,N2
      DOUBLE PRECISION A2
      DIMENSION NO(2),A1(N1),A2(254)
C
C.... LOCAL VARIABLES
      INTEGER NWRDS,IREC
      REAL REC
      DOUBLE PRECISION DREC
      DIMENSION IREC(512),REC(512),DREC(256)
      EQUIVALENCE (REC(1),IREC(1))
      EQUIVALENCE (REC(1),DREC(1))
C
C.... COMMON BLOCKS
      INCLUDE (DARRAY)    
C
      ID=NO(1)
      IF (NO(1).EQ.0)  ID=NO(2)
C
      READ (ID,ERR=99,END=90,IOSTAT=IRET) NWRDS,(REC(I+1),I=1,NWRDS)
C
      DO 10 I=1,N1
        A1(I)=IREC(I+1)
   10 CONTINUE
C
      IF (N.EQ.1) THEN
        IRET=-1
      ELSE IF (N.EQ.2) THEN
C
       IF (N2.EQ.0) THEN
         NW=(NWRDS-N1)/2
         NN=NW
       ELSE
         NN=N2
       ENDIF
C
       I1=(N1+2)/2
       DO 20 I=1,NN
         A2(I)=DREC(I1+I)
   20  CONTINUE
       IRET=-1
      ELSE
       CALL CFORM(' *** ERROR IN CALL TO ATAPRD - MAXIMUM OF TWO ARRAYS
     +ALLOWED ***',DARRAY,1,64)
       CALL CPRINT(DARRAY)
       IRET=1
      ENDIF
      RETURN
C
   90 IRET=0
      RETURN
   99 IRET=1
      RETURN
      END
