**** SOURCE FILE : EVAL.V01   ***
*
      SUBROUTINE EVAL(NAME,U,V,ARRAY,SPW,MODE)
C
      INCLUDE (DARRAY)    
C
      DOUBLE PRECISION U,V,ARRAY(*),SPW(32)
      INTEGER MODE
      CHARACTER*8 NAME
C
      INTEGER SLEN,IPOS
C
      IF (NAME.EQ.'MDCS') THEN
        CALL EMDCS(U,V,ARRAY,SPW,MODE)
      ELSE IF (NAME.EQ.'TORUS') THEN
        CALL ETORUS(U,V,ARRAY,SPW,MODE)
      ELSE IF (NAME.EQ.'VDAFS') THEN
        CALL EVDAFS(U,V,ARRAY,SPW,MODE)
      ELSE
        SLEN=0
        CALL CFORM('0 EVALUATOR FOR NON-NATIVE SURFACE TYPE :',
     +             DARRAY,1,SLEN)
        IPOS=SLEN+2
        CALL CFORM(NAME,DARRAY,IPOS,8)
        IPOS=IPOS+10
        SLEN=0
        CALL CFORM(': NOT AVAILABLE',DARRAY,IPOS,SLEN)
        CALL CPRINT(DARRAY)
        CALL ABNEND
      ENDIF
      RETURN
      END
**** SOURCE FILE : TEVAL.V01   ***
*
      SUBROUTINE TEVAL(NAME,TRM,DATA)
C
      INCLUDE (DARRAY)    
C
      DOUBLE PRECISION TRM(4,3),DATA(*)
      CHARACTER*8 NAME
C
      INTEGER SLEN,IPOS
C
      IF (NAME.EQ.'MDCS') THEN
        CALL TMDCS(TRM,DATA)
      ELSE IF (NAME.EQ.'TORUS') THEN
        CALL TTORUS(TRM,DATA)
      ELSE IF (NAME.EQ.'VDAFS') THEN
        CALL TVDAFS(TRM,DATA)
      ELSE
        SLEN=0
        CALL CFORM('0 TRANSFORMATOR FOR NON-NATIVE SURFACE TYPE :',
     +             DARRAY,1,SLEN)
        IPOS=SLEN+2
        CALL CFORM(NAME,DARRAY,IPOS,8)
        IPOS=IPOS+10
        SLEN=0
        CALL CFORM(': NOT AVAILABLE',DARRAY,IPOS,SLEN)
        CALL CPRINT(DARRAY)
        CALL ABNEND
      ENDIF
      RETURN
      END
**** SOURCE FILE : M0008175.V05   ***
*
      SUBROUTINE EMDCS (U,V,DATA,SPV,MODE)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C  EVALUATION ROUTINE FOR
C   "MASTER DIMENSION CONTOUR SURFACE" - MCDS
C
C   PATCH DATA
      DIMENSION DATA(120)
C   OUTPUT: EVALUATION VECTOR
      DIMENSION SPV(4,12)
C  FUNCTIOS IN V, FV(I,2): 1.DERIVATIVE; FV(I,3): 2.DERIVATIVE;
C                                        FV(I,4): 3.DERIVATIVE
      DIMENSION FV(3,4)
C  8 CONICS WITH DERIVATIVES (1.,2.,AND 3.)
      DIMENSION YZ(8,4),YZ1(2,4,4)
      EQUIVALENCE (YZ(1,1),YZ1(1,1,1))
C  6 CONIC DELTAS AND DERIVATIVE ((Y1,Y4,Y3),(Z1,Z4,Z3))
      DIMENSION YZS(3,2,4)
C  3 WEIGHT FUNCTIONS UND DERIVATIVES (W1,W4,W3)
      DIMENSION WS(3,4)
      INTEGER IW(4)
C  AUXILIARY ARRAY
      DIMENSION HI(3)
                     
      DATA FV(1,3),FV(2,3),FV(3,3) /2.D0,-2.D0,2.D0/
      DATA FV(1,4),FV(2,4),FV(3,4) /3*0.D0/
      DATA IW/2,3,1,2/
C
C    SET OF INTERNAL MODE, IF NECESSARY
      GOTO (1,2,3),MODE
C    POINT ONLY
      IMODE=1
      NRES=1
      GOTO 4
C    POINT AND TANGENTS
    1 IMODE=2
      NRES=3
      GOTO 4
C    POINT, TANGENTS AND 2. DERIVATIVE
    2 IMODE=3
      NRES=8
      GOTO 4
C    POINT, TANGENTS, 2. AND 3. DERIVATIVE
    3 IMODE=4
      NRES=12
      GOTO 4
C  ZERO SPV
    4 DO 5 I=1,4
      DO 5 J=1,NRES
    5 SPV(I,J)=0.D0
C  X(U) = XMIN+EXT*U
      SPV(1,1)=DATA(31)+DATA(32)*U
C  DX/DU = EXT
      SPV(1,2)=DATA(32)
C  FUNCTIONS IN V:  FV(1-3,1) = (1-V)**2, V*(1-V), V**2
   10 FV(3,1)=V*V
      FV(2,1)=V-FV(3,1)
      FV(1,1)=1.D0-V-FV(2,1)
      IF(IMODE.EQ.1) GOTO 20
C  DERIVATIVES IN V:  FV(1-3,2) = 2V-2, 1-2V, 2V
      FV(3,2)=V+V
      FV(2,2)= 1.D0-FV(3,2)
      FV(1,2)=-1.D0-FV(2,2)
C  2. DERIVATIVES OF V-FUNCTIONS  FV(1-3,3) = 2,-2, 2 (CONSTANT)
C  3. DERIVATIVES OF V-FUNCTIONS  FV(1-3,4) = 0, 0, 0  (CONSTANT)
C
C  8 CONIC FUNCTIONS
   20 XHX=SPV(1,1)*SPV(1,1)
      IRN=0
      DO 30 I=1,8
      IRN1=DATA(I)
      IF(IRN1.LE.IRN) GOTO 25
C  COMPUTE CONIC (1. TIME)
      IRN=IRN1
      ID=DATA(IRN+9)
      IF(DATA(ID).NE.1.D0) GOTO 23
C  LINE CONIC: Y = YMIN+YEXT*U
      YZ(I,1)=DATA(ID+1)+DATA(ID+2)*U
      YZ(I,2)=DATA(ID+2)
      YZ(I,3)=0.D0
      YZ(I,4)=0.D0
      GOTO 30
C  CONICS: Y1,Z1,Y2,Z2,Y3,Z3,Y4,Z4
   23 YZ(I,1)=(DSQRT(DATA(ID+7)*XHX+DATA(ID+8)*SPV(1,1)
     *              +DATA(ID+9))*DATA(ID+10)
     *              -DATA(ID+2)*SPV(1,1)-DATA(ID+5))/DATA(ID+3)
      IF(IMODE.EQ.1) GOTO 30
C  CONIC DERIVATIVES TO U:YS= -(A*X+B*Y+D)/(B*X+C*Y+E)*L
      QQ=       DATA(ID+2)*SPV(1,1)+DATA(ID+3)*YZ(I,1)+DATA(ID+5)
      YZ(I,2)=-(DATA(ID+1)*SPV(1,1)+DATA(ID+2)*YZ(I,1)+DATA(ID+4))
     *        /QQ*SPV(1,2)
      IF(IMODE.EQ.2) GOTO 30
C  2. DERIVATIVES:YSS= -(A*L**2+2*B*L*YS+C*YS**2)/(B*X+C*Y+E)
      YZ(I,3)=-(SPV(1,2)*(DATA(ID+1)*SPV(1,2)
     *        +2.D0*DATA(ID+2)*YZ(I,2))
     *        +DATA(ID+3)*YZ(I,2)*YZ(I,2))/QQ
      IF(IMODE.EQ.3) GOTO 30
C  3. DERIVATIVES:YSSS= -3*YSS*(B*L+C*YS)/(B*X+C*Y+E)
      YZ(I,4)=-3.D0*YZ(I,3)*(DATA(ID+2)*SPV(1,2)+
     *                       DATA(ID+3)*YZ(I,2))/QQ
      GOTO 30
C  CONIC ALREADY COMPUTED
   25 DO 27 I1=1,I
      IRN2=DATA(I1)
      IF(IRN2.NE.IRN1) GOTO 27
      YZ(I,1)=YZ(I1,1)
      YZ(I,2)=YZ(I1,2)
      YZ(I,3)=YZ(I1,3)
      YZ(I,4)=YZ(I1,4)
      GOTO 30
   27 CONTINUE
   30 CONTINUE
C  CONIC DIFFERENCES
      DO 40 I=1,IMODE
C  Y1S = Y1 - Y2
      YZS(1,1,I)=YZ(1,I)-YZ(3,I)
C  Y4S = Y4 - Y2
      YZS(2,1,I)=YZ(7,I)-YZ(3,I)
C  Y3S = Y3 - Y2
      YZS(3,1,I)=YZ(5,I)-YZ(3,I)
C  Z1S = Z1 - Z2
      YZS(1,2,I)=YZ(2,I)-YZ(4,I)
C  Z4S = Z4 - Z2
      YZS(2,2,I)=YZ(8,I)-YZ(4,I)
C  Z3S = Z3 - Z2
      YZS(3,2,I)=YZ(6,I)-YZ(4,I)
C  MOVE Y4, Z4 TO Y2, Z2
      YZ(3,I)=YZ(7,I)
      YZ(4,I)=YZ(8,I)
   40 CONTINUE
C  COEFFICIENTS OF WEIGHT FUNCTIONS
      DO 50 I=1,3
      I1=IW(I)
      I2=IW(I+1)
      WS(I,1)=YZS(I1,1,1)*YZS(I2,2,1)-YZS(I1,2,1)*YZS(I2,1,1)
      IF(IMODE.EQ.1) GOTO 50
C  1. DERIVATIVE
      WS(I,2)=YZS(I1,1,2)*YZS(I2,2,1)-YZS(I1,2,2)*YZS(I2,1,1)
     *       +YZS(I1,1,1)*YZS(I2,2,2)-YZS(I1,2,1)*YZS(I2,1,2)
      IF(IMODE.EQ.2) GOTO 50
C  2. DERIVATIVE
      WS(I,3)=YZS(I1,1,3)*YZS(I2,2,1)-YZS(I1,2,3)*YZS(I2,1,1)
     * +2.D0*(YZS(I1,1,2)*YZS(I2,2,2)-YZS(I1,2,2)*YZS(I2,1,2))
     *       +YZS(I1,1,1)*YZS(I2,2,3)-YZS(I1,2,1)*YZS(I2,1,3)
      IF(IMODE.EQ.3) GOTO 50
C  2. DERIVATIVE
      WS(I,4)=YZS(I1,1,4)*YZS(I2,2,1)-YZS(I1,2,4)*YZS(I2,1,1)
     * +3.D0*(YZS(I1,1,3)*YZS(I2,2,2)-YZS(I1,2,3)*YZS(I2,1,2))
     * +3.D0*(YZS(I1,1,2)*YZS(I2,2,3)-YZS(I1,2,2)*YZS(I2,1,3))
     *       +YZS(I1,1,1)*YZS(I2,2,4)-YZS(I1,2,1)*YZS(I2,1,4)
   50 CONTINUE
C  WEIGHTED COORDINATES
      DO 60 I=1,2
      DO 60 J=1,3
      QQ1=WS(J,1)*YZ1(I,J,1)
      SPV(I+1,1)=SPV(I+1,1)+QQ1*FV(J,1)
      IF(IMODE.EQ.1) GOTO 60
C
      QQ2=WS(J,2)*YZ1(I,J,1)+WS(J,1)*YZ1(I,J,2)
      SPV(I+1,2)=SPV(I+1,2)+QQ2*FV(J,1)
      SPV(I+1,3)=SPV(I+1,3)+QQ1*FV(J,2)
      IF(IMODE.EQ.2) GOTO 60
C
      QQ3=WS(J,3)*YZ1(I,J,1)+WS(J,2)*YZ1(I,J,2)*2.D0
     *                      +WS(J,1)*YZ1(I,J,3)
      SPV(I+1,4)=SPV(I+1,4)+QQ3*FV(J,1)
      SPV(I+1,5)=SPV(I+1,5)+QQ2*FV(J,2)
      SPV(I+1,6)=SPV(I+1,6)+QQ1*FV(J,3)
      IF(IMODE.EQ.3) GOTO 60
      QQ4=WS(J,4)*YZ1(I,J,1)+WS(J,3)*YZ1(I,J,2)*3.D0
     *                      +WS(J,2)*YZ1(I,J,3)*3.D0
     *                      +WS(J,1)*YZ1(I,J,4)
      SPV(I+1, 9)=SPV(I+1, 9)+QQ4*FV(J,1)
      SPV(I+1,10)=SPV(I+1,10)+QQ3*FV(J,2)
      SPV(I+1,11)=SPV(I+1,11)+QQ2*FV(J,3)
      SPV(I+1,12)=SPV(I+1,12)+QQ1*FV(J,4)
   60 CONTINUE
C  WEIGHT FUNCTION
      DO 65 J=1,3
      SPV(4,1)=SPV(4,1)+WS(J,1)*FV(J,1)
      IF(IMODE.EQ.1) GOTO 65
C
      SPV(4,2)=SPV(4,2)+WS(J,2)*FV(J,1)
      SPV(4,3)=SPV(4,3)+WS(J,1)*FV(J,2)
      IF(IMODE.EQ.2) GOTO 65
C
      SPV(4,4)=SPV(4,4)+WS(J,3)*FV(J,1)
      SPV(4,5)=SPV(4,5)+WS(J,2)*FV(J,2)
      SPV(4,6)=SPV(4,6)+WS(J,1)*FV(J,3)
      IF(IMODE.EQ.3) GOTO 65
C
      SPV(4, 9)=SPV(4, 9)+WS(J,4)*FV(J,1)
      SPV(4,10)=SPV(4,10)+WS(J,3)*FV(J,2)
      SPV(4,11)=SPV(4,11)+WS(J,2)*FV(J,3)
      SPV(4,12)=SPV(4,12)+WS(J,1)*FV(J,4)
   65 CONTINUE
C  COMPUTATION OF (X,Y,Z)-COORDINATES
      IF(IMODE.EQ.1) GOTO 71
      DO 70 I=2,NRES
   70 SPV(4,I)=SPV(4,I)/SPV(4,1)
   71 DO 72 I=2,3
      SPV(I,1)=SPV(I,1)/SPV(4,1)
      IF(IMODE.EQ.1) GOTO 72
      SPV(I,2)=SPV(I,2)/SPV(4,1)-SPV(I,1)*SPV(4,2)
      SPV(I,3)=SPV(I,3)/SPV(4,1)-SPV(I,1)*SPV(4,3)
      IF(IMODE.EQ.2) GOTO 72
      SPV(I,4)=SPV(I,4)/SPV(4,1)-2.D0*SPV(I,2)*SPV(4,2)
     *                               -SPV(I,1)*SPV(4,4)
      SPV(I,5)=SPV(I,5)/SPV(4,1)-SPV(I,2)*SPV(4,3)
     *                          -SPV(I,3)*SPV(4,2)
     *                          -SPV(I,1)*SPV(4,5)
      SPV(I,6)=SPV(I,6)/SPV(4,1)-2.D0*SPV(I,3)*SPV(4,3)
     *                               -SPV(I,1)*SPV(4,6)
      IF(IMODE.EQ.3) GOTO 72
      SPV(I, 9)=SPV(I, 9)/SPV(4,1)-3.D0*SPV(I, 4)*SPV(4, 2)
     *                            -3.D0*SPV(I, 2)*SPV(4, 4)
     *                                 -SPV(I, 1)*SPV(4, 9)
      SPV(I,10)=SPV(I,10)/SPV(4,1)-2.D0*SPV(I, 5)*SPV(4, 2)
     *                                 -SPV(I, 4)*SPV(4, 3)
     *                                 -SPV(I, 3)*SPV(4, 4)
     *                            -2.D0*SPV(I, 2)*SPV(4, 5)
     *                                 -SPV(I, 1)*SPV(4,10)
      SPV(I,11)=SPV(I,11)/SPV(4,1)     -SPV(I, 6)*SPV(4, 2)
     *                            -2.D0*SPV(I, 5)*SPV(4, 3)
     *                            -2.D0*SPV(I, 3)*SPV(4, 5)
     *                                 -SPV(I, 2)*SPV(4, 6)
     *                                 -SPV(I, 1)*SPV(4,11)
      SPV(I,12)=SPV(I,12)/SPV(4,1)-3.D0*SPV(I, 6)*SPV(4, 3)
     *                            -3.D0*SPV(I, 3)*SPV(4, 6)
     *                                 -SPV(I, 1)*SPV(4,12)
   72 CONTINUE
C
C  TRANSFORMATION NECESSARY ?
      IF(DATA(18).EQ.0.D0) GOTO 80
      DO 76 I=1,NRES
      IF(I.EQ.7)GOTO 76
      IF(I.EQ.8)GOTO 76
      DO 74 J=1,3
   74 HI(J)=SPV(J,I)
      DO 75 J=1,3
   75 SPV(J,I)=DATA(4*J+15)*HI(1)+DATA(4*J+16)*HI(2)+DATA(4*J+17)*HI(3)
   76 CONTINUE
C
C  TRANSLATION OF SURFACE POINT COORDINATES
   77 DO 78 I=1,3
   78 SPV(I,1)=SPV(I,1)+DATA(4*I+18)
C
C  SURFACE NORMAL NECESSARY ?
   80 IF(IMODE.LT.2) GOTO 89
C
C  SURFACE NORMAL
      SPV(1,7)=SPV(2,2)*SPV(3,3)-SPV(3,2)*SPV(2,3)
      SPV(2,7)=SPV(3,2)*SPV(1,3)-SPV(1,2)*SPV(3,3)
      SPV(3,7)=SPV(1,2)*SPV(2,3)-SPV(2,2)*SPV(1,3)
C
C  NORMALIZING OF SURFACE NORMAL
      QQ=DSQRT(SPV(1,7)*SPV(1,7)+SPV(2,7)*SPV(2,7)+SPV(3,7)*SPV(3,7))
      IF(QQ.LT.1.D-12)GOTO 89
      SPV(1,8)=SPV(1,7)/QQ
      SPV(2,8)=SPV(2,7)/QQ
      SPV(3,8)=SPV(3,7)/QQ
      SPV(4,7)=1.D0
      SPV(4,8)=1.D0
C
C  SET THE COMPUTATION SIGNAL
   89 DO 90 I=1,NRES
      IF(I.EQ.7)GOTO 90
      IF(I.EQ.8)GOTO 90
      SPV(4,I)=1.D0
   90 CONTINUE
      RETURN
      END
**** SOURCE FILE : M0008177.V01   ***
*
      SUBROUTINE KREUZ(V1,V2,V3)
C
C   COMPUTATION OF VECTOR CROSS PRODUCT
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DOUBLE PRECISION V1(3),V2(3),V3(3)
C
      V3(1)=(V1(2)*V2(3)-V1(3)*V2(2))
      V3(2)=(V1(3)*V2(1)-V1(1)*V2(3))
      V3(3)=(V1(1)*V2(2)-V1(2)*V2(1))
C
      RETURN
      END
**** SOURCE FILE : M0008176.V01   ***
*
      SUBROUTINE KRUMM(SPV,E,F,G,XL,XM,XN,HKR,RK1,RK2)
C
C SUBROUTINE FOR THE OUTPUT OF THE CURVING OF PATCHES
C
C  SPV :   SURFACE POINTS AND DERIVATIVES
C  E   :   COEFFICIENTS OF FIRST AND SECOND GAUSSIAN FUNDAMENTAL FORM
C  F   :
C  G   :
C  XL  :
C  XM  :
C  XN  :
C  HKR :   MAIN CURVATURE DIRECTION
C  RK1 :   1.CURVATURE
C  RK2 :   2.CURVATURE
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DOUBLE PRECISION SPV(4,8),HKR(3)
C  HELP STORAGE
      DOUBLE PRECISION VT(3),VT2(3)
C
C  COMPUTATION OF THE FUNDAMENTAL COEFFICIENTS
      E=0.D0
      F=0.D0
      G=0.D0
      XL=0.D0
      XN=0.D0
      XM=0.D0
      DO 7002 I=1,3
      SUPI=SPV(I,2)
      SVPI=SPV(I,3)
      E=SUPI*SUPI+E
      F=SUPI*SVPI+F
      G=SVPI*SVPI+G
      XNORM=SPV(I,8)
      XL=SPV(I,4)*XNORM+XL
      XM=SPV(I,5)*XNORM+XM
      XN=SPV(I,6)*XNORM+XN
 7002 CONTINUE
C   THE LENGTH OF THE NORMAL
      XNL=DSQRT(E*G-F*F)+1.D-12
C   COMPUTATION OF ONE MAIN CURVATURE DIRECTION
C   A=G*M-F*N
      A=G*XM-F*XN
C   B=G*L-E*N
      B=G*XL-E*XN
C   C=F*L-E*M
      C=F*XL-E*XM
      T1=B*B-4.D0*A*C
      T2=DSQRT(T1)
      T3=E*B-2.D0*F*C
      IF(T3.LT.0.D0)T2=-T2
      T4=DSQRT(2.D0*E*E*T1+2.D0*E*T3*T2)
      IF(DABS(T4).GT.0.D-20) GOTO 7060
C   NO MAIN DIRECTION GIVEN
      SINALF=0.D0
      COSALF=1.D0
      GOTO 7070
 7060 SINALF=(T3+E*T2)/T4
      COSALF=(2.D0*C*XNL)/T4
 7070 WE=DSQRT(E)
      DO 7300 I=1,3
C  U-TANGENT
 7300 VT(I)=SPV(I,2)/WE
C  VECTOR, PERPENTICULAR TO U-TANGENT
      CALL KREUZ(SPV(1,8),VT,VT2)
C   DIRECTION OF 1. MAIN CURVATURE
      DO 7310 I=1,3
 7310 HKR(I)=COSALF*VT(I)+SINALF*VT2(I)
C  COMPUTATION OF 1.CURVATURE:
      DV=E*SINALF
      DU= XNL*COSALF-F*SINALF
      RK1=(XL*DU*DU+2.D0*XM*DU*DV+XN*DV*DV)/
     *        (E*DU*DU+2.D0*F*DU*DV+G*DV*DV)
C  COMPUTATION OF 2.CURVATURE:
      DV=E*COSALF
      DU=-XNL*SINALF-F*COSALF
      RK2=(XL*DU*DU+2.D0*XM*DU*DV+XN*DV*DV)/
     *        (E*DU*DU+2.D0*F*DU*DV+G*DV*DV)
C
      RETURN
      END
**** SOURCE FILE : M0008178.V02   ***
*
      SUBROUTINE TMDCS(TRM,DATA)
      IMPLICIT DOUBLE PRECISION (A-H,O-Z)
C PROGRAM TO TRANSFORM THE PATCH GEOMETRY
C  OF "MASTER DIMENSION CONTOUR SURFACE"
C
C   TRANSFORMATION MATRIX
      DOUBLE PRECISION TRM(12)
C   PATCH DATA
      DIMENSION DATA(120)
C   AUXILIARY MATRIX
      DOUBLE PRECISION TRM1(12)
C   'NO TRANSFORMATION' MATRIX
      DOUBLE PRECISION NTRM(12)
C   SCALE FACTOR
      DOUBLE PRECISION SCALE,SCALES
C
      DATA NTRM/1.D0,4*0.D0,1.D0,4*0.D0,1.D0,0.D0/
C
C   TEST PRINT
C     WRITE(6,100)
C 100 FORMAT('0TMDCSSSS WAS CALLED')
C    PRESET OF SCALE FACTOR
      SCALE=1.D0
C    SQUARED SCALE FACTOR
      SCALES=TRM(1)**2+TRM(2)**2+TRM(3)**2
C    COMPUTATION OF SCALE FACTOR
      IF(DABS(SCALES-1.D0).GE.1.D-10)SCALE=DSQRT(SCALES)
C    TEST IF ALL SCALE FACTORS EQUAL
      IF(DABS(TRM( 5)**2+TRM( 6)**2+TRM( 7)**2-SCALES).LT.1.D-10.AND.
     *   DABS(TRM( 9)**2+TRM(10)**2+TRM(11)**2-SCALES).LT.1.D-10)
     *GOTO 1
C    NO TRANSFORMATION AND ERROR MESSAGE
      CALL ERROR(97,'TMDCSSSS')
      GOTO 99
C    MOVE OLD MATRIX TO SCATCH AREA
    1 DO 2 I=1,12
    2 TRM1(I)=DATA(I+18)
C    COMPUTE NEW TRANSFORMATION MATRIX
      CALL APT066(DATA(19),TRM,TRM1,0)
C    PRESET SCALE FACTOR OF MATRIX
      DATA(18)=SCALE
C    CHECK THE RESULT MATRIX FOR 'NO TRANSFORMATION'
      DO 3 I=1,12
      IF(DABS(DATA(I+18)-NTRM(I)).GE.1.D-10)GOTO 99
    3 CONTINUE
C    SWITCH OFF TRANSFORMATION
      DATA(18)=0.D0
   99 RETURN
      END
**** SOURCE FILE : ETORUS.ORG   ***
*
      SUBROUTINE ETORUS(U,V,GEO,RESULT,MODE)
      DOUBLE PRECISION U,V,UA,VA,SU,SV,CU,CV,RP,TOT
      DOUBLE PRECISION GEO(15),RESULT(4,8),AP(3),SN(3)
      INTEGER MODE
C PARAMETRIC EVALUATOR FOR TORUS.
C TORUS PATCH CANONICAL DATA IS IN GEO(15)
C  GEO(1)-GEO(3) = AXIS OF TORUS
C  GEO(4)-GEO(6) = CENTRE OF TORUS
C  GEO(7)-GEO(9) = REF. AXIS (I.E. DEFINES U=0,V=0)
C  GEO(10)       = MAJOR RADIUS R1
C  GEO(11)       = MINOR RADIUS R2
C  GEO(12)       = UMIN (IN RADIANS)
C  GEO(13)       = UMAX (IN RADIANS)
C  GEO(14)       = VMIN (IN RADIANS)
C  GEO(15)       = VMAX (IN RADIANS)
C RESULT RETURNS IN HOMOGENEOUS COORDINATES POINT, FIRST DERIVATIVES,
C 2ND DERIVATIVES, NORMAL AND UNIT NORMAL AT (U,V)
      UA=U*(GEO(13)-GEO(12)) + GEO(12)
      VA=V*(GEO(15)-GEO(14)) + GEO(14)
      SU=SIN(UA)
      SV=SIN(VA)
      CU=COS(UA)
      CV=COS(VA)
      R1=GEO(10)
      R2=GEO(11)
C AP IS THIRD ORTHOGONAL AXIS P*A
      AP(1)=-GEO(2)*GEO(9)+GEO(3)*GEO(8)
      AP(2)=-GEO(3)*GEO(7)+GEO(1)*GEO(9)
      AP(3)=-GEO(1)*GEO(8)+GEO(2)*GEO(7)
      RP=R1+R2*CU
      DO 10 I=1,3
       RESULT(I,1)=GEO(I+3)+R2*SU*GEO(I)+CV*RP*GEO(I+6)+SV*RP*AP(I)
  10  CONTINUE
      RESULT(4,1)=1.0
C POINT EVALUATED, NOW FIND DERIVATIVES RU,RV
      DO 20 I=1,3
       RESULT(I,2)=R2*CU*GEO(I)-R2*CV*SU*GEO(I+6)-R2*SV*SU*AP(I)
       RESULT(I,3)=-RP*SV*GEO(I+6)+CV*RP*AP(I)
  20  CONTINUE
C FIND 2ND DERIVATIVES RUU, RUV AND RVV
      DO 30 I=1,3
       RESULT(I,4)=-R2*SU*GEO(I)-R2*CU*(CV*GEO(I+6)+SV*AP(I))
       RESULT(I,5)=R2*SU*(SV*GEO(I+6)-CV*AP(I))
       RESULT(I,6)=-RP*(CV*GEO(I+6)+SV*AP(I))
  30  CONTINUE
C EVALUATE SURFACE NORMAL SN
      SN(1)=RESULT(2,2)*RESULT(3,3)-RESULT(3,2)*RESULT(2,3)
      SN(2)=RESULT(3,2)*RESULT(1,3)-RESULT(1,2)*RESULT(3,3)
      SN(3)=RESULT(1,2)*RESULT(2,3)-RESULT(2,2)*RESULT(1,3)
      TOT=0.0
      DO 40 I=1,3
       RESULT(I,7)=SN(I)
       TOT=TOT+SN(I)*SN(I)
  40  CONTINUE
      TOT=DSQRT(TOT)
      IF(TOT.LE.1.0E-8) GO TO 55
      DO 50 I=1,3
       RESULT(I,8)=SN(I)/TOT
  50  CONTINUE
C SET W COMPONENT OF ALL VECTOR QUANTITIES TO 0.0 (?)
  55  DO 60 I=2,8
       RESULT(4,I)=0.0
  60  CONTINUE
      RETURN
      END
**** SOURCE FILE : TTORUS.ORG   ***
*
      SUBROUTINE TTORUS(TRM,DATA)
C
C.... TRANSFORMATOR FOR NON-NATIVE TORUS
C
      DOUBLE PRECISION TRM(4,3),DATA(15),A(3)
C
C.... AXIS, CENTER AND REF AXIS FOR TORUS REQUIRE ROTATION
C
      DO 10 I=1,7,3
       A(1)=TRM(1,1)*DATA(I)+TRM(2,1)*DATA(I+1)+TRM(3,1)*DATA(I+2)
       A(2)=TRM(1,2)*DATA(I)+TRM(2,2)*DATA(I+1)+TRM(3,2)*DATA(I+2)
       A(3)=TRM(1,3)*DATA(I)+TRM(2,3)*DATA(I+1)+TRM(3,3)*DATA(I+2)
       DATA(I)=A(1)
       DATA(I+1)=A(2)
       DATA(I+2)=A(3)
  10  CONTINUE
C
C.... CENTER ALSO NEEDS TRANSLATION
C
      DATA(4)=DATA(4)+TRM(4,1)
      DATA(5)=DATA(5)+TRM(4,2)
      DATA(6)=DATA(6)+TRM(4,3)
C
      RETURN
      END
         
**** SOURCE FILE : EVDAFS.ORG   ***
*
      SUBROUTINE EVDAFS(U,V,GEO,RESULT,MODE)
C THIS SUBROUTINE EVALUATES POINT COORDINATES AND DERIVATIVES ON
C A PATCH OF A VDAFS DEFINED SURFACE. SUBROUTINE BIPROD IS CALLED
C FOR BASIC BILINEAR MATRIX PRODUCT EVALUATION.
C SUBROUTINE CVDAFS ORGANISES ENTIRE COMPUTATION EVDAFS CHECKS INPUT DAT
      DOUBLE PRECISION U,V,RESULT(4,8),GEO(*),AX(625),AY(625),AZ(625)
      DOUBLE PRECISION CU(25),CV(25)
      INTEGER MODE,MU,MV
      MU=INT(GEO(1))
      MV=INT(GEO(2))
      N=MU*MV
      IF(MU.GT.25.OR.MV.GT.25) THEN
         PRINT*,' DEGREE U OR DEGREE V TOO LARGE FOR ARRAY DIMENSIONS'
         RETURN
      ENDIF
      CALL CVDAFS(U,V,GEO,RESULT,MODE,MU,MV,N,AX,AY,AZ,CU,CV)
      RETURN
      END
         
      SUBROUTINE CVDAFS(U,V,GEO,RESULT,MODE,MU,MV,N,AX,AY,AZ,CU,CV)
C THIS SUBROUTINE PERFORMS ALL BASIC EVALUATION COMPUTATIONS ON VDA SURF
      DOUBLE PRECISION U,V,X,Y,Z,RES(3),AX(N),AY(N),AZ(N),CU(MU)
      DOUBLE PRECISION CV(MV),GEO(*),RESULT(4,8)
      INTEGER MU,MV,N,I,J
C MU=DEGREE+1 IN U, MV=DEGREE+1 IN V FOR THIS PATCH, COEFF MAT IS MU*MV.
C     N=MU*MV
C SET UP COEFFICIENT MATRICES.
      DO 10 I=1,N
      AX(I)=GEO(I+2)
      AY(I)=GEO(I+2+N)
 10   AZ(I)=GEO(I+2+2*N)
C INITIALISE RESULT ARRAY USED TO RETURN POINT ADD DERIVATIVE DATA.
      DO 15 I=1,4
      DO 15 J=1,8
  15  RESULT(I,J)=0.0
      DO 20 I=1,MU
 20   CU(I)=1.0
      DO 30 I=1,MV
 30   CV(I)=1.0
C EVALUATE POINT COORDINATES
      CALL BIPROD(AX,MU,MV,CU,CV,U,V,X)
      CALL BIPROD(AY,MU,MV,CU,CV,U,V,Y)
      CALL BIPROD(AZ,MU,MV,CU,CV,U,V,Z)
      RESULT(1,1)=X
      RESULT(2,1)=Y
      RESULT(3,1)=Z
      RESULT(4,1)=1.0
      IF(MODE.EQ.0) RETURN
C MODE=0 INDICATES THAT ONLY POINT COORDINATES ARE REQUIRED.
C EVALUATE FIRST DERIVATIVES, STORE IN COLS 2 AND 3 OF RESULT.
      DO 40 I=2,MU
 40   CU(I)=I-1.0
      CU(1)=0.0
      CALL BIPROD(AX,MU,MV,CU,CV,U,V,RES(1))
      CALL BIPROD(AY,MU,MV,CU,CV,U,V,RES(2))
      CALL BIPROD(AZ,MU,MV,CU,CV,U,V,RES(3))
      DO 50 I=1,3
 50   RESULT(I,2)=RES(I)
      DO 60 I=1,MU
 60   CU(I)=1.0
      DO 70 I=2,MV
 70   CV(I)=I-1.0
      CV(1)=0.0
      CALL BIPROD(AX,MU,MV,CU,CV,U,V,RES(1))
      CALL BIPROD(AY,MU,MV,CU,CV,U,V,RES(2))
      CALL BIPROD(AZ,MU,MV,CU,CV,U,V,RES(3))
      DO 80 I=1,3
 80   RESULT(I,3)=RES(I)
C EVALUATE MIXED DERIVATIVE (TWIST VECTOR), COL 5 OF RESULT.
      DO 90 I=2,MU
 90   CU(I)=I-1.0
      CU(1)=0.0
      CALL BIPROD(AX,MU,MV,CU,CV,U,V,RES(1))
      CALL BIPROD(AY,MU,MV,CU,CV,U,V,RES(2))
      CALL BIPROD(AZ,MU,MV,CU,CV,U,V,RES(3))
      DO 95 I=1,3
 95   RESULT(I,5)=RES(I)
      IF(MU.LE.2) GO TO 135
C 2ND DERIVATIVE ZERO IF U DEGREE=1
C EVALUATE 2ND DERIVATIVES, STORE IN COLS 4,6 OF RESULT.
      DO 110 I=3,MU
 110  CU(I)=CU(I)*(I-2.0)
      CU(2)=0.0
      DO 120 I=1,MV
 120  CV(I)=1.0
      CALL BIPROD(AX,MU,MV,CU,CV,U,V,RES(1))
      CALL BIPROD(AY,MU,MV,CU,CV,U,V,RES(2))
      CALL BIPROD(AZ,MU,MV,CU,CV,U,V,RES(3))
      DO 130 I=1,3
 130  RESULT(I,4)=RES(I)
 135  CONTINUE
      IF(MV.LE.2) GO TO 165
      DO 140 I=1,MU
 140  CU(I)=1.0
      DO 150 I=3,MV
 150  CV(I)=(I-1.0)*(I-2.0)
      CV(2)=0.0
      CV(1)=0.0
      CALL BIPROD(AX,MU,MV,CU,CV,U,V,RES(1))
      CALL BIPROD(AY,MU,MV,CU,CV,U,V,RES(2))
      CALL BIPROD(AZ,MU,MV,CU,CV,U,V,RES(3))
      DO 160 I=1,3
 160  RESULT(I,6)=RES(I)
 165  CONTINUE
C COMPUTE NORMAL AND UNIT NORMAL, STORE IN COLS 7,8 OF RESULT.
      RESULT(1,7)=RESULT(2,2)*RESULT(3,3)-RESULT(3,2)*RESULT(2,3)
      RESULT(2,7)=RESULT(3,2)*RESULT(1,3)-RESULT(1,2)*RESULT(3,3)
      RESULT(3,7)=RESULT(1,2)*RESULT(2,3)-RESULT(2,2)*RESULT(1,3)
      X=0.0
      DO 170 I=1,3
 170  X=X+RESULT(I,7)*RESULT(I,7)
      X=DSQRT(X)
      IF(X.LT.1.0E-8) RETURN
C NORMAL VECTOR IS NOT WELL DEFINED IF X(VECTOR LENGTH) SMALL.
      DO 180 I=1,3
 180  RESULT(I,8)=RESULT(I,7)/X
      RESULT(4,8)=1.0
C RESULT(4,8)=1 INDICATES A WELL DEFINED UNIT NORMAL IN COL 8.
      RETURN
      END
         
         
      SUBROUTINE BIPROD(A,MU,MV,CU,CV,U,V,RES)
C SUBROUTINE TO EVALUATE BILINEAR PRODUCT (PU)'A(PV), WHERE PU, PV ARE
C POWER SERIES WITH COEFFICIENTS CU,CV; LEADIONG 0.0 COEFFICIENTS INDICA
C DERIVATIVE TERMS OF LOWER DEGREE. FINAL (SCALAR) PRODUCT IS RETURNED A
      DOUBLE PRECISION A(MU,MV),CU(MU),CV(MV),U,V,RES,SUM
      INTEGER I,J,MU,MV
      RES=0.0
      DO 20 I=MU,1,-1
      IF(CU(I).LE.0.0) GO TO 30
      SUM=0.0
      DO 10 J=MV,1,-1
      IF(CV(J).LE.0.0) GO TO 15
  10  SUM=SUM*V+CV(J)*A(I,J)
  15  CONTINUE
  20  RES=RES*U+SUM*CU(I)
  30  CONTINUE
C RES NOW CONTAINS THE EVALUATED PRODUCT (PU)'A(PV) AT PARAMETRIC POINT
C THIS WILL CORRESPOND TO A POINT COORDINATE OR A DERIVATIVE VECTOR COMP
      RETURN
      END
**** SOURCE FILE : TVDAFS.ORG   ***
*
      SUBROUTINE TVDAFS(TRM,GEO)
C TRANSFORMATOR ROUTINE FOR VDAFS SURFACE PATCH USING
C APT TRANSFORMATION MATRIX TRM
      DOUBLE PRECISION TRM(4,3),GEO(*),A(3)
      MU=INT(GEO(1))
      MV=INT(GEO(2))
      N=MU*MV
C 1ST 2 LOCATIONS OF GEO CONTAIN DIMENSIONS OF ARRAYS AX,AY,AZ OF COEFFI
C THESE COEFFICIENT MATRICES FOLLOW IN CONSECUTIVE LOCATIONS IN GEO.
C ALL COEFFICIENT VECTORS MUST BE ROTATED.
      DO 10 I=1,N
      IX=2+I
      IY=IX+N
      IZ=IY+N
      DO 5 J=1,3
  5   A(J)=TRM(1,J)*GEO(IX)+TRM(2,J)*GEO(IY)+TRM(3,J)*GEO(IZ)
      GEO(IX)=A(1)
      GEO(IY)=A(2)
      GEO(IZ)=A(3)
 10   CONTINUE
C (0,0) COEFFICIENT IN EACH ARRAY IS ALSO TRANSLATED
      GEO(3)=GEO(3)+TRM(4,1)
      GEO(3+N)=GEO(3+N)+TRM(4,2)
      GEO(3+2*N)=GEO(3+2*N)+TRM(4,3)
      RETURN
      END
