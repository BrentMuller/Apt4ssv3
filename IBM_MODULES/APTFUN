**** SOURCE FILE : UTILTY00.ORG   ***
*
*
*
*  * UTILTY PACKAGE *  VAX11 VERSION  6.6.85  E.MCLELLAN
*
*
*  * ABSF *
*
*
      SUBROUTINE ABSF(RES,ARG)
C
      DOUBLE PRECISION RES,ARG
C
      RES=DABS(ARG)
      RETURN
      END
*
*  * ATANF *
*
      SUBROUTINE ATANF(RES,ARG)
C
      DOUBLE PRECISION RES,ARG
C
      RES=DATAN(ARG)/0.0174532925
      RETURN
      END
*
*  * COSF *
*
      SUBROUTINE COSF(RES,ARG)
C
      DOUBLE PRECISION RES,ARG
C
      RES=DCOS(ARG*0.0174532925)
      RETURN
      END
*
*  * SINF *
*
      SUBROUTINE SINF(RES,ARG)
C
      DOUBLE PRECISION RES,ARG
C
      RES=DSIN(ARG*0.0174532925)
      RETURN
      END
*
*  EXPF *
*
      SUBROUTINE EXPF(RES,ARG)
C
      DOUBLE PRECISION RES,ARG
C
      RES=DEXP(ARG)
      RETURN
      END
*
*  * SQRTF *
*
      SUBROUTINE SQRTF(RES,ARG)
C
      DOUBLE PRECISION RES,ARG
C
      IF (ARG.LT.0.0D0) THEN
        CALL ERROR(20,'SQRTF   ')
        ARG=DABS(ARG)
      END IF
      RES=DSQRT(ARG)
      RETURN
      END
*
*  * VNORM *
*
*  PURPOSE    NORMALIZE A VECTOR   V3=NORM(VA)
*
*  CALLING SEQUENCE
*
*             CALL VNORM(VA,V3)
*
      SUBROUTINE VNORM(VA,V3)
C
      INCLUDE (IFXCOR)    
C
      INCLUDE (FXCOR)    
C
      DOUBLE PRECISION VA(3),V3(3)
C
      VTEM=DSQRT(VA(1)*VA(1)+VA(2)*VA(2)+VA(3)*VA(3))
      IF (DABS(VTEM).LT.1.0E-24) THEN
        IER=1
        DO 25 I=1,3
          V3(I)=VA(I)
   25   CONTINUE
C
      ELSE
        IER=0
        DO 26 I=1,3
          V3(I)=VA(I)/VTEM
   26   CONTINUE
C
      END IF
C
      RETURN
      END
*
*  * CROSS *
*
*  PURPOSE    EVALUATE V3=V1 X V2
*
*  CALLING SEQUENCE
*
*             CALL CROSS(V1,V2,V3)
*
      SUBROUTINE CROSS(V1,V2,V3)
C
      DOUBLE PRECISION V1(3),V2(3),V3(3),VT(3)
C
      VT(1)=V1(2)*V2(3)-V1(3)*V2(2)
      VT(2)=V1(3)*V2(1)-V1(1)*V2(3)
      VT(3)=V1(1)*V2(2)-V1(2)*V2(1)
C
      DO 10 I=1,3
      V3(I)=VT(I)
  10  CONTINUE
C
      RETURN
      END
*
*  * CROSSV *
*
*  PURPOSE    EVALUATE CROSS PRODUCT AND NORMALIZE
*
*  CALLING SEQUENCE
*
*             CALL CROSSV(V1,V2,V3)
*
      SUBROUTINE CROSSV(V1,V2,V3)
C
      DOUBLE PRECISION V1(3),V2(3),V3(3),VT(3)
C
      CALL CROSS(V1,V2,VT)
C
      CALL VNORM(VT,V3)
C
      RETURN
      END
*
*
*  * DOTV *
*
*  PURPOSE    EVALUATE DOT PRODUCT   RES=V1.V2
*
*  CALLING SEQUENCE
*
*             CALL DOTV(RES,V1,V2)
*
      SUBROUTINE DOTV(RES,V1,V2)
C
      DOUBLE PRECISION RES,V1(3),V2(3)
C
      RES=V1(1)*V2(1)+V1(2)*V2(2)+V1(3)*V2(3)
C
      RETURN
      END
**** SOURCE FILE : M0002914.V03   ***
*
C.....FORTRAN SUBROUTINE              ANGLF/ANBLB          18.10.78 EC
C
C              FORTRAN SUBROUTINE ANGLF
C PURPOSE      TO COMPUTE THE ANGLE BETWEEN THE POSITIVE X-AXIS AND A
C              VECTOR FROM THE CENTER OF A CIRCLE TO A GIVEN POINT
C
C LINKAGE      CALL ANGLF(RES,ARG1,ARG2)
C
C ARGUMENTS    RES     ARRAY TO CONTAIN RESULT
C              ARG1    ARRAY CONTAINING THE CANONICAL FORM
C                      OF THE INPUT
C              ARG2    ARRAY CONTAINING THE CANONICAL FORM
C                      OF THE INPUT
C
C SUBSIDIARIES TYPE                ENTRY
C              LOGICAL FUNCTION    CKDEF
C              SUBROUTINE          UNPACK
C              REAL FUNCTION       DATAN2
C              REAL FUNCTION       DARCOS
C              REAL FUNCTION       DSQRT
C              REAL FUNCTION       DABS
C              REAL FUNCTION       DMIN1
C              REAL FUNCTION       DMAX1
C              SUBROUTINE          ERROR
C              SUBROUTINE          UNDEF
C              SUBROUTINE          TRANSF
C
      SUBROUTINE ANGLF(RES,ARG1,ARG2)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DIMENSION ARG1(1),ARG2(1),SR(2),A1(12),A2(12),RES(1)
      LOGICAL CKDEF
      INTEGER IR(20),IW(20)
      DOUBLE PRECISION FACT
C SCHALTANGABE FUER TRANSFORMATIONSROUTINE TRANSF
      DATA IR/4,4,5,5,2,1,1,1,5,1,0,0,0,1,0,0,0,0,2,3/
C SCHALTZIFFERN FUER ANGLF-AUFGABENERKENNUNG
      DATA IW/1,1,2,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,2,1/
      DATA FACT/.0174532925D0/
C
C
    1 IF(CKDEF(ARG1).OR.CKDEF(ARG2))GO TO 30
      CALL UNPACK(ARG1,MODE1,ISIZE1,ISUB1)
      IF(MODE1.LE.0.OR.MODE1.GT.20.OR.IR(MODE1).EQ.0)GOTO 30
      CALL UNPACK(ARG2,MODE2,ISIZE2,ISUB2)
      IF(MODE2.LE.0.OR.MODE2.GT.20.OR.IR(MODE2).EQ.0)GOTO 30
      IWW=IW(MODE1)*IW(MODE2)
      GOTO (10,9,9,20),IWW
    9 GOTO 30
C   WINKEL ZWISCHEN VEKTOREN (AUCH EBENEN-NORMALEN)
   10 B1=0.D0
      B2=0.D0
      B3=0.D0
      DO 11 I=1,3
      B1=ARG1(I)*ARG1(I)+B1
      B2=ARG2(I)*ARG2(I)+B2
   11 B3=ARG1(I)*ARG2(I)+B3
      IF(B1.LT.1.D-12.OR.B2.LT.1.D-12)GOTO 30
      RES(1)=B3/DSQRT(B1)/DSQRT(B2)
      RES(1)=DMAX1(-1.D0,RES(1))
      RES(1)=DMIN1( 1.D0,RES(1))
      RES(1)=DARCOS(RES(1))
      GOTO 25
C    2-D-VERARBEITUNG,WINKEL ZUR POSITIVEN X-ACHSE
   20 CALL TRANSF (A1,ARG1,IR(MODE1),ISIZE1,0)
      CALL TRANSF (A2,ARG2,IR(MODE2),ISIZE2,0)
      SR(1)=A2(1)-A1(1)
      SR(2)=A2(2)-A1(2)
      IF(DABS(SR(1))+DABS(SR(2)).LT.D-12)GOTO 30
      RES(1)=DATAN2(SR(2),SR(1))
      IF(RES(1).LT.0.D0) RES(1)=RES(1)+6.283185306D0
   25 RES(1)=RES(1)/FACT
      RETURN
C  'MINDESTENS EINE EINGABE IST UNDEFINIERT ODER ERGEBNIS NICHT
C                                                   BERECHENBAR'
   30 CALL ERROR(80,'ANGLF   ')
      RES(1)=0.D0
      RETURN
      END
C
C              FORTRAN SUBROUTINE ANGLB
C PURPOSE      TO COMPUTE THE ANGLE BETWEEN THE POSITIVE X-AXIS AND A
C              VECTOR FROM THE CENTER OF A CIRCLE TO A GIVEN POINT
C
C LINKAGE      CALL ANGLB(RES,ARG1,ARG2)
C
C ARGUMENTS    RES     ARRAY TO CONTAIN RESULT
C              ARG1    ARRAY CONTAINING THE CANONICAL FORM
C                      OF THE INPUT
C              ARG2    ARRAY CONTAINING THE CANONICAL FORM
C                      OF THE INPUT
C
C SUBSIDIARIES TYPE                ENTRY
C              LOGICAL FUNCTION    CKDEF
C              SUBROUTINE          UNPACK
C              REAL FUNCTION       DATAN2
C              REAL FUNCTION       DARCOS
C              REAL FUNCTION       DSQRT
C              REAL FUNCTION       DABS
C              REAL FUNCTION       DMIN1
C              REAL FUNCTION       DMAX1
C              SUBROUTINE          ERROR
C              SUBROUTINE          UNDEF
C              SUBROUTINE          TRANSF
C
      SUBROUTINE ANGLB(RES,ARG1,ARG2)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DIMENSION ARG1(1),ARG2(1),SR(2),A1(12),A2(12),RES(1)
      LOGICAL CKDEF
      INTEGER IR(20),IW(20)
C SCHALTANGABE FUER TRANSFORMATIONSROUTINE TRANSF
      DATA IR/4,4,5,5,2,1,1,1,5,1,0,0,0,1,0,0,0,0,2,3/
C SCHALTZIFFERN FUER ANGLB-AUFGABENERKENNUNG
      DATA IW/1,1,2,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,2,1/
C
C
    1 IF(CKDEF(ARG1).OR.CKDEF(ARG2))GO TO 30
      CALL UNPACK(ARG1,MODE1,ISIZE1,ISUB1)
      IF(MODE1.LE.0.OR.MODE1.GT.20.OR.IR(MODE1).EQ.0)GOTO 30
      CALL UNPACK(ARG2,MODE2,ISIZE2,ISUB2)
      IF(MODE2.LE.0.OR.MODE2.GT.20.OR.IR(MODE2).EQ.0)GOTO 30
      IWW=IW(MODE1)*IW(MODE2)
      GOTO (10,9,9,20),IWW
    9 GOTO 30
C   WINKEL ZWISCHEN VEKTOREN (AUCH EBENEN-NORMALEN)
   10 B1=0.D0
      B2=0.D0
      B3=0.D0
      DO 11 I=1,3
      B1=ARG1(I)*ARG1(I)+B1
      B2=ARG2(I)*ARG2(I)+B2
   11 B3=ARG1(I)*ARG2(I)+B3
      IF(B1.LT.1.D-12.OR.B2.LT.1.D-12)GOTO 30
      RES(1)=B3/DSQRT(B1)/DSQRT(B2)
      RES(1)=DMAX1(-1.D0,RES(1))
      RES(1)=DMIN1( 1.D0,RES(1))
      RES(1)=DARCOS(RES(1))
      GOTO 25
C    2-D-VERARBEITUNG,WINKEL ZUR POSITIVEN X-ACHSE
   20 CALL TRANSF (A1,ARG1,IR(MODE1),ISIZE1,0)
      CALL TRANSF (A2,ARG2,IR(MODE2),ISIZE2,0)
      SR(1)=A2(1)-A1(1)
      SR(2)=A2(2)-A1(2)
      IF(DABS(SR(1))+DABS(SR(2)).LT.D-12)GOTO 30
      RES(1)=DATAN2(SR(2),SR(1))
      IF(RES(1).LT.0.D0) RES(1)=RES(1)+6.283185306D0
   25 CONTINUE
      RETURN
C  'MINDESTENS EINE EINGABE IST UNDEFINIERT ODER ERGEBNIS NICHT
C                                                   BERECHENBAR'
   30 CALL ERROR(80,'ANGLB   ')
      RES(1)=0.D0
      RETURN
      END
**** SOURCE FILE : M0002892.V07   ***
*
C
C.... FORTRAN SUBROUTINE   NEW FUNCTIONS                  16/10/78EC
C
C
C
      SUBROUTINE LOGF (RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      DOUBLE PRECISION NEG
      INTEGER INEG(2)
      EQUIVALENCE (NEG,INEG(1))
      DATA INEG/-1,-1/
      A=ARG(1)
      IF(A)1,2,3
    1 A=-A
C      'NEGATIVE LOGARITHM-ARGUMENT;CONTINUING WITH POSITIVE ARGUMENT'
      CALL ERROR(20,'LOGF    ')
    3 RES(1)=DLOG(A)
      RETURN
C      'LOGARITHM-ARGUMENT ZERO;RESULT IS A NEGATIVE NUMBER'
    2 CALL ERROR(37,'LOG10F  ')
      RES(1)=NEG
      END
C
C
      SUBROUTINE LOG10F (RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      DOUBLE PRECISION NEG
      INTEGER INEG(2)
      EQUIVALENCE (NEG,INEG(1))
      DATA INEG/-1,-1/
      A=ARG(1)
      IF(A)4,2,5
    4 A=-A
C      'NEGATIVE LOGARITHM-ARGUMENT;CONTINUING WITH POSITIVE ARGUMENT'
      CALL ERROR(36,'LOG10F  ')
    5 RES(1)=DLOG10(A)
      RETURN
C      'LOGARITHM-ARGUMENT ZERO;RESULT IS A NEGATIVE NUMBER'
    2 CALL ERROR(37,'LOG10F  ')
      RES(1)=NEG
      RETURN
      END
C
C
      SUBROUTINE TANF(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      DATA FACT/.0174532925D0/
      A=ARG(1)*FACT
      RES(1)=DTAN(A)
      RETURN
      END
C
C
      SUBROUTINE TANB(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      A=ARG(1)
      RES(1)=DTAN(A)
      RETURN
      END
C
C
      SUBROUTINE COTANF(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      DATA FACT/.0174532925D0/
      A=ARG(1)*FACT
      RES(1)=DCOTAN(A)
      RETURN
      END
C
C
      SUBROUTINE COTANB(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      A=ARG(1)
      RES(1)=DCOTAN(A)
      RETURN
      END
C
C
      SUBROUTINE SINB(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      RES(1)=DSIN(ARG(1))
      RETURN
      END
C
C
      SUBROUTINE COSB(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      RES(1)=DCOS(ARG(1))
      RETURN
      END
C
C
      SUBROUTINE ATANB(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      RES(1)=DATAN(ARG(1))
      RETURN
      END
C
C
      SUBROUTINE ARSINF(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      DATA FACT/.0174532925D0/
      IF(DABS(ARG(1)).LE.1.D0)GOTO 9
C    'ARSINF-ARCOSF ARGUMENT ABSOLUTE GREATER 1.:RESULT 0.'
      CALL ERROR(38,'ARSINF  ')
      RES(1)=0.D0
      RETURN
    9 RES(1)=DARSIN(ARG(1))
      RES(1)=RES(1)/FACT
      RETURN
      END
C
C
      SUBROUTINE ARSINB(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      IF(DABS(ARG(1)).LE.1.D0)GOTO 9
C    'ARSINF-ARCOSF ARGUMENT ABSOLUTE GREATER 1.:RESULT 0.'
      CALL ERROR(38,'ARSINB  ')
      RES(1)=0.D0
      RETURN
    9 RES(1)=DARSIN(ARG(1))
      RETURN
      END
C
C
      SUBROUTINE ARCOSF(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      DATA FACT/.0174532925D0/
      IF(DABS(ARG(1)).LE.1.D0)GOTO 11
C    'ARSINF-ARCOSF ARGUMENT ABSOLUTE GREATER 1.:RESULT 0.'
      CALL ERROR(38,'ARCOSF  ')
      RES(1)=0.D0
      RETURN
   11 RES(1)=DARCOS(ARG(1))
      RES(1)=RES(1)/FACT
      RETURN
      END
C
C
      SUBROUTINE ARCOSB(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      DATA FACT/.0174532925D0/
      IF(DABS(ARG(1)).LE.1.D0)GOTO 11
C    'ARSINF-ARCOSF ARGUMENT ABSOLUTE GREATER 1.:RESULT 0.'
      CALL ERROR(38,'ARCOSB  ')
      RES(1)=0.D0
      RETURN
   11 RES(1)=DARCOS(ARG(1))
      RETURN
      END
C
C
      SUBROUTINE SINHF(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      RES(1)=DSINH(ARG(1))
      RETURN
      END
C
C
      SUBROUTINE COSHF(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      RES(1)=DCOSH(ARG(1))
      RETURN
      END
C
C
      SUBROUTINE TANHF(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      RES(1)=DTANH(ARG(1))
      RETURN
      END
C
C
      SUBROUTINE INTF(RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      I=IDINT(ARG(1))
      RES(1)=I
      RETURN
      END
C
C
      SUBROUTINE MODF(RES,ARG,BRG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      DIMENSION BRG(1)
      RES(1)=DMOD(ARG(1),BRG(1))
      RETURN
      END
C
C
      SUBROUTINE SIGNF(RES,ARG,BRG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      DIMENSION BRG(1)
      RES(1)=DSIGN(ARG(1),BRG(1))
      RETURN
      END
C
C
      SUBROUTINE ATAN2F(RES,ARG,BRG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      DIMENSION BRG(1)
      DATA FACT/.0174532925D0/
      RES(1)=DATAN2(ARG(1),BRG(1))
      RES(1)=RES(1)/FACT
      RETURN
      END
C
C
      SUBROUTINE ATAN2B(RES,ARG,BRG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION RES(1),ARG(1)
      DIMENSION BRG(1)
      RES(1)=DATAN2(ARG(1),BRG(1))
      RETURN
      END
**** SOURCE FILE : M0002880.V03   ***
*
C.....FORTRAN SUBROUTINE             CANF....             16.10.78  EC
C
C              FORTRAN SUBROUTINE CANF
C
C ZWECK        EXTRAKTION VON KANONISCHEN ELEMENTEN
C
C VERKNUEPFUNG CALL CANF (RES, ORT, ARG)
C
C ARGUMENTE    RES     REAL VARIABLE FUER RESULTAT
C              ORT     STELLENANGABE IN DER KANONISCHEN FORM
C              ARG     FELD MIT DER KANONISCHEN FORM
C
C UNTEPROGR.:  TYPE                ENTRY
C              LOGICAL FUNCTION    CKDEF
C              SUBROUTINE          ERROR
C              SUBROUTINE          UNPACK
C              SUBROUTINE          UNDEF
C              SUBROUTINE          TRANSF
      SUBROUTINE CANF (RES,ORT,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION ARG(*),A(12),RES(*)
      INTEGER IR(20)
      LOGICAL CKDEF
      DATA IR/4,4,5,5,2,1,1,1,5,1,0,0,0,1,0,0,0,0,2,3/
C...     CHECK OB KANONISCHE FORM DEFINIERT
      IF (CKDEF(ARG)) GO TO 20
C...     KONTROLLE OB KANONISCHE FORM LANG GENUG
      I=ORT
      CALL UNPACK(ARG(1),MODE,ISIZE,ISUB)
      IF(I.LE.0)GOTO22
      IF(I.GT.ISIZE)GOTO21
C...     KONTROLLE OB TRANSFORMIERT WERDEN KANN UND TRANSFORMATION
      IF(MODE.EQ.18)GOTO 10
      IF(MODE.LE.0.OR.MODE.GT.20.OR.IR(MODE).EQ.0)GOTO 20
      CALL TRANSF (A,ARG,IR(MODE),ISIZE,0)
      RES(1)=A(I)
      RETURN
C   MATRIX-ABGRIFF
   10 RES(1)=ARG(I)
      RETURN
C
C...   'GEOMETRIE NICHT DEFINIERT'
   20 CALL ERROR( 39,'CANF    ')
      GOTO 23
C...   'KANONISCHE FORM ZU KURZ FUER INDEX ODER INDEX NICHT DEFINIERT'
   21 CALL ERROR( 40,'CANF    ')
      GOTO 23
C...   'INDEX KLEINER ODER GLEICH NULL'
   22 CALL ERROR( 41,'CANF    ')
   23 CALL UNDEF(RES(1))
      RETURN
      END
**** SOURCE FILE : M0002884.V03   ***
*
C.....FORTRAN SUBROUTINE              DISTF                16.10.78 EC
C
C              FORTRAN SUBROUTINE DISTF
C PURPOSE      DISTANCE-COMPUTATION:
C               MOD=1 PLANE/PLANE
C               MOD=2 POINT/PLANE
C               MOD=2 POINT/POINT
C
C CALL         CALL DISTF(RES,ARG1,ARG2)
C
C ARGUMENTS    RES     ARRAY FOR THE RESULT
C              ARG1    ARRAY OF FIRST ELEMENT
C              ARG2    ARRAY OF SECOND ELEMENT
C
C SUBPROGRAM   TYPE                ENTRY
C              LOGICAL FUNCTION    CKDEF
C              SUBROUTINE          ERROR
C              SUBROUTINE          UNPACK
C              DOUBLE PRECISION FUNCTION     DABS
C              SUBROUTINE          UNDEF
      SUBROUTINE DISTF(RES,ARG1,ARG2)
      DOUBLE PRECISION RES(*),ARG1(*),ARG2(*),AB,COSW
      INTEGER IENT(20)
      LOGICAL CKDEF
      DATA IENT/1,1,2,2,2,0,0,0,2,0,0,0,0,0,0,0,0,0,2,0/
      IF(CKDEF(ARG1).OR.CKDEF(ARG2))GOTO 50
      CALL UNPACK(ARG1,MODE,ISIZE,ISUB)
      IF(MODE.LT.1.OR.MODE.GT.20)GOTO 51
      IARG1=IENT(MODE)
      IF(IARG1.EQ.0)GOTO 51
      CALL UNPACK(ARG2,MODE,ISIZE,ISUB)
      IF(MODE.LT.1.OR.MODE.GT.20)GOTO 51
      IARG2=IENT(MODE)
      IF(IARG2.EQ.0)GOTO 51
      MOD=IARG1+IARG2-1
      GOTO (10,20,30),MOD
C    DISTANCE OF TWO PLANES
   10 COSW=ARG1(1)*ARG2(1)+ARG1(2)*ARG2(2)+ARG1(3)*ARG2(3)
      IF(DABS(DABS(COSW)-1.D0).GT.1.D-6)GOTO 52
      RES(1)=DABS(ARG1(4)-COSW*ARG2(4))
      RETURN
C    DISTANCE OF POINT AND PLANE
   20 AB=ARG1(4)
      IF(IARG1.EQ.2)AB=ARG2(4)
      RES(1)=ARG1(1)*ARG2(1)+ARG1(2)*ARG2(2)+ARG1(3)*ARG2(3)-AB
      RETURN
C     DISTANCE OF TWO POINTS
   30 RES(1)=DSQRT((ARG1(1)-ARG2(1))**2
     1         +(ARG1(2)-ARG2(2))**2
     2         +(ARG1(3)-ARG2(3))**2)
      RETURN
C     'ONE ELEMENT OR BOTH ARE UNDEFINED'
   50 CALL ERROR(55,'DISTF   ')
      GOTO 53
C     'WRONG INPUT'
   51 CALL ERROR(61,'DISTF   ')
      GOTO 53
C     'PLANES NOT PARALLEL'
   52 CALL ERROR(62,'DISTF   ')
   53 CALL UNDEF(RES(1))
      RETURN
      END
**** SOURCE FILE : M0002836.V02   ***
*
C.....FORTRAN SUBROUTINE             DOTF.....              5/1/68   GK
C                      THE FIRST INPUT VECTOR
C              ARG2    ARRAY CONTAINING THE CANONICAL FORM OF
C                      THE SECOND INPUT VECTOR
C
C SUBSIDIARIES TYPE                ENTRY
C              LOGICAL FUNCTION    CKDEF
C              SUBROUTINE          ERROR
C
      SUBROUTINE DOTF (RESULT,ARG1,ARG2)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION ARG1(3),ARG2(3),DS(6)
      DOUBLE PRECISION DS
      LOGICAL CKDEF
C
C
C
      INCLUDE (TOTAL)    
      INCLUDE (ZNUMBR)    
      INCLUDE (KNUMBR)    
C
      IF (CKDEF(ARG1).OR.CKDEF(ARG2)) GO TO 20
C
C...     MOVE ARGUMENTS TO DOUBLE PRECISION SCRATCH LOCATIONS
C
C
      DO 10 I=1,3
      DS(I)=ARG1(I)
      DS(I+3)=ARG2(I)
   10 CONTINUE
C
C...     COMPUTE DOT PRODUCT
C
      RESULT = DS(1)*DS(4) +DS(2)*DS(5) +DS(3)*DS(6)
      GO TO 9
C
C...     ISSUE DIAGNOSTIC, INPUT UNDEFINED, RESULT=0
C
   20 CALL ERROR (10,'DOTF   ')
      RESULT = Z0
    9 RETURN
       END
**** SOURCE FILE : M0002848.V02   ***
*
C.....FORTRAN SUBROUTINE             LNTHF....              3/1/68   GK
C
C              FORTRAN SUBROUTINE LNTHF
C
C PURPOSE      TO COMPUTE THE LENGTH OF A VECTOR.
C
C LINKAGE      CALL LNTHF (RES, ARG)
C
C ARGUMENTS    RES     REAL VARIABLE TO CONTAIN THE RESULT
C              ARG     ARRAY CONTAINING THE CANONICAL FORM OF
C                      THE INPUT VECTOR
C
C SUBSIDIARIES TYPE                ENTRY
C              LOGICAL FUNCTION    CKDEF
C              SUBROUTINE          ERROR
C              REAL FUNCTION       SQRT
      SUBROUTINE LNTHF (RES,ARG)
      IMPLICIT DOUBLE PRECISION (A-H),DOUBLE PRECISION (O-Z)
      DIMENSION ARG(3)
      LOGICAL CKDEF
C
C
C
      INCLUDE (TOTAL)    
      INCLUDE (ZNUMBR)    
      INCLUDE (KNUMBR)    
C
C
C
C...     CHECK DEFINITION OF INPUT VECTOR
C
      IF (CKDEF(ARG)) GO TO 20
C
C...     COMPUTE LENGTH OF VECTOR
C
      RES=DSQRT(ARG(1)**2+ARG(2)**2+ARG(3)**2)
      GO TO 9
C
C...     DIAGNOSE UNDEFINED INPUT
C
   20 CALL ERROR( 56,'LNTHF   ')
      RES= Z0
    9 RETURN
       END
**** SOURCE FILE : MINF0000.ORG   ***
*
      SUBROUTINE MINF(PTABLE)
*
*  * MINF *   VAX11 FORTRAN VERSION  29.8.86  E.MCLELLAN
*
*  PURPOSE    TO FIND THE MINIMUM VALUE OF ITEMS IN UNLABELLED
*             COMMON REFERENCED BY THE PARAMETER LIST
*  CALLING SEQUENCE
*             CALL MINF(PTABLE)
*  ARGUMENTS
*             PTABLE    PARAMETER LIST
*
C      UNLABELED COMMON
C
      INCLUDE (BLANKCOM)    
C
      DIMENSION PTABLE(50)
      DOUBLE PRECISION RESULT
      INTEGER PTABLE,TERM
C
      DATA TERM/-999/
C
C
      RESULT=COM(PTABLE(3))
      I=4
   10 IF (COM(PTABLE(I)).LT.RESULT)RESULT=COM(PTABLE(I))
      I=I+1
      IF (PTABLE(I).NE.TERM) GOTO 10
      COM(PTABLE(2))=RESULT
      RETURN
      END
C
C
C
      SUBROUTINE MAXF(PTABLE)
*
*  * MAXF *   VAX11 FORTRAN VERSION  29.8.86  E.MCLELLAN
*
*  PURPOSE    TO FIND THE MAXIMUM VALUE OF ITEMS IN UNLABELLED
*             COMMON REFERENCED BY THE PARAMETER LIST
*  CALLING SEQUENCE
*             CALL MAXF(PTABLE)
*  ARGUMENTS
*             PTABLE    PARAMETER LIST
*
C      UNLABELED COMMON
C
      INCLUDE (BLANKCOM)    
C
      DIMENSION PTABLE(50)
      DOUBLE PRECISION RESULT
      INTEGER PTABLE,TERM
C
      DATA TERM/-999/
C
C
      RESULT=COM(PTABLE(3))
      I=4
   20 IF (COM(PTABLE(I)).GT.RESULT)RESULT=COM(PTABLE(I))
      I=I+1
      IF (PTABLE(I).NE.TERM) GOTO 20
      COM(PTABLE(2))=RESULT
      RETURN
      END
**** SOURCE FILE : M0011451.V08   ***
*
C
C...  FORTRAN SUBROUTINE     NUMF1
C
C PURPOSE      TO DETERMINE THE NUMBER OF POINTS IN A PATERN,SCURV,SSURF
C              OR PREVIOUS CL DATA
C
C LINKAGE      CALL NUMF1(RESULT,PAT)
C              CALL NUMF2(RESULT,PAT,ARG2)
C
C ARGUMENTS    RESULT  REAL VARIABLE TO CONTAIN THE RESULTING
C                      NUMBER OF POINTS
C              PAT     ARRAY CONTAINING THE I.C.F. OF THE PATERN
C              OR BCD 'CLDATA'
C
C SUBSIDIARIES TYPE                ENTRY
C              SUBROUTINE          APT094
C              LOGICAL FUNCTION    CKDEF
C              SUBROUTINE          ERROR
C
      SUBROUTINE NUMF1(RESULT,PAT)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DIMENSION RESULT(1),PAT(1)
C
C
      INCLUDE (TOTAL)    
C...  REFERENCE TO LOCAL VARIABLE, IS, CHANGED TO ISIZE,
C...  BECAUSE IS OCCURS IN IFXCOR.INC
      INCLUDE (IFXCOR)    
C
C
      LOGICAL CKDEF
      INCLUDE (BLANKCOM)    
C
      CHARACTER*8 HCLDA,TEST
      DATA HCLDA /'CLDATA  '/
C
      CALL HOLFRM (PAT(1),TEST,1,8,NWD)
      IF(TEST.EQ.HCLDA) GO TO 95
    1 IF(CKDEF(PAT))GO TO 90
      CALL UNPACK(PAT(1),MODE,ISIZE,ISUB)
      IF(MODE.NE.26.AND.MODE.NE.29.AND.MODE.NE.30)GOTO 90
C
C          MOVE THE EXTERNAL CANONICAL FORM TO  CANON
C
      CALL APT094(3,PAT,ILOC)
      IF(CKDEF(PAT))GO TO 90
      IF(MODE.NE.26)GOTO 20
C
C  NUMBER OF POINTS IS NOW IN CANON(ILOC+3)  (PATERN)
C
      RESULT(1)=CANON(ILOC+3)
C
      RETURN
C
C  COMPUTATIONS
C      SCURV ?
   20 IF(MODE.NE.30)GOTO 30
C         SCURV GIVEN
C  OUTPUT NUMBER OF ARCS WITH >NUMF(C)<
   21 RESULT(1)=CANON(ILOC+3)
      RETURN
C      SSURF ?
   30 IF(MODE.NE.29)GOTO 90
C         SSURF GIVEN
C  OUTPUT NUMBER OF PATCHES WITH >NUMF(S)<
   31 RESULT(1)=CANON(ILOC+3)
      RETURN
C
C   OUTPUT OF NUMBER OF POINTS IN LAST CUTTER PATH WITH >NUMF(CLDATA)<
C
   95 RESULT(1) = NUMCNT
      RETURN
C
C     USED GEOMETRY UNDEFINED OR WRONG INPUT
C
   90 CALL ERROR(36,'NUMF1   ')
  120 RESULT(1)=0.D0
      RETURN
C
C     ERROR DIAGNOSTIC 96
C     CLDAT SECTION NOT FOUND OR NOT CLOSED
  110 CALL ERROR(96,'NUMF1   ')
      GOTO 120
C
      END
C
      SUBROUTINE NUMF2(RESULT,PAT,ARG2)
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
      DIMENSION RESULT(1),PAT(1),ARG2(1)
C
C
      INCLUDE (TOTAL)    
C...  REFERENCE TO LOCAL VARIABLE, IS, CHANGED TO ISIZE,
C...  BECAUSE IS OCCURS IN IFXCOR.INC
      INCLUDE (IFXCOR)    
C
      INCLUDE (CLDT)    
C
      LOGICAL CKDEF
      INCLUDE (BLANKCOM)    
C
      CHARACTER*8 HCLDA,ARC,SEG,PATCH,SPLINE,CRSSPL,TEST1,TEST2
      DATA HCLDA /'CLDATA  '/
      DATA ARC   /'ARC     '/
      DATA SEG   /'SEG     '/
      DATA PATCH /'PATCH   '/
      DATA SPLINE/'SPLINE  '/
      DATA CRSSPL/'CRSSPL  '/
C
      CALL HOLFRM(PAT(1),TEST1,1,8,NWD)
      CALL HOLFRM(ARG2(1),TEST2,1,8,NWD)
      IF(TEST1.NE.HCLDA) GO TO 1
      IARG2=ARG2(1)
      DO 15 L=1,ICLCNT
      IF(IARG2.EQ.ICLTAB(1,L))GOTO 100
   15 CONTINUE
      GOTO 110
C
    1 IF(CKDEF(PAT))GO TO 90
      CALL UNPACK(PAT(1),MODE,ISIZE,ISUB)
      IF(MODE.NE.26.AND.MODE.NE.29.AND.MODE.NE.30)GOTO 90
C
C          MOVE THE EXTERNAL CANONICAL FORM TO  CANON
C
      CALL APT094(3,PAT,ILOC)
      IF(CKDEF(PAT))GO TO 90
      IF(MODE.EQ.26)GOTO 90
C
C  COMPUTATIONS
C      SCURV ?
   20 IF(MODE.NE.30)GOTO 30
C         SCURV GIVEN
      IF(TEST2.EQ.ARC)GOTO 21
      IF(TEST2.EQ.SEG)GOTO 22
      GOTO 90
C  OUTPUT NUMBER OF ARCS WITH >NUMF(C,ARC)<
   21 RESULT(1)=CANON(ILOC+3)
      RETURN
C  OUTPUT NUMBER OF SEGMENTS WITH >NUMF(C,SEG)<
   22 RESULT(1)=CANON(ILOC+7)
      IF(RESULT(1).EQ.0.D0)GOTO 90
      RETURN
C      SSURF ?
   30 IF(MODE.NE.29)GOTO 90
C         SSURF GIVEN
      IF(TEST2.EQ.PATCH)GOTO 31
C  ERROR , IF NOT MESH TYPE
      IF(CANON(ILOC+4).NE.2.D0)GOTO 90
      IF(TEST2.EQ.SPLINE)GOTO 32
      IF(TEST2.EQ.CRSSPL)GOTO 33
      GOTO 90
C  OUTPUT NUMBER OF PATCHES WITH >NUMF(S,PATCH)<
   31 RESULT(1)=CANON(ILOC+3)
      RETURN
C  OUTPUT NUMBER OF SPLINES WITH >NUMF(S,SPLINE)<
   32 RESULT(1)=CANON(ILOC+8)
      RETURN
C  OUTPUT NUMBER OF CROSS SPLINES WITH >NUMF(S,CRSSPL)<
   33 RESULT(1)=CANON(ILOC+9)
      RETURN
C
C   OUTPUT OF NUMBER OF POINTS IN LAST CUTTER PATH WITH >NUMF(CLDATA)<
C
   95 RESULT(1) = NUMCNT
      RETURN
  100 RESULT(1) = ICLTAB(2,L)
      RETURN
C
C     USED GEOMETRY UNDEFINED OR WRONG INPUT
C
   90 CALL ERROR(36,'NUMF2   ')
  120 RESULT(1)=0.D0
      RETURN
C
C     ERROR DIAGNOSTIC 96
C     CLDAT SECTION NOT FOUND OR NOT CLOSED
  110 CALL ERROR(96,'NUMF2   ')
      GOTO 120
C
      END
**** SOURCE FILE : M0004164.V08   ***
*
C   PARAMETER FETCH  ROUTINES
C   CALLABLE AFTER EXTRINSIC EXTRACTION OF POINT/VECTOR IN APT109
C
C
C  ENTRY WITH 1 ARGUMENT
C
      SUBROUTINE PARMF1(RES,ARG1)
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      DOUBLE PRECISION RES(1),ARG1(*)
C
      INCLUDE (BLANKCOM)    
C
      COMMON/PARMFC/UA,VA,PNUM,UT,US,FNAM
C
      LOGICAL CKDEF
      DOUBLE PRECISION FNAM1,RTS(3)
      CHARACTER*4 UVAL,VVAL,PVAL,TVAL,SVAL,TEST
      DOUBLE PRECISION UA,VA,PNUM,UT,US,FNAM
      DATA UVAL/'UVAL'/,VVAL/'VVAL'/,PVAL/'PVAL'/
      DATA TVAL/'TVAL'/,SVAL/'SVAL'/
C
C
      IART=1
      IF(FNAM.EQ.0.D0)GOTO 20
      CALL HOLFRM(ARG1,TEST,1,4,NWD)
      IF(TEST.EQ.UVAL)GOTO 1
      IF(TEST.EQ.VVAL)GOTO 2
      IF(TEST.EQ.PVAL)GOTO 3
      IF(TEST.EQ.TVAL)GOTO 4
      IF(TEST.EQ.SVAL)GOTO 5
C  LOOK FOR FUNCTION WITH GEOMETRY INPUT
   30 IF(CKDEF(ARG1))GO TO 21
      CALL UNPACK(ARG1(1),MODE,IS,ISUB)
      IF(MODE.NE.29.AND.MODE.NE.30)GOTO 21
C          CHECK,IF RIGHT GEOMETRY
      FNAM1=ARG1(IS+1)
      IF(ISUB.GE.1)FNAM1=ARG1(ISUB*IS+ISUB)
      IF(FNAM.NE.FNAM1)GOTO 20
C
C          MOVE THE EXTERNAL CANONICAL FORM TO  CANON
C
      CALL APT094(3,ARG1,ILOC)
      IF(CKDEF(ARG1))GO TO 21
C   SSURF ?
      IF(MODE.NE.29)GOTO 35
C   SSURF GIVEN
      GOTO 3
C    SCURV ?
   35 IF(MODE.NE.30)GOTO 21
C   SCURV GIVEN
C  OUTPUT FOR >PARMF(C)< OR >PARMF(C,PARAM)<
   36 RES(1)=US+UT-1.D0
      RETURN
C  OUTPUT FOR >PARMF(UVAL)< OR >PARMF(S,UPARAM)< (NON MESH TYPE)
    1 RES(1)=UA
      RETURN
C  OUTPUT FOR >PARMF(VVAL)< OR >PARMF(S,VPARAM)< (NON MESH TYPE)
    2 RES(1)=VA
      RETURN
C  OUTPUT FOR >PARMF(PVAL)< OR >PARMF(S,PATCH)<
    3 RES(1)=PNUM
      RETURN
C  OUTPUT FOR >PARMF(TVAL)<
    4 RES(1)=UT
      RETURN
C  OUTPUT FOR >PARMF(SVAL)<
    5 RES(1)=US
      RETURN
C    'NO PARAMETER EXISTING'
   20 CALL ERROR(42,'PARMF   ')
      GOTO 22
C    'WRONG PARMF CALL'
   21 CALL ERROR(43,'PARMF   ')
   22 RES(1)=0.D0
      RETURN
      END
C
C
C
C
C  ENTRY WITH TWO ARGUMENTS
      SUBROUTINE PARMF2(RES,ARG1,ARG2)
C
      IMPLICIT DOUBLE PRECISION(A-H),DOUBLE PRECISION(O-Z)
C
      DOUBLE PRECISION RES(1),ARG1(*),ARG2(1)
C
      INCLUDE (BLANKCOM)    
C
      COMMON/PARMFC/UA,VA,PNUM,UT,US,FNAM
C
      LOGICAL CKDEF
      DOUBLE PRECISION FNAM1,RTS(3)
      CHARACTER*8 FLOW,PARAM,UPARAM,VPARAM,PATCH,TEST
      DOUBLE PRECISION UA,VA,PNUM,UT,US,FNAM
      DATA FLOW  /'FLOW    '/
      DATA PARAM /'PARAM   '/
      DATA UPARAM/'UPARAM  '/
      DATA VPARAM/'VPARAM  '/
      DATA PATCH /'PATCH   '/
C
C
      IART=2
      IF (FNAM.EQ.0.D0) GOTO 20
      CALL HOLFRM(ARG2,TEST,1,8,NWD)
C  LOOK FOR FUNCTION WITH GEOMETRY INPUT
   30 IF(CKDEF(ARG1))GO TO 21
      CALL UNPACK(ARG1(1),MODE,IS,ISUB)
      IF(MODE.NE.29.AND.MODE.NE.30)GOTO 21
C          CHECK,IF RIGHT GEOMETRY
      FNAM1=ARG1(IS+1)
      IF(ISUB.GE.1)FNAM1=ARG1(ISUB*IS+ISUB)
      IF(FNAM.NE.FNAM1)GOTO 20
C
C          MOVE THE EXTERNAL CANONICAL FORM TO  CANON
C
      CALL APT094(3,ARG1,ILOC)
      IF(CKDEF(ARG1))GO TO 21
C   SSURF ?
      IF(MODE.NE.29)GOTO 35
C   SSURF GIVEN
      IF(TEST.EQ.PATCH )GOTO 3
C   MESH TYPE ?
      IF(CANON(ILOC+4).EQ.2.D0)GOTO 31
      IF(TEST.EQ.UPARAM)GOTO 1
      IF(TEST.EQ.VPARAM)GOTO 2
      GOTO 21
C  MESH TYPE
   31 IP=PNUM
      NU=CANON(ILOC+9)-1.D0
      IV=(IP-1)/NU
      IF(TEST.EQ.UPARAM)GOTO 32
      IF(TEST.EQ.VPARAM)GOTO 33
      GOTO 21
C  GLOBAL U-PARAMETER  >PARMF(S,UPARAM)< (MESH TYPE)
   32 IU=IP-1-IV*NU
      RES(1)=IU+UA
      RETURN
C  GLOBAL V-PARAMETER  >PARMF(S,VPARAM)< (MESH TYPE)
   33 RES(1)=IV+VA
      RETURN
C    SCURV ?
   35 IF(MODE.NE.30)GOTO 21
C   SCURV GIVEN
      IF(TEST.EQ.PARAM )GOTO 36
      IF(TEST.EQ.FLOW  )GOTO 37
C  OUTPUT FOR >PARMF(C)< OR >PARMF(C,PARAM)<
   36 RES(1)=US+UT-1.D0
      RETURN
   37 IF(CANON(ILOC+7).EQ.0.D0)GOTO 21
C  OUTPUT FOR >PARMF(C,FLOW)<
C  SEARCH IN FLOW DESCRIPTION OF NATURAL SEGMENT
      IS=US-1.D0
      IFSEG=CANON(ILOC+6)
      IFLOW1=CANON(ILOC+IFSEG-1+4*IS)
      IFLOW2=IFLOW1+(CANON(ILOC+IFSEG+4*IS)-1.D0)*4.D0
      IFLOW1=IFLOW1+ILOC-1
      IFLOW2=IFLOW2+ILOC-1
      DO 40 IFLOW=IFLOW1,IFLOW2,4
      IF(UT.GE.CANON(IFLOW+1).AND.UT.LT.CANON(IFLOW+5)) GOTO 50
   40 CONTINUE
      GOTO 21
C  COMPUTE FLOW-PARAMETER
   50 SPAN=CANON(IFLOW+4)-CANON(IFLOW)
      UA=CANON(IFLOW+1)
      UB=CANON(IFLOW+5)
      UMA=CANON(IFLOW+2)*SPAN
      UMB=CANON(IFLOW+6)*SPAN
      W1=3.D0*(UB-UA)-UMA-UMA-UMB
      W2=2.D0*(UA-UB)+UMA+UMB
      CALL GCUBIC(W2,W1,UMA,UA-UT,RTS,MN)
      IF(MN.EQ.0) GOTO 21
      DO 60 I=1,MN
      PU=RTS(I)
      IF(PU.GE.-1.D-7.AND.PU.LT.1.0000001D0) GOTO 70
   60 CONTINUE
      GOTO 21
C COMPUTE GLOBAL FLOW PARAMETER
   70 PU=CANON(IFLOW)+PU*SPAN
      ISEG1=ILOC-1+CANON(ILOC+8)
      ISEGA=CANON(ILOC+7)
      ISEG2=ISEG1+(ISEGA-1)*4
      USN=US-1.D0
      USF=0.D0
      DO 80 ISEG=ISEG1,ISEG2,4
      IF(CANON(ISEG)+CANON(ISEG+1).GT.USN) GOTO 90
      USF=USF+1.D0
   80 CONTINUE
C COMPUTE FINAL GLOBAL FLOW PARAMETER
   90 RES(1) = USF+PU
      RETURN
C  OUTPUT FOR >PARMF(UVAL)< OR >PARMF(S,UPARAM)< (NON MESH TYPE)
    1 RES(1)=UA
      RETURN
C  OUTPUT FOR >PARMF(VVAL)< OR >PARMF(S,VPARAM)< (NON MESH TYPE)
    2 RES(1)=VA
      RETURN
C  OUTPUT FOR >PARMF(PVAL)< OR >PARMF(S,PATCH)<
    3 RES(1)=PNUM
      RETURN
C  OUTPUT FOR >PARMF(TVAL)<
    4 RES(1)=UT
      RETURN
C  OUTPUT FOR >PARMF(SVAL)<
    5 RES(1)=US
      RETURN
C    'NO PARAMETER EXISTING'
   20 CALL ERROR(42,'PARMF   ')
      GOTO 22
C    'WRONG PARMF CALL'
   21 CALL ERROR(43,'PARMF   ')
   22 RES(1)=0.D0
      RETURN
      END
**** SOURCE FILE : M0002891.V03   ***
*
C.....FORTRAN SUBROUTINE              SPATF                16.10.78 EC
C
C              FORTRAN SUBROUTINE SPATF
C PURPOSE      COMPUTATION OF THE SPAT-PRODUCT OF 3 VECTORS
C
C CALLING SEQ.: CALL SPATF(RES,ARG1,ARG2,ARG3)
C
C ARGUMENTS    RES     FIELD FOR RESULT
C              ARG1    FIELD OF 1ST VECTOR
C              ARG2    FIELD OF 2ND VECTOR
C              ARG3    FIELD OF 3RD VECTOR
C
C SUBPROGRAMS  TYPE                ENTRY
C              LOGICAL FUNCTION    CKDEF
C              SUBROUTINE          ERROR
C              SUBROUTINE          UNPACK
C              SUBROUTINE          UNDEF
      SUBROUTINE SPATF(RES,ARG1,ARG2,ARG3)
      DOUBLE PRECISION RES(*),ARG1(*),ARG2(*),ARG3(*)
      LOGICAL CKDEF
      INTEGER IS(20)
      DATA IS/1,1,1,1,1,0,0,0,1,0,0,0,0,0,0,0,0,0,1,1/
      IF(CKDEF(ARG1).OR.CKDEF(ARG2).OR.CKDEF(ARG3))GOTO 30
      CALL UNPACK (ARG1,MODE,ISI,ISU)
      IF(MODE.LT.1.OR.MODE.GT.20.OR.IS(MODE).NE.1) GOTO 30
      CALL UNPACK (ARG2,MODE,ISI,ISU)
      IF(MODE.LT.1.OR.MODE.GT.20.OR.IS(MODE).NE.1) GOTO 30
      CALL UNPACK (ARG3,MODE,ISI,ISU)
      IF(MODE.LT.1.OR.MODE.GT.20.OR.IS(MODE).NE.1) GOTO 30
      RES(1)=ARG1(1)*(ARG2(2)*ARG3(3)-ARG2(3)*ARG3(2))
     1   +ARG1(2)*(ARG2(3)*ARG3(1)-ARG2(1)*ARG3(3))
     2   +ARG1(3)*(ARG2(1)*ARG3(2)-ARG2(2)*ARG3(1))
      RETURN
C     'AT LEAST ONE OF THE VECTORS UNDEFINED OR WRONG INPUT'
   30 CALL ERROR(54,'SPATF   ')
      CALL UNDEF(RES(1))
      RETURN
      END
