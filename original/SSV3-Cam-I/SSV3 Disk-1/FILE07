cat afile07
**** CREATED AT 23-MAY-1989 11:39:10.80 ****
**** FILENAME = FTORUS.FOR ****
      PROGRAM FTORUS
C
C  PURPOSE: TO DEFINE A NON-NATIVE CANONICAL FORM FOR A TORUS
C           FORMATTED TO SATISFY THE APT4 DATA STRUCTURE
C           AND STORE IT IN APT4 EXTERNAL LDA FORM
C
      DOUBLE PRECISION RESULT(4,8),TORCAN(110)
      COMMON/TOR/TORCAN
C
      COMMON/SDP/NBCHAR,NBWRD,IWRD,IFAC
C
C
C.... DEFINE TORUS CANONICAL FORM IN APT4 DATA STRUCTURE
C
      CALL DEFTOR
C
C.... OUTPUT TORUS CANONICAL FORM IN APT4 LDA EXTERNAL FILE FORMAT
C
      CALL PUNTOR
C
      STOP
      END
      BLOCK DATA SDPDAT
C
      COMMON/SDP/NBCHAR,NBWRD,IWRD,IFAC
C
C
C     NBCHAR:  NO. OF BITS PER BYTE
      DATA NBCHAR/8/
C     NBWRD:   NO. OF BITS PER WORD
      DATA NBWRD/32/
C     IWRD:    NO. OF BYTES PER WORD
      DATA IWRD/4/
C     IFAC:    BYTE LEFT SHIFT MULTIPLICATION FACTOR
      DATA IFAC/256/
C
      END
      SUBROUTINE DEFTOR
      DOUBLE PRECISION A(3),P(3),C(3),TORCAN(110),TEMP
      DOUBLE PRECISION TOT,R1,R2,UM,VM
      INTEGER ITEMP(2),BCDF
      EQUIVALENCE (TEMP,ITEMP(1))
      COMMON/TOR/TORCAN
C
C SUBROUTINE TO SET UP A CANONICAL ARRAY FOR A TORUS AS 4 PATCHES.
C
C FOR EACH PATCH DATA CONSISTS OF:
C           1-3   = AXIS OF SYMMETRY
C           4-6   = CENTRE OF TOROID
C           7-9   = REF AXIS ( START OF PARAMETERIZATION)
C           10    = MAJOR RADIUS R1
C           11    = MINOR RADIUS R2
C           12,13 = UMIN,UMAX (IN RADIANS)
C           14,15 = VMIN,VMAX (IN RADIANS)
C
      PRINT*,' '
      PRINT*,
     1' THIS PROGRAM SETS UP THE CANONICAL FORM OF A TORUS AS 4 PATCHES'
      PRINT*,' AND CREATES AN APT4 LDA EXTERNAL FILE'
      PRINT*,' '
      PRINT*,' INPUT MAJOR AND MINOR RADII OF TORUS'
      READ*,R1,R2
      PRINT*,' AXIS OF SYMMETRY VECTOR ?'
      READ*,A(1),A(2),A(3)
      PRINT*,' CENTRE OF TORUS ?'
      READ *,C(1),C(2),C(3)
      PRINT*,' REF POINT (START OF PARAMETERIZATION, IE. U=0,V=0) ?'
      READ *,P(1),P(2),P(3)
      PRINT*, 'UMAX,VMAX (IN RADIANS) ?'
      PRINT*,' NOTE: U - MINOR RADIUS DIRECTION'
      PRINT*,'       V - MAJOR RADIUS DIRECTION'
      READ*, UM,VM
C NORMALISE AXIS VECTOR
      TOT=A(1)*A(1)+A(2)*A(2)+A(3)*A(3)
      TOT=DSQRT(TOT)
      IF(TOT.LE.1.0E-6) GO TO 200
      DO 10 I=1,3
      A(I)=A(I)/TOT
 10   P(I)=P(I)-C(I)
      TOT=0.0
      DO 20 I=1,3
 20   TOT=TOT+A(I)*P(I)
      DO 30 I=1,3
  30  P(I)=P(I)-A(I)*TOT
      TOT=0.0
C P WILL NOW DEFINE THE NORMALISED REFERENCE AXIS
      DO 40 I=1,3
  40  TOT=TOT+P(I)*P(I)
      TOT=DSQRT(TOT)
      IF(TOT.LE.1.0E-6) GO TO 200
      DO 50 I=1,3
  50  P(I)=P(I)/TOT
C SET UP HEADER BLOCK
      TORCAN(2)=60.0
      TORCAN(3)=16.0
      TORCAN(4)=4.0
      TORCAN(5)=2.0
      TORCAN(6)=1.0
      TORCAN(7)=1.0
      TORCAN(8)=110.
      TORCAN(9)=3.0
      TORCAN(10)=3.0
C PATCH HEADER BLOCKS
C
C.... INSERT NON-NATIVE SURFACE TYPE NAME IN SYSTEM INDEPENDENT
C     INTERNAL FORM
      ITEMP(1)=BCDF('TORU')
      ITEMP(2)=BCDF('S   ')
      DO 60 I=11,29,6
       DO 55 J=1,3
        TORCAN(I+J)=0.0
  55   CONTINUE
       TORCAN(I+4)=TEMP
  60  CONTINUE
      TORCAN(16)=95.0
      TORCAN(22)=99.0
      TORCAN(28)=103.0
      TORCAN(34)=107.0
      TORCAN(11)=35.0
      TORCAN(17)=50.0
      TORCAN(23)=65.0
      TORCAN(29)=80.0
C PATCH GEOMETRY BLOCKS
      DO 70 I=34,79,15
       DO 65 J=1,3
        TORCAN(I+J)=A(J)
        TORCAN(I+3+J)=C(J)
        TORCAN(I+6+J)=P(J)
  65   CONTINUE
       TORCAN(I+10)=R1
       TORCAN(I+11)=R2
  70  CONTINUE
      TORCAN(46)=0.0
      TORCAN(47)=UM/2.0
      TORCAN(49)=VM/2.0
      TORCAN(48)=0.0
      TORCAN(61)=UM/2.0
      TORCAN(62)=UM
      TORCAN(63)=0.0
      TORCAN(64)=VM/2.0
      TORCAN(76)=0.0
      TORCAN(77)=UM/2.0
      TORCAN(78)=VM/2.0
      TORCAN(79)=VM
      TORCAN(91)=UM/2.0
      TORCAN(92)=UM
      TORCAN(93)=VM/2.0
      TORCAN(94)=VM
C PATCH TOPOLOGY DATA
      TORCAN(95)=0.0
      TORCAN(96)=0.0
      TORCAN(97)=2.0
      TORCAN(98)=3.0
      TORCAN(99)=0.0
      TORCAN(100)=1.0
      TORCAN(101)=0.0
      TORCAN(102)=4.0
      TORCAN(103)=1.0
      TORCAN(104)=0.0
      TORCAN(105)=4.0
      TORCAN(106)=0.0
      TORCAN(107)=2.0
      TORCAN(108)=3.0
      TORCAN(109)=0.0
      TORCAN(110)=0.0
C
      RETURN
 200  PRINT*,' AXIS VECTOR MAGNITUDE TOO SMALL'
      RETURN
      END
      SUBROUTINE PUNTOR
C
C    PURPOSE: TO OUTPUT THE APT4 FORMATTED CANONICAL FORM OF A TORUS
C             IN APT4 LDA EXTERNAL FILE FORMAT
C
      DOUBLE PRECISION TORCAN(110)
      COMMON/TOR/TORCAN
C
      COMMON/SDP/NBCHAR,NBWRD,IWRD,IFAC
C
C
      CHARACTER*6 SSNAME
      CHARACTER FILNAM*40,CSTAT*6
      CHARACTER RES*1
C
      DOUBLE PRECISION ARRAY(10)
      INTEGER IARRAY(2,10),SIZE,BCDF,ILEN,LEN,ID
      EQUIVALENCE (ARRAY(1),IARRAY(1,1))
C
      PRINT *,' APT SURFACE NAME (MAX 6 CHARACTERS) ?'
      READ (*,'(A6)') SSNAME
C
      PRINT *,' DEFAULT FILENAME : NAME.LDA - IS THIS OK (Y/N)?'
  10  READ (*,'(A1)') RES
      IF (RES.EQ.'Y') THEN
        FILNAM=SSNAME
        ILEN=6
      ELSE IF (RES.EQ.'N') THEN
        PRINT *,' FILENAME (MAX 40 CHARACTERS) ?'
        READ (*,'(A40)') FILNAM
        ILEN=40
      ELSE
        PRINT *,' Y OR N ?'
        GO TO 10
      ENDIF
C
      DO 20 I=ILEN,1,-1
        IF (FILNAM(I:I).NE.' ') THEN
          LEN=I
          GOTO 22
        ENDIF
   20 CONTINUE
C
C.... NULL FILENAME
      FILNAM='TOR'
      LEN=3
C.... APPEND FILE TYPE TO NAME
   22 FILNAM=FILNAM(1:LEN)//'.LDA'
      LEN=LEN+4
C
C.... OPEN LDA EXTERNAL FILE
C
      ID=30
      OPEN (UNIT=ID,FILE=FILNAM(1:LEN),STATUS='NEW',ERR=100,
     +      FORM='UNFORMATTED',ACCESS='SEQUENTIAL')
C
C.... SET UP FILE HEADER INFORMATION FOR EXTERNAL FILE
C
C.... SET UP SURFACE NAME IN SAME INTERNAL FORM AS USED IN APT4,
C     IN FIRST D.P. WORD
C
      IARRAY(1,1)=BCDF(SSNAME(1:IWRD))
      IARRAY(2,1)=BCDF(SSNAME(IWRD+1:6))
C
C.... SUBSCRIPT ?
C
      ARRAY(2)=0.D0
C.... MODE
      IARRAY(1,3)=29
C.... LENGTH OF HEADER IN D.P. WORDS ?
      IARRAY(2,3)=5
C
      IARRAY(1,4)=0
C.... SIZE OF CANONICAL FORM FOR TORUS
      SIZE=INT(TORCAN(8))
      IARRAY(2,4)=SIZE
C
      ARRAY(5)=0.D0
C
C
C.... STORE LDA CANONICAL FORM IN EXTERNAL FILE
C
      CNT=0
      JJ=6
      I1=SIZE-1
      DO 30 I=1,I1
       ARRAY(JJ)=TORCAN(I+1)
       IF (I.EQ.I1) GOTO 25
       JJ=JJ+1
       IF (JJ.LE.9) GOTO 30
  25   CNT=CNT+1
       ARRAY(10)=CNT
C.... WRITE TO LDA FILE
       WRITE(UNIT=ID,ERR=200) (ARRAY(J),J=1,10)
       DO 26 J=1,10
         ARRAY(J)=0.D0
  26   CONTINUE
       JJ=1
  30  CONTINUE
C
      CSTAT='KEEP'
      GOTO 900
C
  100 PRINT *,' ERROR OPENING FILE: ',FILNAM(1:LEN)
      GOTO 999
C
  200 PRINT *,' ERROR WRITING TO EXTERNAL FILE: ',FILNAM(1:LEN)
      CSTAT='DELETE'
      GOTO 900
C
  900 CLOSE(UNIT=ID,STATUS=CSTAT)
C
  999 RETURN
      END
***********************
*    SSV3 ROUTINES    *
***********************
*
*  * BCDF *  FORTRAN 77 INTEGER FUNCTION  19-DEC-1985  E.MCLELLAN
*            MODIFIED                      2-FEB-1988  E.MCLELLAN
*
*  PURPOSE:  CONVERT A STRING OF CHARACTERS WHICH OCCUPY THE SAME
*            NUMBER OF BYTES AS AN INTEGER WORD INTO AN EQUIVALENT
*            INTEGER VALUE
*
*  CALLING SEQUENCE:
*                   VALUE=BCDF(STR)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*       STR         CHARACTER  STRING TO BE CONVERTED
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   IWRD            SDP       INTEGER    NO. OF BYTES PER WORD
*   NBCHAR          SDP       INTEGER    NO. OF BITS PER BYTE
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*        I          INTEGER    LOOP COUNT
*        BCD        INTEGER    VARIABLE FOR BUILDING UP BCD VALUE
*        TSTR       CHARACTER  TEMPORARY STORAGE FOR STRING
*
*  FILES:  NONE
*
*  SUBSIDIARIES:  NONE
*
      INTEGER FUNCTION BCDF(STR)
C
      INCLUDE 'SDP.INC'
C
      INTEGER  BCD
      CHARACTER*(*) STR,TSTR*10
C
      BCD=0
      TSTR=STR//' '
      DO 10 I=1,IWRD
      BCD=ISHFT(BCD,NBCHAR)+ICHAR(TSTR(I:I))
  10  CONTINUE
C
      BCDF=BCD
C
      END
*
*  * HOLFRM *  FORTRAN 77 SUBROUTINE  16.7.86  E.MCLELLAN
*                MODIFIED                 2-FEB-1988  E.MCLELLAN
*
*  PURPOSE:  TO INSERT SPECIFIED NUMBER OF CHARACTERS IN BCDF FORM
*            FROM INTEGER ARRAY INTO CHARACTER VARIABLE
*            STARTING FROM SPECIFIED LOCATION - RETURNING THE NUMBER
*            OF INTEGER WORDS OCCUPIED
*
*  CALLING SEQUENCE:
*                   CALL HOLFRM(IARR,STR,IST,NCHR,NWD)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*       IARR        INTEGER    ARRAY CONTAINING BCDF CHARACTERS
*       STR         CHARACTER  STRING INTO WHICH CHARACTERS ARE
*                              TO BE LOADED
*       IST         INTEGER    START LOCATION IN STR
*       NCHR        INTEGER    NUMBER OF CHARACTERS TO BE INSERTED
*       NWD         INTEGER    NUMBER OF WORDS OCCUPIED
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*     IWRD          SDP       INTEGER    NO OF BYTES PER WORD
*     NBCHAR        SDP       INTEGER    NO OF BITS PER BYTE
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*     IVAL          INTEGER    VALUE OF INTEGER WORD
*     JVAL          INTEGER    INDEX OF CHARACTER IN CONCATINATION
*                              SEQUENCE
*
*  FILES:  NONE
*
*  SUBSIDIARIES:  NONE
*
      SUBROUTINE HOLFRM(IARR,STR,IST,NCHR,NWD)
C
C.... SYSTEM DEPENDENT PARAMETERS
C
      INCLUDE 'SDP.INC'
C
      INTEGER IARR(*),IST,NCHR,NWD,IVAL,JVAL,SLEN
C
      CHARACTER*(*) STR
C
      SLEN=LEN(STR)
      NWD=NCHR/IWRD
      IF (NCHR.GT.NWD*IWRD) NWD=NWD+1
      DO 20 I=1,NWD
        IVAL=IARR(I)
        K1=IST+I*IWRD
        DO 10 J=IWRD,1,-1
          K=K1-J
          JJ=NBCHAR*(J-1)
          JVAL=ISHFT(IVAL,-JJ)
          IF (K.LE.SLEN) THEN
            STR(K:K)=CHAR(JVAL)
          ENDIF
          IVAL=(IVAL-ISHFT(JVAL,JJ))
  10    CONTINUE
  20  CONTINUE
C
      END
**** FILENAME = FVDAFS.FOR ****
C____________________________________________________________________
C                                                                   *
C                                                                   *
C                                                                   *
C                                                                   *
C___________________________________________________________________*
C

      PROGRAM FVDAFS
C
C PURPOSE TO DEFINE A NON-NATIVE CANONICAL FORM FOR VDAFS SURFACES AND STORE
C AND STORE IN APT4 EXTERNAL LDA FORMAT ON APTLIB. VDA SURFACE DATA IS READ
C FROM A VDA-FS DATA FILE
C
C
C DIMENSIONS ALLOW FOR A MAXIMUM OF 50000 DATA ITEMS PER VDA SURFACE
C THIS CORRESPONDS TO MAXIMUM DEGREE    AND WITH
C A MAX OF 30 PATCHES IN EACH DIRECTION.
C
      CHARACTER*40 FILOUT,FILEIN
      CHARACTER*4  REPLY
      INTEGER FLEN1,FLEN2,I,UNITIN,UNOUT
      LOGICAL SEPFIL
C
C
C       READ IN VDAFS FILENAME
C
      UNITIN=1
      UNOUT=30
      PRINT*,'VDAFS FILENAME ?'
      READ(*,'(A40)')FILEIN
      DO 5 I=40,1,-1
        IF (FILEIN(I:I).NE.' ') THEN
          FLEN1=I
          GO TO 8
        ENDIF
 5    CONTINUE
 8    PRINT*,' '
      PRINT*,' '
      PRINT*,'ENTER Y FOR ONE LDA OUTPUT FILE FOR EACH SURFACE READ'
      PRINT*,'FROM THE VDA-FS FILE,'
      PRINT*,'N FOR ONE FILE CONTAINING ALL SURFACES'
      READ(*,'(A4)')REPLY
      DO 15 I=1,40
        IF (REPLY(I:I).NE.' ') THEN
          IF ((REPLY(I:I).EQ.'Y').OR.(REPLY(I:I).EQ.'y')) THEN
            SEPFIL=.TRUE.
            PRINT*,'IN THAT CASE THE FILENAMES WILL CORRESPOND TO THE'
            PRINT*,'VDA-FS SURFACE NAMES'
            GO TO 30
          ELSE IF ((REPLY(I:I).EQ.'N').OR.(REPLY(I:I).EQ.'n')) THEN
             SEPFIL=.FALSE.
             PRINT*,'OUTPUT FILENAME ?'
             READ(*,'(A40)')FILOUT
             DO 25 J=40,1,-1
               IF (FILOUT(J:J).NE.' ') THEN
                 FLEN2=J
                 GO TO 30
               ENDIF
 25          CONTINUE
          ELSE
           GO TO 8
          END IF
        END IF
 15   CONTINUE
 30   CALL VDAPRC(FILEIN,FLEN1,UNITIN,FILOUT,FLEN2,UNOUT,SEPFIL)
      END

      BLOCK DATA BDVDA
C
C.... INITIALIZE COMMON BLOCKS
C
      INCLUDE 'INPUT.INC'
      INCLUDE 'SDP.INC'
C
       DATA NUMLIN/0/
       DATA LINENO,LINPOS/0,1/
C
C     NBCHAR: NO. OF BITS PER BYTE
      DATA NBCHAR/8/
C     NBWRD: NO. OF BITS PER WORD
      DATA NBWRD/32/
C     IWRD: NO. OF BYTES PER WORD
      DATA IWRD/4/
C     IFAC: BYTE LEFT SHIFT MULTIPLICATION FACTOR
      DATA IFAC/256/
C
      END


       SUBROUTINE VDAPRC(INFILE,LEN1,INID,OUTFIL,LEN2,OUTID,SEPFIL)
C
C      ______________________________________________________________
C      MAIN CALLING PROCEDURE, ARRAY DECLARATIONS FOR THE
C      STAGES PARSE, CHECK (INPUT) AND PROCESS (OUTPUT) STAGES
C
C
       CHARACTER*(*) INFILE,OUTFIL
C
       INTEGER EQCHR,SLACHR,LENNAM,ENDNAM,I,J,START,FILERR,
     +         LEN1,LEN2,IFAIL,OUTID,INID

       LOGICAL GEOMET,FLHEAD,ERR,ENDFIL,EQUAL,SLASH,BEGLIN,
     +         SEPFIL,STRUCT,FIRST
       CHARACTER*8 ENTNAM,DETERM

       INCLUDE 'INPUT.INC'
       INCLUDE 'SDP.INC'
C
C      PARSING STAGE - SCAN VDA FILE FOR SURFACE DATA
C
C

       GEOMET=.FALSE.
       FLHEAD=.FALSE.
       ERR=.FALSE.
       ENDFIL=.FALSE.
       EQUAL=.FALSE.
       SLASH=.FALSE.
       BEGLIN=.FALSE.
       FIRST=.TRUE.
C
C         OPEN SOURCE FILE
C
       CALL OPSRCE(INFILE,LEN1,INID,ERR,IFAIL)
D      PRINT*,IFAIL
       IF (.NOT. ERR) THEN
         IF (.NOT.SEPFIL) THEN
           OPEN(OUTID,FILE=OUTFIL(1:LEN2),STATUS='NEW'
     +        ,ERR=300,FORM='UNFORMATTED',ACCESS='SEQUENTIAL')
         END IF
C
C       SCAN HEADER
C
           CALL HEADER(INID,IFAIL,ERR)
           IF (IFAIL.LT.10000) THEN
C
C      READ SUBSEQUENT DATA IN FILE
C
1000         DETERM='        '
             ENTNAM='        '
             SLASH=.FALSE.
             EQUAL=.FALSE.
             EQCHR=0
             SLACHR=0
             BEGLIN=.FALSE.
             IF (.NOT.(GEOMET)) THEN
               CALL REDDAT(INID)
             END IF
             GEOMET=.FALSE.
             I=0
10           I=I+1
C
C      FIND START OF LINE
C
             IF (LINBUF(I).EQ.' ') THEN
               IF (I.LE.72) THEN
                 GO TO 10
               END IF
              ELSE
               START=I
               BEGLIN=.TRUE.
             END IF
             IF (BEGLIN) THEN
C
C         CHECK SOMETHING UNDERSTANDABLE IS ON LINE, ELSE
C         GO T0 1000
C
              IF ((LINBUF(START).EQ.'$').AND.
     +                  (LINBUF(START+1).EQ.'$')) THEN
C
C        CHECK FOR A COMMENT
C
                 CONTINUE
               ELSE
C
C        NOT A COMMENT LINE SO FIND OUT WHAT IT IS
C
                 LENNAM=0
                 DO 20 J=START,73-START
                   IF ((.NOT. EQUAL).AND.(LINBUF(J).NE.' ')) THEN
                     LENNAM=LENNAM+1
                   END IF
                   IF (LINBUF(J).EQ.'=') THEN
                     EQUAL=.TRUE.
                     EQCHR=J
                   END IF
                   IF (LINBUF(J).EQ.'/') THEN
                     SLASH=.TRUE.
                     SLACHR=J
                   END IF
                   IF ((SLASH).AND.(EQUAL)) THEN
                     GO TO 300
                   END IF
20               CONTINUE
300              IF ((SLASH).AND.(EQUAL)) THEN
C
C        PROBABLY AN ENTITY ASSIGNMENT
C
                   IF (LENNAM.GT.8) THEN
                      ENDNAM=START+7
                      IFAIL=300
                    ELSE
                      ENDNAM=LENNAM
                   END IF
                   IF (LENNAM.GT.0) THEN
                      CALL MAKSTR(START,ENDNAM-1,ENTNAM)
D                     PRINT*,'    ',ENTNAM,'.'
                   END IF
                   IF ((SLACHR-EQCHR).GT.0) THEN
                      CALL MAKSTR((EQCHR+1),(SLACHR-1),DETERM)
D                     PRINT*,'    ',DETERM,'.'
                   END IF
                   IF (DETERM(1:4).EQ.'SURF') THEN
                     CALL RSURF(INID,OUTID,SEPFIL,ENTNAM,SLACHR,
     +                              LENNAM-1,ERR)
                     GEOMET=.TRUE.
                   END IF
                ELSE IF ((EQUAL).AND.(.NOT.SLASH)) THEN
C
C      NOT AN ENTITY SO  EITHER ENDFILE, BEGINSET OR ENDSET
C
                   CALL MAKSTR((EQCHR+1),(EQCHR+9),DETERM)
D                  PRINT*,'    ',DETERM,'.'
                   IF (DETERM(1:8).EQ.'BEGINSET') THEN
                      IF (.NOT. STRUCT) THEN
                         STRUCT=.TRUE.
                       ELSE
                         IFAIL=305
                      END IF
                    ELSE IF (DETERM(1:6).EQ.'ENDSET') THEN
                        IF (STRUCT) THEN
                           STRUCT=.FALSE.
                         ELSE
                            IFAIL=305
                        END IF
                     ELSE IF (DETERM(1:3).EQ.'END') THEN
                        ENDFIL=.TRUE.
                       ELSE
                          IFAIL=304
                   END IF
                  ELSE
D                 PRINT*,'LINE IS UNRECOG. NO ENTITY FOUND'
                 END IF
                END IF
               ELSE
D              PRINT*,'BEGINNING OF LINE NOT FOUND'
              END IF
              IF (.NOT. ENDFIL) THEN
                GO TO 1000
              END IF
             CLOSE(OUTID)
             ELSE
             PRINT*,'FATAL ERROR/ HEADER NOT FOUND'
             END IF
       ELSE
       PRINT*,'UNABLE TO OPEN SOURCE FILE'
      END IF
      END

C     __________________________________________________________
      SUBROUTINE RSURF(INID,OUTID,SEPFIL,VSNAME,START,LEN,ERR)
C     __________________________________________________________
C
C
      INCLUDE 'INPUT.INC'
      DOUBLE PRECISION VCAN(50000),TEMP,BU(30),BV(30)
C
      CHARACTER*8 VSNAME
      CHARACTER*12 TEMNAM,OUTFIL
      CHARACTER*6 SNAME
      INTEGER START,NPU,NPV,ITEMP(2),BCDF,NPTCHS,
     +        ID,I,PHEAD,MU,MV,NPC,LENGTH,
     +        NMPACH,PDAT,NPDAT,LEN,OUTID
      LOGICAL FOUND,ERR,SUREND,SEPFIL

      EQUIVALENCE (TEMP,ITEMP(1))
      ITEMP(1)=BCDF('VDAF')
      ITEMP(2)=BCDF('S   ')
C

C
      OUTFIL='            '
      TEMNAM='            '
      ERR=.FALSE.
      SUREND=.FALSE.
      NMPACH=0
      LINPOS=START+1
C
C     TRUNCATE VDAFS SURFACE NAME TO A SIX CHARCTER NAME
C
      IF (LEN.GT.6) THEN
        PRINT*,' '
        PRINT*,'the surface name - ',VSNAME,' is too long'
        print*,' '
        CALL NEWNAM(VSNAME,SNAME,LEN)
      ELSE
        SNAME=VSNAME(1:6)
      END IF
C
C     IF SEPARATE FILE OUTPUT THEN OPEN IT
C
      IF (SEPFIL) THEN
        OUTFIL=SNAME
        TEMNAM='           '
        TEMNAM=OUTFIL
        OUTFIL='.LDA'
        OUTFIL=TEMNAM(1:LEN)//OUTFIL
        OPEN(OUTID,FILE=OUTFIL(1:(LEN+4)),STATUS='NEW'
     +        ,ERR=300,FORM='UNFORMATTED',ACCESS='SEQUENTIAL')
      END IF
C
D     PRINT*,'ABOUT TO GET N PATCHES'
C
      CALL RNOPAT(INID,NPU,NPV,FOUND)
C     SET  UP PATCH HEADER DATA, PHEAD IS POINTER TO START OF
C     PATCH HEADER DATA PDAT IS GEOMETRY POINTER
C
300   PHEAD=11
      NPTCHS=NPU*NPV
      PDAT=11+6*NPTCHS
C
D     PRINT*,'PATU,PATV',PATU,PATV
      IF (FOUND) THEN
        CALL RPARS(INID,BU,BV,FOUND)
C       IGNORE THIS BUT ENSURE THAT THERE WAS NO READ-ERROR BEFORE
C       CONTINUING
100       IF ((.NOT.SUREND).AND.(.NOT.ERR)) THEN
C
C         SET UP HEADER BLOCK (EXCLUDING GEOMETRY POINTER)
C
           VCAN(PHEAD)=PDAT
           VCAN(PHEAD+1)=0.0
           VCAN(PHEAD+2)=0.0
           VCAN(PHEAD+3)=0.0
           VCAN(PHEAD+4)=TEMP
           PHEAD=PHEAD+6
           CALL RPATCH(INID,VCAN,PHEAD,PDAT,NPDAT,ERR,SUREND)
           PDAT=NPDAT
          GO TO 100
         END IF


C     ALL PATCH GEOMETRY DATA HAS BEEN CREATED, SET TOPOLOGY DATA
C     POINTERS AND CREATE TOPOLOGY TABLES
C
      IF (.NOT.ERR) THEN
       PHEAD=10
       DO 30 I=1,NPTCHS
         VCAN(PHEAD+6*I)=PDAT+4*(I-1)
30     CONTINUE
C
C     TOPOLOGY TABLE CONSISTS OF 4 NUMBERS OF ADJACENT PATCHES FOR
C     EACH PATCH
C
       DO 40 I=1,NPTCHS
         VCAN(PDAT)=MAX(0,I-NPU)
         IF (MOD(I,NPU).EQ.1) THEN
           VCAN(PDAT+1)=0.0
         ELSE
           VCAN(PDAT+1)=I-1
         ENDIF
         IF (MOD(I,NPU).EQ.0) THEN
           VCAN(PDAT+2)=0.0
         ELSE
           VCAN(PDAT+2)=I+1
         ENDIF
         IF (I+NPU.GT.NPTCHS) THEN
           VCAN(PDAT+3)=0.0
         ELSE
           VCAN(PDAT+3)=I+NPU
         ENDIF
       PDAT=PDAT+4
40     CONTINUE
C      CREATE SURFACE HEADER BLOCK
       LENGTH=PDAT-1
       VCAN(2)=VCAN(16)-VCAN(11)
       VCAN(3)=4*NPTCHS
       VCAN(4)=NPTCHS
       VCAN(5)=2.0
       VCAN(6)=1.0
       VCAN(7)=1.0
       VCAN(8)=LENGTH
       VCAN(9)=NPV+1.0
       VCAN(10)=NPU+1.0
C      ITEMS 9 AND 10 OF HEADER BLOCK ARE NOS OF SPLINES AND CRSSPLS
C      SURFACE CANONICAL DATA NOW COMPLETE, CREATE .LDA FILE.
       CALL PUNVDA(OUTID,VCAN,SNAME,LENGTH)
       END IF
      END IF
      IF (SEPFIL) THEN
        CLOSE(OUTID)
      ENDIF
      END

C
C
C
C______________________________________________________________
       SUBROUTINE RPATCH(ID,VCAN,PHEAD,PDAT,NPDAT,ERR,SUREND)
C      ________________________________________________________
C
C
       INCLUDE 'INPUT.INC'

       DOUBLE PRECISION RELGOT,VCAN(50000)
       INTEGER NUMRIT,INTGOT,UORD,VORD,NEXT,PHEAD
     +       ,PDAT,NPDAT,NUMRED
       LOGICAL FOUND,ERR,SUREND

       SUREND=.FALSE.
       FOUND=.FALSE.
       NUMRED=0
       CALL RSORDR(ID,UORD,VORD,FOUND)

C      CREATE HEADER BLOCK AND GEOMETRY BLOCK
C      FOR EACH PATCH. MU AND MV ARE PATCH ORDERS (DEGREE+1).
C
       IF (FOUND) THEN
         VCAN(PDAT)=UORD
         VCAN(PDAT+1)=VORD
       END IF
C
C      CALCULATE NEW VALUE OF PDAT TO RETURN
C
       NPDAT=PDAT+2+3*UORD*VORD
D      PRINT*,'UORD & VORD ',UORD,VORD
100    FOUND=.FALSE.
       CALL REDREL(ID,RELGOT,FOUND,NEXT)
       IF (FOUND) THEN
         LINPOS=NEXT
         NUMRED=NUMRED+1
         VCAN(PDAT+1+NUMRED)=RELGOT
         GO TO 100
       END IF
       IF (.NOT.FOUND) THEN
         FOUND=.FALSE.
         CALL REDINT(ID,INTGOT,FOUND,NEXT)
         IF (.NOT.FOUND) THEN
           SUREND=.TRUE.
         END IF
       END IF
       END


C______________________________________________________________

      SUBROUTINE PUNVDA(ID,VCAN,SNAME,LENGTH)

      INCLUDE 'SDP.INC'
C
      INTEGER LENGTH,IARRAY(2,10),BCDF,CNT,JJ,I1,I,J,IRET,ID
      DOUBLE PRECISION VCAN(LENGTH),ARRAY(10),DATUM,MEMBER
      CHARACTER*6 SNAME
      CHARACTER RES*1
C
      EQUIVALENCE(ARRAY(1),IARRAY(1,1))
C
C
C     SET UP SURFACE NAME IN APT4 INTERNAL FORMAT IN 1ST WORD.
      IARRAY(1,1)=BCDF(SNAME(1:IWRD))
      IARRAY(2,1)=BCDF(SNAME(IWRD+1:6))
      ARRAY(2)=0.D0
C     MODE
      IARRAY(1,3)=29
C     LENGTH OF HEADER IN D.P. WORDS
      IARRAY(2,3)=5
      IARRAY(1,4)=0
C     SIZE OF VDA FORMAT DATA
      IARRAY(2,4)=LENGTH
      ARRAY(5)=0.D0
C STORE VDA CANONICAL FORM (IN VCAN) AS LDA FORMATTED FILE
      CNT=0
      JJ=6
      I1=LENGTH-1
      DO 30 I=1,I1
        ARRAY(JJ)=VCAN(I+1)
        IF(I.EQ.I1) GO TO 25
        JJ=JJ+1
        IF(JJ.LE.9) GO TO 30
 25     CNT=CNT+1
        ARRAY(10)=CNT
C WRITE TO LDA FILE
        WRITE(UNIT=ID,ERR=27) (ARRAY(J),J=1,10)
        DO 26 J=1,10
          ARRAY(J)=0.0
  26    CONTINUE
        JJ=1
  30  CONTINUE
C
      RETURN
C
  27  PRINT*,' ERROR WRITING TO FILE:',SNAME
C
      END

C______________________________________________________________
       SUBROUTINE HEADER(ID,ERR,IFAIL)
C      ________________________________________________________
C      READS 1ST LINE OF VDA FILE IE HEADER
C
       INCLUDE 'INPUT.INC'
C
       INTEGER NUMLEN,BLAPOS,COUNT,I,J,L,IFAIL,SLAPOS,
     +         EQUIND,M,N,INTEGR,ID
       DOUBLE PRECISION DPRECN
       LOGICAL ERR,EQUAL,SLASH,BLANK,NONBLA,RELNM,INTNM
       CHARACTER*8 TEMP,DETERM,HEDNAM

D      PRINT*,'CALLED HEADER'
       BLANK=.FALSE.
       ERR=.FALSE.
       EQUAL=.FALSE.
       SLASH=.FALSE.
       RELNM=.FALSE.
       INTNM=.FALSE.
C
C      LOCATE POSITIONS OF = SIGN,/ AND IST BLANK CHARACTER
C
       CALL REDLIN(ID)
       DO 10 I=1,25
C
C                                   = SIGN
C
         IF (LINBUF(I).EQ.'=') THEN
           EQUAL=.TRUE.
           EQUIND=I
         END IF
C
C                                   / CHARACTER
C
         IF (LINBUF(I).EQ.'/') THEN
           SLASH=.TRUE.
           SLAPOS=I
         END IF
C
C                                   IST BLANK
C
         IF (LINBUF(I).EQ.' ') THEN
           IF (.NOT. BLANK) THEN
             BLAPOS=I
           END IF
           BLANK=.TRUE.
         END IF
10     CONTINUE
C
C                        IF ALL 3 ARE FOUND
C
       IF (EQUAL) THEN
         IF (EQUIND.GT.8) THEN
           IFAIL=300
           COUNT=9
          ELSE
            COUNT=EQUIND
         END IF
         DO 20 J=COUNT-1,1,-1
           TEMP=HEDNAM
           HEDNAM=LINBUF(J)//TEMP
20       CONTINUE
        ELSE
         IFAIL=350
       END IF
C
C      EXTRACT AND IDENTIFY THE HEADER QUALIFIER
C
       TEMP='        '
       IF (SLASH) THEN
         CALL MAKSTR((EQUIND+1),(SLAPOS-1),DETERM)
         IF (DETERM(1:6).EQ.'HEADER') THEN
C
C      EXTRACT NO OF HEADER LINES, CONVERT TO INTEGER
C
D          PRINT*,'HEADER FOUND & IDENTIFIED'
           TEMP='        '
           DETERM='        '
C
C          FIND FIRST BLANK AFTER LAST NONBLANK AFTER THE / CHARACTER
C
           BLANK=.FALSE.
           NONBLA=.FALSE.
           DO 40 I=SLAPOS+1,73
             IF (.NOT. BLANK) THEN
               IF (LINBUF(I).EQ.' ') THEN
                 IF (NONBLA) THEN
                   BLANK=.TRUE.
                   BLAPOS=I
                 END IF
                ELSE
                 NONBLA=.TRUE.
               END IF
              ELSE
               GO TO 30
             END IF
40         CONTINUE
C
C          NOW CONSTRUCT THE NO OF HEADER LINES, BASED ON THESE
C
30         IF (BLANK) THEN
             CALL MAKSTR((SLAPOS+1),(BLAPOS-1),DETERM)
            ELSE
             IFAIL=350
           END IF
D          PRINT*,'BLAPOS',BLAPOS,'SLAPOS',SLAPOS
           NUMLEN=(BLAPOS-1)-SLAPOS
D          PRINT*,DETERM(1:NUMLEN),'IS THE HEADER NUMBER'
           CALL MAKNUM(DETERM(1:NUMLEN),NUMLEN,DPRECN,RELNM,INTEGR
     +                      ,INTNM,IFAIL)
D          PRINT*,'NUMBER',INTEGR,'LENGTH',NUMLEN
C
C          WRITE TO SCRATCH FILE
C
           IF ((INTNM).AND.(IFAIL.EQ.0)) THEN
             DO 50 N=1,INTEGR
               CALL REDLIN(ID)
50           CONTINUE
           END IF
          ELSE
           IFAIL=350
         END IF
       END IF
       END




C__________________________________________________________________*
C                                                                  *
C   THE FOLLOWING SUBROUTINES PERFORM INPUT/OUTPUT (FROM THE       *
C   VDA FILE TO THE TEMPORARY INTERNAL FORM WHICH IS MANIPULATED   *
C   IN THE FORM OF READ CHARACHTER STRINGS AND ARRAYS),            *
C   AND FROM THIS TO THE PROCESSORS INTERNAL, DIRECT ACCESS        *
C   SCRATCH FILE                                                   *
C__________________________________________________________________*
C
C
C__________________________________________________________
       SUBROUTINE REDLIN(UNIT)
C
C      READS AN 80 CHARACHTER RECORD FROM THE ASSIGNED FILE
C      INTO THE 80 CHARACTER INPUT ARRAY
C      ____________________________________________________

C
       INCLUDE 'INPUT.INC'
C
       INTEGER J,UNIT

D      PRINT*,'CALLED REDLIN'
       READ(UNIT,'(80A1)')(LINBUF(J),J=1,80)
       NUMLIN=NUMLIN+1
       LINPOS=1
       END






C_________________________________________________________________
       SUBROUTINE OPSRCE(FLNM,LEN1,UNIT,ERR,IFAIL)
C
C      THIS CHECKS FOR VALIDITY, AND THEN OPENS THE SPECIFIED INPUT
C      THE FILE IS ASSIGNED TO UNIT
C      ___________________________________________________________


       INTEGER LEN1,TEST,IFAIL,FILERR,UNIT
       CHARACTER FLNM*(*),SEQ*7,FORREC*7
       LOGICAL ERR,FILEXT,FILOP

       ERR=.FALSE.
       TEST=LEN(FLNM(1:LEN1))
       TEST=LEN(FLNM)
       INQUIRE(FILE=FLNM(1:LEN1),IOSTAT=FILERR,ERR=10,
     +                         SEQUENTIAL=SEQ,OPENED=FILOP)
C               CHECK TO SEE IT EXISTS ???
10     IF ((SEQ(1:2).EQ.'NO').OR.(FILERR.NE.0).OR.
     +              (FILOP)) THEN
           ERR=.TRUE.
           IFAIL=10002
          ELSE IF (FILERR.EQ.0) THEN
D                PRINT*,'ABOUT TO OPEN '
                 OPEN(UNIT,FILE=FLNM(1:LEN1),STATUS='OLD',ERR=20,
     +                                     IOSTAT=FILERR)
20                 IF (FILERR.EQ.0) THEN
D                  PRINT*,'INQUIRING AGAIN'
                   INQUIRE(UNIT=UNIT,FORMATTED=FORREC,
     +                         IOSTAT=FILERR,ERR=30)
30                 IF (FILERR.NE.0) THEN
                     ERR=.TRUE.
                     IFAIL=10002
                   END IF
                  ELSE
                    ERR=.TRUE.
                    IFAIL=10003
                 END IF
          END IF
          END



C______________________________________________________
       SUBROUTINE REDDAT(UNIT)
C
C      READS A LINE OF DATA FROM THE FILE IE IT RETURNS
C      NON COMMENT LINES ONLY, SO SHOULD A COMMENT LINE BE
C      ENCOUNTERED IN THE MIDDLE OF A BLOCK OF DATA, THE
C      COMMENT INFO IS WRITTEN AWAY AND ACCOUNTED FOR, THE
C      CALLING ROUTINE ONLY CONCERNING ITSELF WITH RELEVANT
C      NUMERICAL DATA
C      ________________________________________________

       INCLUDE 'INPUT.INC'

       INTEGER I,STPOSN,UNIT
       LOGICAL ERR,START

D      PRINT*,'CALLED REDDAT'
100    CALL REDLIN(UNIT)
       LINENO=LINENO+1
       DO 10 I=1,72
         IF (LINBUF(I).NE.' ') THEN
           STPOSN=I
           START=.TRUE.
           GO TO 200
         END IF
10    CONTINUE
C
C     ENSURE START OF LINE IS FOUND AND THAT
C     FIRST NONBLANK IS IN COLS 1-72
C
200   IF ((START).AND.(STPOSN.LE.72)) THEN
        IF ((LINBUF(STPOSN).EQ.'$').AND.
     +      (LINBUF(STPOSN+1).EQ.'$')) THEN
          GO TO 100
        ELSE
         LINPOS=1
        END IF
       ELSE
        GO TO 100
      END IF
      END


C     __________________________________________________________
C     __________________________________________________________
      SUBROUTINE REDINT(ID,NUMBER,FOUND,NEXT)
C     __________________________________________________________
C
      INCLUDE 'INPUT.INC'
C
      INTEGER ID,NUMBER,STRLEN,START,END,NEXT,IFAIL
      LOGICAL EOLN,ERR,FOUND,COMMA,EXIST,RELNO
      DOUBLE PRECISION DPRECN
      CHARACTER*22 CSTRIN

D     PRINT*,'INSIDE REDINT'

100   EOLN=.FALSE.
      COMMA=.FALSE.
      RELNO=.FALSE.
      EXIST=.FALSE.
      ERR=.FALSE.
      FOUND=.FALSE.
      CSTRIN='                      '
      CALL GNOSTR(LINPOS,CSTRIN,STRLEN,COMMA,START,END,NEXT,EOLN,ERR)
      IF (EOLN) THEN
        CALL REDDAT(ID)
        GO TO 100
      END IF
      IF (.NOT.ERR) THEN
        ERR=.FALSE.
        CALL MAKNUM(CSTRIN,STRLEN,DPRECN,RELNO,NUMBER,EXIST,IFAIL)
        IF ((IFAIL.NE.0).OR.(RELNO)) THEN
          ERR=.TRUE.
        END IF
        IF (.NOT.ERR) THEN
          FOUND=.TRUE.
        END IF
      END IF
      END

C     __________________________________________________________
C     __________________________________________________________
      SUBROUTINE REDREL(ID,NUMBER,FOUND,NEXT)
C     __________________________________________________________
C
      INCLUDE 'INPUT.INC'
C
      INTEGER INTEG,STRLEN,START,END,NEXT,IFAIL
      LOGICAL FOUND,EOLN,ERR,COMMA,EXIST,INTNO
      DOUBLE PRECISION NUMBER
      CHARACTER*22 CSTRIN

D     PRINT*,'INSIDE REDREL'

100   EOLN=.FALSE.
      COMMA=.FALSE.
      EXIST=.FALSE.
      ERR=.FALSE.
      FOUND=.FALSE.
      CSTRIN='                      '
      CALL GNOSTR(LINPOS,CSTRIN,STRLEN,COMMA,START,END,NEXT,EOLN,ERR)
      IF (EOLN) THEN
        CALL REDDAT(ID)
C                                 ?? SHOULD SET LINECOUNT TO ZERO
        GO TO 100
      END IF
      IF (.NOT.ERR) THEN
        ERR=.FALSE.
        CALL MAKNUM(CSTRIN,STRLEN,NUMBER,EXIST,INTEG,INTNO,IFAIL)
        IF ((IFAIL.NE.0).OR.(INTNO)) THEN
          ERR=.TRUE.
        END IF
        IF (.NOT.ERR) THEN
D         PRINT*,'THIS TIME A NUMBERS BEEN FOUND'
          FOUND=.TRUE.
        END IF
      END IF
      END




C
C________________________________________________________________
       SUBROUTINE GNOSTR(FIRST,STRING,STRLEN,COMMA,INITAL,FINAL,
     +  NEXT,EOLN,ERR)
C      __________________________________________________________
C
C      GETS THE NEXT NONBLANK CHARACTER STRING FROM THE
C      CURRENT LINE BUFFER, STARTING FROM 'FIRST', RETURNING
C      COMMA=.TRUE. IF A COMMA IS FOUND (IE CONTINUATION),
C      COMMA IS SET FALSE IF THE LAST NONBLANK CHARACTER
C      IN LINES 1-72 IS A BLANK (IE NO CONTINUATION). NB THE
C      FINAL POSITION IS THE POSITION AFTER COMMA IF THE COMMA
C      IS FOUND, OTHERWISE 73 IS RETURNED
C
C
       INCLUDE 'INPUT.INC'
C
       INTEGER INITAL,FINAL,I,J,K,STRLEN,FIRST,COMPOS,NEXT,ENDPOS
       CHARACTER*22 STRING,TEMP
       LOGICAL COMMA,START,ERR,ENDFND,EOLN

D      PRINT*,'CALLED GNOSTR'
       COMMA=.FALSE.
       START=.FALSE.
       ERR=.FALSE.
       ENDFND=.FALSE.
C
C      FIND START OF STRING
C
       DO 10 I=FIRST,72
        IF (LINBUF(I).NE.' ') THEN
         START=.TRUE.
         INITAL=I
         GO TO 200
        END IF
10     CONTINUE
C
C      FIND EITHER FIRST BLANK OR COMMA AFTER THE BEGINNING
C      OF THE STRING
C
200    IF (START) THEN
         DO 20 J=INITAL,72
           IF (.NOT. ENDFND) THEN
             IF ((LINBUF(J).EQ.',').OR.(LINBUF(J).EQ.' ')) THEN
               FINAL=J-1
               ENDPOS=J
               ENDFND=.TRUE.
             END IF
           END IF
           IF (LINBUF(J).EQ.',') THEN
             COMPOS=J
             COMMA=.TRUE.
           END IF
           IF (COMMA) THEN
             GO TO 300
           END IF
20       CONTINUE
300      IF (ENDFND) THEN
           IF (.NOT.COMMA) THEN
             DO 30 I=ENDPOS,72
             IF (LINBUF(I).EQ.',') THEN
               COMPOS=I
               COMMA=.TRUE.
             END IF
30           CONTINUE
           END IF
            STRING='                      '
            TEMP='                      '
            DO 40 K=FINAL,INITAL,-1
              TEMP=STRING
              STRING=LINBUF(K)//TEMP
40          CONTINUE
            STRLEN=ENDPOS-INITAL
            IF (COMPOS.GT.ENDPOS) THEN
              NEXT=COMPOS+1
            ELSE
              NEXT=ENDPOS+1
            END IF
         ELSE
          ERR=.TRUE.
         END IF
      ELSE
       ERR=.TRUE.
       EOLN=.TRUE.
      END IF
      END



C________________________________________________________________
       SUBROUTINE MAKSTR(FIRST,LAST,STRING)
C         CREATES A CHARACTER STRING FROM THE START TO THE END
C         LOCATIONS IN THE INPUT CHARACHTER ARRAY, BLANKS ARE
C         LEFT IN THE RIGHTMOST POSITIONS
C      __________________________________________________________
C
       INCLUDE 'INPUT.INC'
C
       INTEGER FIRST,LAST,I
       CHARACTER*8 STRING,TEMP

D      PRINT*,'CALLED MAKSTR'
       STRING='        '
       TEMP='        '
       DO 10 I=LAST,FIRST,-1
         IF (LINBUF(I).EQ.' ') THEN
           GO TO 10
         END IF
         TEMP=STRING
         STRING=LINBUF(I)//TEMP
10     CONTINUE
       END




C
C
C_________________________________________________________________________
C                                                                        *
C THE FOLLOWING SUBROUTINES MANIPULATE AND CHECK CHARACHTER STRINGS      *
C WHICH HAVE BEEN COMPOSED FROM THE FILE, DETERMINING WHETHER            *
C THEY REPRESENT VALID NUMERIC DATA AND IN SUCH CASES AS THEY            *
C DO, THE APPROPRIATE NUMBER IS CONSTRUCTED                              *
C                                                                        *
C________________________________________________________________________*
C
C
C________________________________________________________________________
       SUBROUTINE MAKNUM(CHRSTR,LENGTH,DPRECN,RELNO,INTEGR,INTNO,IFAIL)
C
C      ANALYSES A STRING OF CHARS FOR PROPS OF REAL/INT AND/OR
C      OTHER, CALLING MAKINT, MAKDPR AND RETURNING T/F RELNO/INTNO
C      DEPENDING ON WHETHER IT IS REAL
C      OR DOUBLE AND ERROR CODES
C      ________________________________________________________________
C
       DOUBLE PRECISION DPRECN
       INTEGER EXP,DIGIT,DPOINT,SIGN,LENGTH,INTEGR,IFAIL,I,TEST,
     +               NUMINT,NUMREA,NUMCHR
       LOGICAL REAL,INVALC,ERR,NONNUM,INTNO,RELNO
       CHARACTER CHRSTR*22
       CHARACTER*1 SUBCHR

D      PRINT*,'CALLED MAKNUM'
       RELNO=.FALSE.
       INTNO=.FALSE.
       REAL=.FALSE.
       NONNUM=.FALSE.
       INVALC=.FALSE.
       IFAIL=0
       EXP=0
       DIGIT=0
       DPOINT=0
       SIGN=0
       DPRECN=0.0
       INTEGR=0

       DO 10 I=1,LENGTH
       SUBCHR=CHRSTR(I:I)
       TEST=ICHAR('SUBCHR')
       IF(SUBCHR.EQ.'.') THEN
         DPOINT=DPOINT+1
        ELSE IF ((SUBCHR.EQ.'E').OR.(SUBCHR.EQ.'D')) THEN
               EXP=EXP+1
              ELSE IF ((SUBCHR.EQ.'+').OR.(SUBCHR.EQ.'-')) THEN
                     SIGN=SIGN+1
                    ELSE IF ((TEST.GE.43).AND.(TEST.LE.57)) THEN
                           DIGIT=DIGIT+1

       END IF
10     CONTINUE
       IF ((DIGIT.GT.16).OR.(SIGN.GT.2).OR.(EXP.GT.1).OR.
     +                                      (DPOINT.GT.1)) THEN
         INVALC=.TRUE.
       END IF
       IF (DPOINT.GT.0) THEN
         REAL=.TRUE.
       END IF
       IF ((REAL).AND.(.NOT. INVALC)) THEN
D        PRINT*,'CALLING MAKDPR USING STRING',CHRSTR,':: LENGTH IS',
D    +                            LENGTH
         CALL MAKDPR(CHRSTR,LENGTH,DPRECN,ERR)
D        PRINT*,'NUMBER RETURNED FROM MAKDPR IS',DPRECN
         IF (ERR) THEN
           IFAIL=101
          ELSE
           RELNO=.TRUE.
         END IF
        ELSE IF ((.NOT. REAL).AND.(.NOT. INVALC)) THEN
D              PRINT*,'CALLING MAKINT USING STRING',CHRSTR,'::'
               CALL MAKINT(CHRSTR,LENGTH,INTEGR,ERR)
D              PRINT*,'NUMBER RETURNED FROM MAKINT IS',INTEGR
               IF (ERR) THEN
                 IFAIL=102
                ELSE
                 INTNO=.TRUE.
               END IF
        ELSE
             IFAIL=100
       END IF
       END


C______________________________________________________________________
       SUBROUTINE MAKINT(STRING,LENGTH,INTEGR,ERR)
C
C      OUTPUTS THE INTEGER NUMBER EQUIVALENT TO AN INPUT CHARACTER
C      STRING, CHECKING THE INTEGRITY OF THE STRING
C      ________________________________________________________________
C
       INTEGER INTEGR,I,MULTIP,NUM,LENGTH
       LOGICAL NEGATE,ERR
       CHARACTER*1 SUBSTR
       CHARACTER STRING*(*)

D      PRINT*,'CALLED MAKINT'
       ERR=.FALSE.
       NEGATE=.FALSE.
       MULTIP=1
       INTEGR=0
C
C      LOOK FOR LEADING SIGN, + OR - AND IF PRESENT,
C      ALTER THE LENGTH ACCORDINGLY.  IF THE SIGN IS NEGATIVE THEN SET
C      THE NEGATE FLAG TRUE
C
       SUBSTR=STRING(1:1)
       IF (SUBSTR.EQ.'-') THEN
         NEGATE=.TRUE.
         LENGTH=LENGTH-1
       END IF
       IF (SUBSTR.EQ.'+') THEN
         LENGTH=LENGTH-1
       END IF
C
C      BUILD UP INTEGER FROM EXTREME RIGHT
C
D      PRINT*,'CHAR STRING TO BE MADE INTEGER',STRING(1:LENGTH)
       DO 10 I=LENGTH,1,-1
         SUBSTR=STRING(I:I)
         CALL CHRNUM(SUBSTR,NUM,ERR)
         IF (.NOT. ERR) THEN
           INTEGR=INTEGR+(MULTIP*NUM)
           MULTIP=MULTIP*10
          ELSE
             ERR=.TRUE.
         END IF
10     CONTINUE
       IF (NEGATE) THEN
         INTEGR=INTEGR*(-1)
       END IF
       END


C______________________________________________________________________
       SUBROUTINE CHRNUM(CHAR,NUMB,ERR)
C
C      RETURNS THE NUMBER CORRESPONDING TO THE (BASED ON
C      ITS ASCII CODE) INPUT CHARACTER
C      ________________________________________________________________
C
       CHARACTER*1 CHAR
       INTEGER NUMB
       LOGICAL ERR

D      PRINT*,'CALLED CHRNUM'
       NUMB=ICHAR(CHAR)
       IF ((NUMB.GT.47).AND.(NUMB.LT.58)) THEN
         NUMB=NUMB-48
         ERR=.FALSE.
        ELSE
             ERR=.TRUE.
       END IF
       END

C________________________________________________________________________
       SUBROUTINE MAKDPR(STRING,LEN,DPREC,ERR)
C
C      RETURNS THE DOUBLE PRECISION NUMBER REPRESENTED BY THE
C      INPUT CHARACTER STRING, CHECKING THE SYNTAX OF THE INPUT NUMBER
C      __________________________________________________________________
C
       INTEGER DIGIT,LEN,INDEX,I,J,DPOINT,EXPT
       LOGICAL ERR,NEGATE,FNDEXP,FNDPNT,NEGEXP
       DOUBLE PRECISION DPREC,TEN
       CHARACTER*2 EXPCHR
       CHARACTER*1 SUBSTR
       CHARACTER STRING*(*)
       CHARACTER UNSIGN(22)*1

D      PRINT*,'CALLED MAKDPR'
       NEGATE=.FALSE.
       ERR=.FALSE.
       NEGEXP=.FALSE.
       DIGIT=0
       DPREC=0.0
       FNDEXP=.FALSE.
       NEGEXP=.FALSE.
       FNDPNT=.FALSE.
       DPOINT=0
       DO 5 I=1,22
         UNSIGN(I)=' '
5      CONTINUE
C
C
C      LOOK FOR LEADING +/- SIGN, STRIP IT FROM INPUT STRING IF
C      FOUND, ALTERING THE LENGTH IF NECESSARY.  IF THE SIGN
C      EXISTS AND IS NEGATIVE THEN NEGATE IS SET TRUE
C
       SUBSTR=STRING(1:1)
       IF (SUBSTR.EQ.'-') THEN
         NEGATE=.TRUE.
         STRING=STRING(2:LEN)
         LEN=LEN-1
        ELSE IF (SUBSTR.EQ.'+') THEN
               STRING=STRING(2:LEN)
               LEN=LEN-1
       END IF
C
C      PLACE REMAINING ELEMENTS OF STRING IN AN ARRAY FOR
C      EASE OF ACCESS
C
       DO 10 I=1,LEN
       SUBSTR=STRING(I:I)
       UNSIGN(I)=SUBSTR
10     CONTINUE
C
C      LOCATE THE POSITION OF THE EXPONENT IN 'UNSIGN' AND IF
C      FOUND, RECORD ITS LOCATION IN THE ARRAY IN INDEX
C
       INDEX=LEN+1
       DO 20 I=1,LEN
       IF ((UNSIGN(I).EQ.'E').OR.(UNSIGN(I).EQ.'D')) THEN
         INDEX=I
         FNDEXP=.TRUE.
         IF (UNSIGN(INDEX+1).EQ.'-') THEN
            NEGEXP=.TRUE.
            IF ((INDEX+3).GT.LEN) THEN
              ERR=.TRUE.
             ELSE
                  EXPCHR=UNSIGN(INDEX+2)(1:1)//
     +                            UNSIGN(INDEX+3)(1:1)
            ENDIF
          ELSE IF (UNSIGN(INDEX+1).EQ.'+') THEN
                 NEGEXP=.FALSE.
                 IF ((INDEX+3).GT.LEN) THEN
                   ERR=.TRUE.
                  ELSE
                       EXPCHR=UNSIGN(INDEX+2)(1:1)//
     +                            UNSIGN(INDEX+3)(1:1)
                 END IF
            ELSE IF ((INDEX+2).GT.LEN) THEN
                   ERR=.TRUE.
             ELSE
                  EXPCHR=UNSIGN(INDEX+1)(1:1)//
     +                            UNSIGN(INDEX+2)(1:1)
         END IF
         GO TO 30
       END IF
20     CONTINUE
C
C      EVALUATE EXPONENT AS AN INTEGER
C
30     IF ((FNDEXP).AND.(.NOT. ERR)) THEN
         CALL MAKINT(EXPCHR,2,EXPT,ERR)
         IF (NEGEXP) THEN
           EXPT=EXPT*(-1)
         END IF
       END IF
C
C      LOCATE DECIMAL POINT POSITION IN UNSIGN, RECORDING IT IN
C      DPOINT
C
       IF (.NOT. ERR) THEN
         DO 40 I=1,LEN
         IF (UNSIGN(I).EQ.'.') THEN
           DPOINT=I
           FNDPNT=.TRUE.
           GO TO 50
         END IF
40       CONTINUE
       END IF
C
C      IF THERE IS NO DECIMAL POINT THEN THIS CONSTITUTES AN ERROR
C
50     IF (.NOT. FNDPNT) THEN
         ERR=.TRUE.
       END IF
C
C      CHECK THAT POINT IS BEFORE EXPONENT
C

       IF (FNDEXP.AND.(DPOINT.GE.INDEX)) THEN
         ERR=.TRUE.
       END IF
C
C      EVALUATE LHS OF DECIMAL POINT, IF LHS EXISTS AND
C      IF DEC POINT EXISTS
C
       IF ((.NOT. ERR).AND.(FNDPNT)) THEN
         TEN=1.0
         IF ((DPOINT-1).GE.1) THEN
           DO 60 J=DPOINT-1,1,-1
            CALL CHRNUM(UNSIGN(J),DIGIT,ERR)
            IF (.NOT. ERR) THEN
              DPREC=DPREC+(TEN*(DBLE(DIGIT)))
            END IF
            TEN=TEN*10.0
60         CONTINUE
          ELSE
               DPREC=0.0
         END IF
       ENDIF
C
C      EVALUATE RHS OF DECIMAL POINT IF RHS EXISTS AND DP EXISTS
C
       IF ((.NOT. ERR).AND.(FNDPNT)) THEN
         TEN=0.1
         IF ((DPOINT+1).LE.LEN) THEN
           DO 70 J=DPOINT+1,INDEX-1
             CALL CHRNUM(UNSIGN(J),DIGIT,ERR)
             IF (.NOT. ERR) THEN
               DPREC=DPREC+(TEN*(DBLE(DIGIT)))
             END IF
             TEN=TEN/10.0
70         CONTINUE
         END IF
       END IF
C
C      MODIFY DPREC WITH THE EXPONENT IF FOUND, AND NEGATE IF
C      NECESSARY
C
       IF ((FNDEXP).AND.(.NOT. ERR)) THEN
         DPREC=DPREC*(10.0**(DBLE(EXPT)))
       END IF
       IF ((NEGATE).AND.(.NOT. ERR)) THEN
         DPREC=DPREC*(-1.0)
       END IF
       END




       SUBROUTINE RSORDR(ID,UORD,VORD,FOUND)
C      ________________________________________________________


      INCLUDE 'INPUT.INC'

      INTEGER INTGOT,UORD,VORD
      LOGICAL FOUND,NEXT

C
      ORDIND=0
D     PRINT*,'INSIDE READ PATCH ORDER'
100   FOUND=.FALSE.
      CALL REDINT(ID,INTGOT,FOUND,NEXT)
      IF (FOUND) THEN
        LINPOS=NEXT
        ORDIND=ORDIND+1
        IF (ORDIND.EQ.1) THEN
          UORD=INTGOT
        ELSE
          VORD=INTGOT
        END IF
        IF (ORDIND.LT.2) THEN
         GO TO 100
        END IF
      ENDIF
      END





C     __________________________________________________________
      SUBROUTINE RNOPAT(ID,PATU,PATV,FOUND)
C     __________________________________________________________
C
      INCLUDE 'INPUT.INC'
C
      INTEGER INTGOT,NUMINT,PATU,PATV,NEXT
      LOGICAL FOUND
C
D     PRINT*,'INSIDE RNOPAT'
C
      NUMINT=0
100   FOUND=.FALSE.
      CALL REDINT(ID,INTGOT,FOUND,NEXT)
      IF (FOUND) THEN
        LINPOS=NEXT
        NUMINT=NUMINT+1
        IF (NUMINT.EQ.1) THEN
          PATU=INTGOT
        ELSE IF (NUMINT.EQ.2) THEN
               PATV=INTGOT
               GO TO 50
        END IF
        GO TO 100
      ELSE IF (NUMINT.EQ.2) THEN
             GO TO 50
      END IF
50    END




C     __________________________________________________________
      SUBROUTINE RPARS(ID,NUMPAR,ERR)
C     __________________________________________________________
C
      INCLUDE 'INPUT.INC'

      DOUBLE PRECISION RELGOT
      LOGICAL FOUND,ERR
      INTEGER NUMPAR,NEXT

C
D     PRINT*,'INSIDE READ PARAMETERS'
      NUMPAR=0
      ERR=.FALSE.
100   FOUND=.FALSE.
      CALL REDREL(ID,RELGOT,FOUND,NEXT)
      IF (FOUND) THEN
        LINPOS=NEXT
        NUMPAR=NUMPAR+1
        GO TO 100
      ENDIF
      END







      SUBROUTINE NEWNAM(VSNAME,SNAME,LEN)
      CHARACTER*8 VSNAME
      CHARACTER*6 SNAME
      CHARACTER*40 FILEIN
      INTEGER LEN,namlen
5     PRINT*,'   please input a new surface name of up '
      PRINT*,'   to six uppercase characters'

      READ(*,'(A40)')FILEIN
      DO 10 I=40,1,-1
        IF (FILEIN(I:I).NE.' ') THEN
          NAMLEN=I
          GO TO 8
        ENDIF
10    CONTINUE
 8    IF (I.GT.6) THEN
        GO TO 5
      ENDIF
      SNAME=FILEIN(1:I)
      LEN=I
      RETURN
      END


**********************
*   SSV3 ROUTINES    *
**********************
*
*  * BCDF *  FORTRAN 77 INTEGER FUNCTION  19-DEC-1985  E.MCLELLAN
*            MODIFIED                      2-FEB-1988  E.MCLELLAN
*
*  PURPOSE:  CONVERT A STRING OF CHARACTERS WHICH OCCUPY THE SAME
*            NUMBER OF BYTES AS AN INTEGER WORD INTO AN EQUIVALENT
*            INTEGER VALUE
*
*  CALLING SEQUENCE:
*                   VALUE=BCDF(STR)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*       STR         CHARACTER  STRING TO BE CONVERTED
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*   IWRD            SDP       INTEGER    NO. OF BYTES PER WORD
*   NBCHAR          SDP       INTEGER    NO. OF BITS PER BYTE
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*        I          INTEGER    LOOP COUNT
*        BCD        INTEGER    VARIABLE FOR BUILDING UP BCD VALUE
*        TSTR       CHARACTER  TEMPORARY STORAGE FOR STRING
*
*  FILES:  NONE
*
*  SUBSIDIARIES:  NONE
*
      INTEGER FUNCTION BCDF(STR)
C
      INCLUDE 'SDP.INC'
C
      INTEGER  BCD
      CHARACTER*(*) STR,TSTR*10
C
      BCD=0
      TSTR=STR//' '
      DO 10 I=1,IWRD
      BCD=ISHFT(BCD,NBCHAR)+ICHAR(TSTR(I:I))
  10  CONTINUE
C
      BCDF=BCD
C
      END


*
*  * HOLFRM *  FORTRAN 77 SUBROUTINE  16.7.86  E.MCLELLAN
*                MODIFIED                 2-FEB-1988  E.MCLELLAN
*
*  PURPOSE:  TO INSERT SPECIFIED NUMBER OF CHARACTERS IN BCDF FORM
*            FROM INTEGER ARRAY INTO CHARACTER VARIABLE
*            STARTING FROM SPECIFIED LOCATION - RETURNING THE NUMBER
*            OF INTEGER WORDS OCCUPIED
*
*  CALLING SEQUENCE:
*                   CALL HOLFRM(IARR,STR,IST,NCHR,NWD)
*
*  ARGUMENTS:
*                   TYPE       DESCRIPTION
*       IARR        INTEGER    ARRAY CONTAINING BCDF CHARACTERS
*       STR         CHARACTER  STRING INTO WHICH CHARACTERS ARE
*                              TO BE LOADED
*       IST         INTEGER    START LOCATION IN STR
*       NCHR        INTEGER    NUMBER OF CHARACTERS TO BE INSERTED
*       NWD         INTEGER    NUMBER OF WORDS OCCUPIED
*
*  GLOBAL VARIABLES:
*
*---------------------------------------------------
*   VARIABLE        BLOCK     TYPE       DESCRIPTION
*---------------------------------------------------
*     IWRD          SDP       INTEGER    NO OF BYTES PER WORD
*     NBCHAR        SDP       INTEGER    NO OF BITS PER BYTE
*
*  LOCAL VARIABLES:
*                   TYPE       DESCRIPTION
*     IVAL          INTEGER    VALUE OF INTEGER WORD
*     JVAL          INTEGER    INDEX OF CHARACTER IN CONCATINATION
*                              SEQUENCE
*
*  FILES:  NONE
*
*  SUBSIDIARIES:  NONE
*
      SUBROUTINE HOLFRM(IARR,STR,IST,NCHR,NWD)
C
C.... SYSTEM DEPENDENT PARAMETERS
C
      INCLUDE 'SDP.INC'
C
      INTEGER IARR(*),IST,NCHR,NWD,IVAL,JVAL,SLEN
C
      CHARACTER*(*) STR
C
      SLEN=LEN(STR)
      NWD=NCHR/IWRD
      IF (NCHR.GT.NWD*IWRD) NWD=NWD+1
      DO 20 I=1,NWD
        IVAL=IARR(I)
        K1=IST+I*IWRD
        DO 10 J=IWRD,1,-1
          K=K1-J
          JJ=NBCHAR*(J-1)
          JVAL=ISHFT(IVAL,-JJ)
          IF (K.LE.SLEN) THEN
            STR(K:K)=CHAR(JVAL)
          ENDIF
          IVAL=(IVAL-ISHFT(JVAL,JJ))
  10    CONTINUE
  20  CONTINUE
C
      END
**** EOF ****








(uafhcx) 161% 